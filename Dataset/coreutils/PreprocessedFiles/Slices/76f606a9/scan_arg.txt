scan_arg 

{

  operand ret;



  if (! xstrtold (arg, NULL, &ret.value, c_strtold))

    {

      error (0, 0, _("invalid floating point argument: %s"), arg);

      usage (EXIT_FAILURE);

    }



  /* We don't output spaces or '+' so don't include in width */

  while (isspace (to_uchar (*arg)) || *arg == '+')

    arg++;



  ret.width = strlen (arg);

  ret.precision = INT_MAX;



  if (! arg[strcspn (arg, "xX")] && isfinite (ret.value))

    {

      char const *decimal_point = strchr (arg, '.');

      if (! decimal_point)

        ret.precision = 0;

      else

        {

          size_t fraction_len = strcspn (decimal_point + 1, "eE");

          if (fraction_len <= INT_MAX)

            ret.precision = fraction_len;

          ret.width += (fraction_len == 0                      /* #.  -> #   */

                        ? -1

                        : (decimal_point == arg                /* .#  -> 0.# */

                           || ! ISDIGIT (decimal_point[-1]))); /* -.# -> 0.# */

        }

      char const *e = strchr (arg, 'e');

      if (! e)

        e = strchr (arg, 'E');

      if (e)

        {

          long exponent = strtol (e + 1, NULL, 10);

          ret.precision += exponent < 0 ? -exponent : 0;

          /* Don't account for e.... in the width since this is not output.  */

          ret.width -= strlen (arg) - (e - arg);

          /* Adjust the width as per the exponent.  */

          if (exponent < 0)

            {

              if (decimal_point)

                {

                  if (e == decimal_point + 1) /* undo #. -> # above  */

                    ret.width++;

                }

              else

                ret.width++;

              exponent = -exponent;

            }

          ret.width += exponent;

        }

    }



  return ret;

}

