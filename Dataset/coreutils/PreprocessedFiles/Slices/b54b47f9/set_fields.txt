set_fields 

{

  size_t initial = 1;		/* Value of first number in a range.  */

  size_t value = 0;		/* If nonzero, a number being accumulated.  */

  bool lhs_specified = false;

  bool rhs_specified = false;

  bool dash_found = false;	/* True if a '-' is found in this field.  */

  bool field_found = false;	/* True if at least one field spec

                                   has been processed.  */



  size_t i;

  bool in_digits = false;



  /* Collect and store in RP the range end points.

     It also sets EOL_RANGE_START if appropriate.  */



  while (true)

    {

      if (*fieldstr == '-')

        {

          in_digits = false;

          /* Starting a range. */

          if (dash_found)

            FATAL_ERROR (_("invalid byte, character or field list"));

          dash_found = true;

          fieldstr++;



          if (lhs_specified && !value)

            FATAL_ERROR (_("fields and positions are numbered from 1"));



          initial = (lhs_specified ? value : 1);

          value = 0;

        }

      else if (*fieldstr == ','

               || isblank (to_uchar (*fieldstr)) || *fieldstr == '\0')

        {

          in_digits = false;

          /* Ending the string, or this field/byte sublist. */

          if (dash_found)

            {

              dash_found = false;



              if (!lhs_specified && !rhs_specified)

                FATAL_ERROR (_("invalid range with no endpoint: -"));



              /* A range.  Possibilities: -n, m-n, n-.

                 In any case, 'initial' contains the start of the range. */

              if (!rhs_specified)

                {

                  /* 'n-'.  From 'initial' to end of line.  If we've already

                     seen an M- range, ignore subsequent N- unless N < M.  */

                  if (eol_range_start == 0 || initial < eol_range_start)

                    eol_range_start = initial;

                  field_found = true;

                }

              else

                {

                  /* 'm-n' or '-n' (1-n). */

                  if (value < initial)

                    FATAL_ERROR (_("invalid decreasing range"));



                  ADD_RANGE_PAIR (rp, initial, value);

                  field_found = true;

                }

              value = 0;

            }

          else

            {

              /* A simple field number, not a range. */

              ADD_RANGE_PAIR (rp, value, value);

              value = 0;

              field_found = true;

            }



          if (*fieldstr == '\0')

            break;



          fieldstr++;

          lhs_specified = false;

          rhs_specified = false;

        }

      else if (ISDIGIT (*fieldstr))

        {

          /* Record beginning of digit string, in case we have to

             complain about it.  */

          static char const *num_start;

          if (!in_digits || !num_start)

            num_start = fieldstr;

          in_digits = true;



          if (dash_found)

            rhs_specified = 1;

          else

            lhs_specified = 1;



          /* Detect overflow.  */

          if (!DECIMAL_DIGIT_ACCUMULATE (value, *fieldstr - '0', size_t))

            {

              /* In case the user specified -c$(echo 2^64|bc),22,

                 complain only about the first number.  */

              /* Determine the length of the offending number.  */

              size_t len = strspn (num_start, "0123456789");

              char *bad_num = xstrndup (num_start, len);

              if (operating_mode == byte_mode)

                error (0, 0,

                       _("byte offset %s is too large"), quote (bad_num));

              else

                error (0, 0,

                       _("field number %s is too large"), quote (bad_num));

              free (bad_num);

              exit (EXIT_FAILURE);

            }



          fieldstr++;

        }

      else

        FATAL_ERROR (_("invalid byte, character or field list"));

    }



  max_range_endpoint = 0;

  for (i = 0; i < n_rp; i++)

    {

      if (rp[i].hi > max_range_endpoint)

        max_range_endpoint = rp[i].hi;

    }



  /* For performance, allocate an array large enough so that it may be

     indexed by the field numbers corresponding to all finite ranges

     (i.e. '2-6' or '-4', but not '5-') in FIELDSTR.

     Note this enhancement is not possible with very large ranges,

     or when --output-delimiter is specified.  */



  if (!output_delimiter_specified

      && max_range_endpoint

      && max_range_endpoint / CHAR_BIT < PRINTABLE_ARRAY_MAX)

    printable_field = xzalloc (max_range_endpoint / CHAR_BIT + 1);



  qsort (rp, n_rp, sizeof (rp[0]), compare_ranges);



  /* Omit finite ranges subsumed by a to-EOL range. */

  if (eol_range_start && n_rp)

    {

      i = n_rp;

      while (i && eol_range_start <= rp[i - 1].hi)

        {

          eol_range_start = MIN (rp[i - 1].lo, eol_range_start);

          --n_rp;

          --i;

        }

    }



  /* Merge finite range pairs (e.g. `2-5,3-4' becomes `2-5').

     Also for small enough ranges, mark items as printable.  */

  for (i = 0; i < n_rp; ++i)

    {

      for (size_t j = i + 1; j < n_rp; ++j)

        {

          if (rp[j].lo <= rp[i].hi)

            {

              rp[i].hi = MAX (rp[j].hi, rp[i].hi);

              memmove (rp + j, rp + j + 1,

                       (n_rp - j - 1) * sizeof (struct range_pair));

              --n_rp;

            }

          else

            break;

        }



      if (printable_field)

        {

          for (size_t k = rp[i].lo; k <= rp[i].hi; k++)

            mark_printable_field (k);

        }

    }



  /* After merging, reallocate RP so we release memory to the system.

     Also add a sentinel at the end of RP, to avoid out of bounds access.  */

  ++n_rp;

  rp = xrealloc (rp, n_rp * sizeof (struct range_pair));

  rp[n_rp - 1].lo = rp[n_rp - 1].hi = 0;



  return field_found;

}

