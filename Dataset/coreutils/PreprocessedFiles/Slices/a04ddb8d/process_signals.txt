process_signals 

{

  while (interrupt_signal || stop_signal_count)

    {

      int sig;

      int stops;

      sigset_t oldset;



      if (used_color)

        restore_default_color ();

      fflush (stdout);



      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);



      /* Reload interrupt_signal and stop_signal_count, in case a new

         signal was handled before sigprocmask took effect.  */

      sig = interrupt_signal;

      stops = stop_signal_count;



      /* SIGTSTP is special, since the application can receive that signal

         more than once.  In this case, don't set the signal handler to the

         default.  Instead, just raise the uncatchable SIGSTOP.  */

      if (stops)

        {

          stop_signal_count = stops - 1;

          sig = SIGSTOP;

        }

      else

        signal (sig, SIG_DFL);



      /* Exit or suspend the program.  */

      raise (sig);

      sigprocmask (SIG_SETMASK, &oldset, NULL);



      /* If execution reaches here, then the program has been

         continued (after being suspended).  */

    }

}

