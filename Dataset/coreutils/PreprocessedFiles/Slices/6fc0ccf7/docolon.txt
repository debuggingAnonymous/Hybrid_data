docolon 

{

  VALUE *v;

  const char *errmsg;

  struct re_pattern_buffer re_buffer;

  struct re_registers re_regs;

  size_t len;

  int matchlen;



  tostring (sv);

  tostring (pv);



  if (pv->u.s[0] == '^')

    {

      error (0, 0, _("\

warning: unportable BRE: `%s': using `^' as the first character\n\

of the basic regular expression is not portable; it is being ignored"),

	     pv->u.s);

    }



  len = strlen (pv->u.s);

  memset (&re_buffer, 0, sizeof (re_buffer));

  memset (&re_regs, 0, sizeof (re_regs));

  re_buffer.allocated = 2 * len;

  if (re_buffer.allocated < len)

    xalloc_die ();

  re_buffer.buffer = xmalloc (re_buffer.allocated);

  re_buffer.translate = NULL;

  re_syntax_options = RE_SYNTAX_POSIX_BASIC;

  errmsg = re_compile_pattern (pv->u.s, len, &re_buffer);

  if (errmsg)

    error (EXPR_FAILURE, 0, "%s", errmsg);



  matchlen = re_match (&re_buffer, sv->u.s, strlen (sv->u.s), 0, &re_regs);

  if (0 <= matchlen)

    {

      /* Were \(...\) used? */

      if (re_buffer.re_nsub > 0)/* was (re_regs.start[1] >= 0) */

	{

	  sv->u.s[re_regs.end[1]] = '\0';

	  v = str_value (sv->u.s + re_regs.start[1]);

	}

      else

	v = int_value (matchlen);

    }

  else

    {

      /* Match failed -- return the right kind of null.  */

      if (re_buffer.re_nsub > 0)

	v = str_value ("");

      else

	v = int_value (0);

    }

  free (re_buffer.buffer);

  return v;

}

