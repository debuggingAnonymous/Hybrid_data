eval2 

{

  VALUE *l;

  VALUE *r;

  enum

  {

    less_than, less_equal, equal, not_equal, greater_equal, greater_than

  } fxn;

  bool val;

  intmax_t lval;

  intmax_t rval;

  int collation_errno;

  char *collation_arg1;



#ifdef EVAL_TRACE

  trace ("eval2");

#endif

  l = eval3 (evaluate);

  while (1)

    {

      if (nextarg ("<"))

	fxn = less_than;

      else if (nextarg ("<="))

	fxn = less_equal;

      else if (nextarg ("=") || nextarg ("=="))

	fxn = equal;

      else if (nextarg ("!="))

	fxn = not_equal;

      else if (nextarg (">="))

	fxn = greater_equal;

      else if (nextarg (">"))

	fxn = greater_than;

      else

	return l;

      r = eval3 (evaluate);

      tostring (l);

      tostring (r);



      /* Save the first arg to strcoll, in case we need its value for

	 a diagnostic later.  This is needed because 'toarith' might

	 free the first arg.  */

      collation_arg1 = xstrdup (l->u.s);



      errno = 0;

      lval = strcoll (collation_arg1, r->u.s);

      collation_errno = errno;

      rval = 0;

      if (toarith (l) && toarith (r))

	{

	  lval = l->u.i;

	  rval = r->u.i;

	}

      else if (collation_errno && evaluate)

	{

	  error (0, collation_errno, _("string comparison failed"));

	  error (0, 0, _("Set LC_ALL='C' to work around the problem."));

	  error (EXPR_FAILURE, 0,

		 _("The strings compared were %s and %s."),

		 quotearg_n_style (0, locale_quoting_style, collation_arg1),

		 quotearg_n_style (1, locale_quoting_style, r->u.s));

	}



      switch (fxn)

	{

	case less_than:     val = (lval <  rval); break;

	case less_equal:    val = (lval <= rval); break;

	case equal:         val = (lval == rval); break;

	case not_equal:     val = (lval != rval); break;

	case greater_equal: val = (lval >= rval); break;

	case greater_than:  val = (lval >  rval); break;

	default: abort ();

	}

      freev (l);

      freev (r);

      free (collation_arg1);

      l = int_value (val);

    }

}

