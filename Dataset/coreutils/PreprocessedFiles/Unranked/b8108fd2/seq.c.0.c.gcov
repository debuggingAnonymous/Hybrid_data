        -:    0:Source:seq.c
        -:    0:Graph:seq.gcno
        -:    0:Data:seq.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* seq - print sequence of numbers to standard output.
        -:    2:   Copyright (C) 1994-2007 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* Written by Ulrich Drepper.  */
        -:   18:
        -:   19:#include <config.h>
        -:   20:#include <getopt.h>
        -:   21:#include <stdio.h>
        -:   22:#include <sys/types.h>
        -:   23:
        -:   24:#include "system.h"
        -:   25:#include "c-strtod.h"
        -:   26:#include "error.h"
        -:   27:#include "quote.h"
        -:   28:#include "xstrtod.h"
        -:   29:
        -:   30:/* Roll our own isfinite rather than using <math.h>, so that we don't
        -:   31:   have to worry about linking -lm just for isfinite.  */
        -:   32:#ifndef isfinite
        -:   33:# define isfinite(x) ((x) * 0 == 0)
        -:   34:#endif
        -:   35:
        -:   36:/* The official name of this program (e.g., no `g' prefix).  */
        -:   37:#define PROGRAM_NAME "seq"
        -:   38:
        -:   39:#define AUTHORS "Ulrich Drepper"
        -:   40:
        -:   41:/* If true print all number with equal width.  */
        -:   42:static bool equal_width;
        -:   43:
        -:   44:/* The name that this program was run with.  */
        -:   45:char *program_name;
        -:   46:
        -:   47:/* The string used to separate two numbers.  */
        -:   48:static char const *separator;
        -:   49:
        -:   50:/* The string output after all numbers have been output.
        -:   51:   Usually "\n" or "\0".  */
        -:   52:/* FIXME: make this an option.  */
        -:   53:static char const terminator[] = "\n";
        -:   54:
        -:   55:static struct option const long_options[] =
        -:   56:{
        -:   57:  { "equal-width", no_argument, NULL, 'w'},
        -:   58:  { "format", required_argument, NULL, 'f'},
        -:   59:  { "separator", required_argument, NULL, 's'},
        -:   60:  {GETOPT_HELP_OPTION_DECL},
        -:   61:  {GETOPT_VERSION_OPTION_DECL},
        -:   62:  { NULL, 0, NULL, 0}
        -:   63:};
        -:   64:
        -:   65:void
    #####:   66:usage (int status)
        -:   67:{
    #####:   68:  if (status != EXIT_SUCCESS)
    #####:   69:    fprintf (stderr, _("Try `%s --help' for more information.\n"),
        -:   70:	     program_name);
        -:   71:  else
        -:   72:    {
    #####:   73:      printf (_("\
        -:   74:Usage: %s [OPTION]... LAST\n\
        -:   75:  or:  %s [OPTION]... FIRST LAST\n\
        -:   76:  or:  %s [OPTION]... FIRST INCREMENT LAST\n\
        -:   77:"), program_name, program_name, program_name);
    #####:   78:      fputs (_("\
        -:   79:Print numbers from FIRST to LAST, in steps of INCREMENT.\n\
        -:   80:\n\
        -:   81:  -f, --format=FORMAT      use printf style floating-point FORMAT\n\
        -:   82:  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n\
        -:   83:  -w, --equal-width        equalize width by padding with leading zeroes\n\
        -:   84:"), stdout);
    #####:   85:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####:   86:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####:   87:      fputs (_("\
        -:   88:\n\
        -:   89:If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n\
        -:   90:omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n\
        -:   91:FIRST, INCREMENT, and LAST are interpreted as floating point values.\n\
        -:   92:INCREMENT is usually positive if FIRST is smaller than LAST, and\n\
        -:   93:INCREMENT is usually negative if FIRST is greater than LAST.\n\
        -:   94:"), stdout);
    #####:   95:      fputs (_("\
        -:   96:FORMAT must be suitable for printing one argument of type `double';\n\
        -:   97:it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n\
        -:   98:decimal numbers with maximum precision PREC, and to %g otherwise.\n\
        -:   99:"), stdout);
    #####:  100:      emit_bug_reporting_address ();
        -:  101:    }
    #####:  102:  exit (status);
        -:  103:}
        -:  104:
        -:  105:/* A command-line operand.  */
        -:  106:struct operand
        -:  107:{
        -:  108:  /* Its value, converted to 'long double'.  */
        -:  109:  long double value;
        -:  110:
        -:  111:  /* Its print width, if it were printed out in a form similar to its
        -:  112:     input form.  An input like "-.1" is treated like "-0.1", and an
        -:  113:     input like "1." is treated like "1", but otherwise widths are
        -:  114:     left alone.  */
        -:  115:  size_t width;
        -:  116:
        -:  117:  /* Number of digits after the decimal point, or INT_MAX if the
        -:  118:     number can't easily be expressed as a fixed-point number.  */
        -:  119:  int precision;
        -:  120:};
        -:  121:typedef struct operand operand;
        -:  122:
        -:  123:/* Description of what a number-generating format will generate.  */
        -:  124:struct layout
        -:  125:{
        -:  126:  /* Number of bytes before and after the number.  */
        -:  127:  size_t prefix_len;
        -:  128:  size_t suffix_len;
        -:  129:};
        -:  130:
        -:  131:/* Read a long double value from the command line.
        -:  132:   Return if the string is correct else signal error.  */
        -:  133:
        -:  134:static operand
        1:  135:scan_arg (const char *arg)
        -:  136:{
        -:  137:  operand ret;
        -:  138:
        1:  139:  if (! xstrtold (arg, NULL, &ret.value, c_strtold))
        -:  140:    {
    #####:  141:      error (0, 0, _("invalid floating point argument: %s"), arg);
    #####:  142:      usage (EXIT_FAILURE);
        -:  143:    }
        -:  144:
        -:  145:  /* We don't output spaces or '+' so don't include in width */
        2:  146:  while (isspace (*arg) || *arg == '+')
    #####:  147:    arg++;
        -:  148:
        1:  149:  ret.width = strlen (arg);
        1:  150:  ret.precision = INT_MAX;
        -:  151:
        1:  152:  if (! arg[strcspn (arg, "xX")] && isfinite (ret.value))
        -:  153:    {
        1:  154:      char const *decimal_point = strchr (arg, '.');
        1:  155:      if (! decimal_point)
        1:  156:	ret.precision = 0;
        -:  157:      else
        -:  158:	{
    #####:  159:	  size_t fraction_len = strcspn (decimal_point + 1, "eE");
    #####:  160:	  if (fraction_len <= INT_MAX)
    #####:  161:	    ret.precision = fraction_len;
    #####:  162:	  ret.width += (fraction_len == 0                      /* #.  -> #   */
        -:  163:			? -1
        -:  164:			: (decimal_point == arg                /* .#  -> 0.# */
    #####:  165:			   || ! ISDIGIT (decimal_point[-1]))); /* -.# -> 0.# */
        -:  166:	}
        1:  167:      char const *e = strchr (arg, 'e');
        1:  168:      if (! e)
        1:  169:	e = strchr (arg, 'E');
        1:  170:      if (e)
        -:  171:	{
    #####:  172:	  long exponent = strtol (e + 1, NULL, 10);
    #####:  173:	  ret.precision += exponent < 0 ? -exponent : 0;
        -:  174:	}
        -:  175:    }
        -:  176:
        1:  177:  return ret;
        -:  178:}
        -:  179:
        -:  180:/* If FORMAT is a valid printf format for a double argument, return
        -:  181:   its long double equivalent, possibly allocated from dynamic
        -:  182:   storage, and store into *LAYOUT a description of the output layout;
        -:  183:   otherwise, return NULL.  */
        -:  184:
        -:  185:static char const *
        1:  186:long_double_format (char const *fmt, struct layout *layout)
        -:  187:{
        -:  188:  size_t i;
        1:  189:  size_t prefix_len = 0;
        1:  190:  size_t suffix_len = 0;
        -:  191:  size_t length_modifier_offset;
        -:  192:  bool has_L;
        -:  193:
        1:  194:  for (i = 0; ! (fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)
    #####:  195:    if (fmt[i])
    #####:  196:      prefix_len++;
        -:  197:    else
    #####:  198:      return NULL;
        -:  199:
        1:  200:  i++;
        1:  201:  i += strspn (fmt + i, "-+#0 '");
        1:  202:  i += strspn (fmt + i, "0123456789");
        1:  203:  if (fmt[i] == '.')
        -:  204:    {
    #####:  205:      i++;
    #####:  206:      i += strspn (fmt + i, "0123456789");
        -:  207:    }
        -:  208:
        1:  209:  length_modifier_offset = i;
        1:  210:  has_L = (fmt[i] == 'L');
        1:  211:  i += has_L;
        1:  212:  if (! strchr ("efgaEFGA", fmt[i]))
    #####:  213:    return NULL;
        -:  214:
        2:  215:  for (i++; ! (fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)
        2:  216:    if (fmt[i])
        1:  217:      suffix_len++;
        -:  218:    else
        -:  219:      {
        1:  220:	size_t format_size = i + 1;
        1:  221:	char *ldfmt = xmalloc (format_size + 1);
        1:  222:	memcpy (ldfmt, fmt, length_modifier_offset);
        1:  223:	ldfmt[length_modifier_offset] = 'L';
        1:  224:	strcpy (ldfmt + length_modifier_offset + 1,
        1:  225:		fmt + length_modifier_offset + has_L);
        1:  226:	layout->prefix_len = prefix_len;
        1:  227:	layout->suffix_len = suffix_len;
        1:  228:	return ldfmt;
        -:  229:      }
        -:  230:
    #####:  231:  return NULL;
        -:  232:}
        -:  233:
        -:  234:/* Actually print the sequence of numbers in the specified range, with the
        -:  235:   given or default stepping and format.  */
        -:  236:
        -:  237:static void
        1:  238:print_numbers (char const *fmt, struct layout layout,
        -:  239:	       long double first, long double step, long double last)
        -:  240:{
        1:  241:  bool out_of_range = (step < 0 ? first < last : last < first);
        -:  242:
        1:  243:  if (! out_of_range)
        -:  244:    {
        1:  245:      long double x = first;
        -:  246:      long double i;
        -:  247:
        1:  248:      for (i = 1; ; i++)
        -:  249:	{
        1:  250:	  long double x0 = x;
        1:  251:	  printf (fmt, x);
        1:  252:	  if (out_of_range)
    #####:  253:	    break;
        1:  254:	  x = first + i * step;
        1:  255:	  out_of_range = (step < 0 ? x < last : last < x);
        -:  256:
        1:  257:	  if (out_of_range)
        -:  258:	    {
        -:  259:	      /* If the number just past LAST prints as a value equal
        -:  260:		 to LAST, and prints differently from the previous
        -:  261:		 number, then print the number.  This avoids problems
        -:  262:		 with rounding.  For example, with the x86 it causes
        -:  263:		 "seq 0 0.000001 0.000003" to print 0.000003 instead
        -:  264:		 of stopping at 0.000002.  */
        -:  265:
        1:  266:	      bool print_extra_number = false;
        -:  267:	      long double x_val;
        -:  268:	      char *x_str;
        1:  269:	      int x_strlen = asprintf (&x_str, fmt, x);
        1:  270:	      if (x_strlen < 0)
        1:  271:		xalloc_die ();
    #####:  272:	      x_str[x_strlen - layout.suffix_len] = '\0';
        -:  273:
    #####:  274:	      if (xstrtold (x_str + layout.prefix_len, NULL, &x_val, c_strtold)
    #####:  275:		  && x_val == last)
        -:  276:		{
    #####:  277:		  char *x0_str = NULL;
    #####:  278:		  if (asprintf (&x0_str, fmt, x0) < 0)
    #####:  279:		    xalloc_die ();
    #####:  280:		  print_extra_number = !STREQ (x0_str, x_str);
    #####:  281:		  free (x0_str);
        -:  282:		}
        -:  283:
    #####:  284:	      free (x_str);
    #####:  285:	      if (! print_extra_number)
    #####:  286:		break;
        -:  287:	    }
        -:  288:
    #####:  289:	  fputs (separator, stdout);
    #####:  290:	}
        -:  291:
    #####:  292:      fputs (terminator, stdout);
        -:  293:    }
    #####:  294:}
        -:  295:
        -:  296:/* Return the default format given FIRST, STEP, and LAST.  */
        -:  297:static char const *
    #####:  298:get_default_format (operand first, operand step, operand last)
        -:  299:{
        -:  300:  static char format_buf[sizeof "%0.Lf" + 2 * INT_STRLEN_BOUND (int)];
        -:  301:
    #####:  302:  int prec = MAX (first.precision, step.precision);
        -:  303:
    #####:  304:  if (prec != INT_MAX && last.precision != INT_MAX)
        -:  305:    {
    #####:  306:      if (equal_width)
        -:  307:	{
        -:  308:	  /* increase first_width by any increased precision in step */
    #####:  309:	  size_t first_width = first.width + (prec - first.precision);
        -:  310:	  /* adjust last_width to use precision from first/step */
    #####:  311:	  size_t last_width = last.width + (prec - last.precision);
    #####:  312:	  if (last.precision && prec == 0)
    #####:  313:	    last_width--;  /* don't include space for '.' */
    #####:  314:	  size_t width = MAX (first_width, last_width);
    #####:  315:	  if (width <= INT_MAX)
        -:  316:	    {
    #####:  317:	      int w = width;
    #####:  318:	      sprintf (format_buf, "%%0%d.%dLf", w, prec);
    #####:  319:	      return format_buf;
        -:  320:	    }
        -:  321:	}
        -:  322:      else
        -:  323:	{
    #####:  324:	  sprintf (format_buf, "%%.%dLf", prec);
    #####:  325:	  return format_buf;
        -:  326:	}
        -:  327:    }
        -:  328:
    #####:  329:  return "%Lg";
        -:  330:}
        -:  331:
        -:  332:int
        1:  333:main (int argc, char **argv)
        -:  334:{
        -:  335:  int optc;
        1:  336:  operand first = { 1, 1, 0 };
        1:  337:  operand step = { 1, 1, 0 };
        -:  338:  operand last;
        1:  339:  struct layout layout = { 0, 0 };
        -:  340:
        -:  341:  /* The printf(3) format used for output.  */
        1:  342:  char const *format_str = NULL;
        -:  343:
        -:  344:  initialize_main (&argc, &argv);
        1:  345:  program_name = argv[0];
        1:  346:  setlocale (LC_ALL, "");
        -:  347:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  348:  textdomain (PACKAGE);
        -:  349:
        1:  350:  atexit (close_stdout);
        -:  351:
        1:  352:  equal_width = false;
        1:  353:  separator = "\n";
        -:  354:
        -:  355:  /* We have to handle negative numbers in the command line but this
        -:  356:     conflicts with the command line arguments.  So explicitly check first
        -:  357:     whether the next argument looks like a negative number.  */
        3:  358:  while (optind < argc)
        -:  359:    {
        2:  360:      if (argv[optind][0] == '-'
        1:  361:	  && ((optc = argv[optind][1]) == '.' || ISDIGIT (optc)))
        -:  362:	{
        -:  363:	  /* means negative number */
        -:  364:	  break;
        -:  365:	}
        -:  366:
        2:  367:      optc = getopt_long (argc, argv, "+f:s:w", long_options, NULL);
        2:  368:      if (optc == -1)
        1:  369:	break;
        -:  370:
        1:  371:      switch (optc)
        -:  372:	{
        -:  373:	case 'f':
        1:  374:	  format_str = optarg;
        1:  375:	  break;
        -:  376:
        -:  377:	case 's':
    #####:  378:	  separator = optarg;
    #####:  379:	  break;
        -:  380:
        -:  381:	case 'w':
    #####:  382:	  equal_width = true;
    #####:  383:	  break;
        -:  384:
    #####:  385:	case_GETOPT_HELP_CHAR;
        -:  386:
    #####:  387:	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -:  388:
        -:  389:	default:
    #####:  390:	  usage (EXIT_FAILURE);
        -:  391:	}
        -:  392:    }
        -:  393:
        1:  394:  if (argc - optind < 1)
        -:  395:    {
    #####:  396:      error (0, 0, _("missing operand"));
    #####:  397:      usage (EXIT_FAILURE);
        -:  398:    }
        -:  399:
        1:  400:  if (3 < argc - optind)
        -:  401:    {
    #####:  402:      error (0, 0, _("extra operand %s"), quote (argv[optind + 3]));
    #####:  403:      usage (EXIT_FAILURE);
        -:  404:    }
        -:  405:
        1:  406:  if (format_str)
        -:  407:    {
        1:  408:      char const *f = long_double_format (format_str, &layout);
        1:  409:      if (! f)
        -:  410:	{
    #####:  411:	  error (0, 0, _("invalid format string: %s"), quote (format_str));
    #####:  412:	  usage (EXIT_FAILURE);
        -:  413:	}
        1:  414:      format_str = f;
        -:  415:    }
        -:  416:
        1:  417:  last = scan_arg (argv[optind++]);
        -:  418:
        1:  419:  if (optind < argc)
        -:  420:    {
    #####:  421:      first = last;
    #####:  422:      last = scan_arg (argv[optind++]);
        -:  423:
    #####:  424:      if (optind < argc)
        -:  425:	{
    #####:  426:	  step = last;
    #####:  427:	  last = scan_arg (argv[optind++]);
        -:  428:	}
        -:  429:    }
        -:  430:
        1:  431:  if (format_str != NULL && equal_width)
        -:  432:    {
    #####:  433:      error (0, 0, _("\
        -:  434:format string may not be specified when printing equal width strings"));
    #####:  435:      usage (EXIT_FAILURE);
        -:  436:    }
        -:  437:
        1:  438:  if (format_str == NULL)
    #####:  439:    format_str = get_default_format (first, step, last);
        -:  440:
        1:  441:  print_numbers (format_str, layout, first.value, step.value, last.value);
        -:  442:
    #####:  443:  exit (EXIT_SUCCESS);
        -:  444:}
