        -:    0:Source:ls.c
        -:    0:Graph:ls.gcno
        -:    0:Data:ls.gcda
        -:    0:Runs:12
        -:    0:Programs:1
        -:    1:/* `dir', `vdir' and `ls' directory listing programs for GNU.
        -:    2:   Copyright (C) 85, 88, 90, 91, 1995-2007 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software; you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation; either version 2, or (at your option)
        -:    7:   any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program; if not, write to the Free Software Foundation,
        -:   16:   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
        -:   17:
        -:   18:/* If ls_mode is LS_MULTI_COL,
        -:   19:   the multi-column format is the default regardless
        -:   20:   of the type of output device.
        -:   21:   This is for the `dir' program.
        -:   22:
        -:   23:   If ls_mode is LS_LONG_FORMAT,
        -:   24:   the long format is the default regardless of the
        -:   25:   type of output device.
        -:   26:   This is for the `vdir' program.
        -:   27:
        -:   28:   If ls_mode is LS_LS,
        -:   29:   the output format depends on whether the output
        -:   30:   device is a terminal.
        -:   31:   This is for the `ls' program.  */
        -:   32:
        -:   33:/* Written by Richard Stallman and David MacKenzie.  */
        -:   34:
        -:   35:/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis
        -:   36:   Flaherty <dennisf@denix.elk.miles.com> based on original patches by
        -:   37:   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */
        -:   38:
        -:   39:#include <config.h>
        -:   40:#include <sys/types.h>
        -:   41:
        -:   42:#if HAVE_TERMIOS_H
        -:   43:# include <termios.h>
        -:   44:#endif
        -:   45:#if HAVE_STROPTS_H
        -:   46:# include <stropts.h>
        -:   47:#endif
        -:   48:#if HAVE_SYS_IOCTL_H
        -:   49:# include <sys/ioctl.h>
        -:   50:#endif
        -:   51:
        -:   52:#ifdef WINSIZE_IN_PTEM
        -:   53:# include <sys/stream.h>
        -:   54:# include <sys/ptem.h>
        -:   55:#endif
        -:   56:
        -:   57:#include <stdio.h>
        -:   58:#include <assert.h>
        -:   59:#include <setjmp.h>
        -:   60:#include <grp.h>
        -:   61:#include <pwd.h>
        -:   62:#include <getopt.h>
        -:   63:#include <signal.h>
        -:   64:#include <selinux/selinux.h>
        -:   65:#include <wchar.h>
        -:   66:
        -:   67:/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
        -:   68:   present.  */
        -:   69:#ifndef SA_NOCLDSTOP
        -:   70:# define SA_NOCLDSTOP 0
        -:   71:# define sigprocmask(How, Set, Oset) /* empty */
        -:   72:# define sigset_t int
        -:   73:# if ! HAVE_SIGINTERRUPT
        -:   74:#  define siginterrupt(sig, flag) /* empty */
        -:   75:# endif
        -:   76:#endif
        -:   77:#ifndef SA_RESTART
        -:   78:# define SA_RESTART 0
        -:   79:#endif
        -:   80:
        -:   81:#include "system.h"
        -:   82:#include <fnmatch.h>
        -:   83:
        -:   84:#include "acl.h"
        -:   85:#include "argmatch.h"
        -:   86:#include "dev-ino.h"
        -:   87:#include "dirfd.h"
        -:   88:#include "error.h"
        -:   89:#include "filenamecat.h"
        -:   90:#include "hard-locale.h"
        -:   91:#include "hash.h"
        -:   92:#include "human.h"
        -:   93:#include "filemode.h"
        -:   94:#include "inttostr.h"
        -:   95:#include "ls.h"
        -:   96:#include "lstat.h"
        -:   97:#include "mbswidth.h"
        -:   98:#include "mpsort.h"
        -:   99:#include "obstack.h"
        -:  100:#include "quote.h"
        -:  101:#include "quotearg.h"
        -:  102:#include "same.h"
        -:  103:#include "stat-time.h"
        -:  104:#include "strftime.h"
        -:  105:#include "strverscmp.h"
        -:  106:#include "xstrtol.h"
        -:  107:#include "mreadlink.h"
        -:  108:
        -:  109:#define PROGRAM_NAME (ls_mode == LS_LS ? "ls" \
        -:  110:		      : (ls_mode == LS_MULTI_COL \
        -:  111:			 ? "dir" : "vdir"))
        -:  112:
        -:  113:#define AUTHORS "Richard Stallman", "David MacKenzie"
        -:  114:
        -:  115:#define obstack_chunk_alloc malloc
        -:  116:#define obstack_chunk_free free
        -:  117:
        -:  118:/* Return an int indicating the result of comparing two integers.
        -:  119:   Subtracting doesn't always work, due to overflow.  */
        -:  120:#define longdiff(a, b) ((a) < (b) ? -1 : (a) > (b))
        -:  121:
        -:  122:#if ! HAVE_STRUCT_STAT_ST_AUTHOR
        -:  123:# define st_author st_uid
        -:  124:#endif
        -:  125:
        -:  126:enum filetype
        -:  127:  {
        -:  128:    unknown,
        -:  129:    fifo,
        -:  130:    chardev,
        -:  131:    directory,
        -:  132:    blockdev,
        -:  133:    normal,
        -:  134:    symbolic_link,
        -:  135:    sock,
        -:  136:    whiteout,
        -:  137:    arg_directory
        -:  138:  };
        -:  139:
        -:  140:/* Display letters and indicators for each filetype.
        -:  141:   Keep these in sync with enum filetype.  */
        -:  142:static char const filetype_letter[] = "?pcdb-lswd";
        -:  143:
        -:  144:/* Ensure that filetype and filetype_letter have the same
        -:  145:   number of elements.  */
        -:  146:verify (sizeof filetype_letter - 1 == arg_directory + 1);
        -:  147:
        -:  148:#define FILETYPE_INDICATORS				\
        -:  149:  {							\
        -:  150:    C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE,	\
        -:  151:    C_LINK, C_SOCK, C_FILE, C_DIR			\
        -:  152:  }
        -:  153:
        -:  154:
        -:  155:struct fileinfo
        -:  156:  {
        -:  157:    /* The file name.  */
        -:  158:    char *name;
        -:  159:
        -:  160:    /* For symbolic link, name of the file linked to, otherwise zero.  */
        -:  161:    char *linkname;
        -:  162:
        -:  163:    struct stat stat;
        -:  164:
        -:  165:    enum filetype filetype;
        -:  166:
        -:  167:    /* For symbolic link and long listing, st_mode of file linked to, otherwise
        -:  168:       zero.  */
        -:  169:    mode_t linkmode;
        -:  170:
        -:  171:    /* SELinux security context.  */
        -:  172:    security_context_t scontext;
        -:  173:
        -:  174:    bool stat_ok;
        -:  175:
        -:  176:    /* For symbolic link and color printing, true if linked-to file
        -:  177:       exists, otherwise false.  */
        -:  178:    bool linkok;
        -:  179:
        -:  180:    /* For long listings, true if the file has an access control list,
        -:  181:       or an SELinux security context.  */
        -:  182:    bool have_acl;
        -:  183:  };
        -:  184:
        -:  185:#define LEN_STR_PAIR(s) sizeof (s) - 1, s
        -:  186:
        -:  187:/* Null is a valid character in a color indicator (think about Epson
        -:  188:   printers, for example) so we have to use a length/buffer string
        -:  189:   type.  */
        -:  190:
        -:  191:struct bin_str
        -:  192:  {
        -:  193:    size_t len;			/* Number of bytes */
        -:  194:    const char *string;		/* Pointer to the same */
        -:  195:  };
        -:  196:
        -:  197:char *getgroup ();
        -:  198:char *getuser ();
        -:  199:
        -:  200:#if ! HAVE_TCGETPGRP
        -:  201:# define tcgetpgrp(Fd) 0
        -:  202:#endif
        -:  203:
        -:  204:static size_t quote_name (FILE *out, const char *name,
        -:  205:			  struct quoting_options const *options,
        -:  206:			  size_t *width);
        -:  207:static char *make_link_name (char const *name, char const *linkname);
        -:  208:static int decode_switches (int argc, char **argv);
        -:  209:static bool file_ignored (char const *name);
        -:  210:static uintmax_t gobble_file (char const *name, enum filetype type,
        -:  211:			      ino_t inode, bool command_line_arg,
        -:  212:			      char const *dirname);
        -:  213:static void print_color_indicator (const char *name, mode_t mode, int linkok,
        -:  214:				   bool stat_ok, enum filetype type);
        -:  215:static void put_indicator (const struct bin_str *ind);
        -:  216:static void add_ignore_pattern (const char *pattern);
        -:  217:static void attach (char *dest, const char *dirname, const char *name);
        -:  218:static void clear_files (void);
        -:  219:static void extract_dirs_from_files (char const *dirname,
        -:  220:				     bool command_line_arg);
        -:  221:static void get_link_name (char const *filename, struct fileinfo *f,
        -:  222:			   bool command_line_arg);
        -:  223:static void indent (size_t from, size_t to);
        -:  224:static size_t calculate_columns (bool by_columns);
        -:  225:static void print_current_files (void);
        -:  226:static void print_dir (char const *name, char const *realname,
        -:  227:		       bool command_line_arg);
        -:  228:static void print_file_name_and_frills (const struct fileinfo *f);
        -:  229:static void print_horizontal (void);
        -:  230:static int format_user_width (uid_t u);
        -:  231:static int format_group_width (gid_t g);
        -:  232:static void print_long_format (const struct fileinfo *f);
        -:  233:static void print_many_per_line (void);
        -:  234:static void print_name_with_quoting (const char *p, mode_t mode,
        -:  235:				     int linkok, bool stat_ok,
        -:  236:				     enum filetype type,
        -:  237:				     struct obstack *stack);
        -:  238:static void prep_non_filename_text (void);
        -:  239:static void print_type_indicator (bool stat_ok, mode_t mode,
        -:  240:				  enum filetype type);
        -:  241:static void print_with_commas (void);
        -:  242:static void queue_directory (char const *name, char const *realname,
        -:  243:			     bool command_line_arg);
        -:  244:static void sort_files (void);
        -:  245:static void parse_ls_color (void);
        -:  246:void usage (int status);
        -:  247:
        -:  248:/* The name this program was run with.  */
        -:  249:char *program_name;
        -:  250:
        -:  251:/* Initial size of hash table.
        -:  252:   Most hierarchies are likely to be shallower than this.  */
        -:  253:#define INITIAL_TABLE_SIZE 30
        -:  254:
        -:  255:/* The set of `active' directories, from the current command-line argument
        -:  256:   to the level in the hierarchy at which files are being listed.
        -:  257:   A directory is represented by its device and inode numbers (struct dev_ino).
        -:  258:   A directory is added to this set when ls begins listing it or its
        -:  259:   entries, and it is removed from the set just after ls has finished
        -:  260:   processing it.  This set is used solely to detect loops, e.g., with
        -:  261:   mkdir loop; cd loop; ln -s ../loop sub; ls -RL  */
        -:  262:static Hash_table *active_dir_set;
        -:  263:
        -:  264:#define LOOP_DETECT (!!active_dir_set)
        -:  265:
        -:  266:/* The table of files in the current directory:
        -:  267:
        -:  268:   `cwd_file' points to a vector of `struct fileinfo', one per file.
        -:  269:   `cwd_n_alloc' is the number of elements space has been allocated for.
        -:  270:   `cwd_n_used' is the number actually in use.  */
        -:  271:
        -:  272:/* Address of block containing the files that are described.  */
        -:  273:static struct fileinfo *cwd_file;
        -:  274:
        -:  275:/* Length of block that `cwd_file' points to, measured in files.  */
        -:  276:static size_t cwd_n_alloc;
        -:  277:
        -:  278:/* Index of first unused slot in `cwd_file'.  */
        -:  279:static size_t cwd_n_used;
        -:  280:
        -:  281:/* Vector of pointers to files, in proper sorted order, and the number
        -:  282:   of entries allocated for it.  */
        -:  283:static void **sorted_file;
        -:  284:static size_t sorted_file_alloc;
        -:  285:
        -:  286:/* When true, in a color listing, color each symlink name according to the
        -:  287:   type of file it points to.  Otherwise, color them according to the `ln'
        -:  288:   directive in LS_COLORS.  Dangling (orphan) symlinks are treated specially,
        -:  289:   regardless.  This is set when `ln=target' appears in LS_COLORS.  */
        -:  290:
        -:  291:static bool color_symlink_as_referent;
        -:  292:
        -:  293:/* mode of appropriate file for colorization */
        -:  294:#define FILE_OR_LINK_MODE(File) \
        -:  295:    ((color_symlink_as_referent & (File)->linkok) \
        -:  296:     ? (File)->linkmode : (File)->stat.st_mode)
        -:  297:
        -:  298:
        -:  299:/* Record of one pending directory waiting to be listed.  */
        -:  300:
        -:  301:struct pending
        -:  302:  {
        -:  303:    char *name;
        -:  304:    /* If the directory is actually the file pointed to by a symbolic link we
        -:  305:       were told to list, `realname' will contain the name of the symbolic
        -:  306:       link, otherwise zero.  */
        -:  307:    char *realname;
        -:  308:    bool command_line_arg;
        -:  309:    struct pending *next;
        -:  310:  };
        -:  311:
        -:  312:static struct pending *pending_dirs;
        -:  313:
        -:  314:/* Current time in seconds and nanoseconds since 1970, updated as
        -:  315:   needed when deciding whether a file is recent.  */
        -:  316:
        -:  317:static time_t current_time = TYPE_MINIMUM (time_t);
        -:  318:static int current_time_ns = -1;
        -:  319:
        -:  320:static bool print_scontext;
        -:  321:
        -:  322:/* Whether any of the files has an ACL.  This affects the width of the
        -:  323:   mode column.  */
        -:  324:
        -:  325:static bool any_has_acl;
        -:  326:
        -:  327:/* The number of columns to use for columns containing inode numbers,
        -:  328:   block sizes, link counts, owners, groups, authors, major device
        -:  329:   numbers, minor device numbers, and file sizes, respectively.  */
        -:  330:
        -:  331:static int inode_number_width;
        -:  332:static int block_size_width;
        -:  333:static int nlink_width;
        -:  334:static int scontext_width;
        -:  335:static int owner_width;
        -:  336:static int group_width;
        -:  337:static int author_width;
        -:  338:static int major_device_number_width;
        -:  339:static int minor_device_number_width;
        -:  340:static int file_size_width;
        -:  341:
        -:  342:/* Option flags */
        -:  343:
        -:  344:/* long_format for lots of info, one per line.
        -:  345:   one_per_line for just names, one per line.
        -:  346:   many_per_line for just names, many per line, sorted vertically.
        -:  347:   horizontal for just names, many per line, sorted horizontally.
        -:  348:   with_commas for just names, many per line, separated by commas.
        -:  349:
        -:  350:   -l (and other options that imply -l), -1, -C, -x and -m control
        -:  351:   this parameter.  */
        -:  352:
        -:  353:enum format
        -:  354:  {
        -:  355:    long_format,		/* -l and other options that imply -l */
        -:  356:    one_per_line,		/* -1 */
        -:  357:    many_per_line,		/* -C */
        -:  358:    horizontal,			/* -x */
        -:  359:    with_commas			/* -m */
        -:  360:  };
        -:  361:
        -:  362:static enum format format;
        -:  363:
        -:  364:/* `full-iso' uses full ISO-style dates and times.  `long-iso' uses longer
        -:  365:   ISO-style time stamps, though shorter than `full-iso'.  `iso' uses shorter
        -:  366:   ISO-style time stamps.  `locale' uses locale-dependent time stamps.  */
        -:  367:enum time_style
        -:  368:  {
        -:  369:    full_iso_time_style,	/* --time-style=full-iso */
        -:  370:    long_iso_time_style,	/* --time-style=long-iso */
        -:  371:    iso_time_style,		/* --time-style=iso */
        -:  372:    locale_time_style		/* --time-style=locale */
        -:  373:  };
        -:  374:
        -:  375:static char const *const time_style_args[] =
        -:  376:{
        -:  377:  "full-iso", "long-iso", "iso", "locale", NULL
        -:  378:};
        -:  379:static enum time_style const time_style_types[] =
        -:  380:{
        -:  381:  full_iso_time_style, long_iso_time_style, iso_time_style,
        -:  382:  locale_time_style
        -:  383:};
        -:  384:ARGMATCH_VERIFY (time_style_args, time_style_types);
        -:  385:
        -:  386:/* Type of time to print or sort by.  Controlled by -c and -u.
        -:  387:   The values of each item of this enum are important since they are
        -:  388:   used as indices in the sort functions array (see sort_files()).  */
        -:  389:
        -:  390:enum time_type
        -:  391:  {
        -:  392:    time_mtime,			/* default */
        -:  393:    time_ctime,			/* -c */
        -:  394:    time_atime,			/* -u */
        -:  395:    time_numtypes		/* the number of elements of this enum */
        -:  396:  };
        -:  397:
        -:  398:static enum time_type time_type;
        -:  399:
        -:  400:/* The file characteristic to sort by.  Controlled by -t, -S, -U, -X, -v.
        -:  401:   The values of each item of this enum are important since they are
        -:  402:   used as indices in the sort functions array (see sort_files()).  */
        -:  403:
        -:  404:enum sort_type
        -:  405:  {
        -:  406:    sort_none = -1,		/* -U */
        -:  407:    sort_name,			/* default */
        -:  408:    sort_extension,		/* -X */
        -:  409:    sort_size,			/* -S */
        -:  410:    sort_version,		/* -v */
        -:  411:    sort_time,			/* -t */
        -:  412:    sort_numtypes		/* the number of elements of this enum */
        -:  413:  };
        -:  414:
        -:  415:static enum sort_type sort_type;
        -:  416:
        -:  417:/* Direction of sort.
        -:  418:   false means highest first if numeric,
        -:  419:   lowest first if alphabetic;
        -:  420:   these are the defaults.
        -:  421:   true means the opposite order in each case.  -r  */
        -:  422:
        -:  423:static bool sort_reverse;
        -:  424:
        -:  425:/* True means to display owner information.  -g turns this off.  */
        -:  426:
        -:  427:static bool print_owner = true;
        -:  428:
        -:  429:/* True means to display author information.  */
        -:  430:
        -:  431:static bool print_author;
        -:  432:
        -:  433:/* True means to display group information.  -G and -o turn this off.  */
        -:  434:
        -:  435:static bool print_group = true;
        -:  436:
        -:  437:/* True means print the user and group id's as numbers rather
        -:  438:   than as names.  -n  */
        -:  439:
        -:  440:static bool numeric_ids;
        -:  441:
        -:  442:/* True means mention the size in blocks of each file.  -s  */
        -:  443:
        -:  444:static bool print_block_size;
        -:  445:
        -:  446:/* Human-readable options for output.  */
        -:  447:static int human_output_opts;
        -:  448:
        -:  449:/* The units to use when printing sizes other than file sizes.  */
        -:  450:static uintmax_t output_block_size;
        -:  451:
        -:  452:/* Likewise, but for file sizes.  */
        -:  453:static uintmax_t file_output_block_size = 1;
        -:  454:
        -:  455:/* Follow the output with a special string.  Using this format,
        -:  456:   Emacs' dired mode starts up twice as fast, and can handle all
        -:  457:   strange characters in file names.  */
        -:  458:static bool dired;
        -:  459:
        -:  460:/* `none' means don't mention the type of files.
        -:  461:   `slash' means mention directories only, with a '/'.
        -:  462:   `file_type' means mention file types.
        -:  463:   `classify' means mention file types and mark executables.
        -:  464:
        -:  465:   Controlled by -F, -p, and --indicator-style.  */
        -:  466:
        -:  467:enum indicator_style
        -:  468:  {
        -:  469:    none,	/*     --indicator-style=none */
        -:  470:    slash,	/* -p, --indicator-style=slash */
        -:  471:    file_type,	/*     --indicator-style=file-type */
        -:  472:    classify	/* -F, --indicator-style=classify */
        -:  473:  };
        -:  474:
        -:  475:static enum indicator_style indicator_style;
        -:  476:
        -:  477:/* Names of indicator styles.  */
        -:  478:static char const *const indicator_style_args[] =
        -:  479:{
        -:  480:  "none", "slash", "file-type", "classify", NULL
        -:  481:};
        -:  482:static enum indicator_style const indicator_style_types[] =
        -:  483:{
        -:  484:  none, slash, file_type, classify
        -:  485:};
        -:  486:ARGMATCH_VERIFY (indicator_style_args, indicator_style_types);
        -:  487:
        -:  488:/* True means use colors to mark types.  Also define the different
        -:  489:   colors as well as the stuff for the LS_COLORS environment variable.
        -:  490:   The LS_COLORS variable is now in a termcap-like format.  */
        -:  491:
        -:  492:static bool print_with_color;
        -:  493:
        -:  494:enum color_type
        -:  495:  {
        -:  496:    color_never,		/* 0: default or --color=never */
        -:  497:    color_always,		/* 1: --color=always */
        -:  498:    color_if_tty		/* 2: --color=tty */
        -:  499:  };
        -:  500:
        -:  501:enum Dereference_symlink
        -:  502:  {
        -:  503:    DEREF_UNDEFINED = 1,
        -:  504:    DEREF_NEVER,
        -:  505:    DEREF_COMMAND_LINE_ARGUMENTS,	/* -H */
        -:  506:    DEREF_COMMAND_LINE_SYMLINK_TO_DIR,	/* the default, in certain cases */
        -:  507:    DEREF_ALWAYS			/* -L */
        -:  508:  };
        -:  509:
        -:  510:enum indicator_no
        -:  511:  {
        -:  512:    C_LEFT, C_RIGHT, C_END, C_NORM, C_FILE, C_DIR, C_LINK, C_FIFO, C_SOCK,
        -:  513:    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,
        -:  514:    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE
        -:  515:  };
        -:  516:
        -:  517:static const char *const indicator_name[]=
        -:  518:  {
        -:  519:    "lc", "rc", "ec", "no", "fi", "di", "ln", "pi", "so",
        -:  520:    "bd", "cd", "mi", "or", "ex", "do", "su", "sg", "st",
        -:  521:    "ow", "tw", NULL
        -:  522:  };
        -:  523:
        -:  524:struct color_ext_type
        -:  525:  {
        -:  526:    struct bin_str ext;		/* The extension we're looking for */
        -:  527:    struct bin_str seq;		/* The sequence to output when we do */
        -:  528:    struct color_ext_type *next;	/* Next in list */
        -:  529:  };
        -:  530:
        -:  531:static struct bin_str color_indicator[] =
        -:  532:  {
        -:  533:    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
        -:  534:    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
        -:  535:    { 0, NULL },			/* ec: End color (replaces lc+no+rc) */
        -:  536:    { LEN_STR_PAIR ("0") },		/* no: Normal */
        -:  537:    { LEN_STR_PAIR ("0") },		/* fi: File: default */
        -:  538:    { LEN_STR_PAIR ("01;34") },		/* di: Directory: bright blue */
        -:  539:    { LEN_STR_PAIR ("01;36") },		/* ln: Symlink: bright cyan */
        -:  540:    { LEN_STR_PAIR ("33") },		/* pi: Pipe: yellow/brown */
        -:  541:    { LEN_STR_PAIR ("01;35") },		/* so: Socket: bright magenta */
        -:  542:    { LEN_STR_PAIR ("01;33") },		/* bd: Block device: bright yellow */
        -:  543:    { LEN_STR_PAIR ("01;33") },		/* cd: Char device: bright yellow */
        -:  544:    { 0, NULL },			/* mi: Missing file: undefined */
        -:  545:    { 0, NULL },			/* or: Orphaned symlink: undefined */
        -:  546:    { LEN_STR_PAIR ("01;32") },		/* ex: Executable: bright green */
        -:  547:    { LEN_STR_PAIR ("01;35") },		/* do: Door: bright magenta */
        -:  548:    { LEN_STR_PAIR ("37;41") },		/* su: setuid: white on red */
        -:  549:    { LEN_STR_PAIR ("30;43") },		/* sg: setgid: black on yellow */
        -:  550:    { LEN_STR_PAIR ("37;44") },		/* st: sticky: black on blue */
        -:  551:    { LEN_STR_PAIR ("34;42") },		/* ow: other-writable: blue on green */
        -:  552:    { LEN_STR_PAIR ("30;42") },		/* tw: ow w/ sticky: black on green */
        -:  553:  };
        -:  554:
        -:  555:/* FIXME: comment  */
        -:  556:static struct color_ext_type *color_ext_list = NULL;
        -:  557:
        -:  558:/* Buffer for color sequences */
        -:  559:static char *color_buf;
        -:  560:
        -:  561:/* True means to check for orphaned symbolic link, for displaying
        -:  562:   colors.  */
        -:  563:
        -:  564:static bool check_symlink_color;
        -:  565:
        -:  566:/* True means mention the inode number of each file.  -i  */
        -:  567:
        -:  568:static bool print_inode;
        -:  569:
        -:  570:/* What to do with symbolic links.  Affected by -d, -F, -H, -l (and
        -:  571:   other options that imply -l), and -L.  */
        -:  572:
        -:  573:static enum Dereference_symlink dereference;
        -:  574:
        -:  575:/* True means when a directory is found, display info on its
        -:  576:   contents.  -R  */
        -:  577:
        -:  578:static bool recursive;
        -:  579:
        -:  580:/* True means when an argument is a directory name, display info
        -:  581:   on it itself.  -d  */
        -:  582:
        -:  583:static bool immediate_dirs;
        -:  584:
        -:  585:/* True means that directories are grouped before files. */
        -:  586:
        -:  587:static bool directories_first;
        -:  588:
        -:  589:/* Which files to ignore.  */
        -:  590:
        -:  591:static enum
        -:  592:{
        -:  593:  /* Ignore files whose names start with `.', and files specified by
        -:  594:     --hide and --ignore.  */
        -:  595:  IGNORE_DEFAULT,
        -:  596:
        -:  597:  /* Ignore `.', `..', and files specified by --ignore.  */
        -:  598:  IGNORE_DOT_AND_DOTDOT,
        -:  599:
        -:  600:  /* Ignore only files specified by --ignore.  */
        -:  601:  IGNORE_MINIMAL
        -:  602:} ignore_mode;
        -:  603:
        -:  604:/* A linked list of shell-style globbing patterns.  If a non-argument
        -:  605:   file name matches any of these patterns, it is ignored.
        -:  606:   Controlled by -I.  Multiple -I options accumulate.
        -:  607:   The -B option adds `*~' and `.*~' to this list.  */
        -:  608:
        -:  609:struct ignore_pattern
        -:  610:  {
        -:  611:    const char *pattern;
        -:  612:    struct ignore_pattern *next;
        -:  613:  };
        -:  614:
        -:  615:static struct ignore_pattern *ignore_patterns;
        -:  616:
        -:  617:/* Similar to IGNORE_PATTERNS, except that -a or -A causes this
        -:  618:   variable itself to be ignored.  */
        -:  619:static struct ignore_pattern *hide_patterns;
        -:  620:
        -:  621:/* True means output nongraphic chars in file names as `?'.
        -:  622:   (-q, --hide-control-chars)
        -:  623:   qmark_funny_chars and the quoting style (-Q, --quoting-style=WORD) are
        -:  624:   independent.  The algorithm is: first, obey the quoting style to get a
        -:  625:   string representing the file name;  then, if qmark_funny_chars is set,
        -:  626:   replace all nonprintable chars in that string with `?'.  It's necessary
        -:  627:   to replace nonprintable chars even in quoted strings, because we don't
        -:  628:   want to mess up the terminal if control chars get sent to it, and some
        -:  629:   quoting methods pass through control chars as-is.  */
        -:  630:static bool qmark_funny_chars;
        -:  631:
        -:  632:/* Quoting options for file and dir name output.  */
        -:  633:
        -:  634:static struct quoting_options *filename_quoting_options;
        -:  635:static struct quoting_options *dirname_quoting_options;
        -:  636:
        -:  637:/* The number of chars per hardware tab stop.  Setting this to zero
        -:  638:   inhibits the use of TAB characters for separating columns.  -T */
        -:  639:static size_t tabsize;
        -:  640:
        -:  641:/* True means print each directory name before listing it.  */
        -:  642:
        -:  643:static bool print_dir_name;
        -:  644:
        -:  645:/* The line length to use for breaking lines in many-per-line format.
        -:  646:   Can be set with -w.  */
        -:  647:
        -:  648:static size_t line_length;
        -:  649:
        -:  650:/* If true, the file listing format requires that stat be called on
        -:  651:   each file.  */
        -:  652:
        -:  653:static bool format_needs_stat;
        -:  654:
        -:  655:/* Similar to `format_needs_stat', but set if only the file type is
        -:  656:   needed.  */
        -:  657:
        -:  658:static bool format_needs_type;
        -:  659:
        -:  660:/* An arbitrary limit on the number of bytes in a printed time stamp.
        -:  661:   This is set to a relatively small value to avoid the need to worry
        -:  662:   about denial-of-service attacks on servers that run "ls" on behalf
        -:  663:   of remote clients.  1000 bytes should be enough for any practical
        -:  664:   time stamp format.  */
        -:  665:
        -:  666:enum { TIME_STAMP_LEN_MAXIMUM = MAX (1000, INT_STRLEN_BOUND (time_t)) };
        -:  667:
        -:  668:/* strftime formats for non-recent and recent files, respectively, in
        -:  669:   -l output.  */
        -:  670:
        -:  671:static char const *long_time_format[2] =
        -:  672:  {
        -:  673:    /* strftime format for non-recent files (older than 6 months), in
        -:  674:       -l output.  This should contain the year, month and day (at
        -:  675:       least), in an order that is understood by people in your
        -:  676:       locale's territory.  Please try to keep the number of used
        -:  677:       screen columns small, because many people work in windows with
        -:  678:       only 80 columns.  But make this as wide as the other string
        -:  679:       below, for recent files.  */
        -:  680:    N_("%b %e  %Y"),
        -:  681:    /* strftime format for recent files (younger than 6 months), in -l
        -:  682:       output.  This should contain the month, day and time (at
        -:  683:       least), in an order that is understood by people in your
        -:  684:       locale's territory.  Please try to keep the number of used
        -:  685:       screen columns small, because many people work in windows with
        -:  686:       only 80 columns.  But make this as wide as the other string
        -:  687:       above, for non-recent files.  */
        -:  688:    N_("%b %e %H:%M")
        -:  689:  };
        -:  690:
        -:  691:/* The set of signals that are caught.  */
        -:  692:
        -:  693:static sigset_t caught_signals;
        -:  694:
        -:  695:/* If nonzero, the value of the pending fatal signal.  */
        -:  696:
        -:  697:static sig_atomic_t volatile interrupt_signal;
        -:  698:
        -:  699:/* A count of the number of pending stop signals that have been received.  */
        -:  700:
        -:  701:static sig_atomic_t volatile stop_signal_count;
        -:  702:
        -:  703:/* Desired exit status.  */
        -:  704:
        -:  705:static int exit_status;
        -:  706:
        -:  707:/* Exit statuses.  */
        -:  708:enum
        -:  709:  {
        -:  710:    /* "ls" had a minor problem (e.g., it could not stat a directory
        -:  711:       entry).  */
        -:  712:    LS_MINOR_PROBLEM = 1,
        -:  713:
        -:  714:    /* "ls" had more serious trouble.  */
        -:  715:    LS_FAILURE = 2
        -:  716:  };
        -:  717:
        -:  718:/* For long options that have no equivalent short option, use a
        -:  719:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  720:enum
        -:  721:{
        -:  722:  AUTHOR_OPTION = CHAR_MAX + 1,
        -:  723:  BLOCK_SIZE_OPTION,
        -:  724:  COLOR_OPTION,
        -:  725:  DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION,
        -:  726:  FILE_TYPE_INDICATOR_OPTION,
        -:  727:  FORMAT_OPTION,
        -:  728:  FULL_TIME_OPTION,
        -:  729:  GROUP_DIRECTORIES_FIRST_OPTION,
        -:  730:  HIDE_OPTION,
        -:  731:  INDICATOR_STYLE_OPTION,
        -:  732:
        -:  733:  /* FIXME: --kilobytes is deprecated (but not -k); remove in late 2006 */
        -:  734:  KILOBYTES_LONG_OPTION,
        -:  735:
        -:  736:  QUOTING_STYLE_OPTION,
        -:  737:  SHOW_CONTROL_CHARS_OPTION,
        -:  738:  SI_OPTION,
        -:  739:  SORT_OPTION,
        -:  740:  TIME_OPTION,
        -:  741:  TIME_STYLE_OPTION
        -:  742:};
        -:  743:
        -:  744:static struct option const long_options[] =
        -:  745:{
        -:  746:  {"all", no_argument, NULL, 'a'},
        -:  747:  {"escape", no_argument, NULL, 'b'},
        -:  748:  {"directory", no_argument, NULL, 'd'},
        -:  749:  {"dired", no_argument, NULL, 'D'},
        -:  750:  {"full-time", no_argument, NULL, FULL_TIME_OPTION},
        -:  751:  {"group-directories-first", no_argument, NULL,
        -:  752:   GROUP_DIRECTORIES_FIRST_OPTION},
        -:  753:  {"human-readable", no_argument, NULL, 'h'},
        -:  754:  {"inode", no_argument, NULL, 'i'},
        -:  755:  {"kilobytes", no_argument, NULL, KILOBYTES_LONG_OPTION},
        -:  756:  {"numeric-uid-gid", no_argument, NULL, 'n'},
        -:  757:  {"no-group", no_argument, NULL, 'G'},
        -:  758:  {"hide-control-chars", no_argument, NULL, 'q'},
        -:  759:  {"reverse", no_argument, NULL, 'r'},
        -:  760:  {"size", no_argument, NULL, 's'},
        -:  761:  {"width", required_argument, NULL, 'w'},
        -:  762:  {"almost-all", no_argument, NULL, 'A'},
        -:  763:  {"ignore-backups", no_argument, NULL, 'B'},
        -:  764:  {"classify", no_argument, NULL, 'F'},
        -:  765:  {"file-type", no_argument, NULL, FILE_TYPE_INDICATOR_OPTION},
        -:  766:  {"si", no_argument, NULL, SI_OPTION},
        -:  767:  {"dereference-command-line", no_argument, NULL, 'H'},
        -:  768:  {"dereference-command-line-symlink-to-dir", no_argument, NULL,
        -:  769:   DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION},
        -:  770:  {"hide", required_argument, NULL, HIDE_OPTION},
        -:  771:  {"ignore", required_argument, NULL, 'I'},
        -:  772:  {"indicator-style", required_argument, NULL, INDICATOR_STYLE_OPTION},
        -:  773:  {"dereference", no_argument, NULL, 'L'},
        -:  774:  {"literal", no_argument, NULL, 'N'},
        -:  775:  {"quote-name", no_argument, NULL, 'Q'},
        -:  776:  {"quoting-style", required_argument, NULL, QUOTING_STYLE_OPTION},
        -:  777:  {"recursive", no_argument, NULL, 'R'},
        -:  778:  {"format", required_argument, NULL, FORMAT_OPTION},
        -:  779:  {"show-control-chars", no_argument, NULL, SHOW_CONTROL_CHARS_OPTION},
        -:  780:  {"sort", required_argument, NULL, SORT_OPTION},
        -:  781:  {"tabsize", required_argument, NULL, 'T'},
        -:  782:  {"time", required_argument, NULL, TIME_OPTION},
        -:  783:  {"time-style", required_argument, NULL, TIME_STYLE_OPTION},
        -:  784:  {"color", optional_argument, NULL, COLOR_OPTION},
        -:  785:  {"block-size", required_argument, NULL, BLOCK_SIZE_OPTION},
        -:  786:  {"context", no_argument, 0, 'Z'},
        -:  787:  {"author", no_argument, NULL, AUTHOR_OPTION},
        -:  788:  {GETOPT_HELP_OPTION_DECL},
        -:  789:  {GETOPT_VERSION_OPTION_DECL},
        -:  790:  {NULL, 0, NULL, 0}
        -:  791:};
        -:  792:
        -:  793:static char const *const format_args[] =
        -:  794:{
        -:  795:  "verbose", "long", "commas", "horizontal", "across",
        -:  796:  "vertical", "single-column", NULL
        -:  797:};
        -:  798:static enum format const format_types[] =
        -:  799:{
        -:  800:  long_format, long_format, with_commas, horizontal, horizontal,
        -:  801:  many_per_line, one_per_line
        -:  802:};
        -:  803:ARGMATCH_VERIFY (format_args, format_types);
        -:  804:
        -:  805:static char const *const sort_args[] =
        -:  806:{
        -:  807:  "none", "time", "size", "extension", "version", NULL
        -:  808:};
        -:  809:static enum sort_type const sort_types[] =
        -:  810:{
        -:  811:  sort_none, sort_time, sort_size, sort_extension, sort_version
        -:  812:};
        -:  813:ARGMATCH_VERIFY (sort_args, sort_types);
        -:  814:
        -:  815:static char const *const time_args[] =
        -:  816:{
        -:  817:  "atime", "access", "use", "ctime", "status", NULL
        -:  818:};
        -:  819:static enum time_type const time_types[] =
        -:  820:{
        -:  821:  time_atime, time_atime, time_atime, time_ctime, time_ctime
        -:  822:};
        -:  823:ARGMATCH_VERIFY (time_args, time_types);
        -:  824:
        -:  825:static char const *const color_args[] =
        -:  826:{
        -:  827:  /* force and none are for compatibility with another color-ls version */
        -:  828:  "always", "yes", "force",
        -:  829:  "never", "no", "none",
        -:  830:  "auto", "tty", "if-tty", NULL
        -:  831:};
        -:  832:static enum color_type const color_types[] =
        -:  833:{
        -:  834:  color_always, color_always, color_always,
        -:  835:  color_never, color_never, color_never,
        -:  836:  color_if_tty, color_if_tty, color_if_tty
        -:  837:};
        -:  838:ARGMATCH_VERIFY (color_args, color_types);
        -:  839:
        -:  840:/* Information about filling a column.  */
        -:  841:struct column_info
        -:  842:{
        -:  843:  bool valid_len;
        -:  844:  size_t line_len;
        -:  845:  size_t *col_arr;
        -:  846:};
        -:  847:
        -:  848:/* Array with information about column filledness.  */
        -:  849:static struct column_info *column_info;
        -:  850:
        -:  851:/* Maximum number of columns ever possible for this display.  */
        -:  852:static size_t max_idx;
        -:  853:
        -:  854:/* The minimum width of a column is 3: 1 character for the name and 2
        -:  855:   for the separating white space.  */
        -:  856:#define MIN_COLUMN_WIDTH	3
        -:  857:
        -:  858:
        -:  859:/* This zero-based index is used solely with the --dired option.
        -:  860:   When that option is in effect, this counter is incremented for each
        -:  861:   byte of output generated by this program so that the beginning
        -:  862:   and ending indices (in that output) of every file name can be recorded
        -:  863:   and later output themselves.  */
        -:  864:static size_t dired_pos;
        -:  865:
        -:  866:#define DIRED_PUTCHAR(c) do {putchar ((c)); ++dired_pos;} while (0)
        -:  867:
        -:  868:/* Write S to STREAM and increment DIRED_POS by S_LEN.  */
        -:  869:#define DIRED_FPUTS(s, stream, s_len) \
        -:  870:    do {fputs (s, stream); dired_pos += s_len;} while (0)
        -:  871:
        -:  872:/* Like DIRED_FPUTS, but for use when S is a literal string.  */
        -:  873:#define DIRED_FPUTS_LITERAL(s, stream) \
        -:  874:    do {fputs (s, stream); dired_pos += sizeof (s) - 1;} while (0)
        -:  875:
        -:  876:#define DIRED_INDENT()							\
        -:  877:    do									\
        -:  878:      {									\
        -:  879:	if (dired)							\
        -:  880:	  DIRED_FPUTS_LITERAL ("  ", stdout);				\
        -:  881:      }									\
        -:  882:    while (0)
        -:  883:
        -:  884:/* With --dired, store pairs of beginning and ending indices of filenames.  */
        -:  885:static struct obstack dired_obstack;
        -:  886:
        -:  887:/* With --dired, store pairs of beginning and ending indices of any
        -:  888:   directory names that appear as headers (just before `total' line)
        -:  889:   for lists of directory entries.  Such directory names are seen when
        -:  890:   listing hierarchies using -R and when a directory is listed with at
        -:  891:   least one other command line argument.  */
        -:  892:static struct obstack subdired_obstack;
        -:  893:
        -:  894:/* Save the current index on the specified obstack, OBS.  */
        -:  895:#define PUSH_CURRENT_DIRED_POS(obs)					\
        -:  896:  do									\
        -:  897:    {									\
        -:  898:      if (dired)							\
        -:  899:	obstack_grow (obs, &dired_pos, sizeof (dired_pos));		\
        -:  900:    }									\
        -:  901:  while (0)
        -:  902:
        -:  903:/* With -R, this stack is used to help detect directory cycles.
        -:  904:   The device/inode pairs on this stack mirror the pairs in the
        -:  905:   active_dir_set hash table.  */
        -:  906:static struct obstack dev_ino_obstack;
        -:  907:
        -:  908:/* Push a pair onto the device/inode stack.  */
        -:  909:#define DEV_INO_PUSH(Dev, Ino)						\
        -:  910:  do									\
        -:  911:    {									\
        -:  912:      struct dev_ino *di;						\
        -:  913:      obstack_blank (&dev_ino_obstack, sizeof (struct dev_ino));	\
        -:  914:      di = -1 + (struct dev_ino *) obstack_next_free (&dev_ino_obstack); \
        -:  915:      di->st_dev = (Dev);						\
        -:  916:      di->st_ino = (Ino);						\
        -:  917:    }									\
        -:  918:  while (0)
        -:  919:
        -:  920:/* Pop a dev/ino struct off the global dev_ino_obstack
        -:  921:   and return that struct.  */
        -:  922:static struct dev_ino
    #####:  923:dev_ino_pop (void)
        -:  924:{
    #####:  925:  assert (sizeof (struct dev_ino) <= obstack_object_size (&dev_ino_obstack));
    #####:  926:  obstack_blank (&dev_ino_obstack, -(int) (sizeof (struct dev_ino)));
    #####:  927:  return *(struct dev_ino *) obstack_next_free (&dev_ino_obstack);
        -:  928:}
        -:  929:
        -:  930:#define ASSERT_MATCHING_DEV_INO(Name, Di)	\
        -:  931:  do						\
        -:  932:    {						\
        -:  933:      struct stat sb;				\
        -:  934:      assert (Name);				\
        -:  935:      assert (0 <= stat (Name, &sb));		\
        -:  936:      assert (sb.st_dev == Di.st_dev);		\
        -:  937:      assert (sb.st_ino == Di.st_ino);		\
        -:  938:    }						\
        -:  939:  while (0)
        -:  940:
        -:  941:
        -:  942:/* Write to standard output PREFIX, followed by the quoting style and
        -:  943:   a space-separated list of the integers stored in OS all on one line.  */
        -:  944:
        -:  945:static void
    #####:  946:dired_dump_obstack (const char *prefix, struct obstack *os)
        -:  947:{
        -:  948:  size_t n_pos;
        -:  949:
    #####:  950:  n_pos = obstack_object_size (os) / sizeof (dired_pos);
    #####:  951:  if (n_pos > 0)
        -:  952:    {
        -:  953:      size_t i;
        -:  954:      size_t *pos;
        -:  955:
    #####:  956:      pos = (size_t *) obstack_finish (os);
    #####:  957:      fputs (prefix, stdout);
    #####:  958:      for (i = 0; i < n_pos; i++)
    #####:  959:	printf (" %lu", (unsigned long int) pos[i]);
    #####:  960:      putchar ('\n');
        -:  961:    }
    #####:  962:}
        -:  963:
        -:  964:static size_t
    #####:  965:dev_ino_hash (void const *x, size_t table_size)
        -:  966:{
    #####:  967:  struct dev_ino const *p = x;
    #####:  968:  return (uintmax_t) p->st_ino % table_size;
        -:  969:}
        -:  970:
        -:  971:static bool
    #####:  972:dev_ino_compare (void const *x, void const *y)
        -:  973:{
    #####:  974:  struct dev_ino const *a = x;
    #####:  975:  struct dev_ino const *b = y;
    #####:  976:  return SAME_INODE (*a, *b) ? true : false;
        -:  977:}
        -:  978:
        -:  979:static void
    #####:  980:dev_ino_free (void *x)
        -:  981:{
    #####:  982:  free (x);
    #####:  983:}
        -:  984:
        -:  985:/* Add the device/inode pair (P->st_dev/P->st_ino) to the set of
        -:  986:   active directories.  Return true if there is already a matching
        -:  987:   entry in the table.  */
        -:  988:
        -:  989:static bool
    #####:  990:visit_dir (dev_t dev, ino_t ino)
        -:  991:{
        -:  992:  struct dev_ino *ent;
        -:  993:  struct dev_ino *ent_from_table;
        -:  994:  bool found_match;
        -:  995:
    #####:  996:  ent = xmalloc (sizeof *ent);
    #####:  997:  ent->st_ino = ino;
    #####:  998:  ent->st_dev = dev;
        -:  999:
        -: 1000:  /* Attempt to insert this entry into the table.  */
    #####: 1001:  ent_from_table = hash_insert (active_dir_set, ent);
        -: 1002:
    #####: 1003:  if (ent_from_table == NULL)
        -: 1004:    {
        -: 1005:      /* Insertion failed due to lack of memory.  */
    #####: 1006:      xalloc_die ();
        -: 1007:    }
        -: 1008:
    #####: 1009:  found_match = (ent_from_table != ent);
        -: 1010:
    #####: 1011:  if (found_match)
        -: 1012:    {
        -: 1013:      /* ent was not inserted, so free it.  */
    #####: 1014:      free (ent);
        -: 1015:    }
        -: 1016:
    #####: 1017:  return found_match;
        -: 1018:}
        -: 1019:
        -: 1020:static void
    #####: 1021:free_pending_ent (struct pending *p)
        -: 1022:{
    #####: 1023:  free (p->name);
    #####: 1024:  free (p->realname);
    #####: 1025:  free (p);
    #####: 1026:}
        -: 1027:
        -: 1028:static bool
    #####: 1029:is_colored (enum indicator_no type)
        -: 1030:{
    #####: 1031:  size_t len = color_indicator[type].len;
    #####: 1032:  char const *s = color_indicator[type].string;
    #####: 1033:  return ! (len == 0
    #####: 1034:	    || (len == 1 && strncmp (s, "0", 1) == 0)
    #####: 1035:	    || (len == 2 && strncmp (s, "00", 2) == 0));
        -: 1036:}
        -: 1037:
        -: 1038:static void
    #####: 1039:restore_default_color (void)
        -: 1040:{
    #####: 1041:  put_indicator (&color_indicator[C_LEFT]);
    #####: 1042:  put_indicator (&color_indicator[C_RIGHT]);
    #####: 1043:}
        -: 1044:
        -: 1045:/* An ordinary signal was received; arrange for the program to exit.  */
        -: 1046:
        -: 1047:static void
    #####: 1048:sighandler (int sig)
        -: 1049:{
        -: 1050:  if (! SA_NOCLDSTOP)
        -: 1051:    signal (sig, SIG_IGN);
    #####: 1052:  if (! interrupt_signal)
    #####: 1053:    interrupt_signal = sig;
    #####: 1054:}
        -: 1055:
        -: 1056:/* A SIGTSTP was received; arrange for the program to suspend itself.  */
        -: 1057:
        -: 1058:static void
    #####: 1059:stophandler (int sig)
        -: 1060:{
        -: 1061:  if (! SA_NOCLDSTOP)
        -: 1062:    signal (sig, stophandler);
    #####: 1063:  if (! interrupt_signal)
    #####: 1064:    stop_signal_count++;
    #####: 1065:}
        -: 1066:
        -: 1067:/* Process any pending signals.  If signals are caught, this function
        -: 1068:   should be called periodically.  Ideally there should never be an
        -: 1069:   unbounded amount of time when signals are not being processed.
        -: 1070:   Signal handling can restore the default colors, so callers must
        -: 1071:   immediately change colors after invoking this function.  */
        -: 1072:
        -: 1073:static void
    #####: 1074:process_signals (void)
        -: 1075:{
    #####: 1076:  while (interrupt_signal | stop_signal_count)
        -: 1077:    {
        -: 1078:      int sig;
        -: 1079:      int stops;
        -: 1080:      sigset_t oldset;
        -: 1081:
    #####: 1082:      restore_default_color ();
    #####: 1083:      fflush (stdout);
        -: 1084:
    #####: 1085:      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
        -: 1086:
        -: 1087:      /* Reload interrupt_signal and stop_signal_count, in case a new
        -: 1088:	 signal was handled before sigprocmask took effect.  */
    #####: 1089:      sig = interrupt_signal;
    #####: 1090:      stops = stop_signal_count;
        -: 1091:
        -: 1092:      /* SIGTSTP is special, since the application can receive that signal
        -: 1093:	 more than once.  In this case, don't set the signal handler to the
        -: 1094:	 default.  Instead, just raise the uncatchable SIGSTOP.  */
    #####: 1095:      if (stops)
        -: 1096:	{
    #####: 1097:	  stop_signal_count = stops - 1;
    #####: 1098:	  sig = SIGSTOP;
        -: 1099:	}
        -: 1100:      else
    #####: 1101:	signal (sig, SIG_DFL);
        -: 1102:
        -: 1103:      /* Exit or suspend the program.  */
    #####: 1104:      raise (sig);
    #####: 1105:      sigprocmask (SIG_SETMASK, &oldset, NULL);
        -: 1106:
        -: 1107:      /* If execution reaches here, then the program has been
        -: 1108:	 continued (after being suspended).  */
        -: 1109:    }
    #####: 1110:}
        -: 1111:
        -: 1112:int
       12: 1113:main (int argc, char **argv)
        -: 1114:{
        -: 1115:  int i;
        -: 1116:  struct pending *thispend;
        -: 1117:  int n_files;
        -: 1118:
        -: 1119:  /* The signals that are trapped, and the number of such signals.  */
        -: 1120:  static int const sig[] =
        -: 1121:    {
        -: 1122:      /* This one is handled specially.  */
        -: 1123:      SIGTSTP,
        -: 1124:
        -: 1125:      /* The usual suspects.  */
        -: 1126:      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
        -: 1127:#ifdef SIGPOLL
        -: 1128:      SIGPOLL,
        -: 1129:#endif
        -: 1130:#ifdef SIGPROF
        -: 1131:      SIGPROF,
        -: 1132:#endif
        -: 1133:#ifdef SIGVTALRM
        -: 1134:      SIGVTALRM,
        -: 1135:#endif
        -: 1136:#ifdef SIGXCPU
        -: 1137:      SIGXCPU,
        -: 1138:#endif
        -: 1139:#ifdef SIGXFSZ
        -: 1140:      SIGXFSZ,
        -: 1141:#endif
        -: 1142:    };
        -: 1143:  enum { nsigs = sizeof sig / sizeof sig[0] };
        -: 1144:
        -: 1145:#if ! SA_NOCLDSTOP
        -: 1146:  bool caught_sig[nsigs];
        -: 1147:#endif
        -: 1148:
        -: 1149:  initialize_main (&argc, &argv);
       12: 1150:  program_name = argv[0];
       12: 1151:  setlocale (LC_ALL, "");
        -: 1152:  bindtextdomain (PACKAGE, LOCALEDIR);
        -: 1153:  textdomain (PACKAGE);
        -: 1154:
       12: 1155:  initialize_exit_failure (LS_FAILURE);
       12: 1156:  atexit (close_stdout);
        -: 1157:
        -: 1158:#define N_ENTRIES(Array) (sizeof Array / sizeof *(Array))
        -: 1159:  assert (N_ENTRIES (color_indicator) + 1 == N_ENTRIES (indicator_name));
        -: 1160:
       12: 1161:  exit_status = EXIT_SUCCESS;
       12: 1162:  print_dir_name = true;
       12: 1163:  pending_dirs = NULL;
        -: 1164:
       12: 1165:  i = decode_switches (argc, argv);
        -: 1166:
       12: 1167:  if (print_with_color)
    #####: 1168:    parse_ls_color ();
        -: 1169:
        -: 1170:  /* Test print_with_color again, because the call to parse_ls_color
        -: 1171:     may have just reset it -- e.g., if LS_COLORS is invalid.  */
       12: 1172:  if (print_with_color)
        -: 1173:    {
        -: 1174:      /* Avoid following symbolic links when possible.  */
    #####: 1175:      if (is_colored (C_ORPHAN)
    #####: 1176:	  || is_colored (C_EXEC)
    #####: 1177:	  || (is_colored (C_MISSING) && format == long_format))
    #####: 1178:	check_symlink_color = true;
        -: 1179:
        -: 1180:      /* If the standard output is a controlling terminal, watch out
        -: 1181:         for signals, so that the colors can be restored to the
        -: 1182:         default state if "ls" is suspended or interrupted.  */
        -: 1183:
    #####: 1184:      if (0 <= tcgetpgrp (STDOUT_FILENO))
        -: 1185:	{
        -: 1186:	  int j;
        -: 1187:#if SA_NOCLDSTOP
        -: 1188:	  struct sigaction act;
        -: 1189:
    #####: 1190:	  sigemptyset (&caught_signals);
    #####: 1191:	  for (j = 0; j < nsigs; j++)
        -: 1192:	    {
    #####: 1193:	      sigaction (sig[j], NULL, &act);
    #####: 1194:	      if (act.sa_handler != SIG_IGN)
    #####: 1195:		sigaddset (&caught_signals, sig[j]);
        -: 1196:	    }
        -: 1197:
    #####: 1198:	  act.sa_mask = caught_signals;
    #####: 1199:	  act.sa_flags = SA_RESTART;
        -: 1200:
    #####: 1201:	  for (j = 0; j < nsigs; j++)
    #####: 1202:	    if (sigismember (&caught_signals, sig[j]))
        -: 1203:	      {
    #####: 1204:		act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
    #####: 1205:		sigaction (sig[j], &act, NULL);
        -: 1206:	      }
        -: 1207:#else
        -: 1208:	  for (j = 0; j < nsigs; j++)
        -: 1209:	    {
        -: 1210:	      caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
        -: 1211:	      if (caught_sig[j])
        -: 1212:		{
        -: 1213:		  signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
        -: 1214:		  siginterrupt (sig[j], 0);
        -: 1215:		}
        -: 1216:	    }
        -: 1217:#endif
        -: 1218:	}
        -: 1219:
    #####: 1220:      prep_non_filename_text ();
        -: 1221:    }
        -: 1222:
       12: 1223:  if (dereference == DEREF_UNDEFINED)
       12: 1224:    dereference = ((immediate_dirs
       12: 1225:		    || indicator_style == classify
       12: 1226:		    || format == long_format)
        -: 1227:		   ? DEREF_NEVER
        -: 1228:		   : DEREF_COMMAND_LINE_SYMLINK_TO_DIR);
        -: 1229:
        -: 1230:  /* When using -R, initialize a data structure we'll use to
        -: 1231:     detect any directory cycles.  */
       12: 1232:  if (recursive)
        -: 1233:    {
    #####: 1234:      active_dir_set = hash_initialize (INITIAL_TABLE_SIZE, NULL,
        -: 1235:					dev_ino_hash,
        -: 1236:					dev_ino_compare,
        -: 1237:					dev_ino_free);
    #####: 1238:      if (active_dir_set == NULL)
    #####: 1239:	xalloc_die ();
        -: 1240:
    #####: 1241:      obstack_init (&dev_ino_obstack);
        -: 1242:    }
        -: 1243:
       36: 1244:  format_needs_stat = sort_type == sort_time || sort_type == sort_size
       12: 1245:    || format == long_format
       12: 1246:    || print_scontext
       24: 1247:    || print_block_size;
       24: 1248:  format_needs_type = (! format_needs_stat
       12: 1249:		       && (recursive
       12: 1250:			   || print_with_color
       12: 1251:			   || indicator_style != none
       12: 1252:			   || directories_first));
        -: 1253:
       12: 1254:  if (dired)
        -: 1255:    {
    #####: 1256:      obstack_init (&dired_obstack);
    #####: 1257:      obstack_init (&subdired_obstack);
        -: 1258:    }
        -: 1259:
       12: 1260:  cwd_n_alloc = 100;
       12: 1261:  cwd_file = xnmalloc (cwd_n_alloc, sizeof *cwd_file);
       12: 1262:  cwd_n_used = 0;
        -: 1263:
       12: 1264:  clear_files ();
        -: 1265:
       12: 1266:  n_files = argc - i;
        -: 1267:
       12: 1268:  if (n_files <= 0)
        -: 1269:    {
    #####: 1270:      if (immediate_dirs)
    #####: 1271:	gobble_file (".", directory, NOT_AN_INODE_NUMBER, true, "");
        -: 1272:      else
    #####: 1273:	queue_directory (".", NULL, true);
        -: 1274:    }
        -: 1275:  else
        -: 1276:    do
     1164: 1277:      gobble_file (argv[i++], unknown, NOT_AN_INODE_NUMBER, true, "");
     1164: 1278:    while (i < argc);
        -: 1279:
       12: 1280:  if (cwd_n_used)
        -: 1281:    {
       12: 1282:      sort_files ();
       12: 1283:      if (!immediate_dirs)
       12: 1284:	extract_dirs_from_files (NULL, true);
        -: 1285:      /* `cwd_n_used' might be zero now.  */
        -: 1286:    }
        -: 1287:
        -: 1288:  /* In the following if/else blocks, it is sufficient to test `pending_dirs'
        -: 1289:     (and not pending_dirs->name) because there may be no markers in the queue
        -: 1290:     at this point.  A marker may be enqueued when extract_dirs_from_files is
        -: 1291:     called with a non-empty string or via print_dir.  */
       12: 1292:  if (cwd_n_used)
        -: 1293:    {
       12: 1294:      print_current_files ();
       12: 1295:      if (pending_dirs)
    #####: 1296:	DIRED_PUTCHAR ('\n');
        -: 1297:    }
    #####: 1298:  else if (n_files <= 1 && pending_dirs && pending_dirs->next == 0)
    #####: 1299:    print_dir_name = false;
        -: 1300:
       24: 1301:  while (pending_dirs)
        -: 1302:    {
    #####: 1303:      thispend = pending_dirs;
    #####: 1304:      pending_dirs = pending_dirs->next;
        -: 1305:
    #####: 1306:      if (LOOP_DETECT)
        -: 1307:	{
    #####: 1308:	  if (thispend->name == NULL)
        -: 1309:	    {
        -: 1310:	      /* thispend->name == NULL means this is a marker entry
        -: 1311:		 indicating we've finished processing the directory.
        -: 1312:		 Use its dev/ino numbers to remove the corresponding
        -: 1313:		 entry from the active_dir_set hash table.  */
    #####: 1314:	      struct dev_ino di = dev_ino_pop ();
    #####: 1315:	      struct dev_ino *found = hash_delete (active_dir_set, &di);
        -: 1316:	      /* ASSERT_MATCHING_DEV_INO (thispend->realname, di); */
    #####: 1317:	      assert (found);
    #####: 1318:	      dev_ino_free (found);
    #####: 1319:	      free_pending_ent (thispend);
    #####: 1320:	      continue;
        -: 1321:	    }
        -: 1322:	}
        -: 1323:
    #####: 1324:      print_dir (thispend->name, thispend->realname,
    #####: 1325:		 thispend->command_line_arg);
        -: 1326:
    #####: 1327:      free_pending_ent (thispend);
    #####: 1328:      print_dir_name = true;
        -: 1329:    }
        -: 1330:
       12: 1331:  if (print_with_color)
        -: 1332:    {
        -: 1333:      int j;
        -: 1334:
    #####: 1335:      restore_default_color ();
    #####: 1336:      fflush (stdout);
        -: 1337:
        -: 1338:      /* Restore the default signal handling.  */
        -: 1339:#if SA_NOCLDSTOP
    #####: 1340:      for (j = 0; j < nsigs; j++)
    #####: 1341:	if (sigismember (&caught_signals, sig[j]))
    #####: 1342:	  signal (sig[j], SIG_DFL);
        -: 1343:#else
        -: 1344:      for (j = 0; j < nsigs; j++)
        -: 1345:	if (caught_sig[j])
        -: 1346:	  signal (sig[j], SIG_DFL);
        -: 1347:#endif
        -: 1348:
        -: 1349:      /* Act on any signals that arrived before the default was restored.
        -: 1350:	 This can process signals out of order, but there doesn't seem to
        -: 1351:	 be an easy way to do them in order, and the order isn't that
        -: 1352:	 important anyway.  */
    #####: 1353:      for (j = stop_signal_count; j; j--)
    #####: 1354:	raise (SIGSTOP);
    #####: 1355:      j = interrupt_signal;
    #####: 1356:      if (j)
    #####: 1357:	raise (j);
        -: 1358:    }
        -: 1359:
       12: 1360:  if (dired)
        -: 1361:    {
        -: 1362:      /* No need to free these since we're about to exit.  */
    #####: 1363:      dired_dump_obstack ("//DIRED//", &dired_obstack);
    #####: 1364:      dired_dump_obstack ("//SUBDIRED//", &subdired_obstack);
    #####: 1365:      printf ("//DIRED-OPTIONS// --quoting-style=%s\n",
    #####: 1366:	      quoting_style_args[get_quoting_style (filename_quoting_options)]);
        -: 1367:    }
        -: 1368:
       12: 1369:  if (LOOP_DETECT)
        -: 1370:    {
    #####: 1371:      assert (hash_get_n_entries (active_dir_set) == 0);
    #####: 1372:      hash_free (active_dir_set);
        -: 1373:    }
        -: 1374:
       12: 1375:  exit (exit_status);
        -: 1376:}
        -: 1377:
        -: 1378:/* Set all the option flags according to the switches specified.
        -: 1379:   Return the index of the first non-option argument.  */
        -: 1380:
        -: 1381:static int
       12: 1382:decode_switches (int argc, char **argv)
        -: 1383:{
        -: 1384:  int c;
       12: 1385:  char *time_style_option = NULL;
        -: 1386:
        -: 1387:  /* Record whether there is an option specifying sort type.  */
       12: 1388:  bool sort_type_specified = false;
        -: 1389:
       12: 1390:  qmark_funny_chars = false;
        -: 1391:
        -: 1392:  /* initialize all switches to default settings */
        -: 1393:
       12: 1394:  switch (ls_mode)
        -: 1395:    {
        -: 1396:    case LS_MULTI_COL:
        -: 1397:      /* This is for the `dir' program.  */
    #####: 1398:      format = many_per_line;
    #####: 1399:      set_quoting_style (NULL, escape_quoting_style);
    #####: 1400:      break;
        -: 1401:
        -: 1402:    case LS_LONG_FORMAT:
        -: 1403:      /* This is for the `vdir' program.  */
    #####: 1404:      format = long_format;
    #####: 1405:      set_quoting_style (NULL, escape_quoting_style);
    #####: 1406:      break;
        -: 1407:
        -: 1408:    case LS_LS:
        -: 1409:      /* This is for the `ls' program.  */
       12: 1410:      if (isatty (STDOUT_FILENO))
        -: 1411:	{
    #####: 1412:	  format = many_per_line;
        -: 1413:	  /* See description of qmark_funny_chars, above.  */
    #####: 1414:	  qmark_funny_chars = true;
        -: 1415:	}
        -: 1416:      else
        -: 1417:	{
       12: 1418:	  format = one_per_line;
       12: 1419:	  qmark_funny_chars = false;
        -: 1420:	}
       12: 1421:      break;
        -: 1422:
        -: 1423:    default:
    #####: 1424:      abort ();
        -: 1425:    }
        -: 1426:
       12: 1427:  time_type = time_mtime;
       12: 1428:  sort_type = sort_name;
       12: 1429:  sort_reverse = false;
       12: 1430:  numeric_ids = false;
       12: 1431:  print_block_size = false;
       12: 1432:  indicator_style = none;
       12: 1433:  print_inode = false;
       12: 1434:  dereference = DEREF_UNDEFINED;
       12: 1435:  recursive = false;
       12: 1436:  immediate_dirs = false;
       12: 1437:  ignore_mode = IGNORE_DEFAULT;
       12: 1438:  ignore_patterns = NULL;
       12: 1439:  hide_patterns = NULL;
       12: 1440:  print_scontext = false;
        -: 1441:
        -: 1442:  /* FIXME: put this in a function.  */
        -: 1443:  {
       12: 1444:    char const *q_style = getenv ("QUOTING_STYLE");
       12: 1445:    if (q_style)
        -: 1446:      {
    #####: 1447:	int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);
    #####: 1448:	if (0 <= i)
    #####: 1449:	  set_quoting_style (NULL, quoting_style_vals[i]);
        -: 1450:	else
    #####: 1451:	  error (0, 0,
        -: 1452:	 _("ignoring invalid value of environment variable QUOTING_STYLE: %s"),
        -: 1453:		 quotearg (q_style));
        -: 1454:      }
        -: 1455:  }
        -: 1456:
        -: 1457:  {
       12: 1458:    char const *ls_block_size = getenv ("LS_BLOCK_SIZE");
       12: 1459:    human_output_opts = human_options (ls_block_size, false,
        -: 1460:				       &output_block_size);
       12: 1461:    if (ls_block_size || getenv ("BLOCK_SIZE"))
    #####: 1462:      file_output_block_size = output_block_size;
        -: 1463:  }
        -: 1464:
       12: 1465:  line_length = 80;
        -: 1466:  {
       12: 1467:    char const *p = getenv ("COLUMNS");
       12: 1468:    if (p && *p)
        -: 1469:      {
        -: 1470:	unsigned long int tmp_ulong;
    #####: 1471:	if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
    #####: 1472:	    && 0 < tmp_ulong && tmp_ulong <= SIZE_MAX)
        -: 1473:	  {
    #####: 1474:	    line_length = tmp_ulong;
        -: 1475:	  }
        -: 1476:	else
        -: 1477:	  {
    #####: 1478:	    error (0, 0,
        -: 1479:	       _("ignoring invalid width in environment variable COLUMNS: %s"),
        -: 1480:		   quotearg (p));
        -: 1481:	  }
        -: 1482:      }
        -: 1483:  }
        -: 1484:
        -: 1485:#ifdef TIOCGWINSZ
        -: 1486:  {
        -: 1487:    struct winsize ws;
        -: 1488:
       12: 1489:    if (ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws) != -1
    #####: 1490:	&& 0 < ws.ws_col && ws.ws_col == (size_t) ws.ws_col)
    #####: 1491:      line_length = ws.ws_col;
        -: 1492:  }
        -: 1493:#endif
        -: 1494:
        -: 1495:  {
       12: 1496:    char const *p = getenv ("TABSIZE");
       12: 1497:    tabsize = 8;
       12: 1498:    if (p)
        -: 1499:      {
        -: 1500:	unsigned long int tmp_ulong;
    #####: 1501:	if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
        -: 1502:	    && tmp_ulong <= SIZE_MAX)
        -: 1503:	  {
    #####: 1504:	    tabsize = tmp_ulong;
        -: 1505:	  }
        -: 1506:	else
        -: 1507:	  {
    #####: 1508:	    error (0, 0,
        -: 1509:	     _("ignoring invalid tab size in environment variable TABSIZE: %s"),
        -: 1510:		   quotearg (p));
        -: 1511:	  }
        -: 1512:      }
        -: 1513:  }
        -: 1514:
       36: 1515:  while ((c = getopt_long (argc, argv,
        -: 1516:			   "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",
        -: 1517:			   long_options, NULL)) != -1)
        -: 1518:    {
       12: 1519:      switch (c)
        -: 1520:	{
        -: 1521:	case 'a':
    #####: 1522:	  ignore_mode = IGNORE_MINIMAL;
    #####: 1523:	  break;
        -: 1524:
        -: 1525:	case 'b':
    #####: 1526:	  set_quoting_style (NULL, escape_quoting_style);
    #####: 1527:	  break;
        -: 1528:
        -: 1529:	case 'c':
    #####: 1530:	  time_type = time_ctime;
    #####: 1531:	  break;
        -: 1532:
        -: 1533:	case 'd':
    #####: 1534:	  immediate_dirs = true;
    #####: 1535:	  break;
        -: 1536:
        -: 1537:	case 'f':
        -: 1538:	  /* Same as enabling -a -U and disabling -l -s.  */
    #####: 1539:	  ignore_mode = IGNORE_MINIMAL;
    #####: 1540:	  sort_type = sort_none;
    #####: 1541:	  sort_type_specified = true;
        -: 1542:	  /* disable -l */
    #####: 1543:	  if (format == long_format)
    #####: 1544:	    format = (isatty (STDOUT_FILENO) ? many_per_line : one_per_line);
    #####: 1545:	  print_block_size = false;	/* disable -s */
    #####: 1546:	  print_with_color = false;	/* disable --color */
    #####: 1547:	  break;
        -: 1548:
        -: 1549:	case FILE_TYPE_INDICATOR_OPTION: /* --file-type */
    #####: 1550:	  indicator_style = file_type;
    #####: 1551:	  break;
        -: 1552:
        -: 1553:	case 'g':
    #####: 1554:	  format = long_format;
    #####: 1555:	  print_owner = false;
    #####: 1556:	  break;
        -: 1557:
        -: 1558:	case 'h':
    #####: 1559:	  human_output_opts = human_autoscale | human_SI | human_base_1024;
    #####: 1560:	  file_output_block_size = output_block_size = 1;
    #####: 1561:	  break;
        -: 1562:
        -: 1563:	case 'i':
    #####: 1564:	  print_inode = true;
    #####: 1565:	  break;
        -: 1566:
        -: 1567:	case KILOBYTES_LONG_OPTION:
    #####: 1568:	  error (0, 0,
        -: 1569:		 _("the --kilobytes option is deprecated; use -k instead"));
        -: 1570:	  /* fall through */
        -: 1571:	case 'k':
    #####: 1572:	  human_output_opts = 0;
    #####: 1573:	  file_output_block_size = output_block_size = 1024;
    #####: 1574:	  break;
        -: 1575:
        -: 1576:	case 'l':
    #####: 1577:	  format = long_format;
    #####: 1578:	  break;
        -: 1579:
        -: 1580:	case 'm':
    #####: 1581:	  format = with_commas;
    #####: 1582:	  break;
        -: 1583:
        -: 1584:	case 'n':
    #####: 1585:	  numeric_ids = true;
    #####: 1586:	  format = long_format;
    #####: 1587:	  break;
        -: 1588:
        -: 1589:	case 'o':  /* Just like -l, but don't display group info.  */
    #####: 1590:	  format = long_format;
    #####: 1591:	  print_group = false;
    #####: 1592:	  break;
        -: 1593:
        -: 1594:	case 'p':
    #####: 1595:	  indicator_style = slash;
    #####: 1596:	  break;
        -: 1597:
        -: 1598:	case 'q':
    #####: 1599:	  qmark_funny_chars = true;
    #####: 1600:	  break;
        -: 1601:
        -: 1602:	case 'r':
    #####: 1603:	  sort_reverse = true;
    #####: 1604:	  break;
        -: 1605:
        -: 1606:	case 's':
    #####: 1607:	  print_block_size = true;
    #####: 1608:	  break;
        -: 1609:
        -: 1610:	case 't':
    #####: 1611:	  sort_type = sort_time;
    #####: 1612:	  sort_type_specified = true;
    #####: 1613:	  break;
        -: 1614:
        -: 1615:	case 'u':
    #####: 1616:	  time_type = time_atime;
    #####: 1617:	  break;
        -: 1618:
        -: 1619:	case 'v':
    #####: 1620:	  sort_type = sort_version;
    #####: 1621:	  sort_type_specified = true;
    #####: 1622:	  break;
        -: 1623:
        -: 1624:	case 'w':
        -: 1625:	  {
        -: 1626:	    unsigned long int tmp_ulong;
    #####: 1627:	    if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK
    #####: 1628:		|| ! (0 < tmp_ulong && tmp_ulong <= SIZE_MAX))
    #####: 1629:	      error (LS_FAILURE, 0, _("invalid line width: %s"),
        -: 1630:		     quotearg (optarg));
    #####: 1631:	    line_length = tmp_ulong;
    #####: 1632:	    break;
        -: 1633:	  }
        -: 1634:
        -: 1635:	case 'x':
    #####: 1636:	  format = horizontal;
    #####: 1637:	  break;
        -: 1638:
        -: 1639:	case 'A':
    #####: 1640:	  if (ignore_mode == IGNORE_DEFAULT)
    #####: 1641:	    ignore_mode = IGNORE_DOT_AND_DOTDOT;
    #####: 1642:	  break;
        -: 1643:
        -: 1644:	case 'B':
    #####: 1645:	  add_ignore_pattern ("*~");
    #####: 1646:	  add_ignore_pattern (".*~");
    #####: 1647:	  break;
        -: 1648:
        -: 1649:	case 'C':
    #####: 1650:	  format = many_per_line;
    #####: 1651:	  break;
        -: 1652:
        -: 1653:	case 'D':
    #####: 1654:	  dired = true;
    #####: 1655:	  break;
        -: 1656:
        -: 1657:	case 'F':
    #####: 1658:	  indicator_style = classify;
    #####: 1659:	  break;
        -: 1660:
        -: 1661:	case 'G':		/* inhibit display of group info */
    #####: 1662:	  print_group = false;
    #####: 1663:	  break;
        -: 1664:
        -: 1665:	case 'H':
    #####: 1666:	  dereference = DEREF_COMMAND_LINE_ARGUMENTS;
    #####: 1667:	  break;
        -: 1668:
        -: 1669:	case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:
    #####: 1670:	  dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;
    #####: 1671:	  break;
        -: 1672:
        -: 1673:	case 'I':
    #####: 1674:	  add_ignore_pattern (optarg);
    #####: 1675:	  break;
        -: 1676:
        -: 1677:	case 'L':
    #####: 1678:	  dereference = DEREF_ALWAYS;
    #####: 1679:	  break;
        -: 1680:
        -: 1681:	case 'N':
    #####: 1682:	  set_quoting_style (NULL, literal_quoting_style);
    #####: 1683:	  break;
        -: 1684:
        -: 1685:	case 'Q':
    #####: 1686:	  set_quoting_style (NULL, c_quoting_style);
    #####: 1687:	  break;
        -: 1688:
        -: 1689:	case 'R':
    #####: 1690:	  recursive = true;
    #####: 1691:	  break;
        -: 1692:
        -: 1693:	case 'S':
    #####: 1694:	  sort_type = sort_size;
    #####: 1695:	  sort_type_specified = true;
    #####: 1696:	  break;
        -: 1697:
        -: 1698:	case 'T':
        -: 1699:	  {
        -: 1700:	    unsigned long int tmp_ulong;
    #####: 1701:	    if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK
        -: 1702:		|| SIZE_MAX < tmp_ulong)
    #####: 1703:	      error (LS_FAILURE, 0, _("invalid tab size: %s"),
        -: 1704:		     quotearg (optarg));
    #####: 1705:	    tabsize = tmp_ulong;
    #####: 1706:	    break;
        -: 1707:	  }
        -: 1708:
        -: 1709:	case 'U':
    #####: 1710:	  sort_type = sort_none;
    #####: 1711:	  sort_type_specified = true;
    #####: 1712:	  break;
        -: 1713:
        -: 1714:	case 'X':
    #####: 1715:	  sort_type = sort_extension;
    #####: 1716:	  sort_type_specified = true;
    #####: 1717:	  break;
        -: 1718:
        -: 1719:	case '1':
        -: 1720:	  /* -1 has no effect after -l.  */
       12: 1721:	  if (format != long_format)
       12: 1722:	    format = one_per_line;
       12: 1723:	  break;
        -: 1724:
        -: 1725:        case AUTHOR_OPTION:
    #####: 1726:          print_author = true;
    #####: 1727:          break;
        -: 1728:
        -: 1729:	case HIDE_OPTION:
        -: 1730:	  {
    #####: 1731:	    struct ignore_pattern *hide = xmalloc (sizeof *hide);
    #####: 1732:	    hide->pattern = optarg;
    #####: 1733:	    hide->next = hide_patterns;
    #####: 1734:	    hide_patterns = hide;
        -: 1735:	  }
    #####: 1736:	  break;
        -: 1737:
        -: 1738:	case SORT_OPTION:
    #####: 1739:	  sort_type = XARGMATCH ("--sort", optarg, sort_args, sort_types);
    #####: 1740:	  sort_type_specified = true;
    #####: 1741:	  break;
        -: 1742:
        -: 1743:	case GROUP_DIRECTORIES_FIRST_OPTION:
    #####: 1744:	  directories_first = true;
    #####: 1745:	  break;
        -: 1746:
        -: 1747:	case TIME_OPTION:
    #####: 1748:	  time_type = XARGMATCH ("--time", optarg, time_args, time_types);
    #####: 1749:	  break;
        -: 1750:
        -: 1751:	case FORMAT_OPTION:
    #####: 1752:	  format = XARGMATCH ("--format", optarg, format_args, format_types);
    #####: 1753:	  break;
        -: 1754:
        -: 1755:	case FULL_TIME_OPTION:
    #####: 1756:	  format = long_format;
    #####: 1757:	  time_style_option = "full-iso";
    #####: 1758:	  break;
        -: 1759:
        -: 1760:	case COLOR_OPTION:
        -: 1761:	  {
        -: 1762:	    int i;
    #####: 1763:	    if (optarg)
    #####: 1764:	      i = XARGMATCH ("--color", optarg, color_args, color_types);
        -: 1765:	    else
        -: 1766:	      /* Using --color with no argument is equivalent to using
        -: 1767:		 --color=always.  */
    #####: 1768:	      i = color_always;
        -: 1769:
    #####: 1770:	    print_with_color = (i == color_always
    #####: 1771:				|| (i == color_if_tty
    #####: 1772:				    && isatty (STDOUT_FILENO)));
        -: 1773:
    #####: 1774:	    if (print_with_color)
        -: 1775:	      {
        -: 1776:		/* Don't use TAB characters in output.  Some terminal
        -: 1777:		   emulators can't handle the combination of tabs and
        -: 1778:		   color codes on the same line.  */
    #####: 1779:		tabsize = 0;
        -: 1780:	      }
    #####: 1781:	    break;
        -: 1782:	  }
        -: 1783:
        -: 1784:	case INDICATOR_STYLE_OPTION:
    #####: 1785:	  indicator_style = XARGMATCH ("--indicator-style", optarg,
        -: 1786:				       indicator_style_args,
        -: 1787:				       indicator_style_types);
    #####: 1788:	  break;
        -: 1789:
        -: 1790:	case QUOTING_STYLE_OPTION:
    #####: 1791:	  set_quoting_style (NULL,
    #####: 1792:			     XARGMATCH ("--quoting-style", optarg,
        -: 1793:					quoting_style_args,
        -: 1794:					quoting_style_vals));
    #####: 1795:	  break;
        -: 1796:
        -: 1797:	case TIME_STYLE_OPTION:
    #####: 1798:	  time_style_option = optarg;
    #####: 1799:	  break;
        -: 1800:
        -: 1801:	case SHOW_CONTROL_CHARS_OPTION:
    #####: 1802:	  qmark_funny_chars = false;
    #####: 1803:	  break;
        -: 1804:
        -: 1805:	case BLOCK_SIZE_OPTION:
    #####: 1806:	  human_output_opts = human_options (optarg, true, &output_block_size);
    #####: 1807:	  file_output_block_size = output_block_size;
    #####: 1808:	  break;
        -: 1809:
        -: 1810:	case SI_OPTION:
    #####: 1811:	  human_output_opts = human_autoscale | human_SI;
    #####: 1812:	  file_output_block_size = output_block_size = 1;
    #####: 1813:	  break;
        -: 1814:
        -: 1815:	case 'Z':
    #####: 1816:	  print_scontext = true;
    #####: 1817:	  break;
        -: 1818:
    #####: 1819:	case_GETOPT_HELP_CHAR;
        -: 1820:
    #####: 1821:	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -: 1822:
        -: 1823:	default:
    #####: 1824:	  usage (LS_FAILURE);
        -: 1825:	}
        -: 1826:    }
        -: 1827:
       12: 1828:  max_idx = MAX (1, line_length / MIN_COLUMN_WIDTH);
        -: 1829:
       12: 1830:  filename_quoting_options = clone_quoting_options (NULL);
       12: 1831:  if (get_quoting_style (filename_quoting_options) == escape_quoting_style)
    #####: 1832:    set_char_quoting (filename_quoting_options, ' ', 1);
       12: 1833:  if (file_type <= indicator_style)
        -: 1834:    {
        -: 1835:      char const *p;
    #####: 1836:      for (p = "*=>@|" + indicator_style - file_type; *p; p++)
    #####: 1837:	set_char_quoting (filename_quoting_options, *p, 1);
        -: 1838:    }
        -: 1839:
       12: 1840:  dirname_quoting_options = clone_quoting_options (NULL);
       12: 1841:  set_char_quoting (dirname_quoting_options, ':', 1);
        -: 1842:
        -: 1843:  /* --dired is meaningful only with --format=long (-l).
        -: 1844:     Otherwise, ignore it.  FIXME: warn about this?
        -: 1845:     Alternatively, make --dired imply --format=long?  */
       12: 1846:  if (dired && format != long_format)
    #####: 1847:    dired = false;
        -: 1848:
        -: 1849:  /* If -c or -u is specified and not -l (or any other option that implies -l),
        -: 1850:     and no sort-type was specified, then sort by the ctime (-c) or atime (-u).
        -: 1851:     The behavior of ls when using either -c or -u but with neither -l nor -t
        -: 1852:     appears to be unspecified by POSIX.  So, with GNU ls, `-u' alone means
        -: 1853:     sort by atime (this is the one that's not specified by the POSIX spec),
        -: 1854:     -lu means show atime and sort by name, -lut means show atime and sort
        -: 1855:     by atime.  */
        -: 1856:
       12: 1857:  if ((time_type == time_ctime || time_type == time_atime)
    #####: 1858:      && !sort_type_specified && format != long_format)
        -: 1859:    {
    #####: 1860:      sort_type = sort_time;
        -: 1861:    }
        -: 1862:
       12: 1863:  if (format == long_format)
        -: 1864:    {
    #####: 1865:      char *style = time_style_option;
        -: 1866:      static char const posix_prefix[] = "posix-";
        -: 1867:
    #####: 1868:      if (! style)
    #####: 1869:	if (! (style = getenv ("TIME_STYLE")))
    #####: 1870:	  style = "locale";
        -: 1871:
    #####: 1872:      while (strncmp (style, posix_prefix, sizeof posix_prefix - 1) == 0)
        -: 1873:	{
    #####: 1874:	  if (! hard_locale (LC_TIME))
    #####: 1875:	    return optind;
    #####: 1876:	  style += sizeof posix_prefix - 1;
        -: 1877:	}
        -: 1878:
    #####: 1879:      if (*style == '+')
        -: 1880:	{
    #####: 1881:	  char *p0 = style + 1;
    #####: 1882:	  char *p1 = strchr (p0, '\n');
    #####: 1883:	  if (! p1)
    #####: 1884:	    p1 = p0;
        -: 1885:	  else
        -: 1886:	    {
    #####: 1887:	      if (strchr (p1 + 1, '\n'))
    #####: 1888:		error (LS_FAILURE, 0, _("invalid time style format %s"),
        -: 1889:		       quote (p0));
    #####: 1890:	      *p1++ = '\0';
        -: 1891:	    }
    #####: 1892:	  long_time_format[0] = p0;
    #####: 1893:	  long_time_format[1] = p1;
        -: 1894:	}
        -: 1895:      else
    #####: 1896:	switch (XARGMATCH ("time style", style,
        -: 1897:			   time_style_args,
        -: 1898:			   time_style_types))
        -: 1899:	  {
        -: 1900:	  case full_iso_time_style:
    #####: 1901:	    long_time_format[0] = long_time_format[1] =
        -: 1902:	      "%Y-%m-%d %H:%M:%S.%N %z";
    #####: 1903:	    break;
        -: 1904:
        -: 1905:	  case long_iso_time_style:
        -: 1906:	  case_long_iso_time_style:
    #####: 1907:	    long_time_format[0] = long_time_format[1] = "%Y-%m-%d %H:%M";
    #####: 1908:	    break;
        -: 1909:
        -: 1910:	  case iso_time_style:
    #####: 1911:	    long_time_format[0] = "%Y-%m-%d ";
    #####: 1912:	    long_time_format[1] = "%m-%d %H:%M";
    #####: 1913:	    break;
        -: 1914:
        -: 1915:	  case locale_time_style:
    #####: 1916:	    if (hard_locale (LC_TIME))
        -: 1917:	      {
        -: 1918:		/* Ensure that the locale has translations for both
        -: 1919:		   formats.  If not, fall back on long-iso format.  */
        -: 1920:		int i;
    #####: 1921:		for (i = 0; i < 2; i++)
        -: 1922:		  {
    #####: 1923:		    char const *locale_format =
        -: 1924:		      dcgettext (NULL, long_time_format[i], LC_TIME);
    #####: 1925:		    if (locale_format == long_time_format[i])
    #####: 1926:		      goto case_long_iso_time_style;
    #####: 1927:		    long_time_format[i] = locale_format;
        -: 1928:		  }
        -: 1929:	      }
        -: 1930:	  }
        -: 1931:    }
        -: 1932:
       12: 1933:  return optind;
        -: 1934:}
        -: 1935:
        -: 1936:/* Parse a string as part of the LS_COLORS variable; this may involve
        -: 1937:   decoding all kinds of escape characters.  If equals_end is set an
        -: 1938:   unescaped equal sign ends the string, otherwise only a : or \0
        -: 1939:   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
        -: 1940:   true if successful.
        -: 1941:
        -: 1942:   The resulting string is *not* null-terminated, but may contain
        -: 1943:   embedded nulls.
        -: 1944:
        -: 1945:   Note that both dest and src are char **; on return they point to
        -: 1946:   the first free byte after the array and the character that ended
        -: 1947:   the input string, respectively.  */
        -: 1948:
        -: 1949:static bool
    #####: 1950:get_funky_string (char **dest, const char **src, bool equals_end,
        -: 1951:		  size_t *output_count)
        -: 1952:{
        -: 1953:  char num;			/* For numerical codes */
        -: 1954:  size_t count;			/* Something to count with */
        -: 1955:  enum {
        -: 1956:    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
        -: 1957:  } state;
        -: 1958:  const char *p;
        -: 1959:  char *q;
        -: 1960:
    #####: 1961:  p = *src;			/* We don't want to double-indirect */
    #####: 1962:  q = *dest;			/* the whole darn time.  */
        -: 1963:
    #####: 1964:  count = 0;			/* No characters counted in yet.  */
    #####: 1965:  num = 0;
        -: 1966:
    #####: 1967:  state = ST_GND;		/* Start in ground state.  */
    #####: 1968:  while (state < ST_END)
        -: 1969:    {
    #####: 1970:      switch (state)
        -: 1971:	{
        -: 1972:	case ST_GND:		/* Ground state (no escapes) */
    #####: 1973:	  switch (*p)
        -: 1974:	    {
        -: 1975:	    case ':':
        -: 1976:	    case '\0':
    #####: 1977:	      state = ST_END;	/* End of string */
    #####: 1978:	      break;
        -: 1979:	    case '\\':
    #####: 1980:	      state = ST_BACKSLASH; /* Backslash scape sequence */
    #####: 1981:	      ++p;
    #####: 1982:	      break;
        -: 1983:	    case '^':
    #####: 1984:	      state = ST_CARET; /* Caret escape */
    #####: 1985:	      ++p;
    #####: 1986:	      break;
        -: 1987:	    case '=':
    #####: 1988:	      if (equals_end)
        -: 1989:		{
    #####: 1990:		  state = ST_END; /* End */
    #####: 1991:		  break;
        -: 1992:		}
        -: 1993:	      /* else fall through */
        -: 1994:	    default:
    #####: 1995:	      *(q++) = *(p++);
    #####: 1996:	      ++count;
    #####: 1997:	      break;
        -: 1998:	    }
    #####: 1999:	  break;
        -: 2000:
        -: 2001:	case ST_BACKSLASH:	/* Backslash escaped character */
    #####: 2002:	  switch (*p)
        -: 2003:	    {
        -: 2004:	    case '0':
        -: 2005:	    case '1':
        -: 2006:	    case '2':
        -: 2007:	    case '3':
        -: 2008:	    case '4':
        -: 2009:	    case '5':
        -: 2010:	    case '6':
        -: 2011:	    case '7':
    #####: 2012:	      state = ST_OCTAL;	/* Octal sequence */
    #####: 2013:	      num = *p - '0';
    #####: 2014:	      break;
        -: 2015:	    case 'x':
        -: 2016:	    case 'X':
    #####: 2017:	      state = ST_HEX;	/* Hex sequence */
    #####: 2018:	      num = 0;
    #####: 2019:	      break;
        -: 2020:	    case 'a':		/* Bell */
    #####: 2021:	      num = '\a';
    #####: 2022:	      break;
        -: 2023:	    case 'b':		/* Backspace */
    #####: 2024:	      num = '\b';
    #####: 2025:	      break;
        -: 2026:	    case 'e':		/* Escape */
    #####: 2027:	      num = 27;
    #####: 2028:	      break;
        -: 2029:	    case 'f':		/* Form feed */
    #####: 2030:	      num = '\f';
    #####: 2031:	      break;
        -: 2032:	    case 'n':		/* Newline */
    #####: 2033:	      num = '\n';
    #####: 2034:	      break;
        -: 2035:	    case 'r':		/* Carriage return */
    #####: 2036:	      num = '\r';
    #####: 2037:	      break;
        -: 2038:	    case 't':		/* Tab */
    #####: 2039:	      num = '\t';
    #####: 2040:	      break;
        -: 2041:	    case 'v':		/* Vtab */
    #####: 2042:	      num = '\v';
    #####: 2043:	      break;
        -: 2044:	    case '?':		/* Delete */
    #####: 2045:              num = 127;
    #####: 2046:	      break;
        -: 2047:	    case '_':		/* Space */
    #####: 2048:	      num = ' ';
    #####: 2049:	      break;
        -: 2050:	    case '\0':		/* End of string */
    #####: 2051:	      state = ST_ERROR;	/* Error! */
    #####: 2052:	      break;
        -: 2053:	    default:		/* Escaped character like \ ^ : = */
    #####: 2054:	      num = *p;
    #####: 2055:	      break;
        -: 2056:	    }
    #####: 2057:	  if (state == ST_BACKSLASH)
        -: 2058:	    {
    #####: 2059:	      *(q++) = num;
    #####: 2060:	      ++count;
    #####: 2061:	      state = ST_GND;
        -: 2062:	    }
    #####: 2063:	  ++p;
    #####: 2064:	  break;
        -: 2065:
        -: 2066:	case ST_OCTAL:		/* Octal sequence */
    #####: 2067:	  if (*p < '0' || *p > '7')
        -: 2068:	    {
    #####: 2069:	      *(q++) = num;
    #####: 2070:	      ++count;
    #####: 2071:	      state = ST_GND;
        -: 2072:	    }
        -: 2073:	  else
    #####: 2074:	    num = (num << 3) + (*(p++) - '0');
    #####: 2075:	  break;
        -: 2076:
        -: 2077:	case ST_HEX:		/* Hex sequence */
    #####: 2078:	  switch (*p)
        -: 2079:	    {
        -: 2080:	    case '0':
        -: 2081:	    case '1':
        -: 2082:	    case '2':
        -: 2083:	    case '3':
        -: 2084:	    case '4':
        -: 2085:	    case '5':
        -: 2086:	    case '6':
        -: 2087:	    case '7':
        -: 2088:	    case '8':
        -: 2089:	    case '9':
    #####: 2090:	      num = (num << 4) + (*(p++) - '0');
    #####: 2091:	      break;
        -: 2092:	    case 'a':
        -: 2093:	    case 'b':
        -: 2094:	    case 'c':
        -: 2095:	    case 'd':
        -: 2096:	    case 'e':
        -: 2097:	    case 'f':
    #####: 2098:	      num = (num << 4) + (*(p++) - 'a') + 10;
    #####: 2099:	      break;
        -: 2100:	    case 'A':
        -: 2101:	    case 'B':
        -: 2102:	    case 'C':
        -: 2103:	    case 'D':
        -: 2104:	    case 'E':
        -: 2105:	    case 'F':
    #####: 2106:	      num = (num << 4) + (*(p++) - 'A') + 10;
    #####: 2107:	      break;
        -: 2108:	    default:
    #####: 2109:	      *(q++) = num;
    #####: 2110:	      ++count;
    #####: 2111:	      state = ST_GND;
    #####: 2112:	      break;
        -: 2113:	    }
    #####: 2114:	  break;
        -: 2115:
        -: 2116:	case ST_CARET:		/* Caret escape */
    #####: 2117:	  state = ST_GND;	/* Should be the next state... */
    #####: 2118:	  if (*p >= '@' && *p <= '~')
        -: 2119:	    {
    #####: 2120:	      *(q++) = *(p++) & 037;
    #####: 2121:	      ++count;
        -: 2122:	    }
    #####: 2123:	  else if (*p == '?')
        -: 2124:	    {
    #####: 2125:	      *(q++) = 127;
    #####: 2126:	      ++count;
        -: 2127:	    }
        -: 2128:	  else
    #####: 2129:	    state = ST_ERROR;
    #####: 2130:	  break;
        -: 2131:
        -: 2132:	default:
    #####: 2133:	  abort ();
        -: 2134:	}
        -: 2135:    }
        -: 2136:
    #####: 2137:  *dest = q;
    #####: 2138:  *src = p;
    #####: 2139:  *output_count = count;
        -: 2140:
    #####: 2141:  return state != ST_ERROR;
        -: 2142:}
        -: 2143:
        -: 2144:static void
    #####: 2145:parse_ls_color (void)
        -: 2146:{
        -: 2147:  const char *p;		/* Pointer to character being parsed */
        -: 2148:  char *buf;			/* color_buf buffer pointer */
        -: 2149:  int state;			/* State of parser */
        -: 2150:  int ind_no;			/* Indicator number */
        -: 2151:  char label[3];		/* Indicator label */
        -: 2152:  struct color_ext_type *ext;	/* Extension we are working on */
        -: 2153:
    #####: 2154:  if ((p = getenv ("LS_COLORS")) == NULL || *p == '\0')
    #####: 2155:    return;
        -: 2156:
    #####: 2157:  ext = NULL;
    #####: 2158:  strcpy (label, "??");
        -: 2159:
        -: 2160:  /* This is an overly conservative estimate, but any possible
        -: 2161:     LS_COLORS string will *not* generate a color_buf longer than
        -: 2162:     itself, so it is a safe way of allocating a buffer in
        -: 2163:     advance.  */
    #####: 2164:  buf = color_buf = xstrdup (p);
        -: 2165:
    #####: 2166:  state = 1;
    #####: 2167:  while (state > 0)
        -: 2168:    {
    #####: 2169:      switch (state)
        -: 2170:	{
        -: 2171:	case 1:		/* First label character */
    #####: 2172:	  switch (*p)
        -: 2173:	    {
        -: 2174:	    case ':':
    #####: 2175:	      ++p;
    #####: 2176:	      break;
        -: 2177:
        -: 2178:	    case '*':
        -: 2179:	      /* Allocate new extension block and add to head of
        -: 2180:		 linked list (this way a later definition will
        -: 2181:		 override an earlier one, which can be useful for
        -: 2182:		 having terminal-specific defs override global).  */
        -: 2183:
    #####: 2184:	      ext = xmalloc (sizeof *ext);
    #####: 2185:	      ext->next = color_ext_list;
    #####: 2186:	      color_ext_list = ext;
        -: 2187:
    #####: 2188:	      ++p;
    #####: 2189:	      ext->ext.string = buf;
        -: 2190:
    #####: 2191:	      state = (get_funky_string (&buf, &p, true, &ext->ext.len)
    #####: 2192:		       ? 4 : -1);
    #####: 2193:	      break;
        -: 2194:
        -: 2195:	    case '\0':
    #####: 2196:	      state = 0;	/* Done! */
    #####: 2197:	      break;
        -: 2198:
        -: 2199:	    default:	/* Assume it is file type label */
    #####: 2200:	      label[0] = *(p++);
    #####: 2201:	      state = 2;
    #####: 2202:	      break;
        -: 2203:	    }
    #####: 2204:	  break;
        -: 2205:
        -: 2206:	case 2:		/* Second label character */
    #####: 2207:	  if (*p)
        -: 2208:	    {
    #####: 2209:	      label[1] = *(p++);
    #####: 2210:	      state = 3;
        -: 2211:	    }
        -: 2212:	  else
    #####: 2213:	    state = -1;	/* Error */
    #####: 2214:	  break;
        -: 2215:
        -: 2216:	case 3:		/* Equal sign after indicator label */
    #####: 2217:	  state = -1;	/* Assume failure...  */
    #####: 2218:	  if (*(p++) == '=')/* It *should* be...  */
        -: 2219:	    {
    #####: 2220:	      for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
        -: 2221:		{
    #####: 2222:		  if (STREQ (label, indicator_name[ind_no]))
        -: 2223:		    {
    #####: 2224:		      color_indicator[ind_no].string = buf;
    #####: 2225:		      state = (get_funky_string (&buf, &p, false,
        -: 2226:						 &color_indicator[ind_no].len)
    #####: 2227:			       ? 1 : -1);
    #####: 2228:		      break;
        -: 2229:		    }
        -: 2230:		}
    #####: 2231:	      if (state == -1)
    #####: 2232:		error (0, 0, _("unrecognized prefix: %s"), quotearg (label));
        -: 2233:	    }
    #####: 2234:	  break;
        -: 2235:
        -: 2236:	case 4:		/* Equal sign after *.ext */
    #####: 2237:	  if (*(p++) == '=')
        -: 2238:	    {
    #####: 2239:	      ext->seq.string = buf;
    #####: 2240:	      state = (get_funky_string (&buf, &p, false, &ext->seq.len)
    #####: 2241:		       ? 1 : -1);
        -: 2242:	    }
        -: 2243:	  else
    #####: 2244:	    state = -1;
    #####: 2245:	  break;
        -: 2246:	}
        -: 2247:    }
        -: 2248:
    #####: 2249:  if (state < 0)
        -: 2250:    {
        -: 2251:      struct color_ext_type *e;
        -: 2252:      struct color_ext_type *e2;
        -: 2253:
    #####: 2254:      error (0, 0,
        -: 2255:	     _("unparsable value for LS_COLORS environment variable"));
    #####: 2256:      free (color_buf);
    #####: 2257:      for (e = color_ext_list; e != NULL; /* empty */)
        -: 2258:	{
    #####: 2259:	  e2 = e;
    #####: 2260:	  e = e->next;
    #####: 2261:	  free (e2);
        -: 2262:	}
    #####: 2263:      print_with_color = false;
        -: 2264:    }
        -: 2265:
    #####: 2266:  if (color_indicator[C_LINK].len == 6
    #####: 2267:      && !strncmp (color_indicator[C_LINK].string, "target", 6))
    #####: 2268:    color_symlink_as_referent = true;
        -: 2269:}
        -: 2270:
        -: 2271:/* Set the exit status to report a failure.  If SERIOUS, it is a
        -: 2272:   serious failure; otherwise, it is merely a minor problem.  */
        -: 2273:
        -: 2274:static void
    #####: 2275:set_exit_status (bool serious)
        -: 2276:{
    #####: 2277:  if (serious)
    #####: 2278:    exit_status = LS_FAILURE;
    #####: 2279:  else if (exit_status == EXIT_SUCCESS)
    #####: 2280:    exit_status = LS_MINOR_PROBLEM;
    #####: 2281:}
        -: 2282:
        -: 2283:/* Assuming a failure is serious if SERIOUS, use the printf-style
        -: 2284:   MESSAGE to report the failure to access a file named FILE.  Assume
        -: 2285:   errno is set appropriately for the failure.  */
        -: 2286:
        -: 2287:static void
    #####: 2288:file_failure (bool serious, char const *message, char const *file)
        -: 2289:{
    #####: 2290:  error (0, errno, message, quotearg_colon (file));
    #####: 2291:  set_exit_status (serious);
    #####: 2292:}
        -: 2293:
        -: 2294:/* Request that the directory named NAME have its contents listed later.
        -: 2295:   If REALNAME is nonzero, it will be used instead of NAME when the
        -: 2296:   directory name is printed.  This allows symbolic links to directories
        -: 2297:   to be treated as regular directories but still be listed under their
        -: 2298:   real names.  NAME == NULL is used to insert a marker entry for the
        -: 2299:   directory named in REALNAME.
        -: 2300:   If NAME is non-NULL, we use its dev/ino information to save
        -: 2301:   a call to stat -- when doing a recursive (-R) traversal.
        -: 2302:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2303:
        -: 2304:static void
    #####: 2305:queue_directory (char const *name, char const *realname, bool command_line_arg)
        -: 2306:{
    #####: 2307:  struct pending *new = xmalloc (sizeof *new);
    #####: 2308:  new->realname = realname ? xstrdup (realname) : NULL;
    #####: 2309:  new->name = name ? xstrdup (name) : NULL;
    #####: 2310:  new->command_line_arg = command_line_arg;
    #####: 2311:  new->next = pending_dirs;
    #####: 2312:  pending_dirs = new;
    #####: 2313:}
        -: 2314:
        -: 2315:/* Read directory NAME, and list the files in it.
        -: 2316:   If REALNAME is nonzero, print its name instead of NAME;
        -: 2317:   this is used for symbolic links to directories.
        -: 2318:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2319:
        -: 2320:static void
    #####: 2321:print_dir (char const *name, char const *realname, bool command_line_arg)
        -: 2322:{
        -: 2323:  DIR *dirp;
        -: 2324:  struct dirent *next;
    #####: 2325:  uintmax_t total_blocks = 0;
        -: 2326:  static bool first = true;
        -: 2327:
    #####: 2328:  errno = 0;
    #####: 2329:  dirp = opendir (name);
    #####: 2330:  if (!dirp)
        -: 2331:    {
    #####: 2332:      file_failure (command_line_arg, _("cannot open directory %s"), name);
    #####: 2333:      return;
        -: 2334:    }
        -: 2335:
    #####: 2336:  if (LOOP_DETECT)
        -: 2337:    {
        -: 2338:      struct stat dir_stat;
    #####: 2339:      int fd = dirfd (dirp);
        -: 2340:
        -: 2341:      /* If dirfd failed, endure the overhead of using stat.  */
    #####: 2342:      if ((0 <= fd
    #####: 2343:	   ? fstat (fd, &dir_stat)
    #####: 2344:	   : stat (name, &dir_stat)) < 0)
        -: 2345:	{
    #####: 2346:	  file_failure (command_line_arg,
        -: 2347:			_("cannot determine device and inode of %s"), name);
    #####: 2348:	  closedir (dirp);
    #####: 2349:	  return;
        -: 2350:	}
        -: 2351:
        -: 2352:      /* If we've already visited this dev/inode pair, warn that
        -: 2353:	 we've found a loop, and do not process this directory.  */
    #####: 2354:      if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))
        -: 2355:	{
    #####: 2356:	  error (0, 0, _("%s: not listing already-listed directory"),
        -: 2357:		 quotearg_colon (name));
    #####: 2358:	  closedir (dirp);
    #####: 2359:	  return;
        -: 2360:	}
        -: 2361:
    #####: 2362:      DEV_INO_PUSH (dir_stat.st_dev, dir_stat.st_ino);
        -: 2363:    }
        -: 2364:
        -: 2365:  /* Read the directory entries, and insert the subfiles into the `cwd_file'
        -: 2366:     table.  */
        -: 2367:
    #####: 2368:  clear_files ();
        -: 2369:
        -: 2370:  while (1)
        -: 2371:    {
        -: 2372:      /* Set errno to zero so we can distinguish between a readdir failure
        -: 2373:	 and when readdir simply finds that there are no more entries.  */
    #####: 2374:      errno = 0;
    #####: 2375:      next = readdir (dirp);
    #####: 2376:      if (next)
        -: 2377:	{
    #####: 2378:	  if (! file_ignored (next->d_name))
        -: 2379:	    {
    #####: 2380:	      enum filetype type = unknown;
        -: 2381:
        -: 2382:#if HAVE_STRUCT_DIRENT_D_TYPE
    #####: 2383:	      switch (next->d_type)
        -: 2384:		{
    #####: 2385:		case DT_BLK:  type = blockdev;		break;
    #####: 2386:		case DT_CHR:  type = chardev;		break;
    #####: 2387:		case DT_DIR:  type = directory;		break;
    #####: 2388:		case DT_FIFO: type = fifo;		break;
    #####: 2389:		case DT_LNK:  type = symbolic_link;	break;
    #####: 2390:		case DT_REG:  type = normal;		break;
    #####: 2391:		case DT_SOCK: type = sock;		break;
        -: 2392:# ifdef DT_WHT
    #####: 2393:		case DT_WHT:  type = whiteout;		break;
        -: 2394:# endif
        -: 2395:		}
        -: 2396:#endif
    #####: 2397:	      total_blocks += gobble_file (next->d_name, type, D_INO (next),
        -: 2398:					   false, name);
        -: 2399:	    }
        -: 2400:	}
    #####: 2401:      else if (errno != 0)
        -: 2402:	{
    #####: 2403:	  file_failure (command_line_arg, _("reading directory %s"), name);
    #####: 2404:	  if (errno != EOVERFLOW)
    #####: 2405:	    break;
        -: 2406:	}
        -: 2407:      else
    #####: 2408:	break;
    #####: 2409:    }
        -: 2410:
    #####: 2411:  if (closedir (dirp) != 0)
        -: 2412:    {
    #####: 2413:      file_failure (command_line_arg, _("closing directory %s"), name);
        -: 2414:      /* Don't return; print whatever we got.  */
        -: 2415:    }
        -: 2416:
        -: 2417:  /* Sort the directory contents.  */
    #####: 2418:  sort_files ();
        -: 2419:
        -: 2420:  /* If any member files are subdirectories, perhaps they should have their
        -: 2421:     contents listed rather than being mentioned here as files.  */
        -: 2422:
    #####: 2423:  if (recursive)
    #####: 2424:    extract_dirs_from_files (name, command_line_arg);
        -: 2425:
    #####: 2426:  if (recursive | print_dir_name)
        -: 2427:    {
    #####: 2428:      if (!first)
    #####: 2429:	DIRED_PUTCHAR ('\n');
    #####: 2430:      first = false;
    #####: 2431:      DIRED_INDENT ();
    #####: 2432:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
    #####: 2433:      dired_pos += quote_name (stdout, realname ? realname : name,
        -: 2434:			       dirname_quoting_options, NULL);
    #####: 2435:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
    #####: 2436:      DIRED_FPUTS_LITERAL (":\n", stdout);
        -: 2437:    }
        -: 2438:
    #####: 2439:  if (format == long_format || print_block_size)
        -: 2440:    {
        -: 2441:      const char *p;
        -: 2442:      char buf[LONGEST_HUMAN_READABLE + 1];
        -: 2443:
    #####: 2444:      DIRED_INDENT ();
    #####: 2445:      p = _("total");
    #####: 2446:      DIRED_FPUTS (p, stdout, strlen (p));
    #####: 2447:      DIRED_PUTCHAR (' ');
    #####: 2448:      p = human_readable (total_blocks, buf, human_output_opts,
        -: 2449:			  ST_NBLOCKSIZE, output_block_size);
    #####: 2450:      DIRED_FPUTS (p, stdout, strlen (p));
    #####: 2451:      DIRED_PUTCHAR ('\n');
        -: 2452:    }
        -: 2453:
    #####: 2454:  if (cwd_n_used)
    #####: 2455:    print_current_files ();
        -: 2456:}
        -: 2457:
        -: 2458:/* Add `pattern' to the list of patterns for which files that match are
        -: 2459:   not listed.  */
        -: 2460:
        -: 2461:static void
    #####: 2462:add_ignore_pattern (const char *pattern)
        -: 2463:{
        -: 2464:  struct ignore_pattern *ignore;
        -: 2465:
    #####: 2466:  ignore = xmalloc (sizeof *ignore);
    #####: 2467:  ignore->pattern = pattern;
        -: 2468:  /* Add it to the head of the linked list.  */
    #####: 2469:  ignore->next = ignore_patterns;
    #####: 2470:  ignore_patterns = ignore;
    #####: 2471:}
        -: 2472:
        -: 2473:/* Return true if one of the PATTERNS matches FILE.  */
        -: 2474:
        -: 2475:static bool
    #####: 2476:patterns_match (struct ignore_pattern const *patterns, char const *file)
        -: 2477:{
        -: 2478:  struct ignore_pattern const *p;
    #####: 2479:  for (p = patterns; p; p = p->next)
    #####: 2480:    if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)
    #####: 2481:      return true;
    #####: 2482:  return false;
        -: 2483:}
        -: 2484:
        -: 2485:/* Return true if FILE should be ignored.  */
        -: 2486:
        -: 2487:static bool
    #####: 2488:file_ignored (char const *name)
        -: 2489:{
    #####: 2490:  return ((ignore_mode != IGNORE_MINIMAL
    #####: 2491:	   && name[0] == '.'
    #####: 2492:	   && (ignore_mode == IGNORE_DEFAULT || ! name[1 + (name[1] == '.')]))
    #####: 2493:	  || (ignore_mode == IGNORE_DEFAULT
    #####: 2494:	      && patterns_match (hide_patterns, name))
    #####: 2495:	  || patterns_match (ignore_patterns, name));
        -: 2496:}
        -: 2497:
        -: 2498:/* POSIX requires that a file size be printed without a sign, even
        -: 2499:   when negative.  Assume the typical case where negative sizes are
        -: 2500:   actually positive values that have wrapped around.  */
        -: 2501:
        -: 2502:static uintmax_t
    #####: 2503:unsigned_file_size (off_t size)
        -: 2504:{
    #####: 2505:  return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);
        -: 2506:}
        -: 2507:
        -: 2508:/* Enter and remove entries in the table `cwd_file'.  */
        -: 2509:
        -: 2510:/* Empty the table of files.  */
        -: 2511:
        -: 2512:static void
       12: 2513:clear_files (void)
        -: 2514:{
        -: 2515:  size_t i;
        -: 2516:
       12: 2517:  for (i = 0; i < cwd_n_used; i++)
        -: 2518:    {
    #####: 2519:      struct fileinfo *f = sorted_file[i];
    #####: 2520:      free (f->name);
    #####: 2521:      free (f->linkname);
    #####: 2522:      if (f->scontext)
        -: 2523:	{
    #####: 2524:	  freecon (f->scontext);
    #####: 2525:	  f->scontext = NULL;
        -: 2526:	}
        -: 2527:    }
        -: 2528:
       12: 2529:  cwd_n_used = 0;
       12: 2530:  any_has_acl = false;
       12: 2531:  inode_number_width = 0;
       12: 2532:  block_size_width = 0;
       12: 2533:  nlink_width = 0;
       12: 2534:  owner_width = 0;
       12: 2535:  group_width = 0;
       12: 2536:  author_width = 0;
       12: 2537:  scontext_width = 0;
       12: 2538:  major_device_number_width = 0;
       12: 2539:  minor_device_number_width = 0;
       12: 2540:  file_size_width = 0;
       12: 2541:}
        -: 2542:
        -: 2543:/* Add a file to the current table of files.
        -: 2544:   Verify that the file exists, and print an error message if it does not.
        -: 2545:   Return the number of blocks that the file occupies.  */
        -: 2546:
        -: 2547:static uintmax_t
     1164: 2548:gobble_file (char const *name, enum filetype type, ino_t inode,
        -: 2549:	     bool command_line_arg, char const *dirname)
        -: 2550:{
     1164: 2551:  uintmax_t blocks = 0;
        -: 2552:  struct fileinfo *f;
        -: 2553:
        -: 2554:  /* An inode value prior to gobble_file necessarily came from readdir,
        -: 2555:     which is not used for command line arguments.  */
     1164: 2556:  assert (! command_line_arg || inode == NOT_AN_INODE_NUMBER);
        -: 2557:
     1164: 2558:  if (cwd_n_used == cwd_n_alloc)
        -: 2559:    {
    #####: 2560:      cwd_file = xnrealloc (cwd_file, cwd_n_alloc, 2 * sizeof *cwd_file);
    #####: 2561:      cwd_n_alloc *= 2;
        -: 2562:    }
        -: 2563:
     1164: 2564:  f = &cwd_file[cwd_n_used];
     1164: 2565:  memset (f, '\0', sizeof *f);
     1164: 2566:  f->stat.st_ino = inode;
     1164: 2567:  f->filetype = type;
        -: 2568:
     1164: 2569:  if (command_line_arg
    #####: 2570:      || format_needs_stat
        -: 2571:      /* When coloring a directory (we may know the type from
        -: 2572:	 direct.d_type), we have to stat it in order to indicate
        -: 2573:	 sticky and/or other-writable attributes.  */
    #####: 2574:      || (type == directory && print_with_color)
        -: 2575:      /* When dereferencing symlinks, the inode and type must come from
        -: 2576:	 stat, but readdir provides the inode and type of lstat.  */
    #####: 2577:      || ((print_inode || format_needs_type)
    #####: 2578:	  && (type == symbolic_link || type == unknown)
    #####: 2579:	  && (dereference == DEREF_ALWAYS
    #####: 2580:	      || (command_line_arg && dereference != DEREF_NEVER)
    #####: 2581:	      || color_symlink_as_referent || check_symlink_color))
        -: 2582:      /* Command line dereferences are already taken care of by the above
        -: 2583:	 assertion that the inode number is not yet known.  */
    #####: 2584:      || (print_inode && inode == NOT_AN_INODE_NUMBER)
    #####: 2585:      || (format_needs_type
    #####: 2586:	  && (type == unknown || command_line_arg
        -: 2587:	      /* --indicator-style=classify (aka -F)
        -: 2588:		 requires that we stat each regular file
        -: 2589:		 to see if it's executable.  */
    #####: 2590:	      || (type == normal && (indicator_style == classify
        -: 2591:				     /* This is so that --color ends up
        -: 2592:					highlighting files with the executable
        -: 2593:					bit set even when options like -F are
        -: 2594:					not specified.  */
    #####: 2595:				     || (print_with_color
    #####: 2596:					 && is_colored (C_EXEC))
        -: 2597:				     )))))
        -: 2598:
        -: 2599:    {
        -: 2600:      /* FIXME-c99: move this decl "down", once ls.c stabilizes.  */
     1164: 2601:      bool file_has_security_context = false;
        -: 2602:      /* Absolute name of this file.  */
        -: 2603:      char *absolute_name;
        -: 2604:      bool do_deref;
        -: 2605:      int err;
        -: 2606:
     1164: 2607:      if (name[0] == '/' || dirname[0] == 0)
     1164: 2608:	absolute_name = (char *) name;
        -: 2609:      else
        -: 2610:	{
    #####: 2611:	  absolute_name = alloca (strlen (name) + strlen (dirname) + 2);
    #####: 2612:	  attach (absolute_name, dirname, name);
        -: 2613:	}
        -: 2614:
     1164: 2615:      switch (dereference)
        -: 2616:	{
        -: 2617:	case DEREF_ALWAYS:
    #####: 2618:	  err = stat (absolute_name, &f->stat);
    #####: 2619:	  do_deref = true;
    #####: 2620:	  break;
        -: 2621:
        -: 2622:	case DEREF_COMMAND_LINE_ARGUMENTS:
        -: 2623:	case DEREF_COMMAND_LINE_SYMLINK_TO_DIR:
     1164: 2624:	  if (command_line_arg)
        -: 2625:	    {
        -: 2626:	      bool need_lstat;
     1164: 2627:	      err = stat (absolute_name, &f->stat);
     1164: 2628:	      do_deref = true;
        -: 2629:
     1164: 2630:	      if (dereference == DEREF_COMMAND_LINE_ARGUMENTS)
    #####: 2631:		break;
        -: 2632:
     1164: 2633:	      need_lstat = (err < 0
    #####: 2634:			    ? errno == ENOENT
     1164: 2635:			    : ! S_ISDIR (f->stat.st_mode));
     1164: 2636:	      if (!need_lstat)
    #####: 2637:		break;
        -: 2638:
        -: 2639:	      /* stat failed because of ENOENT, maybe indicating a dangling
        -: 2640:		 symlink.  Or stat succeeded, ABSOLUTE_NAME does not refer to a
        -: 2641:		 directory, and --dereference-command-line-symlink-to-dir is
        -: 2642:		 in effect.  Fall through so that we call lstat instead.  */
        -: 2643:	    }
        -: 2644:
        -: 2645:	default: /* DEREF_NEVER */
     1164: 2646:	  err = lstat (absolute_name, &f->stat);
     1164: 2647:	  do_deref = false;
     1164: 2648:	  break;
        -: 2649:	}
        -: 2650:
     1164: 2651:      if (err == 0 && print_scontext)
        -: 2652:	{
    #####: 2653:	  int attr_len = (do_deref
    #####: 2654:			  ?  getfilecon (absolute_name, &f->scontext)
    #####: 2655:			  : lgetfilecon (absolute_name, &f->scontext));
    #####: 2656:	  err = (attr_len < 0);
    #####: 2657:	  file_has_security_context = (err == 0);
        -: 2658:
        -: 2659:	  /* When requesting security context information, don't make
        -: 2660:	     ls fail just because the file (even a command line argument)
        -: 2661:	     isn't on the right type of file system.  I.e., a getfilecon
        -: 2662:	     failure isn't in the same class as a stat failure.  */
    #####: 2663:	  if (err && (errno == ENOTSUP || errno == ENODATA))
    #####: 2664:	    err = 0;
        -: 2665:	}
        -: 2666:
     1164: 2667:      if (err != 0)
        -: 2668:	{
        -: 2669:	  /* Failure to stat a command line argument leads to
        -: 2670:	     an exit status of 2.  For other files, stat failure
        -: 2671:	     provokes an exit status of 1.  */
    #####: 2672:	  file_failure (command_line_arg,
        -: 2673:			_("cannot access %s"), absolute_name);
    #####: 2674:	  if (command_line_arg)
    #####: 2675:	    return 0;
        -: 2676:
    #####: 2677:	  f->name = xstrdup (name);
    #####: 2678:	  cwd_n_used++;
        -: 2679:
    #####: 2680:	  return 0;
        -: 2681:	}
        -: 2682:
     1164: 2683:      f->stat_ok = true;
        -: 2684:
     1164: 2685:      if (format == long_format)
        -: 2686:	{
    #####: 2687:	  int n = file_has_acl (absolute_name, &f->stat);
    #####: 2688:	  f->have_acl = (0 < n || file_has_security_context);
    #####: 2689:	  any_has_acl |= f->have_acl;
    #####: 2690:	  if (n < 0)
    #####: 2691:	    error (0, errno, "%s", quotearg_colon (absolute_name));
        -: 2692:	}
        -: 2693:
     1164: 2694:      if (S_ISLNK (f->stat.st_mode)
    #####: 2695:	  && (format == long_format || check_symlink_color))
        -: 2696:	{
        -: 2697:	  char *linkname;
        -: 2698:	  struct stat linkstats;
        -: 2699:
    #####: 2700:	  get_link_name (absolute_name, f, command_line_arg);
    #####: 2701:	  linkname = make_link_name (absolute_name, f->linkname);
        -: 2702:
        -: 2703:	  /* Avoid following symbolic links when possible, ie, when
        -: 2704:	     they won't be traced and when no indicator is needed.  */
    #####: 2705:	  if (linkname
    #####: 2706:	      && (file_type <= indicator_style || check_symlink_color)
    #####: 2707:	      && stat (linkname, &linkstats) == 0)
        -: 2708:	    {
    #####: 2709:	      f->linkok = true;
        -: 2710:
        -: 2711:	      /* Symbolic links to directories that are mentioned on the
        -: 2712:		 command line are automatically traced if not being
        -: 2713:		 listed as files.  */
    #####: 2714:	      if (!command_line_arg || format == long_format
    #####: 2715:		  || !S_ISDIR (linkstats.st_mode))
        -: 2716:		{
        -: 2717:		  /* Get the linked-to file's mode for the filetype indicator
        -: 2718:		     in long listings.  */
    #####: 2719:		  f->linkmode = linkstats.st_mode;
        -: 2720:		}
        -: 2721:	    }
    #####: 2722:	  free (linkname);
        -: 2723:	}
        -: 2724:
     1164: 2725:      if (S_ISLNK (f->stat.st_mode))
    #####: 2726:	f->filetype = symbolic_link;
     1164: 2727:      else if (S_ISDIR (f->stat.st_mode))
        -: 2728:	{
    #####: 2729:	  if (command_line_arg & !immediate_dirs)
    #####: 2730:	    f->filetype = arg_directory;
        -: 2731:	  else
    #####: 2732:	    f->filetype = directory;
        -: 2733:	}
        -: 2734:      else
     1164: 2735:	f->filetype = normal;
        -: 2736:
     1164: 2737:      blocks = ST_NBLOCKS (f->stat);
     1164: 2738:      if (format == long_format || print_block_size)
        -: 2739:	{
        -: 2740:	  char buf[LONGEST_HUMAN_READABLE + 1];
    #####: 2741:	  int len = mbswidth (human_readable (blocks, buf, human_output_opts,
        -: 2742:					      ST_NBLOCKSIZE, output_block_size),
        -: 2743:			      0);
    #####: 2744:	  if (block_size_width < len)
    #####: 2745:	    block_size_width = len;
        -: 2746:	}
        -: 2747:
     1164: 2748:      if (format == long_format)
        -: 2749:	{
    #####: 2750:	  if (print_owner)
        -: 2751:	    {
    #####: 2752:	      int len = format_user_width (f->stat.st_uid);
    #####: 2753:	      if (owner_width < len)
    #####: 2754:		owner_width = len;
        -: 2755:	    }
        -: 2756:
    #####: 2757:	  if (print_group)
        -: 2758:	    {
    #####: 2759:	      int len = format_group_width (f->stat.st_gid);
    #####: 2760:	      if (group_width < len)
    #####: 2761:		group_width = len;
        -: 2762:	    }
        -: 2763:
    #####: 2764:	  if (print_author)
        -: 2765:	    {
    #####: 2766:	      int len = format_user_width (f->stat.st_author);
    #####: 2767:	      if (author_width < len)
    #####: 2768:		author_width = len;
        -: 2769:	    }
        -: 2770:	}
        -: 2771:
     1164: 2772:      if (print_scontext)
        -: 2773:	{
    #####: 2774:	  int len = f->scontext ? strlen (f->scontext) : 0;
    #####: 2775:	  if (scontext_width < len)
    #####: 2776:	    scontext_width = len;
        -: 2777:	}
        -: 2778:
     1164: 2779:      if (format == long_format)
        -: 2780:	{
        -: 2781:	  char b[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 2782:	  int b_len = strlen (umaxtostr (f->stat.st_nlink, b));
    #####: 2783:	  if (nlink_width < b_len)
    #####: 2784:	    nlink_width = b_len;
        -: 2785:
    #####: 2786:	  if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))
    #####: 2787:	    {
        -: 2788:	      char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 2789:	      int len = strlen (umaxtostr (major (f->stat.st_rdev), buf));
    #####: 2790:	      if (major_device_number_width < len)
    #####: 2791:		major_device_number_width = len;
    #####: 2792:	      len = strlen (umaxtostr (minor (f->stat.st_rdev), buf));
    #####: 2793:	      if (minor_device_number_width < len)
    #####: 2794:		minor_device_number_width = len;
    #####: 2795:	      len = major_device_number_width + 2 + minor_device_number_width;
    #####: 2796:	      if (file_size_width < len)
    #####: 2797:		file_size_width = len;
        -: 2798:	    }
        -: 2799:	  else
        -: 2800:	    {
        -: 2801:	      char buf[LONGEST_HUMAN_READABLE + 1];
    #####: 2802:	      uintmax_t size = unsigned_file_size (f->stat.st_size);
    #####: 2803:	      int len = mbswidth (human_readable (size, buf, human_output_opts,
        -: 2804:						  1, file_output_block_size),
        -: 2805:				  0);
    #####: 2806:	      if (file_size_width < len)
    #####: 2807:		file_size_width = len;
        -: 2808:	    }
        -: 2809:	}
        -: 2810:    }
        -: 2811:
     1164: 2812:  if (print_inode)
        -: 2813:    {
        -: 2814:      char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 2815:      int len = strlen (umaxtostr (f->stat.st_ino, buf));
    #####: 2816:      if (inode_number_width < len)
    #####: 2817:	inode_number_width = len;
        -: 2818:    }
        -: 2819:
     1164: 2820:  f->name = xstrdup (name);
     1164: 2821:  cwd_n_used++;
        -: 2822:
     1164: 2823:  return blocks;
        -: 2824:}
        -: 2825:
        -: 2826:/* Return true if F refers to a directory.  */
        -: 2827:static bool
     1164: 2828:is_directory (const struct fileinfo *f)
        -: 2829:{
     1164: 2830:  return f->filetype == directory || f->filetype == arg_directory;
        -: 2831:}
        -: 2832:
        -: 2833:/* Put the name of the file that FILENAME is a symbolic link to
        -: 2834:   into the LINKNAME field of `f'.  COMMAND_LINE_ARG indicates whether
        -: 2835:   FILENAME is a command-line argument.  */
        -: 2836:
        -: 2837:static void
    #####: 2838:get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
        -: 2839:{
    #####: 2840:  f->linkname = mreadlink_with_size (filename, f->stat.st_size);
    #####: 2841:  if (f->linkname == NULL)
    #####: 2842:    file_failure (command_line_arg, _("cannot read symbolic link %s"),
        -: 2843:		  filename);
    #####: 2844:}
        -: 2845:
        -: 2846:/* If `linkname' is a relative name and `name' contains one or more
        -: 2847:   leading directories, return `linkname' with those directories
        -: 2848:   prepended; otherwise, return a copy of `linkname'.
        -: 2849:   If `linkname' is zero, return zero.  */
        -: 2850:
        -: 2851:static char *
    #####: 2852:make_link_name (char const *name, char const *linkname)
        -: 2853:{
        -: 2854:  char *linkbuf;
        -: 2855:  size_t bufsiz;
        -: 2856:
    #####: 2857:  if (!linkname)
    #####: 2858:    return NULL;
        -: 2859:
    #####: 2860:  if (*linkname == '/')
    #####: 2861:    return xstrdup (linkname);
        -: 2862:
        -: 2863:  /* The link is to a relative name.  Prepend any leading directory
        -: 2864:     in `name' to the link name.  */
    #####: 2865:  linkbuf = strrchr (name, '/');
    #####: 2866:  if (linkbuf == 0)
    #####: 2867:    return xstrdup (linkname);
        -: 2868:
    #####: 2869:  bufsiz = linkbuf - name + 1;
    #####: 2870:  linkbuf = xmalloc (bufsiz + strlen (linkname) + 1);
    #####: 2871:  strncpy (linkbuf, name, bufsiz);
    #####: 2872:  strcpy (linkbuf + bufsiz, linkname);
    #####: 2873:  return linkbuf;
        -: 2874:}
        -: 2875:
        -: 2876:/* Return true if the last component of NAME is `.' or `..'
        -: 2877:   This is so we don't try to recurse on `././././. ...' */
        -: 2878:
        -: 2879:static bool
    #####: 2880:basename_is_dot_or_dotdot (const char *name)
        -: 2881:{
    #####: 2882:  char const *base = last_component (name);
    #####: 2883:  return dot_or_dotdot (base);
        -: 2884:}
        -: 2885:
        -: 2886:/* Remove any entries from CWD_FILE that are for directories,
        -: 2887:   and queue them to be listed as directories instead.
        -: 2888:   DIRNAME is the prefix to prepend to each dirname
        -: 2889:   to make it correct relative to ls's working dir;
        -: 2890:   if it is null, no prefix is needed and "." and ".." should not be ignored.
        -: 2891:   If COMMAND_LINE_ARG is true, this directory was mentioned at the top level,
        -: 2892:   This is desirable when processing directories recursively.  */
        -: 2893:
        -: 2894:static void
       12: 2895:extract_dirs_from_files (char const *dirname, bool command_line_arg)
        -: 2896:{
        -: 2897:  size_t i;
        -: 2898:  size_t j;
       12: 2899:  bool ignore_dot_and_dot_dot = (dirname != NULL);
        -: 2900:
       12: 2901:  if (dirname && LOOP_DETECT)
        -: 2902:    {
        -: 2903:      /* Insert a marker entry first.  When we dequeue this marker entry,
        -: 2904:	 we'll know that DIRNAME has been processed and may be removed
        -: 2905:	 from the set of active directories.  */
    #####: 2906:      queue_directory (NULL, dirname, false);
        -: 2907:    }
        -: 2908:
        -: 2909:  /* Queue the directories last one first, because queueing reverses the
        -: 2910:     order.  */
     1188: 2911:  for (i = cwd_n_used; i-- != 0; )
        -: 2912:    {
     1164: 2913:      struct fileinfo *f = sorted_file[i];
        -: 2914:
     1164: 2915:      if (is_directory (f)
    #####: 2916:	  && (! ignore_dot_and_dot_dot
    #####: 2917:	      || ! basename_is_dot_or_dotdot (f->name)))
        -: 2918:	{
    #####: 2919:	  if (!dirname || f->name[0] == '/')
    #####: 2920:	    queue_directory (f->name, f->linkname, command_line_arg);
        -: 2921:	  else
        -: 2922:	    {
    #####: 2923:	      char *name = file_name_concat (dirname, f->name, NULL);
    #####: 2924:	      queue_directory (name, f->linkname, command_line_arg);
    #####: 2925:	      free (name);
        -: 2926:	    }
    #####: 2927:	  if (f->filetype == arg_directory)
    #####: 2928:	    free (f->name);
        -: 2929:	}
        -: 2930:    }
        -: 2931:
        -: 2932:  /* Now delete the directories from the table, compacting all the remaining
        -: 2933:     entries.  */
        -: 2934:
     1176: 2935:  for (i = 0, j = 0; i < cwd_n_used; i++)
        -: 2936:    {
     1164: 2937:      struct fileinfo *f = sorted_file[i];
     1164: 2938:      sorted_file[j] = f;
     1164: 2939:      j += (f->filetype != arg_directory);
        -: 2940:    }
       12: 2941:  cwd_n_used = j;
       12: 2942:}
        -: 2943:
        -: 2944:/* Use strcoll to compare strings in this locale.  If an error occurs,
        -: 2945:   report an error and longjmp to failed_strcoll.  */
        -: 2946:
        -: 2947:static jmp_buf failed_strcoll;
        -: 2948:
        -: 2949:static int
     3672: 2950:xstrcoll (char const *a, char const *b)
        -: 2951:{
        -: 2952:  int diff;
     3672: 2953:  errno = 0;
     3672: 2954:  diff = strcoll (a, b);
     3672: 2955:  if (errno)
        -: 2956:    {
    #####: 2957:      error (0, errno, _("cannot compare file names %s and %s"),
        -: 2958:	     quote_n (0, a), quote_n (1, b));
    #####: 2959:      set_exit_status (false);
    #####: 2960:      longjmp (failed_strcoll, 1);
        -: 2961:    }
     3672: 2962:  return diff;
        -: 2963:}
        -: 2964:
        -: 2965:/* Comparison routines for sorting the files.  */
        -: 2966:
        -: 2967:typedef void const *V;
        -: 2968:typedef int (*qsortFunc)(V a, V b);
        -: 2969:
        -: 2970:/* Used below in DEFINE_SORT_FUNCTIONS for _df_ sort function variants.
        -: 2971:   The do { ... } while(0) makes it possible to use the macro more like
        -: 2972:   a statement, without violating C89 rules: */
        -: 2973:#define DIRFIRST_CHECK(a, b)						\
        -: 2974:  do									\
        -: 2975:    {									\
        -: 2976:      bool a_is_dir = is_directory ((struct fileinfo const *) a);	\
        -: 2977:      bool b_is_dir = is_directory ((struct fileinfo const *) b);	\
        -: 2978:      if (a_is_dir && !b_is_dir)					\
        -: 2979:	return -1;         /* a goes before b */			\
        -: 2980:      if (!a_is_dir && b_is_dir)					\
        -: 2981:	return 1;          /* b goes before a */			\
        -: 2982:    }									\
        -: 2983:  while (0)
        -: 2984:
        -: 2985:/* Define the 8 different sort function variants required for each sortkey.
        -: 2986:   KEY_NAME is a token describing the sort key, e.g., ctime, atime, size.
        -: 2987:   KEY_CMP_FUNC is a function to compare records based on that key, e.g.,
        -: 2988:   ctime_cmp, atime_cmp, size_cmp.  Append KEY_NAME to the string,
        -: 2989:   '[rev_][x]str{cmp|coll}[_df]_', to create each function name.  */
        -: 2990:#define DEFINE_SORT_FUNCTIONS(key_name, key_cmp_func)			\
        -: 2991:  /* direct, non-dirfirst versions */					\
        -: 2992:  static int xstrcoll_##key_name (V a, V b)				\
        -: 2993:  { return key_cmp_func (a, b, xstrcoll); }				\
        -: 2994:  static int strcmp_##key_name (V a, V b)				\
        -: 2995:  { return key_cmp_func (a, b, strcmp); }				\
        -: 2996:									\
        -: 2997:  /* reverse, non-dirfirst versions */					\
        -: 2998:  static int rev_xstrcoll_##key_name (V a, V b)				\
        -: 2999:  { return key_cmp_func (b, a, xstrcoll); }				\
        -: 3000:  static int rev_strcmp_##key_name (V a, V b)				\
        -: 3001:  { return key_cmp_func (b, a, strcmp); }				\
        -: 3002:									\
        -: 3003:  /* direct, dirfirst versions */					\
        -: 3004:  static int xstrcoll_df_##key_name (V a, V b)				\
        -: 3005:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, xstrcoll); }	\
        -: 3006:  static int strcmp_df_##key_name (V a, V b)				\
        -: 3007:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, strcmp); }	\
        -: 3008:									\
        -: 3009:  /* reverse, dirfirst versions */					\
        -: 3010:  static int rev_xstrcoll_df_##key_name (V a, V b)			\
        -: 3011:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, xstrcoll); }	\
        -: 3012:  static int rev_strcmp_df_##key_name (V a, V b)			\
        -: 3013:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, strcmp); }
        -: 3014:
        -: 3015:static inline int
    #####: 3016:cmp_ctime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3017:	   int (*cmp) (char const *, char const *))
        -: 3018:{
    #####: 3019:  int diff = timespec_cmp (get_stat_ctime (&b->stat),
        -: 3020:			   get_stat_ctime (&a->stat));
    #####: 3021:  return diff ? diff : cmp (a->name, b->name);
        -: 3022:}
        -: 3023:
        -: 3024:static inline int
    #####: 3025:cmp_mtime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3026:	   int (*cmp) (char const *, char const *))
        -: 3027:{
    #####: 3028:  int diff = timespec_cmp (get_stat_mtime (&b->stat),
        -: 3029:			   get_stat_mtime (&a->stat));
    #####: 3030:  return diff ? diff : cmp (a->name, b->name);
        -: 3031:}
        -: 3032:
        -: 3033:static inline int
    #####: 3034:cmp_atime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3035:	   int (*cmp) (char const *, char const *))
        -: 3036:{
    #####: 3037:  int diff = timespec_cmp (get_stat_atime (&b->stat),
        -: 3038:			   get_stat_atime (&a->stat));
    #####: 3039:  return diff ? diff : cmp (a->name, b->name);
        -: 3040:}
        -: 3041:
        -: 3042:static inline int
    #####: 3043:cmp_size (struct fileinfo const *a, struct fileinfo const *b,
        -: 3044:	  int (*cmp) (char const *, char const *))
        -: 3045:{
    #####: 3046:  int diff = longdiff (b->stat.st_size, a->stat.st_size);
    #####: 3047:  return diff ? diff : cmp (a->name, b->name);
        -: 3048:}
        -: 3049:
        -: 3050:static inline int
     3672: 3051:cmp_name (struct fileinfo const *a, struct fileinfo const *b,
        -: 3052:	  int (*cmp) (char const *, char const *))
        -: 3053:{
     3672: 3054:  return cmp (a->name, b->name);
        -: 3055:}
        -: 3056:
        -: 3057:/* Compare file extensions.  Files with no extension are `smallest'.
        -: 3058:   If extensions are the same, compare by filenames instead.  */
        -: 3059:
        -: 3060:static inline int
    #####: 3061:cmp_extension (struct fileinfo const *a, struct fileinfo const *b,
        -: 3062:	       int (*cmp) (char const *, char const *))
        -: 3063:{
    #####: 3064:  char const *base1 = strrchr (a->name, '.');
    #####: 3065:  char const *base2 = strrchr (b->name, '.');
    #####: 3066:  int diff = cmp (base1 ? base1 : "", base2 ? base2 : "");
    #####: 3067:  return diff ? diff : cmp (a->name, b->name);
        -: 3068:}
        -: 3069:
    #####: 3070:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
    #####: 3071:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
    #####: 3072:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
    #####: 3073:DEFINE_SORT_FUNCTIONS (size, cmp_size)
     3672: 3074:DEFINE_SORT_FUNCTIONS (name, cmp_name)
    #####: 3075:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
        -: 3076:
        -: 3077:/* Compare file versions.
        -: 3078:   Unlike all other compare functions above, cmp_version depends only
        -: 3079:   on strverscmp, which does not fail (even for locale reasons), and does not
        -: 3080:   need a secondary sort key.
        -: 3081:   All the other sort options, in fact, need xstrcoll and strcmp variants,
        -: 3082:   because they all use a string comparison (either as the primary or secondary
        -: 3083:   sort key), and xstrcoll has the ability to do a longjmp if strcoll fails for
        -: 3084:   locale reasons.  Last, strverscmp is ALWAYS available in coreutils,
        -: 3085:   thanks to the gnulib library. */
        -: 3086:static inline int
    #####: 3087:cmp_version (struct fileinfo const *a, struct fileinfo const *b)
        -: 3088:{
    #####: 3089:  return strverscmp (a->name, b->name);
        -: 3090:}
        -: 3091:
    #####: 3092:static int xstrcoll_version (V a, V b)
    #####: 3093:{ return cmp_version (a, b); }
    #####: 3094:static int rev_xstrcoll_version (V a, V b)
    #####: 3095:{ return cmp_version (b, a); }
    #####: 3096:static int xstrcoll_df_version (V a, V b)
    #####: 3097:{ DIRFIRST_CHECK (a, b); return cmp_version (a, b); }
    #####: 3098:static int rev_xstrcoll_df_version (V a, V b)
    #####: 3099:{ DIRFIRST_CHECK (a, b); return cmp_version (b, a); }
        -: 3100:
        -: 3101:
        -: 3102:/* We have 2^3 different variants for each sortkey function
        -: 3103:   (for 3 independent sort modes).
        -: 3104:   The function pointers stored in this array must be dereferenced as:
        -: 3105:
        -: 3106:    sort_variants[sort_key][use_strcmp][reverse][dirs_first]
        -: 3107:
        -: 3108:   Note that the order in which sortkeys are listed in the function pointer
        -: 3109:   array below is defined by the order of the elements in the time_type and
        -: 3110:   sort_type enums!  */
        -: 3111:
        -: 3112:#define LIST_SORTFUNCTION_VARIANTS(key_name)                        \
        -: 3113:  {                                                                 \
        -: 3114:    {                                                               \
        -: 3115:      { xstrcoll_##key_name, xstrcoll_df_##key_name },              \
        -: 3116:      { rev_xstrcoll_##key_name, rev_xstrcoll_df_##key_name },      \
        -: 3117:    },                                                              \
        -: 3118:    {                                                               \
        -: 3119:      { strcmp_##key_name, strcmp_df_##key_name },                  \
        -: 3120:      { rev_strcmp_##key_name, rev_strcmp_df_##key_name },          \
        -: 3121:    }                                                               \
        -: 3122:  }
        -: 3123:
        -: 3124:static qsortFunc sort_functions[][2][2][2] =
        -: 3125:  {
        -: 3126:    LIST_SORTFUNCTION_VARIANTS (name),
        -: 3127:    LIST_SORTFUNCTION_VARIANTS (extension),
        -: 3128:    LIST_SORTFUNCTION_VARIANTS (size),
        -: 3129:
        -: 3130:    {
        -: 3131:      {
        -: 3132:        { xstrcoll_version, xstrcoll_df_version },
        -: 3133:        { rev_xstrcoll_version, rev_xstrcoll_df_version },
        -: 3134:      },
        -: 3135:
        -: 3136:      /* We use NULL for the strcmp variants of version comparison
        -: 3137:         since as explained in cmp_version definition, version comparison
        -: 3138:         does not rely on xstrcoll, so it will never longjmp, and never
        -: 3139:         need to try the strcmp fallback. */
        -: 3140:      {
        -: 3141:        { NULL, NULL },
        -: 3142:        { NULL, NULL },
        -: 3143:      }
        -: 3144:    },
        -: 3145:
        -: 3146:    /* last are time sort functions */
        -: 3147:    LIST_SORTFUNCTION_VARIANTS (mtime),
        -: 3148:    LIST_SORTFUNCTION_VARIANTS (ctime),
        -: 3149:    LIST_SORTFUNCTION_VARIANTS (atime)
        -: 3150:  };
        -: 3151:
        -: 3152:/* The number of sortkeys is calculated as
        -: 3153:     the number of elements in the sort_type enum (i.e. sort_numtypes) +
        -: 3154:     the number of elements in the time_type enum (i.e. time_numtypes) - 1
        -: 3155:   This is because when sort_type==sort_time, we have up to
        -: 3156:   time_numtypes possible sortkeys.
        -: 3157:
        -: 3158:   This line verifies at compile-time that the array of sort functions has been
        -: 3159:   initialized for all possible sortkeys. */
        -: 3160:verify (ARRAY_CARDINALITY (sort_functions)
        -: 3161:	== sort_numtypes + time_numtypes - 1 );
        -: 3162:
        -: 3163:/* Set up SORTED_FILE to point to the in-use entries in CWD_FILE, in order.  */
        -: 3164:
        -: 3165:static void
       12: 3166:initialize_ordering_vector (void)
        -: 3167:{
        -: 3168:  size_t i;
     1176: 3169:  for (i = 0; i < cwd_n_used; i++)
     1164: 3170:    sorted_file[i] = &cwd_file[i];
       12: 3171:}
        -: 3172:
        -: 3173:/* Sort the files now in the table.  */
        -: 3174:
        -: 3175:static void
       12: 3176:sort_files (void)
        -: 3177:{
        -: 3178:  bool use_strcmp;
        -: 3179:
       12: 3180:  if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)
        -: 3181:    {
       12: 3182:      free (sorted_file);
       12: 3183:      sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);
       12: 3184:      sorted_file_alloc = 3 * cwd_n_used;
        -: 3185:    }
        -: 3186:
       12: 3187:  initialize_ordering_vector ();
        -: 3188:
       12: 3189:  if (sort_type == sort_none)
       12: 3190:    return;
        -: 3191:
        -: 3192:  /* Try strcoll.  If it fails, fall back on strcmp.  We can't safely
        -: 3193:     ignore strcoll failures, as a failing strcoll might be a
        -: 3194:     comparison function that is not a total order, and if we ignored
        -: 3195:     the failure this might cause qsort to dump core.  */
        -: 3196:
       12: 3197:  if (! setjmp (failed_strcoll))
       12: 3198:    use_strcmp = false;      /* strcoll() succeeded */
        -: 3199:  else
        -: 3200:    {
    #####: 3201:      use_strcmp = true;
    #####: 3202:      assert (sort_type != sort_version);
    #####: 3203:      initialize_ordering_vector ();
        -: 3204:    }
        -: 3205:
        -: 3206:  /* When sort_type == sort_time, use time_type as subindex.  */
       24: 3207:  mpsort ((void const **) sorted_file, cwd_n_used,
       12: 3208:	  sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]
        -: 3209:			[use_strcmp][sort_reverse]
       12: 3210:			[directories_first]);
        -: 3211:}
        -: 3212:
        -: 3213:/* List all the files now in the table.  */
        -: 3214:
        -: 3215:static void
       12: 3216:print_current_files (void)
        -: 3217:{
        -: 3218:  size_t i;
        -: 3219:
       12: 3220:  switch (format)
        -: 3221:    {
        -: 3222:    case one_per_line:
     1176: 3223:      for (i = 0; i < cwd_n_used; i++)
        -: 3224:	{
     1164: 3225:	  print_file_name_and_frills (sorted_file[i]);
     1164: 3226:	  putchar ('\n');
        -: 3227:	}
       12: 3228:      break;
        -: 3229:
        -: 3230:    case many_per_line:
    #####: 3231:      print_many_per_line ();
    #####: 3232:      break;
        -: 3233:
        -: 3234:    case horizontal:
    #####: 3235:      print_horizontal ();
    #####: 3236:      break;
        -: 3237:
        -: 3238:    case with_commas:
    #####: 3239:      print_with_commas ();
    #####: 3240:      break;
        -: 3241:
        -: 3242:    case long_format:
    #####: 3243:      for (i = 0; i < cwd_n_used; i++)
        -: 3244:	{
    #####: 3245:	  print_long_format (sorted_file[i]);
    #####: 3246:	  DIRED_PUTCHAR ('\n');
        -: 3247:	}
    #####: 3248:      break;
        -: 3249:    }
       12: 3250:}
        -: 3251:
        -: 3252:/* Return the expected number of columns in a long-format time stamp,
        -: 3253:   or zero if it cannot be calculated.  */
        -: 3254:
        -: 3255:static int
    #####: 3256:long_time_expected_width (void)
        -: 3257:{
        -: 3258:  static int width = -1;
        -: 3259:
    #####: 3260:  if (width < 0)
        -: 3261:    {
    #####: 3262:      time_t epoch = 0;
    #####: 3263:      struct tm const *tm = localtime (&epoch);
        -: 3264:      char buf[TIME_STAMP_LEN_MAXIMUM + 1];
        -: 3265:
        -: 3266:      /* In case you're wondering if localtime can fail with an input time_t
        -: 3267:	 value of 0, let's just say it's very unlikely, but not inconceivable.
        -: 3268:	 The TZ environment variable would have to specify a time zone that
        -: 3269:	 is 2**31-1900 years or more ahead of UTC.  This could happen only on
        -: 3270:	 a 64-bit system that blindly accepts e.g., TZ=UTC+20000000000000.
        -: 3271:	 However, this is not possible with Solaris 10 or glibc-2.3.5, since
        -: 3272:	 their implementations limit the offset to 167:59 and 24:00, resp.  */
    #####: 3273:      if (tm)
        -: 3274:	{
    #####: 3275:	  size_t len =
    #####: 3276:	    nstrftime (buf, sizeof buf, long_time_format[0], tm, 0, 0);
    #####: 3277:	  if (len != 0)
    #####: 3278:	    width = mbsnwidth (buf, len, 0);
        -: 3279:	}
        -: 3280:
    #####: 3281:      if (width < 0)
    #####: 3282:	width = 0;
        -: 3283:    }
        -: 3284:
    #####: 3285:  return width;
        -: 3286:}
        -: 3287:
        -: 3288:/* Get the current time.  */
        -: 3289:
        -: 3290:static void
    #####: 3291:get_current_time (void)
        -: 3292:{
        -: 3293:#if HAVE_CLOCK_GETTIME && defined CLOCK_REALTIME
        -: 3294:  {
        -: 3295:    struct timespec timespec;
    #####: 3296:    if (clock_gettime (CLOCK_REALTIME, &timespec) == 0)
        -: 3297:      {
    #####: 3298:	current_time = timespec.tv_sec;
    #####: 3299:	current_time_ns = timespec.tv_nsec;
    #####: 3300:	return;
        -: 3301:      }
        -: 3302:  }
        -: 3303:#endif
        -: 3304:
        -: 3305:  /* The clock does not have nanosecond resolution, so get the maximum
        -: 3306:     possible value for the current time that is consistent with the
        -: 3307:     reported clock.  That way, files are not considered to be in the
        -: 3308:     future merely because their time stamps have higher resolution
        -: 3309:     than the clock resolution.  */
        -: 3310:
        -: 3311:#if HAVE_GETTIMEOFDAY
        -: 3312:  {
        -: 3313:    struct timeval timeval;
    #####: 3314:    gettimeofday (&timeval, NULL);
    #####: 3315:    current_time = timeval.tv_sec;
    #####: 3316:    current_time_ns = timeval.tv_usec * 1000 + 999;
        -: 3317:  }
        -: 3318:#else
        -: 3319:  current_time = time (NULL);
        -: 3320:  current_time_ns = 999999999;
        -: 3321:#endif
        -: 3322:}
        -: 3323:
        -: 3324:/* Print the user or group name NAME, with numeric id ID, using a
        -: 3325:   print width of WIDTH columns.  */
        -: 3326:
        -: 3327:static void
    #####: 3328:format_user_or_group (char const *name, unsigned long int id, int width)
        -: 3329:{
        -: 3330:  size_t len;
        -: 3331:
    #####: 3332:  if (name)
        -: 3333:    {
    #####: 3334:      int width_gap = width - mbswidth (name, 0);
    #####: 3335:      int pad = MAX (0, width_gap);
    #####: 3336:      fputs (name, stdout);
    #####: 3337:      len = strlen (name) + pad;
        -: 3338:
        -: 3339:      do
    #####: 3340:	putchar (' ');
    #####: 3341:      while (pad--);
        -: 3342:    }
        -: 3343:  else
        -: 3344:    {
    #####: 3345:      printf ("%*lu ", width, id);
    #####: 3346:      len = width;
        -: 3347:    }
        -: 3348:
    #####: 3349:  dired_pos += len + 1;
    #####: 3350:}
        -: 3351:
        -: 3352:/* Print the name or id of the user with id U, using a print width of
        -: 3353:   WIDTH.  */
        -: 3354:
        -: 3355:static void
    #####: 3356:format_user (uid_t u, int width, bool stat_ok)
        -: 3357:{
    #####: 3358:  format_user_or_group (! stat_ok ? "?" :
        -: 3359:			(numeric_ids ? NULL : getuser (u)), u, width);
    #####: 3360:}
        -: 3361:
        -: 3362:/* Likewise, for groups.  */
        -: 3363:
        -: 3364:static void
    #####: 3365:format_group (gid_t g, int width, bool stat_ok)
        -: 3366:{
    #####: 3367:  format_user_or_group (! stat_ok ? "?" :
        -: 3368:			(numeric_ids ? NULL : getgroup (g)), g, width);
    #####: 3369:}
        -: 3370:
        -: 3371:/* Return the number of columns that format_user_or_group will print.  */
        -: 3372:
        -: 3373:static int
    #####: 3374:format_user_or_group_width (char const *name, unsigned long int id)
        -: 3375:{
    #####: 3376:  if (name)
        -: 3377:    {
    #####: 3378:      int len = mbswidth (name, 0);
    #####: 3379:      return MAX (0, len);
        -: 3380:    }
        -: 3381:  else
        -: 3382:    {
        -: 3383:      char buf[INT_BUFSIZE_BOUND (unsigned long int)];
    #####: 3384:      sprintf (buf, "%lu", id);
    #####: 3385:      return strlen (buf);
        -: 3386:    }
        -: 3387:}
        -: 3388:
        -: 3389:/* Return the number of columns that format_user will print.  */
        -: 3390:
        -: 3391:static int
    #####: 3392:format_user_width (uid_t u)
        -: 3393:{
    #####: 3394:  return format_user_or_group_width (numeric_ids ? NULL : getuser (u), u);
        -: 3395:}
        -: 3396:
        -: 3397:/* Likewise, for groups.  */
        -: 3398:
        -: 3399:static int
    #####: 3400:format_group_width (gid_t g)
        -: 3401:{
    #####: 3402:  return format_user_or_group_width (numeric_ids ? NULL : getgroup (g), g);
        -: 3403:}
        -: 3404:
        -: 3405:
        -: 3406:/* Print information about F in long format.  */
        -: 3407:
        -: 3408:static void
    #####: 3409:print_long_format (const struct fileinfo *f)
        -: 3410:{
        -: 3411:  char modebuf[12];
        -: 3412:  char buf
        -: 3413:    [LONGEST_HUMAN_READABLE + 1		/* inode */
        -: 3414:     + LONGEST_HUMAN_READABLE + 1	/* size in blocks */
        -: 3415:     + sizeof (modebuf) - 1 + 1		/* mode string */
        -: 3416:     + INT_BUFSIZE_BOUND (uintmax_t)	/* st_nlink */
        -: 3417:     + LONGEST_HUMAN_READABLE + 2	/* major device number */
        -: 3418:     + LONGEST_HUMAN_READABLE + 1	/* minor device number */
        -: 3419:     + TIME_STAMP_LEN_MAXIMUM + 1	/* max length of time/date */
        -: 3420:     ];
        -: 3421:  size_t s;
        -: 3422:  char *p;
        -: 3423:  time_t when;
        -: 3424:  int when_ns;
        -: 3425:  struct timespec when_timespec;
        -: 3426:  struct tm *when_local;
        -: 3427:
        -: 3428:  /* Compute the mode string, except remove the trailing space if no
        -: 3429:     file in this directory has an ACL or SELinux security context.  */
    #####: 3430:  if (f->stat_ok)
    #####: 3431:    filemodestring (&f->stat, modebuf);
        -: 3432:  else
        -: 3433:    {
    #####: 3434:      modebuf[0] = filetype_letter[f->filetype];
    #####: 3435:      memset (modebuf + 1, '?', 10);
    #####: 3436:      modebuf[11] = '\0';
        -: 3437:    }
    #####: 3438:  if (! any_has_acl)
    #####: 3439:    modebuf[10] = '\0';
    #####: 3440:  else if (f->have_acl)
    #####: 3441:    modebuf[10] = '+';
        -: 3442:
    #####: 3443:  switch (time_type)
        -: 3444:    {
        -: 3445:    case time_ctime:
    #####: 3446:      when_timespec = get_stat_ctime (&f->stat);
    #####: 3447:      break;
        -: 3448:    case time_mtime:
    #####: 3449:      when_timespec = get_stat_mtime (&f->stat);
    #####: 3450:      break;
        -: 3451:    case time_atime:
    #####: 3452:      when_timespec = get_stat_atime (&f->stat);
    #####: 3453:      break;
        -: 3454:    default:
    #####: 3455:      abort ();
        -: 3456:    }
        -: 3457:
    #####: 3458:  when = when_timespec.tv_sec;
    #####: 3459:  when_ns = when_timespec.tv_nsec;
        -: 3460:
    #####: 3461:  p = buf;
        -: 3462:
    #####: 3463:  if (print_inode)
        -: 3464:    {
        -: 3465:      char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3466:      sprintf (p, "%*s ", inode_number_width,
    #####: 3467:	       (f->stat.st_ino == NOT_AN_INODE_NUMBER
        -: 3468:		? "?"
    #####: 3469:		: umaxtostr (f->stat.st_ino, hbuf)));
        -: 3470:      /* Increment by strlen (p) here, rather than by inode_number_width + 1.
        -: 3471:	 The latter is wrong when inode_number_width is zero.  */
    #####: 3472:      p += strlen (p);
        -: 3473:    }
        -: 3474:
    #####: 3475:  if (print_block_size)
        -: 3476:    {
        -: 3477:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####: 3478:      char const *blocks =
    #####: 3479:	(! f->stat_ok
        -: 3480:	 ? "?"
    #####: 3481:	 : human_readable (ST_NBLOCKS (f->stat), hbuf, human_output_opts,
        -: 3482:			   ST_NBLOCKSIZE, output_block_size));
        -: 3483:      int pad;
    #####: 3484:      for (pad = block_size_width - mbswidth (blocks, 0); 0 < pad; pad--)
    #####: 3485:	*p++ = ' ';
    #####: 3486:      while ((*p++ = *blocks++))
    #####: 3487:	continue;
    #####: 3488:      p[-1] = ' ';
        -: 3489:    }
        -: 3490:
        -: 3491:  /* The last byte of the mode string is the POSIX
        -: 3492:     "optional alternate access method flag".  */
        -: 3493:  {
        -: 3494:    char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3495:    sprintf (p, "%s %*s ", modebuf, nlink_width,
    #####: 3496:	     ! f->stat_ok ? "?" : umaxtostr (f->stat.st_nlink, hbuf));
        -: 3497:  }
        -: 3498:  /* Increment by strlen (p) here, rather than by, e.g.,
        -: 3499:     sizeof modebuf - 2 + any_has_acl + 1 + nlink_width + 1.
        -: 3500:     The latter is wrong when nlink_width is zero.  */
    #####: 3501:  p += strlen (p);
        -: 3502:
    #####: 3503:  DIRED_INDENT ();
        -: 3504:
    #####: 3505:  if (print_owner | print_group | print_author | print_scontext)
        -: 3506:    {
    #####: 3507:      DIRED_FPUTS (buf, stdout, p - buf);
        -: 3508:
    #####: 3509:      if (print_owner)
    #####: 3510:	format_user (f->stat.st_uid, owner_width, f->stat_ok);
        -: 3511:
    #####: 3512:      if (print_group)
    #####: 3513:	format_group (f->stat.st_gid, group_width, f->stat_ok);
        -: 3514:
    #####: 3515:      if (print_author)
    #####: 3516:	format_user (f->stat.st_author, author_width, f->stat_ok);
        -: 3517:
    #####: 3518:      if (print_scontext)
    #####: 3519:	format_user_or_group ((f->scontext ? f->scontext : "?"),
        -: 3520:			      0, scontext_width);
        -: 3521:
    #####: 3522:      p = buf;
        -: 3523:    }
        -: 3524:
    #####: 3525:  if (f->stat_ok
    #####: 3526:      && (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode)))
    #####: 3527:    {
        -: 3528:      char majorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
        -: 3529:      char minorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3530:      int blanks_width = (file_size_width
    #####: 3531:			  - (major_device_number_width + 2
    #####: 3532:			     + minor_device_number_width));
    #####: 3533:      sprintf (p, "%*s, %*s ",
    #####: 3534:	       major_device_number_width + MAX (0, blanks_width),
    #####: 3535:	       umaxtostr (major (f->stat.st_rdev), majorbuf),
        -: 3536:	       minor_device_number_width,
    #####: 3537:	       umaxtostr (minor (f->stat.st_rdev), minorbuf));
    #####: 3538:      p += file_size_width + 1;
        -: 3539:    }
        -: 3540:  else
        -: 3541:    {
        -: 3542:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####: 3543:      char const *size =
    #####: 3544:	(! f->stat_ok
        -: 3545:	 ? "?"
    #####: 3546:	 : human_readable (unsigned_file_size (f->stat.st_size),
        -: 3547:			   hbuf, human_output_opts, 1, file_output_block_size));
        -: 3548:      int pad;
    #####: 3549:      for (pad = file_size_width - mbswidth (size, 0); 0 < pad; pad--)
    #####: 3550:	*p++ = ' ';
    #####: 3551:      while ((*p++ = *size++))
    #####: 3552:	continue;
    #####: 3553:      p[-1] = ' ';
        -: 3554:    }
        -: 3555:
    #####: 3556:  when_local = localtime (&when_timespec.tv_sec);
    #####: 3557:  s = 0;
    #####: 3558:  *p = '\1';
        -: 3559:
    #####: 3560:  if (f->stat_ok && when_local)
        -: 3561:    {
        -: 3562:      time_t six_months_ago;
        -: 3563:      bool recent;
        -: 3564:      char const *fmt;
        -: 3565:
        -: 3566:      /* If the file appears to be in the future, update the current
        -: 3567:	 time, in case the file happens to have been modified since
        -: 3568:	 the last time we checked the clock.  */
    #####: 3569:      if (current_time < when
    #####: 3570:	  || (current_time == when && current_time_ns < when_ns))
        -: 3571:	{
        -: 3572:	  /* Note that get_current_time calls gettimeofday which, on some non-
        -: 3573:	     compliant systems, clobbers the buffer used for localtime's result.
        -: 3574:	     But it's ok here, because we use a gettimeofday wrapper that
        -: 3575:	     saves and restores the buffer around the gettimeofday call.  */
    #####: 3576:	  get_current_time ();
        -: 3577:	}
        -: 3578:
        -: 3579:      /* Consider a time to be recent if it is within the past six
        -: 3580:	 months.  A Gregorian year has 365.2425 * 24 * 60 * 60 ==
        -: 3581:	 31556952 seconds on the average.  Write this value as an
        -: 3582:	 integer constant to avoid floating point hassles.  */
    #####: 3583:      six_months_ago = current_time - 31556952 / 2;
    #####: 3584:      recent = (six_months_ago <= when
    #####: 3585:		&& (when < current_time
    #####: 3586:		    || (when == current_time && when_ns <= current_time_ns)));
    #####: 3587:      fmt = long_time_format[recent];
        -: 3588:
    #####: 3589:      s = nstrftime (p, TIME_STAMP_LEN_MAXIMUM + 1, fmt,
        -: 3590:		     when_local, 0, when_ns);
        -: 3591:    }
        -: 3592:
    #####: 3593:  if (s || !*p)
        -: 3594:    {
    #####: 3595:      p += s;
    #####: 3596:      *p++ = ' ';
        -: 3597:
        -: 3598:      /* NUL-terminate the string -- fputs (via DIRED_FPUTS) requires it.  */
    #####: 3599:      *p = '\0';
        -: 3600:    }
        -: 3601:  else
        -: 3602:    {
        -: 3603:      /* The time cannot be converted using the desired format, so
        -: 3604:	 print it as a huge integer number of seconds.  */
        -: 3605:      char hbuf[INT_BUFSIZE_BOUND (intmax_t)];
    #####: 3606:      sprintf (p, "%*s ", long_time_expected_width (),
    #####: 3607:	       (! f->stat_ok
        -: 3608:		? "?"
        -: 3609:		: (TYPE_SIGNED (time_t)
        -: 3610:		   ? imaxtostr (when, hbuf)
        -: 3611:		   : umaxtostr (when, hbuf))));
    #####: 3612:      p += strlen (p);
        -: 3613:    }
        -: 3614:
    #####: 3615:  DIRED_FPUTS (buf, stdout, p - buf);
    #####: 3616:  print_name_with_quoting (f->name, FILE_OR_LINK_MODE (f), f->linkok,
    #####: 3617:			   f->stat_ok, f->filetype, &dired_obstack);
        -: 3618:
    #####: 3619:  if (f->filetype == symbolic_link)
        -: 3620:    {
    #####: 3621:      if (f->linkname)
        -: 3622:	{
    #####: 3623:	  DIRED_FPUTS_LITERAL (" -> ", stdout);
    #####: 3624:	  print_name_with_quoting (f->linkname, f->linkmode, f->linkok - 1,
    #####: 3625:				   f->stat_ok, f->filetype, NULL);
    #####: 3626:	  if (indicator_style != none)
    #####: 3627:	    print_type_indicator (true, f->linkmode, unknown);
        -: 3628:	}
        -: 3629:    }
    #####: 3630:  else if (indicator_style != none)
    #####: 3631:    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
    #####: 3632:}
        -: 3633:
        -: 3634:/* Output to OUT a quoted representation of the file name NAME,
        -: 3635:   using OPTIONS to control quoting.  Produce no output if OUT is NULL.
        -: 3636:   Store the number of screen columns occupied by NAME's quoted
        -: 3637:   representation into WIDTH, if non-NULL.  Return the number of bytes
        -: 3638:   produced.  */
        -: 3639:
        -: 3640:static size_t
     1164: 3641:quote_name (FILE *out, const char *name, struct quoting_options const *options,
        -: 3642:	    size_t *width)
        -: 3643:{
        -: 3644:  char smallbuf[BUFSIZ];
     1164: 3645:  size_t len = quotearg_buffer (smallbuf, sizeof smallbuf, name, -1, options);
        -: 3646:  char *buf;
        -: 3647:  size_t displayed_width IF_LINT (= 0);
        -: 3648:
     1164: 3649:  if (len < sizeof smallbuf)
     1164: 3650:    buf = smallbuf;
        -: 3651:  else
        -: 3652:    {
    #####: 3653:      buf = alloca (len + 1);
    #####: 3654:      quotearg_buffer (buf, len + 1, name, -1, options);
        -: 3655:    }
        -: 3656:
     1164: 3657:  if (qmark_funny_chars)
        -: 3658:    {
        -: 3659:#if HAVE_MBRTOWC
    #####: 3660:      if (MB_CUR_MAX > 1)
        -: 3661:	{
    #####: 3662:	  char const *p = buf;
    #####: 3663:	  char const *plimit = buf + len;
    #####: 3664:	  char *q = buf;
    #####: 3665:	  displayed_width = 0;
        -: 3666:
    #####: 3667:	  while (p < plimit)
    #####: 3668:	    switch (*p)
        -: 3669:	      {
        -: 3670:		case ' ': case '!': case '"': case '#': case '%':
        -: 3671:		case '&': case '\'': case '(': case ')': case '*':
        -: 3672:		case '+': case ',': case '-': case '.': case '/':
        -: 3673:		case '0': case '1': case '2': case '3': case '4':
        -: 3674:		case '5': case '6': case '7': case '8': case '9':
        -: 3675:		case ':': case ';': case '<': case '=': case '>':
        -: 3676:		case '?':
        -: 3677:		case 'A': case 'B': case 'C': case 'D': case 'E':
        -: 3678:		case 'F': case 'G': case 'H': case 'I': case 'J':
        -: 3679:		case 'K': case 'L': case 'M': case 'N': case 'O':
        -: 3680:		case 'P': case 'Q': case 'R': case 'S': case 'T':
        -: 3681:		case 'U': case 'V': case 'W': case 'X': case 'Y':
        -: 3682:		case 'Z':
        -: 3683:		case '[': case '\\': case ']': case '^': case '_':
        -: 3684:		case 'a': case 'b': case 'c': case 'd': case 'e':
        -: 3685:		case 'f': case 'g': case 'h': case 'i': case 'j':
        -: 3686:		case 'k': case 'l': case 'm': case 'n': case 'o':
        -: 3687:		case 'p': case 'q': case 'r': case 's': case 't':
        -: 3688:		case 'u': case 'v': case 'w': case 'x': case 'y':
        -: 3689:		case 'z': case '{': case '|': case '}': case '~':
        -: 3690:		  /* These characters are printable ASCII characters.  */
    #####: 3691:		  *q++ = *p++;
    #####: 3692:		  displayed_width += 1;
    #####: 3693:		  break;
        -: 3694:		default:
        -: 3695:		  /* If we have a multibyte sequence, copy it until we
        -: 3696:		     reach its end, replacing each non-printable multibyte
        -: 3697:		     character with a single question mark.  */
        -: 3698:		  {
    #####: 3699:		    mbstate_t mbstate = { 0, };
        -: 3700:		    do
        -: 3701:		      {
        -: 3702:			wchar_t wc;
        -: 3703:			size_t bytes;
        -: 3704:			int w;
        -: 3705:
    #####: 3706:			bytes = mbrtowc (&wc, p, plimit - p, &mbstate);
        -: 3707:
    #####: 3708:			if (bytes == (size_t) -1)
        -: 3709:			  {
        -: 3710:			    /* An invalid multibyte sequence was
        -: 3711:			       encountered.  Skip one input byte, and
        -: 3712:			       put a question mark.  */
    #####: 3713:			    p++;
    #####: 3714:			    *q++ = '?';
    #####: 3715:			    displayed_width += 1;
    #####: 3716:			    break;
        -: 3717:			  }
        -: 3718:
    #####: 3719:			if (bytes == (size_t) -2)
        -: 3720:			  {
        -: 3721:			    /* An incomplete multibyte character
        -: 3722:			       at the end.  Replace it entirely with
        -: 3723:			       a question mark.  */
    #####: 3724:			    p = plimit;
    #####: 3725:			    *q++ = '?';
    #####: 3726:			    displayed_width += 1;
    #####: 3727:			    break;
        -: 3728:			  }
        -: 3729:
    #####: 3730:			if (bytes == 0)
        -: 3731:			  /* A null wide character was encountered.  */
    #####: 3732:			  bytes = 1;
        -: 3733:
    #####: 3734:			w = wcwidth (wc);
    #####: 3735:			if (w >= 0)
        -: 3736:			  {
        -: 3737:			    /* A printable multibyte character.
        -: 3738:			       Keep it.  */
    #####: 3739:			    for (; bytes > 0; --bytes)
    #####: 3740:			      *q++ = *p++;
    #####: 3741:			    displayed_width += w;
        -: 3742:			  }
        -: 3743:			else
        -: 3744:			  {
        -: 3745:			    /* An unprintable multibyte character.
        -: 3746:			       Replace it entirely with a question
        -: 3747:			       mark.  */
    #####: 3748:			    p += bytes;
    #####: 3749:			    *q++ = '?';
    #####: 3750:			    displayed_width += 1;
        -: 3751:			  }
        -: 3752:		      }
    #####: 3753:		    while (! mbsinit (&mbstate));
        -: 3754:		  }
    #####: 3755:		  break;
        -: 3756:	      }
        -: 3757:
        -: 3758:	  /* The buffer may have shrunk.  */
    #####: 3759:	  len = q - buf;
        -: 3760:	}
        -: 3761:      else
        -: 3762:#endif
        -: 3763:	{
    #####: 3764:	  char *p = buf;
    #####: 3765:	  char const *plimit = buf + len;
        -: 3766:
    #####: 3767:	  while (p < plimit)
        -: 3768:	    {
    #####: 3769:	      if (! isprint (to_uchar (*p)))
    #####: 3770:		*p = '?';
    #####: 3771:	      p++;
        -: 3772:	    }
    #####: 3773:	  displayed_width = len;
        -: 3774:	}
        -: 3775:    }
     1164: 3776:  else if (width != NULL)
        -: 3777:    {
        -: 3778:#if HAVE_MBRTOWC
    #####: 3779:      if (MB_CUR_MAX > 1)
    #####: 3780:	displayed_width = mbsnwidth (buf, len, 0);
        -: 3781:      else
        -: 3782:#endif
        -: 3783:	{
    #####: 3784:	  char const *p = buf;
    #####: 3785:	  char const *plimit = buf + len;
        -: 3786:
    #####: 3787:	  displayed_width = 0;
    #####: 3788:	  while (p < plimit)
        -: 3789:	    {
    #####: 3790:	      if (isprint (to_uchar (*p)))
    #####: 3791:		displayed_width++;
    #####: 3792:	      p++;
        -: 3793:	    }
        -: 3794:	}
        -: 3795:    }
        -: 3796:
     1164: 3797:  if (out != NULL)
     1164: 3798:    fwrite (buf, 1, len, out);
     1164: 3799:  if (width != NULL)
    #####: 3800:    *width = displayed_width;
     1164: 3801:  return len;
        -: 3802:}
        -: 3803:
        -: 3804:static void
     1164: 3805:print_name_with_quoting (const char *p, mode_t mode, int linkok,
        -: 3806:			 bool stat_ok, enum filetype type,
        -: 3807:			 struct obstack *stack)
        -: 3808:{
     1164: 3809:  if (print_with_color)
    #####: 3810:    print_color_indicator (p, mode, linkok, stat_ok, type);
        -: 3811:
     1164: 3812:  if (stack)
    #####: 3813:    PUSH_CURRENT_DIRED_POS (stack);
        -: 3814:
     1164: 3815:  dired_pos += quote_name (stdout, p, filename_quoting_options, NULL);
        -: 3816:
     1164: 3817:  if (stack)
    #####: 3818:    PUSH_CURRENT_DIRED_POS (stack);
        -: 3819:
     1164: 3820:  if (print_with_color)
        -: 3821:    {
    #####: 3822:      process_signals ();
    #####: 3823:      prep_non_filename_text ();
        -: 3824:    }
     1164: 3825:}
        -: 3826:
        -: 3827:static void
    #####: 3828:prep_non_filename_text (void)
        -: 3829:{
    #####: 3830:  if (color_indicator[C_END].string != NULL)
    #####: 3831:    put_indicator (&color_indicator[C_END]);
        -: 3832:  else
        -: 3833:    {
    #####: 3834:      put_indicator (&color_indicator[C_LEFT]);
    #####: 3835:      put_indicator (&color_indicator[C_NORM]);
    #####: 3836:      put_indicator (&color_indicator[C_RIGHT]);
        -: 3837:    }
    #####: 3838:}
        -: 3839:
        -: 3840:/* Print the file name of `f' with appropriate quoting.
        -: 3841:   Also print file size, inode number, and filetype indicator character,
        -: 3842:   as requested by switches.  */
        -: 3843:
        -: 3844:static void
     1164: 3845:print_file_name_and_frills (const struct fileinfo *f)
        -: 3846:{
        -: 3847:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 3848:
     1164: 3849:  if (print_inode)
    #####: 3850:    printf ("%*s ", format == with_commas ? 0 : inode_number_width,
        -: 3851:	    umaxtostr (f->stat.st_ino, buf));
        -: 3852:
     1164: 3853:  if (print_block_size)
    #####: 3854:    printf ("%*s ", format == with_commas ? 0 : block_size_width,
    #####: 3855:	    human_readable (ST_NBLOCKS (f->stat), buf, human_output_opts,
        -: 3856:			    ST_NBLOCKSIZE, output_block_size));
        -: 3857:
     1164: 3858:  if (print_scontext)
    #####: 3859:    printf ("%*s ", format == with_commas ? 0 : scontext_width,
    #####: 3860:	    (f->scontext ? f->scontext : "?"));
        -: 3861:
     2328: 3862:  print_name_with_quoting (f->name, FILE_OR_LINK_MODE (f), f->linkok,
     1164: 3863:			   f->stat_ok, f->filetype, NULL);
        -: 3864:
     1164: 3865:  if (indicator_style != none)
    #####: 3866:    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
     1164: 3867:}
        -: 3868:
        -: 3869:/* Given these arguments describing a file, return the single-byte
        -: 3870:   type indicator, or 0.  */
        -: 3871:static char
    #####: 3872:get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 3873:{
        -: 3874:  char c;
        -: 3875:
    #####: 3876:  if (stat_ok ? S_ISREG (mode) : type == normal)
        -: 3877:    {
    #####: 3878:      if (stat_ok && indicator_style == classify && (mode & S_IXUGO))
    #####: 3879:	c = '*';
        -: 3880:      else
    #####: 3881:	c = 0;
        -: 3882:    }
        -: 3883:  else
        -: 3884:    {
    #####: 3885:      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)
    #####: 3886:	c = '/';
    #####: 3887:      else if (indicator_style == slash)
    #####: 3888:	c = 0;
    #####: 3889:      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)
    #####: 3890:	c = '@';
    #####: 3891:      else if (stat_ok ? S_ISFIFO (mode) : type == fifo)
    #####: 3892:	c = '|';
    #####: 3893:      else if (stat_ok ? S_ISSOCK (mode) : type == sock)
    #####: 3894:	c = '=';
        -: 3895:      else if (stat_ok && S_ISDOOR (mode))
        -: 3896:	c = '>';
        -: 3897:      else
    #####: 3898:	c = 0;
        -: 3899:    }
    #####: 3900:  return c;
        -: 3901:}
        -: 3902:
        -: 3903:static void
    #####: 3904:print_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 3905:{
    #####: 3906:  char c = get_type_indicator (stat_ok, mode, type);
    #####: 3907:  if (c)
    #####: 3908:    DIRED_PUTCHAR (c);
    #####: 3909:}
        -: 3910:
        -: 3911:static void
    #####: 3912:print_color_indicator (const char *name, mode_t mode, int linkok,
        -: 3913:		       bool stat_ok, enum filetype filetype)
        -: 3914:{
        -: 3915:  int type;
        -: 3916:  struct color_ext_type *ext;	/* Color extension */
        -: 3917:  size_t len;			/* Length of name */
        -: 3918:
        -: 3919:  /* Is this a nonexistent file?  If so, linkok == -1.  */
        -: 3920:
    #####: 3921:  if (linkok == -1 && color_indicator[C_MISSING].string != NULL)
    #####: 3922:    type = C_MISSING;
    #####: 3923:  else if (! stat_ok)
        -: 3924:    {
        -: 3925:      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;
    #####: 3926:      type = filetype_indicator[filetype];
        -: 3927:    }
        -: 3928:  else
        -: 3929:    {
    #####: 3930:      if (S_ISREG (mode))
        -: 3931:	{
    #####: 3932:	  type = C_FILE;
    #####: 3933:	  if ((mode & S_ISUID) != 0)
    #####: 3934:	    type = C_SETUID;
    #####: 3935:	  else if ((mode & S_ISGID) != 0)
    #####: 3936:	    type = C_SETGID;
    #####: 3937:	  else if ((mode & S_IXUGO) != 0)
    #####: 3938:	    type = C_EXEC;
        -: 3939:	}
    #####: 3940:      else if (S_ISDIR (mode))
        -: 3941:	{
    #####: 3942:	  if ((mode & S_ISVTX) && (mode & S_IWOTH))
    #####: 3943:	    type = C_STICKY_OTHER_WRITABLE;
    #####: 3944:	  else if ((mode & S_IWOTH) != 0)
    #####: 3945:	    type = C_OTHER_WRITABLE;
    #####: 3946:	  else if ((mode & S_ISVTX) != 0)
    #####: 3947:	    type = C_STICKY;
        -: 3948:	  else
    #####: 3949:	    type = C_DIR;
        -: 3950:	}
    #####: 3951:      else if (S_ISLNK (mode))
    #####: 3952:	type = ((!linkok && color_indicator[C_ORPHAN].string)
    #####: 3953:		? C_ORPHAN : C_LINK);
    #####: 3954:      else if (S_ISFIFO (mode))
    #####: 3955:	type = C_FIFO;
    #####: 3956:      else if (S_ISSOCK (mode))
    #####: 3957:	type = C_SOCK;
    #####: 3958:      else if (S_ISBLK (mode))
    #####: 3959:	type = C_BLK;
    #####: 3960:      else if (S_ISCHR (mode))
    #####: 3961:	type = C_CHR;
        -: 3962:      else if (S_ISDOOR (mode))
        -: 3963:	type = C_DOOR;
        -: 3964:      else
        -: 3965:	{
        -: 3966:	  /* Classify a file of some other type as C_ORPHAN.  */
    #####: 3967:	  type = C_ORPHAN;
        -: 3968:	}
        -: 3969:    }
        -: 3970:
        -: 3971:  /* Check the file's suffix only if still classified as C_FILE.  */
    #####: 3972:  ext = NULL;
    #####: 3973:  if (type == C_FILE)
        -: 3974:    {
        -: 3975:      /* Test if NAME has a recognized suffix.  */
        -: 3976:
    #####: 3977:      len = strlen (name);
    #####: 3978:      name += len;		/* Pointer to final \0.  */
    #####: 3979:      for (ext = color_ext_list; ext != NULL; ext = ext->next)
        -: 3980:	{
    #####: 3981:	  if (ext->ext.len <= len
    #####: 3982:	      && strncmp (name - ext->ext.len, ext->ext.string,
        -: 3983:			  ext->ext.len) == 0)
    #####: 3984:	    break;
        -: 3985:	}
        -: 3986:    }
        -: 3987:
    #####: 3988:  put_indicator (&color_indicator[C_LEFT]);
    #####: 3989:  put_indicator (ext ? &(ext->seq) : &color_indicator[type]);
    #####: 3990:  put_indicator (&color_indicator[C_RIGHT]);
    #####: 3991:}
        -: 3992:
        -: 3993:/* Output a color indicator (which may contain nulls).  */
        -: 3994:static void
    #####: 3995:put_indicator (const struct bin_str *ind)
        -: 3996:{
        -: 3997:  size_t i;
        -: 3998:  const char *p;
        -: 3999:
    #####: 4000:  p = ind->string;
        -: 4001:
    #####: 4002:  for (i = ind->len; i != 0; --i)
    #####: 4003:    putchar (*(p++));
    #####: 4004:}
        -: 4005:
        -: 4006:static size_t
    #####: 4007:length_of_file_name_and_frills (const struct fileinfo *f)
        -: 4008:{
    #####: 4009:  size_t len = 0;
        -: 4010:  size_t name_width;
        -: 4011:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 4012:
    #####: 4013:  if (print_inode)
    #####: 4014:    len += 1 + (format == with_commas
    #####: 4015:		? strlen (umaxtostr (f->stat.st_ino, buf))
        -: 4016:		: inode_number_width);
        -: 4017:
    #####: 4018:  if (print_block_size)
    #####: 4019:    len += 1 + (format == with_commas
    #####: 4020:		? strlen (human_readable (ST_NBLOCKS (f->stat), buf,
        -: 4021:					  human_output_opts, ST_NBLOCKSIZE,
        -: 4022:					  output_block_size))
        -: 4023:		: block_size_width);
        -: 4024:
    #####: 4025:  if (print_scontext)
    #####: 4026:    len += 1 + (format == with_commas ? strlen (f->scontext) : scontext_width);
        -: 4027:
    #####: 4028:  quote_name (NULL, f->name, filename_quoting_options, &name_width);
    #####: 4029:  len += name_width;
        -: 4030:
    #####: 4031:  if (indicator_style != none)
        -: 4032:    {
    #####: 4033:      char c = get_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
    #####: 4034:      len += (c != 0);
        -: 4035:    }
        -: 4036:
    #####: 4037:  return len;
        -: 4038:}
        -: 4039:
        -: 4040:static void
    #####: 4041:print_many_per_line (void)
        -: 4042:{
        -: 4043:  size_t row;			/* Current row.  */
    #####: 4044:  size_t cols = calculate_columns (true);
    #####: 4045:  struct column_info const *line_fmt = &column_info[cols - 1];
        -: 4046:
        -: 4047:  /* Calculate the number of rows that will be in each column except possibly
        -: 4048:     for a short column on the right.  */
    #####: 4049:  size_t rows = cwd_n_used / cols + (cwd_n_used % cols != 0);
        -: 4050:
    #####: 4051:  for (row = 0; row < rows; row++)
        -: 4052:    {
    #####: 4053:      size_t col = 0;
    #####: 4054:      size_t filesno = row;
    #####: 4055:      size_t pos = 0;
        -: 4056:
        -: 4057:      /* Print the next row.  */
        -: 4058:      while (1)
        -: 4059:	{
    #####: 4060:	  struct fileinfo const *f = sorted_file[filesno];
    #####: 4061:	  size_t name_length = length_of_file_name_and_frills (f);
    #####: 4062:	  size_t max_name_length = line_fmt->col_arr[col++];
    #####: 4063:	  print_file_name_and_frills (f);
        -: 4064:
    #####: 4065:	  filesno += rows;
    #####: 4066:	  if (filesno >= cwd_n_used)
    #####: 4067:	    break;
        -: 4068:
    #####: 4069:	  indent (pos + name_length, pos + max_name_length);
    #####: 4070:	  pos += max_name_length;
    #####: 4071:	}
    #####: 4072:      putchar ('\n');
        -: 4073:    }
    #####: 4074:}
        -: 4075:
        -: 4076:static void
    #####: 4077:print_horizontal (void)
        -: 4078:{
        -: 4079:  size_t filesno;
    #####: 4080:  size_t pos = 0;
    #####: 4081:  size_t cols = calculate_columns (false);
    #####: 4082:  struct column_info const *line_fmt = &column_info[cols - 1];
    #####: 4083:  struct fileinfo const *f = sorted_file[0];
    #####: 4084:  size_t name_length = length_of_file_name_and_frills (f);
    #####: 4085:  size_t max_name_length = line_fmt->col_arr[0];
        -: 4086:
        -: 4087:  /* Print first entry.  */
    #####: 4088:  print_file_name_and_frills (f);
        -: 4089:
        -: 4090:  /* Now the rest.  */
    #####: 4091:  for (filesno = 1; filesno < cwd_n_used; ++filesno)
        -: 4092:    {
    #####: 4093:      size_t col = filesno % cols;
        -: 4094:
    #####: 4095:      if (col == 0)
        -: 4096:	{
    #####: 4097:	  putchar ('\n');
    #####: 4098:	  pos = 0;
        -: 4099:	}
        -: 4100:      else
        -: 4101:	{
    #####: 4102:	  indent (pos + name_length, pos + max_name_length);
    #####: 4103:	  pos += max_name_length;
        -: 4104:	}
        -: 4105:
    #####: 4106:      f = sorted_file[filesno];
    #####: 4107:      print_file_name_and_frills (f);
        -: 4108:
    #####: 4109:      name_length = length_of_file_name_and_frills (f);
    #####: 4110:      max_name_length = line_fmt->col_arr[col];
        -: 4111:    }
    #####: 4112:  putchar ('\n');
    #####: 4113:}
        -: 4114:
        -: 4115:static void
    #####: 4116:print_with_commas (void)
        -: 4117:{
        -: 4118:  size_t filesno;
    #####: 4119:  size_t pos = 0;
        -: 4120:
    #####: 4121:  for (filesno = 0; filesno < cwd_n_used; filesno++)
        -: 4122:    {
    #####: 4123:      struct fileinfo const *f = sorted_file[filesno];
    #####: 4124:      size_t len = length_of_file_name_and_frills (f);
        -: 4125:
    #####: 4126:      if (filesno != 0)
        -: 4127:	{
        -: 4128:	  char separator;
        -: 4129:
    #####: 4130:	  if (pos + len + 2 < line_length)
        -: 4131:	    {
    #####: 4132:	      pos += 2;
    #####: 4133:	      separator = ' ';
        -: 4134:	    }
        -: 4135:	  else
        -: 4136:	    {
    #####: 4137:	      pos = 0;
    #####: 4138:	      separator = '\n';
        -: 4139:	    }
        -: 4140:
    #####: 4141:	  putchar (',');
    #####: 4142:	  putchar (separator);
        -: 4143:	}
        -: 4144:
    #####: 4145:      print_file_name_and_frills (f);
    #####: 4146:      pos += len;
        -: 4147:    }
    #####: 4148:  putchar ('\n');
    #####: 4149:}
        -: 4150:
        -: 4151:/* Assuming cursor is at position FROM, indent up to position TO.
        -: 4152:   Use a TAB character instead of two or more spaces whenever possible.  */
        -: 4153:
        -: 4154:static void
    #####: 4155:indent (size_t from, size_t to)
        -: 4156:{
    #####: 4157:  while (from < to)
        -: 4158:    {
    #####: 4159:      if (tabsize != 0 && to / tabsize > (from + 1) / tabsize)
        -: 4160:	{
    #####: 4161:	  putchar ('\t');
    #####: 4162:	  from += tabsize - from % tabsize;
        -: 4163:	}
        -: 4164:      else
        -: 4165:	{
    #####: 4166:	  putchar (' ');
    #####: 4167:	  from++;
        -: 4168:	}
        -: 4169:    }
    #####: 4170:}
        -: 4171:
        -: 4172:/* Put DIRNAME/NAME into DEST, handling `.' and `/' properly.  */
        -: 4173:/* FIXME: maybe remove this function someday.  See about using a
        -: 4174:   non-malloc'ing version of file_name_concat.  */
        -: 4175:
        -: 4176:static void
    #####: 4177:attach (char *dest, const char *dirname, const char *name)
        -: 4178:{
    #####: 4179:  const char *dirnamep = dirname;
        -: 4180:
        -: 4181:  /* Copy dirname if it is not ".".  */
    #####: 4182:  if (dirname[0] != '.' || dirname[1] != 0)
        -: 4183:    {
    #####: 4184:      while (*dirnamep)
    #####: 4185:	*dest++ = *dirnamep++;
        -: 4186:      /* Add '/' if `dirname' doesn't already end with it.  */
    #####: 4187:      if (dirnamep > dirname && dirnamep[-1] != '/')
    #####: 4188:	*dest++ = '/';
        -: 4189:    }
    #####: 4190:  while (*name)
    #####: 4191:    *dest++ = *name++;
    #####: 4192:  *dest = 0;
    #####: 4193:}
        -: 4194:
        -: 4195:/* Allocate enough column info suitable for the current number of
        -: 4196:   files and display columns, and initialize the info to represent the
        -: 4197:   narrowest possible columns.  */
        -: 4198:
        -: 4199:static void
    #####: 4200:init_column_info (void)
        -: 4201:{
        -: 4202:  size_t i;
    #####: 4203:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4204:
        -: 4205:  /* Currently allocated columns in column_info.  */
        -: 4206:  static size_t column_info_alloc;
        -: 4207:
    #####: 4208:  if (column_info_alloc < max_cols)
        -: 4209:    {
        -: 4210:      size_t new_column_info_alloc;
        -: 4211:      size_t *p;
        -: 4212:
    #####: 4213:      if (max_cols < max_idx / 2)
        -: 4214:	{
        -: 4215:	  /* The number of columns is far less than the display width
        -: 4216:	     allows.  Grow the allocation, but only so that it's
        -: 4217:	     double the current requirements.  If the display is
        -: 4218:	     extremely wide, this avoids allocating a lot of memory
        -: 4219:	     that is never needed.  */
    #####: 4220:	  column_info = xnrealloc (column_info, max_cols,
        -: 4221:				   2 * sizeof *column_info);
    #####: 4222:	  new_column_info_alloc = 2 * max_cols;
        -: 4223:	}
        -: 4224:      else
        -: 4225:	{
    #####: 4226:	  column_info = xnrealloc (column_info, max_idx, sizeof *column_info);
    #####: 4227:	  new_column_info_alloc = max_idx;
        -: 4228:	}
        -: 4229:
        -: 4230:      /* Allocate the new size_t objects by computing the triangle
        -: 4231:	 formula n * (n + 1) / 2, except that we don't need to
        -: 4232:	 allocate the part of the triangle that we've already
        -: 4233:	 allocated.  Check for address arithmetic overflow.  */
        -: 4234:      {
    #####: 4235:	size_t column_info_growth = new_column_info_alloc - column_info_alloc;
    #####: 4236:	size_t s = column_info_alloc + 1 + new_column_info_alloc;
    #####: 4237:	size_t t = s * column_info_growth;
    #####: 4238:	if (s < new_column_info_alloc || t / column_info_growth != s)
    #####: 4239:	  xalloc_die ();
    #####: 4240:	p = xnmalloc (t / 2, sizeof *p);
        -: 4241:      }
        -: 4242:
        -: 4243:      /* Grow the triangle by parceling out the cells just allocated.  */
    #####: 4244:      for (i = column_info_alloc; i < new_column_info_alloc; i++)
        -: 4245:	{
    #####: 4246:	  column_info[i].col_arr = p;
    #####: 4247:	  p += i + 1;
        -: 4248:	}
        -: 4249:
    #####: 4250:      column_info_alloc = new_column_info_alloc;
        -: 4251:    }
        -: 4252:
    #####: 4253:  for (i = 0; i < max_cols; ++i)
        -: 4254:    {
        -: 4255:      size_t j;
        -: 4256:
    #####: 4257:      column_info[i].valid_len = true;
    #####: 4258:      column_info[i].line_len = (i + 1) * MIN_COLUMN_WIDTH;
    #####: 4259:      for (j = 0; j <= i; ++j)
    #####: 4260:	column_info[i].col_arr[j] = MIN_COLUMN_WIDTH;
        -: 4261:    }
    #####: 4262:}
        -: 4263:
        -: 4264:/* Calculate the number of columns needed to represent the current set
        -: 4265:   of files in the current display width.  */
        -: 4266:
        -: 4267:static size_t
    #####: 4268:calculate_columns (bool by_columns)
        -: 4269:{
        -: 4270:  size_t filesno;		/* Index into cwd_file.  */
        -: 4271:  size_t cols;			/* Number of files across.  */
        -: 4272:
        -: 4273:  /* Normally the maximum number of columns is determined by the
        -: 4274:     screen width.  But if few files are available this might limit it
        -: 4275:     as well.  */
    #####: 4276:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4277:
    #####: 4278:  init_column_info ();
        -: 4279:
        -: 4280:  /* Compute the maximum number of possible columns.  */
    #####: 4281:  for (filesno = 0; filesno < cwd_n_used; ++filesno)
        -: 4282:    {
    #####: 4283:      struct fileinfo const *f = sorted_file[filesno];
    #####: 4284:      size_t name_length = length_of_file_name_and_frills (f);
        -: 4285:      size_t i;
        -: 4286:
    #####: 4287:      for (i = 0; i < max_cols; ++i)
        -: 4288:	{
    #####: 4289:	  if (column_info[i].valid_len)
        -: 4290:	    {
    #####: 4291:	      size_t idx = (by_columns
    #####: 4292:			    ? filesno / ((cwd_n_used + i) / (i + 1))
    #####: 4293:			    : filesno % (i + 1));
    #####: 4294:	      size_t real_length = name_length + (idx == i ? 0 : 2);
        -: 4295:
    #####: 4296:	      if (column_info[i].col_arr[idx] < real_length)
        -: 4297:		{
    #####: 4298:		  column_info[i].line_len += (real_length
    #####: 4299:					      - column_info[i].col_arr[idx]);
    #####: 4300:		  column_info[i].col_arr[idx] = real_length;
    #####: 4301:		  column_info[i].valid_len = (column_info[i].line_len
    #####: 4302:					      < line_length);
        -: 4303:		}
        -: 4304:	    }
        -: 4305:	}
        -: 4306:    }
        -: 4307:
        -: 4308:  /* Find maximum allowed columns.  */
    #####: 4309:  for (cols = max_cols; 1 < cols; --cols)
        -: 4310:    {
    #####: 4311:      if (column_info[cols - 1].valid_len)
    #####: 4312:	break;
        -: 4313:    }
        -: 4314:
    #####: 4315:  return cols;
        -: 4316:}
        -: 4317:
        -: 4318:void
    #####: 4319:usage (int status)
        -: 4320:{
    #####: 4321:  if (status != EXIT_SUCCESS)
    #####: 4322:    fprintf (stderr, _("Try `%s --help' for more information.\n"),
        -: 4323:	     program_name);
        -: 4324:  else
        -: 4325:    {
    #####: 4326:      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
    #####: 4327:      fputs (_("\
        -: 4328:List information about the FILEs (the current directory by default).\n\
        -: 4329:Sort entries alphabetically if none of -cftuvSUX nor --sort.\n\
        -: 4330:\n\
        -: 4331:"), stdout);
    #####: 4332:      fputs (_("\
        -: 4333:Mandatory arguments to long options are mandatory for short options too.\n\
        -: 4334:"), stdout);
    #####: 4335:      fputs (_("\
        -: 4336:  -a, --all                  do not ignore entries starting with .\n\
        -: 4337:  -A, --almost-all           do not list implied . and ..\n\
        -: 4338:      --author               with -l, print the author of each file\n\
        -: 4339:  -b, --escape               print octal escapes for nongraphic characters\n\
        -: 4340:"), stdout);
    #####: 4341:      fputs (_("\
        -: 4342:      --block-size=SIZE      use SIZE-byte blocks\n\
        -: 4343:  -B, --ignore-backups       do not list implied entries ending with ~\n\
        -: 4344:  -c                         with -lt: sort by, and show, ctime (time of last\n\
        -: 4345:                               modification of file status information)\n\
        -: 4346:                               with -l: show ctime and sort by name\n\
        -: 4347:                               otherwise: sort by ctime\n\
        -: 4348:"), stdout);
    #####: 4349:      fputs (_("\
        -: 4350:  -C                         list entries by columns\n\
        -: 4351:      --color[=WHEN]         control whether color is used to distinguish file\n\
        -: 4352:                               types.  WHEN may be `never', `always', or `auto'\n\
        -: 4353:  -d, --directory            list directory entries instead of contents,\n\
        -: 4354:                               and do not dereference symbolic links\n\
        -: 4355:  -D, --dired                generate output designed for Emacs' dired mode\n\
        -: 4356:"), stdout);
    #####: 4357:      fputs (_("\
        -: 4358:  -f                         do not sort, enable -aU, disable -ls --color\n\
        -: 4359:  -F, --classify             append indicator (one of */=>@|) to entries\n\
        -: 4360:      --file-type            likewise, except do not append `*'\n\
        -: 4361:      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n\
        -: 4362:                               single-column -1, verbose -l, vertical -C\n\
        -: 4363:      --full-time            like -l --time-style=full-iso\n\
        -: 4364:"), stdout);
    #####: 4365:      fputs (_("\
        -: 4366:  -g                         like -l, but do not list owner\n\
        -: 4367:"), stdout);
    #####: 4368:      fputs (_("\
        -: 4369:      --group-directories-first\n\
        -: 4370:                             group directories before files\n\
        -: 4371:"), stdout);
    #####: 4372:      fputs (_("\
        -: 4373:  -G, --no-group             in a long listing, don't print group names\n\
        -: 4374:  -h, --human-readable       with -l, print sizes in human readable format\n\
        -: 4375:                               (e.g., 1K 234M 2G)\n\
        -: 4376:      --si                   likewise, but use powers of 1000 not 1024\n\
        -: 4377:"), stdout);
    #####: 4378:      fputs (_("\
        -: 4379:  -H, --dereference-command-line\n\
        -: 4380:                             follow symbolic links listed on the command line\n\
        -: 4381:      --dereference-command-line-symlink-to-dir\n\
        -: 4382:                             follow each command line symbolic link\n\
        -: 4383:                             that points to a directory\n\
        -: 4384:      --hide=PATTERN         do not list implied entries matching shell PATTERN\n\
        -: 4385:                               (overridden by -a or -A)\n\
        -: 4386:"), stdout);
    #####: 4387:      fputs (_("\
        -: 4388:      --indicator-style=WORD  append indicator with style WORD to entry names:\n\
        -: 4389:                               none (default), slash (-p),\n\
        -: 4390:                               file-type (--file-type), classify (-F)\n\
        -: 4391:  -i, --inode                print the index number of each file\n\
        -: 4392:  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n\
        -: 4393:  -k                         like --block-size=1K\n\
        -: 4394:"), stdout);
    #####: 4395:      fputs (_("\
        -: 4396:  -l                         use a long listing format\n\
        -: 4397:  -L, --dereference          when showing file information for a symbolic\n\
        -: 4398:                               link, show information for the file the link\n\
        -: 4399:                               references rather than for the link itself\n\
        -: 4400:  -m                         fill width with a comma separated list of entries\n\
        -: 4401:"), stdout);
    #####: 4402:      fputs (_("\
        -: 4403:  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n\
        -: 4404:  -N, --literal              print raw entry names (don't treat e.g. control\n\
        -: 4405:                               characters specially)\n\
        -: 4406:  -o                         like -l, but do not list group information\n\
        -: 4407:  -p, --indicator-style=slash\n\
        -: 4408:                             append / indicator to directories\n\
        -: 4409:"), stdout);
    #####: 4410:      fputs (_("\
        -: 4411:  -q, --hide-control-chars   print ? instead of non graphic characters\n\
        -: 4412:      --show-control-chars   show non graphic characters as-is (default\n\
        -: 4413:                             unless program is `ls' and output is a terminal)\n\
        -: 4414:  -Q, --quote-name           enclose entry names in double quotes\n\
        -: 4415:      --quoting-style=WORD   use quoting style WORD for entry names:\n\
        -: 4416:                               literal, locale, shell, shell-always, c, escape\n\
        -: 4417:"), stdout);
    #####: 4418:      fputs (_("\
        -: 4419:  -r, --reverse              reverse order while sorting\n\
        -: 4420:  -R, --recursive            list subdirectories recursively\n\
        -: 4421:  -s, --size                 print the size of each file, in blocks\n\
        -: 4422:"), stdout);
    #####: 4423:      fputs (_("\
        -: 4424:  -S                         sort by file size\n\
        -: 4425:      --sort=WORD            sort by WORD instead of name: none -U,\n\
        -: 4426:                             extension -X, size -S, time -t, version -v\n\
        -: 4427:      --time=WORD            with -l, show time as WORD instead of modification\n\
        -: 4428:                             time: atime -u, access -u, use -u, ctime -c,\n\
        -: 4429:                             or status -c; use specified time as sort key\n\
        -: 4430:                             if --sort=time\n\
        -: 4431:"), stdout);
    #####: 4432:      fputs (_("\
        -: 4433:      --time-style=STYLE     with -l, show times using style STYLE:\n\
        -: 4434:                             full-iso, long-iso, iso, locale, +FORMAT.\n\
        -: 4435:                             FORMAT is interpreted like `date'; if FORMAT is\n\
        -: 4436:                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n\
        -: 4437:                             non-recent files and FORMAT2 to recent files;\n\
        -: 4438:                             if STYLE is prefixed with `posix-', STYLE\n\
        -: 4439:                             takes effect only outside the POSIX locale\n\
        -: 4440:"), stdout);
    #####: 4441:      fputs (_("\
        -: 4442:  -t                         sort by modification time\n\
        -: 4443:  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n\
        -: 4444:"), stdout);
    #####: 4445:      fputs (_("\
        -: 4446:  -u                         with -lt: sort by, and show, access time\n\
        -: 4447:                               with -l: show access time and sort by name\n\
        -: 4448:                               otherwise: sort by access time\n\
        -: 4449:  -U                         do not sort; list entries in directory order\n\
        -: 4450:  -v                         sort by version\n\
        -: 4451:"), stdout);
    #####: 4452:      fputs (_("\
        -: 4453:  -w, --width=COLS           assume screen width instead of current value\n\
        -: 4454:  -x                         list entries by lines instead of by columns\n\
        -: 4455:  -X                         sort alphabetically by entry extension\n\
        -: 4456:  -Z, --context              print any SELinux security context of each file\n\
        -: 4457:  -1                         list one file per line\n\
        -: 4458:"), stdout);
    #####: 4459:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####: 4460:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####: 4461:      fputs (_("\n\
        -: 4462:SIZE may be (or may be an integer optionally followed by) one of following:\n\
        -: 4463:kB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n\
        -: 4464:"), stdout);
    #####: 4465:      fputs (_("\
        -: 4466:\n\
        -: 4467:By default, color is not used to distinguish types of files.  That is\n\
        -: 4468:equivalent to using --color=none.  Using the --color option without the\n\
        -: 4469:optional WHEN argument is equivalent to using --color=always.  With\n\
        -: 4470:--color=auto, color codes are output only if standard output is connected\n\
        -: 4471:to a terminal (tty).  The environment variable LS_COLORS can influence the\n\
        -: 4472:colors, and can be set easily by the dircolors command.\n\
        -: 4473:"), stdout);
    #####: 4474:      fputs (_("\
        -: 4475:\n\
        -: 4476:Exit status is 0 if OK, 1 if minor problems, 2 if serious trouble.\n\
        -: 4477:"), stdout);
    #####: 4478:      emit_bug_reporting_address ();
        -: 4479:    }
    #####: 4480:  exit (status);
        -: 4481:}
