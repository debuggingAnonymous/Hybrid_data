        -:    0:Source:src/du.c
        -:    0:Graph:src/du.gcno
        -:    0:Data:src/du.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* du -- summarize disk usage
        -:    2:   Copyright (C) 1988-2013 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* Differences from the Unix du:
        -:   18:   * Doesn't simply ignore the names of regular files given as arguments
        -:   19:     when -a is given.
        -:   20:
        -:   21:   By tege@sics.se, Torbjorn Granlund,
        -:   22:   and djm@ai.mit.edu, David MacKenzie.
        -:   23:   Variable blocks added by lm@sgi.com and eggert@twinsun.com.
        -:   24:   Rewritten to use nftw, then to use fts by Jim Meyering.  */
        -:   25:
        -:   26:#include <config.h>
        -:   27:#include <getopt.h>
        -:   28:#include <sys/types.h>
        -:   29:#include <assert.h>
        -:   30:#include "system.h"
        -:   31:#include "argmatch.h"
        -:   32:#include "argv-iter.h"
        -:   33:#include "di-set.h"
        -:   34:#include "error.h"
        -:   35:#include "exclude.h"
        -:   36:#include "fprintftime.h"
        -:   37:#include "human.h"
        -:   38:#include "mountlist.h"
        -:   39:#include "quote.h"
        -:   40:#include "quotearg.h"
        -:   41:#include "stat-size.h"
        -:   42:#include "stat-time.h"
        -:   43:#include "stdio--.h"
        -:   44:#include "xfts.h"
        -:   45:#include "xstrtol.h"
        -:   46:
        -:   47:extern bool fts_debug;
        -:   48:
        -:   49:/* The official name of this program (e.g., no 'g' prefix).  */
        -:   50:#define PROGRAM_NAME "du"
        -:   51:
        -:   52:#define AUTHORS \
        -:   53:  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
        -:   54:  proper_name ("David MacKenzie"), \
        -:   55:  proper_name ("Paul Eggert"), \
        -:   56:  proper_name ("Jim Meyering")
        -:   57:
        -:   58:#if DU_DEBUG
        -:   59:# define FTS_CROSS_CHECK(Fts) fts_cross_check (Fts)
        -:   60:#else
        -:   61:# define FTS_CROSS_CHECK(Fts)
        -:   62:#endif
        -:   63:
        -:   64:/* A set of dev/ino pairs to help identify files and directories
        -:   65:   whose sizes have already been counted.  */
        -:   66:static struct di_set *di_files;
        -:   67:
        -:   68:/* A set containing a dev/ino pair for each local mount point directory.  */
        -:   69:static struct di_set *di_mnt;
        -:   70:
        -:   71:/* Keep track of the preceding "level" (depth in hierarchy)
        -:   72:   from one call of process_file to the next.  */
        -:   73:static size_t prev_level;
        -:   74:
        -:   75:/* Define a class for collecting directory information. */
        -:   76:struct duinfo
        -:   77:{
        -:   78:  /* Size of files in directory.  */
        -:   79:  uintmax_t size;
        -:   80:
        -:   81:  /* Number of inodes in directory.  */
        -:   82:  uintmax_t inodes;
        -:   83:
        -:   84:  /* Latest time stamp found.  If tmax.tv_sec == TYPE_MINIMUM (time_t)
        -:   85:     && tmax.tv_nsec < 0, no time stamp has been found.  */
        -:   86:  struct timespec tmax;
        -:   87:};
        -:   88:
        -:   89:/* Initialize directory data.  */
        -:   90:static inline void
    #####:   91:duinfo_init (struct duinfo *a)
        -:   92:{
    #####:   93:  a->size = 0;
    #####:   94:  a->inodes = 0;
    #####:   95:  a->tmax.tv_sec = TYPE_MINIMUM (time_t);
    #####:   96:  a->tmax.tv_nsec = -1;
    #####:   97:}
        -:   98:
        -:   99:/* Set directory data.  */
        -:  100:static inline void
    #####:  101:duinfo_set (struct duinfo *a, uintmax_t size, struct timespec tmax)
        -:  102:{
    #####:  103:  a->size = size;
    #####:  104:  a->inodes = 1;
    #####:  105:  a->tmax = tmax;
    #####:  106:}
        -:  107:
        -:  108:/* Accumulate directory data.  */
        -:  109:static inline void
    #####:  110:duinfo_add (struct duinfo *a, struct duinfo const *b)
        -:  111:{
    #####:  112:  uintmax_t sum = a->size + b->size;
    #####:  113:  a->size = a->size <= sum ? sum : UINTMAX_MAX;
    #####:  114:  a->inodes = a->inodes + b->inodes;
    #####:  115:  if (timespec_cmp (a->tmax, b->tmax) < 0)
    #####:  116:    a->tmax = b->tmax;
    #####:  117:}
        -:  118:
        -:  119:/* A structure for per-directory level information.  */
        -:  120:struct dulevel
        -:  121:{
        -:  122:  /* Entries in this directory.  */
        -:  123:  struct duinfo ent;
        -:  124:
        -:  125:  /* Total for subdirectories.  */
        -:  126:  struct duinfo subdir;
        -:  127:};
        -:  128:
        -:  129:/* If true, display counts for all files, not just directories.  */
        -:  130:static bool opt_all = false;
        -:  131:
        -:  132:/* If true, rather than using the disk usage of each file,
        -:  133:   use the apparent size (a la stat.st_size).  */
        -:  134:static bool apparent_size = false;
        -:  135:
        -:  136:/* If true, count each hard link of files with multiple links.  */
        -:  137:static bool opt_count_all = false;
        -:  138:
        -:  139:/* If true, hash all files to look for hard links.  */
        -:  140:static bool hash_all;
        -:  141:
        -:  142:/* If true, output the NUL byte instead of a newline at the end of each line. */
        -:  143:static bool opt_nul_terminate_output = false;
        -:  144:
        -:  145:/* If true, print a grand total at the end.  */
        -:  146:static bool print_grand_total = false;
        -:  147:
        -:  148:/* If nonzero, do not add sizes of subdirectories.  */
        -:  149:static bool opt_separate_dirs = false;
        -:  150:
        -:  151:/* Show the total for each directory (and file if --all) that is at
        -:  152:   most MAX_DEPTH levels down from the root of the hierarchy.  The root
        -:  153:   is at level 0, so 'du --max-depth=0' is equivalent to 'du -s'.  */
        -:  154:static size_t max_depth = SIZE_MAX;
        -:  155:
        -:  156:/* Only output entries with at least this SIZE if positive,
        -:  157:   or at most if negative.  See --threshold option.  */
        -:  158:static intmax_t opt_threshold = 0;
        -:  159:
        -:  160:/* Human-readable options for output.  */
        -:  161:static int human_output_opts;
        -:  162:
        -:  163:/* Output inodes count instead of blocks used.  */
        -:  164:static bool opt_inodes = false;
        -:  165:
        -:  166:/* If true, print most recently modified date, using the specified format.  */
        -:  167:static bool opt_time = false;
        -:  168:
        -:  169:/* Type of time to display. controlled by --time.  */
        -:  170:
        -:  171:enum time_type
        -:  172:  {
        -:  173:    time_mtime,			/* default */
        -:  174:    time_ctime,
        -:  175:    time_atime
        -:  176:  };
        -:  177:
        -:  178:static enum time_type time_type = time_mtime;
        -:  179:
        -:  180:/* User specified date / time style */
        -:  181:static char const *time_style = NULL;
        -:  182:
        -:  183:/* Format used to display date / time. Controlled by --time-style */
        -:  184:static char const *time_format = NULL;
        -:  185:
        -:  186:/* The units to use when printing sizes.  */
        -:  187:static uintmax_t output_block_size;
        -:  188:
        -:  189:/* File name patterns to exclude.  */
        -:  190:static struct exclude *exclude;
        -:  191:
        -:  192:/* Grand total size of all args, in bytes. Also latest modified date. */
        -:  193:static struct duinfo tot_dui;
        -:  194:
        -:  195:#define IS_DIR_TYPE(Type)	\
        -:  196:  ((Type) == FTS_DP		\
        -:  197:   || (Type) == FTS_DNR)
        -:  198:
        -:  199:/* For long options that have no equivalent short option, use a
        -:  200:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  201:enum
        -:  202:{
        -:  203:  APPARENT_SIZE_OPTION = CHAR_MAX + 1,
        -:  204:  EXCLUDE_OPTION,
        -:  205:  FILES0_FROM_OPTION,
        -:  206:  HUMAN_SI_OPTION,
        -:  207:  FTS_DEBUG,
        -:  208:  TIME_OPTION,
        -:  209:  TIME_STYLE_OPTION,
        -:  210:  INODES_OPTION
        -:  211:};
        -:  212:
        -:  213:static struct option const long_options[] =
        -:  214:{
        -:  215:  {"all", no_argument, NULL, 'a'},
        -:  216:  {"apparent-size", no_argument, NULL, APPARENT_SIZE_OPTION},
        -:  217:  {"block-size", required_argument, NULL, 'B'},
        -:  218:  {"bytes", no_argument, NULL, 'b'},
        -:  219:  {"count-links", no_argument, NULL, 'l'},
        -:  220:  /* {"-debug", no_argument, NULL, FTS_DEBUG}, */
        -:  221:  {"dereference", no_argument, NULL, 'L'},
        -:  222:  {"dereference-args", no_argument, NULL, 'D'},
        -:  223:  {"exclude", required_argument, NULL, EXCLUDE_OPTION},
        -:  224:  {"exclude-from", required_argument, NULL, 'X'},
        -:  225:  {"files0-from", required_argument, NULL, FILES0_FROM_OPTION},
        -:  226:  {"human-readable", no_argument, NULL, 'h'},
        -:  227:  {"inodes", no_argument, NULL, INODES_OPTION},
        -:  228:  {"si", no_argument, NULL, HUMAN_SI_OPTION},
        -:  229:  {"max-depth", required_argument, NULL, 'd'},
        -:  230:  {"null", no_argument, NULL, '0'},
        -:  231:  {"no-dereference", no_argument, NULL, 'P'},
        -:  232:  {"one-file-system", no_argument, NULL, 'x'},
        -:  233:  {"separate-dirs", no_argument, NULL, 'S'},
        -:  234:  {"summarize", no_argument, NULL, 's'},
        -:  235:  {"total", no_argument, NULL, 'c'},
        -:  236:  {"threshold", required_argument, NULL, 't'},
        -:  237:  {"time", optional_argument, NULL, TIME_OPTION},
        -:  238:  {"time-style", required_argument, NULL, TIME_STYLE_OPTION},
        -:  239:  {GETOPT_HELP_OPTION_DECL},
        -:  240:  {GETOPT_VERSION_OPTION_DECL},
        -:  241:  {NULL, 0, NULL, 0}
        -:  242:};
        -:  243:
        -:  244:static char const *const time_args[] =
        -:  245:{
        -:  246:  "atime", "access", "use", "ctime", "status", NULL
        -:  247:};
        -:  248:static enum time_type const time_types[] =
        -:  249:{
        -:  250:  time_atime, time_atime, time_atime, time_ctime, time_ctime
        -:  251:};
        -:  252:ARGMATCH_VERIFY (time_args, time_types);
        -:  253:
        -:  254:/* 'full-iso' uses full ISO-style dates and times.  'long-iso' uses longer
        -:  255:   ISO-style time stamps, though shorter than 'full-iso'.  'iso' uses shorter
        -:  256:   ISO-style time stamps.  */
        -:  257:enum time_style
        -:  258:  {
        -:  259:    full_iso_time_style,       /* --time-style=full-iso */
        -:  260:    long_iso_time_style,       /* --time-style=long-iso */
        -:  261:    iso_time_style	       /* --time-style=iso */
        -:  262:  };
        -:  263:
        -:  264:static char const *const time_style_args[] =
        -:  265:{
        -:  266:  "full-iso", "long-iso", "iso", NULL
        -:  267:};
        -:  268:static enum time_style const time_style_types[] =
        -:  269:{
        -:  270:  full_iso_time_style, long_iso_time_style, iso_time_style
        -:  271:};
        -:  272:ARGMATCH_VERIFY (time_style_args, time_style_types);
        -:  273:
        -:  274:void
    #####:  275:usage (int status)
        -:  276:{
    #####:  277:  if (status != EXIT_SUCCESS)
    #####:  278:    emit_try_help ();
        -:  279:  else
        -:  280:    {
    #####:  281:      printf (_("\
        -:  282:Usage: %s [OPTION]... [FILE]...\n\
        -:  283:  or:  %s [OPTION]... --files0-from=F\n\
        -:  284:"), program_name, program_name);
    #####:  285:      fputs (_("\
        -:  286:Summarize disk usage of each FILE, recursively for directories.\n\
        -:  287:"), stdout);
        -:  288:
    #####:  289:      emit_mandatory_arg_note ();
        -:  290:
    #####:  291:      fputs (_("\
        -:  292:  -0, --null            end each output line with 0 byte rather than newline\n\
        -:  293:  -a, --all             write counts for all files, not just directories\n\
        -:  294:      --apparent-size   print apparent sizes, rather than disk usage; although\
        -:  295:\n\
        -:  296:                          the apparent size is usually smaller, it may be\n\
        -:  297:                          larger due to holes in ('sparse') files, internal\n\
        -:  298:                          fragmentation, indirect blocks, and the like\n\
        -:  299:"), stdout);
    #####:  300:      fputs (_("\
        -:  301:  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n\
        -:  302:                           '-BM' prints sizes in units of 1,048,576 bytes;\n\
        -:  303:                           see SIZE format below\n\
        -:  304:  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n\
        -:  305:  -c, --total           produce a grand total\n\
        -:  306:  -D, --dereference-args  dereference only symlinks that are listed on the\n\
        -:  307:                          command line\n\
        -:  308:  -d, --max-depth=N     print the total for a directory (or file, with --all)\n\
        -:  309:                          only if it is N or fewer levels below the command\n\
        -:  310:                          line argument;  --max-depth=0 is the same as\n\
        -:  311:                          --summarize\n\
        -:  312:"), stdout);
    #####:  313:      fputs (_("\
        -:  314:      --files0-from=F   summarize disk usage of the\n\
        -:  315:                          NUL-terminated file names specified in file F;\n\
        -:  316:                          if F is -, then read names from standard input\n\
        -:  317:  -H                    equivalent to --dereference-args (-D)\n\
        -:  318:  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)\
        -:  319:\n\
        -:  320:      --inodes          list inode usage information instead of block usage\n\
        -:  321:"), stdout);
    #####:  322:      fputs (_("\
        -:  323:  -k                    like --block-size=1K\n\
        -:  324:  -L, --dereference     dereference all symbolic links\n\
        -:  325:  -l, --count-links     count sizes many times if hard linked\n\
        -:  326:  -m                    like --block-size=1M\n\
        -:  327:"), stdout);
    #####:  328:      fputs (_("\
        -:  329:  -P, --no-dereference  don't follow any symbolic links (this is the default)\n\
        -:  330:  -S, --separate-dirs   for directories do not include size of subdirectories\n\
        -:  331:      --si              like -h, but use powers of 1000 not 1024\n\
        -:  332:  -s, --summarize       display only a total for each argument\n\
        -:  333:"), stdout);
    #####:  334:      fputs (_("\
        -:  335:  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n\
        -:  336:                          or entries greater than SIZE if negative\n\
        -:  337:      --time            show time of the last modification of any file in the\n\
        -:  338:                          directory, or any of its subdirectories\n\
        -:  339:      --time=WORD       show time as WORD instead of modification time:\n\
        -:  340:                          atime, access, use, ctime or status\n\
        -:  341:      --time-style=STYLE  show times using STYLE, which can be:\n\
        -:  342:                            full-iso, long-iso, iso, or +FORMAT;\n\
        -:  343:                            FORMAT is interpreted like in 'date'\n\
        -:  344:"), stdout);
    #####:  345:      fputs (_("\
        -:  346:  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n\
        -:  347:      --exclude=PATTERN    exclude files that match PATTERN\n\
        -:  348:  -x, --one-file-system    skip directories on different file systems\n\
        -:  349:"), stdout);
    #####:  350:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####:  351:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####:  352:      emit_blocksize_note ("DU");
    #####:  353:      emit_size_note ();
    #####:  354:      emit_ancillary_info ();
        -:  355:    }
    #####:  356:  exit (status);
        -:  357:}
        -:  358:
        -:  359:/* Try to insert the INO/DEV pair into DI_SET.
        -:  360:   Return true if the pair is successfully inserted,
        -:  361:   false if the pair was already there.  */
        -:  362:static bool
    #####:  363:hash_ins (struct di_set *di_set, ino_t ino, dev_t dev)
        -:  364:{
    #####:  365:  int inserted = di_set_insert (di_set, dev, ino);
    #####:  366:  if (inserted < 0)
    #####:  367:    xalloc_die ();
    #####:  368:  return inserted;
        -:  369:}
        -:  370:
        -:  371:/* FIXME: this code is nearly identical to code in date.c  */
        -:  372:/* Display the date and time in WHEN according to the format specified
        -:  373:   in FORMAT.  */
        -:  374:
        -:  375:static void
    #####:  376:show_date (const char *format, struct timespec when)
        -:  377:{
    #####:  378:  struct tm *tm = localtime (&when.tv_sec);
    #####:  379:  if (! tm)
        -:  380:    {
        -:  381:      char buf[INT_BUFSIZE_BOUND (intmax_t)];
    #####:  382:      char *when_str = timetostr (when.tv_sec, buf);
    #####:  383:      error (0, 0, _("time %s is out of range"), when_str);
    #####:  384:      fputs (when_str, stdout);
    #####:  385:      return;
        -:  386:    }
        -:  387:
    #####:  388:  fprintftime (stdout, format, tm, 0, when.tv_nsec);
        -:  389:}
        -:  390:
        -:  391:/* Print N_BYTES.  Convert it to a readable value before printing.  */
        -:  392:
        -:  393:static void
    #####:  394:print_only_size (uintmax_t n_bytes)
        -:  395:{
        -:  396:  char buf[LONGEST_HUMAN_READABLE + 1];
    #####:  397:  fputs ((n_bytes == UINTMAX_MAX
        -:  398:          ? _("Infinity")
        -:  399:          : human_readable (n_bytes, buf, human_output_opts,
        -:  400:                            1, output_block_size)),
        -:  401:         stdout);
    #####:  402:}
        -:  403:
        -:  404:/* Print size (and optionally time) indicated by *PDUI, followed by STRING.  */
        -:  405:
        -:  406:static void
    #####:  407:print_size (const struct duinfo *pdui, const char *string)
        -:  408:{
    #####:  409:  print_only_size (opt_inodes
        -:  410:                   ? pdui->inodes
        -:  411:                   : pdui->size);
        -:  412:
    #####:  413:  if (opt_time)
        -:  414:    {
    #####:  415:      putchar ('\t');
    #####:  416:      show_date (time_format, pdui->tmax);
        -:  417:    }
    #####:  418:  printf ("\t%s%c", string, opt_nul_terminate_output ? '\0' : '\n');
    #####:  419:  fflush (stdout);
    #####:  420:}
        -:  421:
        -:  422:/* This function is called once for every file system object that fts
        -:  423:   encounters.  fts does a depth-first traversal.  This function knows
        -:  424:   that and accumulates per-directory totals based on changes in
        -:  425:   the depth of the current entry.  It returns true on success.  */
        -:  426:
        -:  427:static bool
    #####:  428:process_file (FTS *fts, FTSENT *ent)
        -:  429:{
    #####:  430:  bool ok = true;
        -:  431:  struct duinfo dui;
        -:  432:  struct duinfo dui_to_print;
        -:  433:  size_t level;
        -:  434:  static size_t n_alloc;
        -:  435:  /* First element of the structure contains:
        -:  436:     The sum of the st_size values of all entries in the single directory
        -:  437:     at the corresponding level.  Although this does include the st_size
        -:  438:     corresponding to each subdirectory, it does not include the size of
        -:  439:     any file in a subdirectory. Also corresponding last modified date.
        -:  440:     Second element of the structure contains:
        -:  441:     The sum of the sizes of all entries in the hierarchy at or below the
        -:  442:     directory at the specified level.  */
        -:  443:  static struct dulevel *dulvl;
        -:  444:
    #####:  445:  const char *file = ent->fts_path;
    #####:  446:  const struct stat *sb = ent->fts_statp;
    #####:  447:  int info = ent->fts_info;
        -:  448:
    #####:  449:  if (info == FTS_DNR)
        -:  450:    {
        -:  451:      /* An error occurred, but the size is known, so count it.  */
    #####:  452:      error (0, ent->fts_errno, _("cannot read directory %s"), quote (file));
    #####:  453:      ok = false;
        -:  454:    }
    #####:  455:  else if (info != FTS_DP)
        -:  456:    {
    #####:  457:      bool excluded = excluded_file_name (exclude, file);
    #####:  458:      if (! excluded)
        -:  459:        {
        -:  460:          /* Make the stat buffer *SB valid, or fail noisily.  */
        -:  461:
    #####:  462:          if (info == FTS_NSOK)
        -:  463:            {
    #####:  464:              fts_set (fts, ent, FTS_AGAIN);
    #####:  465:              FTSENT const *e = fts_read (fts);
    #####:  466:              assert (e == ent);
    #####:  467:              info = ent->fts_info;
        -:  468:            }
        -:  469:
    #####:  470:          if (info == FTS_NS || info == FTS_SLNONE)
        -:  471:            {
    #####:  472:              error (0, ent->fts_errno, _("cannot access %s"), quote (file));
    #####:  473:              return false;
        -:  474:            }
        -:  475:
        -:  476:          /* The --one-file-system (-x) option cannot exclude anything
        -:  477:             specified on the command-line.  By definition, it can exclude
        -:  478:             a file or directory only when its device number is different
        -:  479:             from that of its just-processed parent directory, and du does
        -:  480:             not process the parent of a command-line argument.  */
    #####:  481:          if (fts->fts_options & FTS_XDEV
    #####:  482:              && FTS_ROOTLEVEL < ent->fts_level
    #####:  483:              && fts->fts_dev != sb->st_dev)
    #####:  484:            excluded = true;
        -:  485:        }
        -:  486:
    #####:  487:      if (excluded
    #####:  488:          || (! opt_count_all
    #####:  489:              && (hash_all || (! S_ISDIR (sb->st_mode) && 1 < sb->st_nlink))
    #####:  490:              && ! hash_ins (di_files, sb->st_ino, sb->st_dev)))
        -:  491:        {
        -:  492:          /* If ignoring a directory in preorder, skip its children.
        -:  493:             Ignore the next fts_read output too, as it's a postorder
        -:  494:             visit to the same directory.  */
    #####:  495:          if (info == FTS_D)
        -:  496:            {
    #####:  497:              fts_set (fts, ent, FTS_SKIP);
    #####:  498:              FTSENT const *e = fts_read (fts);
    #####:  499:              assert (e == ent);
        -:  500:            }
        -:  501:
    #####:  502:          return true;
        -:  503:        }
        -:  504:
    #####:  505:      switch (info)
        -:  506:        {
        -:  507:        case FTS_D:
    #####:  508:          return true;
        -:  509:
        -:  510:        case FTS_ERR:
        -:  511:          /* An error occurred, but the size is known, so count it.  */
    #####:  512:          error (0, ent->fts_errno, "%s", quote (file));
    #####:  513:          ok = false;
    #####:  514:          break;
        -:  515:
        -:  516:        case FTS_DC:
    #####:  517:          if (cycle_warning_required (fts, ent))
        -:  518:            {
        -:  519:              /* If this is a mount point, then diagnose it and avoid
        -:  520:                 the cycle.  */
    #####:  521:              if (di_set_lookup (di_mnt, sb->st_dev, sb->st_ino))
    #####:  522:                error (0, 0, _("mount point %s already traversed"),
        -:  523:                       quote (file));
        -:  524:              else
    #####:  525:                emit_cycle_warning (file);
    #####:  526:              return false;
        -:  527:            }
    #####:  528:          return true;
        -:  529:        }
        -:  530:    }
        -:  531:
    #####:  532:  duinfo_set (&dui,
        -:  533:              (apparent_size
    #####:  534:               ? MAX (0, sb->st_size)
    #####:  535:               : (uintmax_t) ST_NBLOCKS (*sb) * ST_NBLOCKSIZE),
    #####:  536:              (time_type == time_mtime ? get_stat_mtime (sb)
    #####:  537:               : time_type == time_atime ? get_stat_atime (sb)
        -:  538:               : get_stat_ctime (sb)));
        -:  539:
    #####:  540:  level = ent->fts_level;
    #####:  541:  dui_to_print = dui;
        -:  542:
    #####:  543:  if (n_alloc == 0)
        -:  544:    {
    #####:  545:      n_alloc = level + 10;
    #####:  546:      dulvl = xcalloc (n_alloc, sizeof *dulvl);
        -:  547:    }
        -:  548:  else
        -:  549:    {
    #####:  550:      if (level == prev_level)
        -:  551:        {
        -:  552:          /* This is usually the most common case.  Do nothing.  */
        -:  553:        }
    #####:  554:      else if (level > prev_level)
        -:  555:        {
        -:  556:          /* Descending the hierarchy.
        -:  557:             Clear the accumulators for *all* levels between prev_level
        -:  558:             and the current one.  The depth may change dramatically,
        -:  559:             e.g., from 1 to 10.  */
        -:  560:          size_t i;
        -:  561:
    #####:  562:          if (n_alloc <= level)
        -:  563:            {
    #####:  564:              dulvl = xnrealloc (dulvl, level, 2 * sizeof *dulvl);
    #####:  565:              n_alloc = level * 2;
        -:  566:            }
        -:  567:
    #####:  568:          for (i = prev_level + 1; i <= level; i++)
        -:  569:            {
    #####:  570:              duinfo_init (&dulvl[i].ent);
    #####:  571:              duinfo_init (&dulvl[i].subdir);
        -:  572:            }
        -:  573:        }
        -:  574:      else /* level < prev_level */
        -:  575:        {
        -:  576:          /* Ascending the hierarchy.
        -:  577:             Process a directory only after all entries in that
        -:  578:             directory have been processed.  When the depth decreases,
        -:  579:             propagate sums from the children (prev_level) to the parent.
        -:  580:             Here, the current level is always one smaller than the
        -:  581:             previous one.  */
    #####:  582:          assert (level == prev_level - 1);
    #####:  583:          duinfo_add (&dui_to_print, &dulvl[prev_level].ent);
    #####:  584:          if (!opt_separate_dirs)
    #####:  585:            duinfo_add (&dui_to_print, &dulvl[prev_level].subdir);
    #####:  586:          duinfo_add (&dulvl[level].subdir, &dulvl[prev_level].ent);
    #####:  587:          duinfo_add (&dulvl[level].subdir, &dulvl[prev_level].subdir);
        -:  588:        }
        -:  589:    }
        -:  590:
    #####:  591:  prev_level = level;
        -:  592:
        -:  593:  /* Let the size of a directory entry contribute to the total for the
        -:  594:     containing directory, unless --separate-dirs (-S) is specified.  */
    #####:  595:  if (! (opt_separate_dirs && IS_DIR_TYPE (info)))
    #####:  596:    duinfo_add (&dulvl[level].ent, &dui);
        -:  597:
        -:  598:  /* Even if this directory is unreadable or we can't chdir into it,
        -:  599:     do let its size contribute to the total. */
    #####:  600:  duinfo_add (&tot_dui, &dui);
        -:  601:
    #####:  602:  if ((IS_DIR_TYPE (info) && level <= max_depth)
    #####:  603:      || (opt_all && level <= max_depth)
    #####:  604:      || level == 0)
        -:  605:    {
        -:  606:      /* Print or elide this entry according to the --threshold option.  */
    #####:  607:      uintmax_t v = opt_inodes ? dui_to_print.inodes : dui_to_print.size;
    #####:  608:      if (opt_threshold < 0
    #####:  609:          ? v <= -opt_threshold
        -:  610:          : v >= opt_threshold)
    #####:  611:        print_size (&dui_to_print, file);
        -:  612:    }
        -:  613:
    #####:  614:  return ok;
        -:  615:}
        -:  616:
        -:  617:/* Recursively print the sizes of the directories (and, if selected, files)
        -:  618:   named in FILES, the last entry of which is NULL.
        -:  619:   BIT_FLAGS controls how fts works.
        -:  620:   Return true if successful.  */
        -:  621:
        -:  622:static bool
    #####:  623:du_files (char **files, int bit_flags)
        -:  624:{
    #####:  625:  bool ok = true;
        -:  626:
    #####:  627:  if (*files)
        -:  628:    {
    #####:  629:      FTS *fts = xfts_open (files, bit_flags, NULL);
        -:  630:
        -:  631:      while (1)
        -:  632:        {
        -:  633:          FTSENT *ent;
        -:  634:
    #####:  635:          ent = fts_read (fts);
    #####:  636:          if (ent == NULL)
        -:  637:            {
    #####:  638:              if (errno != 0)
        -:  639:                {
    #####:  640:                  error (0, errno, _("fts_read failed: %s"),
    #####:  641:                         quotearg_colon (fts->fts_path));
    #####:  642:                  ok = false;
        -:  643:                }
        -:  644:
        -:  645:              /* When exiting this loop early, be careful to reset the
        -:  646:                 global, prev_level, used in process_file.  Otherwise, its
        -:  647:                 (level == prev_level - 1) assertion could fail.  */
    #####:  648:              prev_level = 0;
    #####:  649:              break;
        -:  650:            }
        -:  651:          FTS_CROSS_CHECK (fts);
        -:  652:
    #####:  653:          ok &= process_file (fts, ent);
    #####:  654:        }
        -:  655:
    #####:  656:      if (fts_close (fts) != 0)
        -:  657:        {
    #####:  658:          error (0, errno, _("fts_close failed"));
    #####:  659:          ok = false;
        -:  660:        }
        -:  661:    }
        -:  662:
    #####:  663:  return ok;
        -:  664:}
        -:  665:
        -:  666:/* Fill the di_mnt set with local mount point dev/ino pairs.  */
        -:  667:
        -:  668:static void
    #####:  669:fill_mount_table (void)
        -:  670:{
    #####:  671:  struct mount_entry *mnt_ent = read_file_system_list (false);
    #####:  672:  while (mnt_ent)
        -:  673:    {
        -:  674:      struct mount_entry *mnt_free;
    #####:  675:      if (!mnt_ent->me_remote && !mnt_ent->me_dummy)
        -:  676:        {
        -:  677:          struct stat buf;
    #####:  678:          if (!stat (mnt_ent->me_mountdir, &buf))
    #####:  679:            hash_ins (di_mnt, buf.st_ino, buf.st_dev);
        -:  680:          else
        -:  681:            {
        -:  682:              /* Ignore stat failure.  False positives are too common.
        -:  683:                 E.g., "Permission denied" on /run/user/<name>/gvfs.  */
        -:  684:            }
        -:  685:        }
        -:  686:
    #####:  687:      mnt_free = mnt_ent;
    #####:  688:      mnt_ent = mnt_ent->me_next;
    #####:  689:      free_mount_entry (mnt_free);
        -:  690:    }
    #####:  691:}
        -:  692:
        -:  693:int
        1:  694:main (int argc, char **argv)
        -:  695:{
        -:  696:  char *cwd_only[2];
        1:  697:  bool max_depth_specified = false;
        1:  698:  bool ok = true;
        1:  699:  char *files_from = NULL;
        -:  700:
        -:  701:  /* Bit flags that control how fts works.  */
        1:  702:  int bit_flags = FTS_NOSTAT;
        -:  703:
        -:  704:  /* Select one of the three FTS_ options that control if/when
        -:  705:     to follow a symlink.  */
        1:  706:  int symlink_deref_bits = FTS_PHYSICAL;
        -:  707:
        -:  708:  /* If true, display only a total for each argument. */
        1:  709:  bool opt_summarize_only = false;
        -:  710:
        1:  711:  cwd_only[0] = bad_cast (".");
        1:  712:  cwd_only[1] = NULL;
        -:  713:
        -:  714:  initialize_main (&argc, &argv);
        1:  715:  set_program_name (argv[0]);
        1:  716:  setlocale (LC_ALL, "");
        -:  717:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  718:  textdomain (PACKAGE);
        -:  719:
        1:  720:  atexit (close_stdout);
        -:  721:
        1:  722:  exclude = new_exclude ();
        -:  723:
        1:  724:  human_options (getenv ("DU_BLOCK_SIZE"),
        -:  725:                 &human_output_opts, &output_block_size);
        -:  726:
        -:  727:  while (true)
        -:  728:    {
        1:  729:      int oi = -1;
        1:  730:      int c = getopt_long (argc, argv, "0abd:chHklmst:xB:DLPSX:",
        -:  731:                           long_options, &oi);
        1:  732:      if (c == -1)
    #####:  733:        break;
        -:  734:
        1:  735:      switch (c)
        -:  736:        {
        -:  737:#if DU_DEBUG
        -:  738:        case FTS_DEBUG:
        -:  739:          fts_debug = true;
        -:  740:          break;
        -:  741:#endif
        -:  742:
        -:  743:        case '0':
    #####:  744:          opt_nul_terminate_output = true;
    #####:  745:          break;
        -:  746:
        -:  747:        case 'a':
    #####:  748:          opt_all = true;
    #####:  749:          break;
        -:  750:
        -:  751:        case APPARENT_SIZE_OPTION:
    #####:  752:          apparent_size = true;
    #####:  753:          break;
        -:  754:
        -:  755:        case 'b':
    #####:  756:          apparent_size = true;
    #####:  757:          human_output_opts = 0;
    #####:  758:          output_block_size = 1;
    #####:  759:          break;
        -:  760:
        -:  761:        case 'c':
    #####:  762:          print_grand_total = true;
    #####:  763:          break;
        -:  764:
        -:  765:        case 'h':
    #####:  766:          human_output_opts = human_autoscale | human_SI | human_base_1024;
    #####:  767:          output_block_size = 1;
    #####:  768:          break;
        -:  769:
        -:  770:        case HUMAN_SI_OPTION:
    #####:  771:          human_output_opts = human_autoscale | human_SI;
    #####:  772:          output_block_size = 1;
    #####:  773:          break;
        -:  774:
        -:  775:        case 'k':
    #####:  776:          human_output_opts = 0;
    #####:  777:          output_block_size = 1024;
    #####:  778:          break;
        -:  779:
        -:  780:        case 'd':		/* --max-depth=N */
        -:  781:          {
        -:  782:            unsigned long int tmp_ulong;
    #####:  783:            if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
        -:  784:                && tmp_ulong <= SIZE_MAX)
        -:  785:              {
    #####:  786:                max_depth_specified = true;
    #####:  787:                max_depth = tmp_ulong;
        -:  788:              }
        -:  789:            else
        -:  790:              {
    #####:  791:                error (0, 0, _("invalid maximum depth %s"),
        -:  792:                       quote (optarg));
    #####:  793:                ok = false;
        -:  794:              }
        -:  795:          }
    #####:  796:          break;
        -:  797:
        -:  798:        case 'm':
    #####:  799:          human_output_opts = 0;
    #####:  800:          output_block_size = 1024 * 1024;
    #####:  801:          break;
        -:  802:
        -:  803:        case 'l':
    #####:  804:          opt_count_all = true;
    #####:  805:          break;
        -:  806:
        -:  807:        case 's':
    #####:  808:          opt_summarize_only = true;
    #####:  809:          break;
        -:  810:
        -:  811:        case 't':
        -:  812:          {
        -:  813:            enum strtol_error e;
    #####:  814:            e = xstrtoimax (optarg, NULL, 0, &opt_threshold, "kKmMGTPEZY0");
    #####:  815:            if (e != LONGINT_OK)
    #####:  816:              xstrtol_fatal (e, oi, c, long_options, optarg);
    #####:  817:            if (opt_threshold == 0 && *optarg == '-')
        -:  818:              {
        -:  819:                /* Do not allow -0, as this wouldn't make sense anyway.  */
    #####:  820:                error (EXIT_FAILURE, 0, _("invalid --threshold argument '-0'"));
        -:  821:              }
        -:  822:          }
    #####:  823:          break;
        -:  824:
        -:  825:        case 'x':
    #####:  826:          bit_flags |= FTS_XDEV;
    #####:  827:          break;
        -:  828:
        -:  829:        case 'B':
        -:  830:          {
    #####:  831:            enum strtol_error e = human_options (optarg, &human_output_opts,
        -:  832:                                                 &output_block_size);
    #####:  833:            if (e != LONGINT_OK)
    #####:  834:              xstrtol_fatal (e, oi, c, long_options, optarg);
        -:  835:          }
    #####:  836:          break;
        -:  837:
        -:  838:        case 'H':  /* NOTE: before 2008-12, -H was equivalent to --si.  */
        -:  839:        case 'D':
    #####:  840:          symlink_deref_bits = FTS_COMFOLLOW | FTS_PHYSICAL;
    #####:  841:          break;
        -:  842:
        -:  843:        case 'L': /* --dereference */
    #####:  844:          symlink_deref_bits = FTS_LOGICAL;
    #####:  845:          break;
        -:  846:
        -:  847:        case 'P': /* --no-dereference */
    #####:  848:          symlink_deref_bits = FTS_PHYSICAL;
    #####:  849:          break;
        -:  850:
        -:  851:        case 'S':
    #####:  852:          opt_separate_dirs = true;
    #####:  853:          break;
        -:  854:
        -:  855:        case 'X':
    #####:  856:          if (add_exclude_file (add_exclude, exclude, optarg,
        -:  857:                                EXCLUDE_WILDCARDS, '\n'))
        -:  858:            {
    #####:  859:              error (0, errno, "%s", quotearg_colon (optarg));
    #####:  860:              ok = false;
        -:  861:            }
    #####:  862:          break;
        -:  863:
        -:  864:        case FILES0_FROM_OPTION:
    #####:  865:          files_from = optarg;
    #####:  866:          break;
        -:  867:
        -:  868:        case EXCLUDE_OPTION:
    #####:  869:          add_exclude (exclude, optarg, EXCLUDE_WILDCARDS);
    #####:  870:          break;
        -:  871:
        -:  872:        case INODES_OPTION:
    #####:  873:          opt_inodes = true;
    #####:  874:          break;
        -:  875:
        -:  876:        case TIME_OPTION:
    #####:  877:          opt_time = true;
    #####:  878:          time_type =
        -:  879:            (optarg
    #####:  880:             ? XARGMATCH ("--time", optarg, time_args, time_types)
        -:  881:             : time_mtime);
    #####:  882:          break;
        -:  883:
        -:  884:        case TIME_STYLE_OPTION:
    #####:  885:          time_style = optarg;
    #####:  886:          break;
        -:  887:
    #####:  888:        case_GETOPT_HELP_CHAR;
        -:  889:
        1:  890:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -:  891:
        -:  892:        default:
    #####:  893:          ok = false;
        -:  894:        }
    #####:  895:    }
        -:  896:
    #####:  897:  if (!ok)
    #####:  898:    usage (EXIT_FAILURE);
        -:  899:
    #####:  900:  if (opt_all && opt_summarize_only)
        -:  901:    {
    #####:  902:      error (0, 0, _("cannot both summarize and show all entries"));
    #####:  903:      usage (EXIT_FAILURE);
        -:  904:    }
        -:  905:
    #####:  906:  if (opt_summarize_only && max_depth_specified && max_depth == 0)
        -:  907:    {
    #####:  908:      error (0, 0,
        -:  909:             _("warning: summarizing is the same as using --max-depth=0"));
        -:  910:    }
        -:  911:
    #####:  912:  if (opt_summarize_only && max_depth_specified && max_depth != 0)
        -:  913:    {
    #####:  914:      unsigned long int d = max_depth;
    #####:  915:      error (0, 0, _("warning: summarizing conflicts with --max-depth=%lu"), d);
    #####:  916:      usage (EXIT_FAILURE);
        -:  917:    }
        -:  918:
    #####:  919:  if (opt_summarize_only)
    #####:  920:    max_depth = 0;
        -:  921:
    #####:  922:  if (opt_inodes)
        -:  923:    {
    #####:  924:      if (apparent_size)
        -:  925:        {
    #####:  926:          error (0, 0, _("warning: options --apparent-size and -b are "
        -:  927:                         "ineffective with --inodes"));
        -:  928:        }
    #####:  929:      output_block_size = 1;
        -:  930:    }
        -:  931:
        -:  932:  /* Process time style if printing last times.  */
    #####:  933:  if (opt_time)
        -:  934:    {
    #####:  935:      if (! time_style)
        -:  936:        {
    #####:  937:          time_style = getenv ("TIME_STYLE");
        -:  938:
        -:  939:          /* Ignore TIMESTYLE="locale", for compatibility with ls.  */
    #####:  940:          if (! time_style || STREQ (time_style, "locale"))
    #####:  941:            time_style = "long-iso";
    #####:  942:          else if (*time_style == '+')
        -:  943:            {
        -:  944:              /* Ignore anything after a newline, for compatibility
        -:  945:                 with ls.  */
    #####:  946:              char *p = strchr (time_style, '\n');
    #####:  947:              if (p)
    #####:  948:                *p = '\0';
        -:  949:            }
        -:  950:          else
        -:  951:            {
        -:  952:              /* Ignore "posix-" prefix, for compatibility with ls.  */
        -:  953:              static char const posix_prefix[] = "posix-";
    #####:  954:              while (strncmp (time_style, posix_prefix, sizeof posix_prefix - 1)
        -:  955:                     == 0)
    #####:  956:                time_style += sizeof posix_prefix - 1;
        -:  957:            }
        -:  958:        }
        -:  959:
    #####:  960:      if (*time_style == '+')
    #####:  961:        time_format = time_style + 1;
        -:  962:      else
        -:  963:        {
    #####:  964:          switch (XARGMATCH ("time style", time_style,
        -:  965:                             time_style_args, time_style_types))
        -:  966:            {
        -:  967:            case full_iso_time_style:
    #####:  968:              time_format = "%Y-%m-%d %H:%M:%S.%N %z";
    #####:  969:              break;
        -:  970:
        -:  971:            case long_iso_time_style:
    #####:  972:              time_format = "%Y-%m-%d %H:%M";
    #####:  973:              break;
        -:  974:
        -:  975:            case iso_time_style:
    #####:  976:              time_format = "%Y-%m-%d";
    #####:  977:              break;
        -:  978:            }
        -:  979:        }
        -:  980:    }
        -:  981:
        -:  982:  struct argv_iterator *ai;
    #####:  983:  if (files_from)
        -:  984:    {
        -:  985:      /* When using --files0-from=F, you may not specify any files
        -:  986:         on the command-line.  */
    #####:  987:      if (optind < argc)
        -:  988:        {
    #####:  989:          error (0, 0, _("extra operand %s"), quote (argv[optind]));
    #####:  990:          fprintf (stderr, "%s\n",
        -:  991:                   _("file operands cannot be combined with --files0-from"));
    #####:  992:          usage (EXIT_FAILURE);
        -:  993:        }
        -:  994:
    #####:  995:      if (! (STREQ (files_from, "-") || freopen (files_from, "r", stdin)))
    #####:  996:        error (EXIT_FAILURE, errno, _("cannot open %s for reading"),
        -:  997:               quote (files_from));
        -:  998:
    #####:  999:      ai = argv_iter_init_stream (stdin);
        -: 1000:
        -: 1001:      /* It's not easy here to count the arguments, so assume the
        -: 1002:         worst.  */
    #####: 1003:      hash_all = true;
        -: 1004:    }
        -: 1005:  else
        -: 1006:    {
    #####: 1007:      char **files = (optind < argc ? argv + optind : cwd_only);
    #####: 1008:      ai = argv_iter_init_argv (files);
        -: 1009:
        -: 1010:      /* Hash all dev,ino pairs if there are multiple arguments, or if
        -: 1011:         following non-command-line symlinks, because in either case a
        -: 1012:         file with just one hard link might be seen more than once.  */
    #####: 1013:      hash_all = (optind + 1 < argc || symlink_deref_bits == FTS_LOGICAL);
        -: 1014:    }
        -: 1015:
    #####: 1016:  if (!ai)
    #####: 1017:    xalloc_die ();
        -: 1018:
        -: 1019:  /* Initialize the set of dev,inode pairs.  */
        -: 1020:
    #####: 1021:  di_mnt = di_set_alloc ();
    #####: 1022:  if (!di_mnt)
    #####: 1023:    xalloc_die ();
        -: 1024:
    #####: 1025:  fill_mount_table ();
        -: 1026:
    #####: 1027:  di_files = di_set_alloc ();
    #####: 1028:  if (!di_files)
    #####: 1029:    xalloc_die ();
        -: 1030:
        -: 1031:  /* If not hashing everything, process_file won't find cycles on its
        -: 1032:     own, so ask fts_read to check for them accurately.  */
    #####: 1033:  if (opt_count_all || ! hash_all)
    #####: 1034:    bit_flags |= FTS_TIGHT_CYCLE_CHECK;
        -: 1035:
    #####: 1036:  bit_flags |= symlink_deref_bits;
        -: 1037:  static char *temp_argv[] = { NULL, NULL };
        -: 1038:
        -: 1039:  while (true)
        -: 1040:    {
    #####: 1041:      bool skip_file = false;
        -: 1042:      enum argv_iter_err ai_err;
    #####: 1043:      char *file_name = argv_iter (ai, &ai_err);
    #####: 1044:      if (!file_name)
        -: 1045:        {
    #####: 1046:          switch (ai_err)
        -: 1047:            {
        -: 1048:            case AI_ERR_EOF:
    #####: 1049:              goto argv_iter_done;
        -: 1050:            case AI_ERR_READ:
    #####: 1051:              error (0, errno, _("%s: read error"),
        -: 1052:                     quotearg_colon (files_from));
    #####: 1053:              ok = false;
    #####: 1054:              goto argv_iter_done;
        -: 1055:            case AI_ERR_MEM:
    #####: 1056:              xalloc_die ();
        -: 1057:            default:
    #####: 1058:              assert (!"unexpected error code from argv_iter");
        -: 1059:            }
        -: 1060:        }
    #####: 1061:      if (files_from && STREQ (files_from, "-") && STREQ (file_name, "-"))
        -: 1062:        {
        -: 1063:          /* Give a better diagnostic in an unusual case:
        -: 1064:             printf - | du --files0-from=- */
    #####: 1065:          error (0, 0, _("when reading file names from stdin, "
        -: 1066:                         "no file name of %s allowed"),
        -: 1067:                 quote (file_name));
    #####: 1068:          skip_file = true;
        -: 1069:        }
        -: 1070:
        -: 1071:      /* Report and skip any empty file names before invoking fts.
        -: 1072:         This works around a glitch in fts, which fails immediately
        -: 1073:         (without looking at the other file names) when given an empty
        -: 1074:         file name.  */
    #####: 1075:      if (!file_name[0])
        -: 1076:        {
        -: 1077:          /* Diagnose a zero-length file name.  When it's one
        -: 1078:             among many, knowing the record number may help.
        -: 1079:             FIXME: currently print the record number only with
        -: 1080:             --files0-from=FILE.  Maybe do it for argv, too?  */
    #####: 1081:          if (files_from == NULL)
    #####: 1082:            error (0, 0, "%s", _("invalid zero-length file name"));
        -: 1083:          else
        -: 1084:            {
        -: 1085:              /* Using the standard 'filename:line-number:' prefix here is
        -: 1086:                 not totally appropriate, since NUL is the separator, not NL,
        -: 1087:                 but it might be better than nothing.  */
    #####: 1088:              unsigned long int file_number = argv_iter_n_args (ai);
    #####: 1089:              error (0, 0, "%s:%lu: %s", quotearg_colon (files_from),
        -: 1090:                     file_number, _("invalid zero-length file name"));
        -: 1091:            }
    #####: 1092:          skip_file = true;
        -: 1093:        }
        -: 1094:
    #####: 1095:      if (skip_file)
    #####: 1096:        ok = false;
        -: 1097:      else
        -: 1098:        {
    #####: 1099:          temp_argv[0] = file_name;
    #####: 1100:          ok &= du_files (temp_argv, bit_flags);
        -: 1101:        }
    #####: 1102:    }
        -: 1103: argv_iter_done:
        -: 1104:
    #####: 1105:  argv_iter_free (ai);
    #####: 1106:  di_set_free (di_files);
    #####: 1107:  di_set_free (di_mnt);
        -: 1108:
    #####: 1109:  if (files_from && (ferror (stdin) || fclose (stdin) != 0) && ok)
    #####: 1110:    error (EXIT_FAILURE, 0, _("error reading %s"), quote (files_from));
        -: 1111:
    #####: 1112:  if (print_grand_total)
    #####: 1113:    print_size (&tot_dui, _("total"));
        -: 1114:
    #####: 1115:  exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);
        -: 1116:}
