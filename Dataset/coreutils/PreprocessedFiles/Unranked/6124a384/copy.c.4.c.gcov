        -:    0:Source:copy.c
        -:    0:Graph:copy.gcno
        -:    0:Data:copy.gcda
        -:    0:Runs:5
        -:    0:Programs:1
        -:    1:/* copy.c -- core functions for copying files and directories
        -:    2:   Copyright (C) 1989-2012 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* Extracted from cp.c and librarified by Jim Meyering.  */
        -:   18:
        -:   19:#include <config.h>
        -:   20:#include <stdio.h>
        -:   21:#include <assert.h>
        -:   22:#include <sys/ioctl.h>
        -:   23:#include <sys/types.h>
        -:   24:#include <selinux/selinux.h>
        -:   25:
        -:   26:#if HAVE_HURD_H
        -:   27:# include <hurd.h>
        -:   28:#endif
        -:   29:#if HAVE_PRIV_H
        -:   30:# include <priv.h>
        -:   31:#endif
        -:   32:
        -:   33:#include "system.h"
        -:   34:#include "acl.h"
        -:   35:#include "backupfile.h"
        -:   36:#include "buffer-lcm.h"
        -:   37:#include "canonicalize.h"
        -:   38:#include "copy.h"
        -:   39:#include "cp-hash.h"
        -:   40:#include "extent-scan.h"
        -:   41:#include "error.h"
        -:   42:#include "fadvise.h"
        -:   43:#include "fcntl--.h"
        -:   44:#include "fiemap.h"
        -:   45:#include "file-set.h"
        -:   46:#include "filemode.h"
        -:   47:#include "filenamecat.h"
        -:   48:#include "full-write.h"
        -:   49:#include "hash.h"
        -:   50:#include "hash-triple.h"
        -:   51:#include "ignore-value.h"
        -:   52:#include "ioblksize.h"
        -:   53:#include "quote.h"
        -:   54:#include "same.h"
        -:   55:#include "savedir.h"
        -:   56:#include "stat-size.h"
        -:   57:#include "stat-time.h"
        -:   58:#include "utimecmp.h"
        -:   59:#include "utimens.h"
        -:   60:#include "write-any-file.h"
        -:   61:#include "areadlink.h"
        -:   62:#include "yesno.h"
        -:   63:
        -:   64:#if USE_XATTR
        -:   65:# include <attr/error_context.h>
        -:   66:# include <attr/libattr.h>
        -:   67:# include <stdarg.h>
        -:   68:# include "verror.h"
        -:   69:#endif
        -:   70:
        -:   71:#ifndef HAVE_FCHOWN
        -:   72:# define HAVE_FCHOWN false
        -:   73:# define fchown(fd, uid, gid) (-1)
        -:   74:#endif
        -:   75:
        -:   76:#ifndef HAVE_LCHOWN
        -:   77:# define HAVE_LCHOWN false
        -:   78:# define lchown(name, uid, gid) chown (name, uid, gid)
        -:   79:#endif
        -:   80:
        -:   81:#ifndef HAVE_MKFIFO
        -:   82:static int
        -:   83:rpl_mkfifo (char const *file, mode_t mode)
        -:   84:{
        -:   85:  errno = ENOTSUP;
        -:   86:  return -1;
        -:   87:}
        -:   88:# define mkfifo rpl_mkfifo
        -:   89:#endif
        -:   90:
        -:   91:#ifndef USE_ACL
        -:   92:# define USE_ACL 0
        -:   93:#endif
        -:   94:
        -:   95:#define SAME_OWNER(A, B) ((A).st_uid == (B).st_uid)
        -:   96:#define SAME_GROUP(A, B) ((A).st_gid == (B).st_gid)
        -:   97:#define SAME_OWNER_AND_GROUP(A, B) (SAME_OWNER (A, B) && SAME_GROUP (A, B))
        -:   98:
        -:   99:struct dir_list
        -:  100:{
        -:  101:  struct dir_list *parent;
        -:  102:  ino_t ino;
        -:  103:  dev_t dev;
        -:  104:};
        -:  105:
        -:  106:/* Initial size of the cp.dest_info hash table.  */
        -:  107:#define DEST_INFO_INITIAL_CAPACITY 61
        -:  108:
        -:  109:static bool copy_internal (char const *src_name, char const *dst_name,
        -:  110:                           bool new_dst, dev_t device,
        -:  111:                           struct dir_list *ancestors,
        -:  112:                           const struct cp_options *x,
        -:  113:                           bool command_line_arg,
        -:  114:                           bool *first_dir_created_per_command_line_arg,
        -:  115:                           bool *copy_into_self,
        -:  116:                           bool *rename_succeeded);
        -:  117:static bool owner_failure_ok (struct cp_options const *x);
        -:  118:
        -:  119:/* Pointers to the file names:  they're used in the diagnostic that is issued
        -:  120:   when we detect the user is trying to copy a directory into itself.  */
        -:  121:static char const *top_level_src_name;
        -:  122:static char const *top_level_dst_name;
        -:  123:
        -:  124:/* Set the timestamp of symlink, FILE, to TIMESPEC.
        -:  125:   If this system lacks support for that, simply return 0.  */
        -:  126:static inline int
    #####:  127:utimens_symlink (char const *file, struct timespec const *timespec)
        -:  128:{
    #####:  129:  int err = lutimens (file, timespec);
        -:  130:  /* When configuring on a system with new headers and libraries, and
        -:  131:     running on one with a kernel that is old enough to lack the syscall,
        -:  132:     utimensat fails with ENOSYS.  Ignore that.  */
    #####:  133:  if (err && errno == ENOSYS)
    #####:  134:    err = 0;
    #####:  135:  return err;
        -:  136:}
        -:  137:
        -:  138:/* Copy the regular file open on SRC_FD/SRC_NAME to DST_FD/DST_NAME,
        -:  139:   honoring the MAKE_HOLES setting and using the BUF_SIZE-byte buffer
        -:  140:   BUF for temporary storage.  Copy no more than MAX_N_READ bytes.
        -:  141:   Return true upon successful completion;
        -:  142:   print a diagnostic and return false upon error.
        -:  143:   Note that for best results, BUF should be "well"-aligned.
        -:  144:   BUF must have sizeof(uintptr_t)-1 bytes of additional space
        -:  145:   beyond BUF[BUF_SIZE-1].
        -:  146:   Set *LAST_WRITE_MADE_HOLE to true if the final operation on
        -:  147:   DEST_FD introduced a hole.  Set *TOTAL_N_READ to the number of
        -:  148:   bytes read.  */
        -:  149:static bool
        4:  150:sparse_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
        -:  151:             bool make_holes,
        -:  152:             char const *src_name, char const *dst_name,
        -:  153:             uintmax_t max_n_read, off_t *total_n_read,
        -:  154:             bool *last_write_made_hole)
        -:  155:{
        4:  156:  *last_write_made_hole = false;
        4:  157:  *total_n_read = 0;
        -:  158:
       12:  159:  while (max_n_read)
        -:  160:    {
        8:  161:      bool make_hole = false;
        -:  162:
        8:  163:      ssize_t n_read = read (src_fd, buf, MIN (max_n_read, buf_size));
        8:  164:      if (n_read < 0)
        -:  165:        {
    #####:  166:          if (errno == EINTR)
    #####:  167:            continue;
    #####:  168:          error (0, errno, _("reading %s"), quote (src_name));
    #####:  169:          return false;
        -:  170:        }
        8:  171:      if (n_read == 0)
        4:  172:        break;
        4:  173:      max_n_read -= n_read;
        4:  174:      *total_n_read += n_read;
        -:  175:
        4:  176:      if (make_holes)
        -:  177:        {
        -:  178:          /* Sentinel required by is_nul().  */
    #####:  179:          buf[n_read] = '\1';
        -:  180:#ifdef lint
        -:  181:          typedef uintptr_t word;
        -:  182:          /* Usually, buf[n_read] is not the byte just before a "word"
        -:  183:             (aka uintptr_t) boundary.  In that case, the word-oriented
        -:  184:             test below (*wp++ == 0) would read some uninitialized bytes
        -:  185:             after the sentinel.  To avoid false-positive reports about
        -:  186:             this condition (e.g., from a tool like valgrind), set the
        -:  187:             remaining bytes -- to any value.  */
        -:  188:          memset (buf + n_read + 1, 0, sizeof (word) - 1);
        -:  189:#endif
        -:  190:
    #####:  191:          if ((make_hole = is_nul (buf, n_read)))
        -:  192:            {
    #####:  193:              if (lseek (dest_fd, n_read, SEEK_CUR) < 0)
        -:  194:                {
    #####:  195:                  error (0, errno, _("cannot lseek %s"), quote (dst_name));
    #####:  196:                  return false;
        -:  197:                }
        -:  198:            }
        -:  199:        }
        -:  200:
        4:  201:      if (!make_hole)
        -:  202:        {
        4:  203:          size_t n = n_read;
        4:  204:          if (full_write (dest_fd, buf, n) != n)
        -:  205:            {
    #####:  206:              error (0, errno, _("writing %s"), quote (dst_name));
    #####:  207:              return false;
        -:  208:            }
        -:  209:
        -:  210:          /* It is tempting to return early here upon a short read from a
        -:  211:             regular file.  That would save the final read syscall for each
        -:  212:             file.  Unfortunately that doesn't work for certain files in
        -:  213:             /proc with linux kernels from at least 2.6.9 .. 2.6.29.  */
        -:  214:        }
        -:  215:
        4:  216:      *last_write_made_hole = make_hole;
        -:  217:    }
        -:  218:
        4:  219:  return true;
        -:  220:}
        -:  221:
        -:  222:/* Perform the O(1) btrfs clone operation, if possible.
        -:  223:   Upon success, return 0.  Otherwise, return -1 and set errno.  */
        -:  224:static inline int
    #####:  225:clone_file (int dest_fd, int src_fd)
        -:  226:{
        -:  227:#ifdef __linux__
        -:  228:# undef BTRFS_IOCTL_MAGIC
        -:  229:# define BTRFS_IOCTL_MAGIC 0x94
        -:  230:# undef BTRFS_IOC_CLONE
        -:  231:# define BTRFS_IOC_CLONE _IOW (BTRFS_IOCTL_MAGIC, 9, int)
    #####:  232:  return ioctl (dest_fd, BTRFS_IOC_CLONE, src_fd);
        -:  233:#else
        -:  234:  (void) dest_fd;
        -:  235:  (void) src_fd;
        -:  236:  errno = ENOTSUP;
        -:  237:  return -1;
        -:  238:#endif
        -:  239:}
        -:  240:
        -:  241:/* Write N_BYTES zero bytes to file descriptor FD.  Return true if successful.
        -:  242:   Upon write failure, set errno and return false.  */
        -:  243:static bool
    #####:  244:write_zeros (int fd, uint64_t n_bytes)
        -:  245:{
        -:  246:  static char *zeros;
        -:  247:  static size_t nz = IO_BUFSIZE;
        -:  248:
        -:  249:  /* Attempt to use a relatively large calloc'd source buffer for
        -:  250:     efficiency, but if that allocation fails, resort to a smaller
        -:  251:     statically allocated one.  */
    #####:  252:  if (zeros == NULL)
        -:  253:    {
        -:  254:      static char fallback[1024];
    #####:  255:      zeros = calloc (nz, 1);
    #####:  256:      if (zeros == NULL)
        -:  257:        {
    #####:  258:          zeros = fallback;
    #####:  259:          nz = sizeof fallback;
        -:  260:        }
        -:  261:    }
        -:  262:
    #####:  263:  while (n_bytes)
        -:  264:    {
    #####:  265:      uint64_t n = MIN (nz, n_bytes);
    #####:  266:      if ((full_write (fd, zeros, n)) != n)
    #####:  267:        return false;
    #####:  268:      n_bytes -= n;
        -:  269:    }
        -:  270:
    #####:  271:  return true;
        -:  272:}
        -:  273:
        -:  274:/* Perform an efficient extent copy, if possible.  This avoids
        -:  275:   the overhead of detecting holes in hole-introducing/preserving
        -:  276:   copy, and thus makes copying sparse files much more efficient.
        -:  277:   Upon a successful copy, return true.  If the initial extent scan
        -:  278:   fails, set *NORMAL_COPY_REQUIRED to true and return false.
        -:  279:   Upon any other failure, set *NORMAL_COPY_REQUIRED to false and
        -:  280:   return false.  */
        -:  281:static bool
    #####:  282:extent_copy (int src_fd, int dest_fd, char *buf, size_t buf_size,
        -:  283:             off_t src_total_size, enum Sparse_type sparse_mode,
        -:  284:             char const *src_name, char const *dst_name,
        -:  285:             bool *require_normal_copy)
        -:  286:{
        -:  287:  struct extent_scan scan;
    #####:  288:  off_t last_ext_start = 0;
    #####:  289:  uint64_t last_ext_len = 0;
        -:  290:
        -:  291:  /* Keep track of the output position.
        -:  292:     We may need this at the end, for a final ftruncate.  */
    #####:  293:  off_t dest_pos = 0;
        -:  294:
    #####:  295:  extent_scan_init (src_fd, &scan);
        -:  296:
    #####:  297:  *require_normal_copy = false;
    #####:  298:  bool wrote_hole_at_eof = true;
        -:  299:  do
        -:  300:    {
    #####:  301:      bool ok = extent_scan_read (&scan);
    #####:  302:      if (! ok)
        -:  303:        {
    #####:  304:          if (scan.hit_final_extent)
    #####:  305:            break;
        -:  306:
    #####:  307:          if (scan.initial_scan_failed)
        -:  308:            {
    #####:  309:              *require_normal_copy = true;
    #####:  310:              return false;
        -:  311:            }
        -:  312:
    #####:  313:          error (0, errno, _("%s: failed to get extents info"),
        -:  314:                 quote (src_name));
    #####:  315:          return false;
        -:  316:        }
        -:  317:
        -:  318:      unsigned int i;
    #####:  319:      bool empty_extent = false;
    #####:  320:      for (i = 0; i < scan.ei_count || empty_extent; i++)
        -:  321:        {
        -:  322:          off_t ext_start;
        -:  323:          uint64_t ext_len;
        -:  324:          uint64_t hole_size;
        -:  325:
    #####:  326:          if (i < scan.ei_count)
        -:  327:            {
    #####:  328:              ext_start = scan.ext_info[i].ext_logical;
    #####:  329:              ext_len = scan.ext_info[i].ext_length;
        -:  330:            }
        -:  331:          else /* empty extent at EOF.  */
        -:  332:            {
    #####:  333:              i--;
    #####:  334:              ext_start = last_ext_start + scan.ext_info[i].ext_length;
    #####:  335:              ext_len = 0;
        -:  336:            }
        -:  337:
    #####:  338:          hole_size = ext_start - last_ext_start - last_ext_len;
        -:  339:
    #####:  340:          wrote_hole_at_eof = false;
        -:  341:
    #####:  342:          if (hole_size)
        -:  343:            {
    #####:  344:              if (lseek (src_fd, ext_start, SEEK_SET) < 0)
        -:  345:                {
    #####:  346:                  error (0, errno, _("cannot lseek %s"), quote (src_name));
        -:  347:                fail:
    #####:  348:                  extent_scan_free (&scan);
    #####:  349:                  return false;
        -:  350:                }
        -:  351:
    #####:  352:              if ((empty_extent && sparse_mode == SPARSE_ALWAYS)
    #####:  353:                  || (!empty_extent && sparse_mode != SPARSE_NEVER))
        -:  354:                {
    #####:  355:                  if (lseek (dest_fd, ext_start, SEEK_SET) < 0)
        -:  356:                    {
    #####:  357:                      error (0, errno, _("cannot lseek %s"), quote (dst_name));
    #####:  358:                      goto fail;
        -:  359:                    }
    #####:  360:                  wrote_hole_at_eof = true;
        -:  361:                }
        -:  362:              else
        -:  363:                {
        -:  364:                  /* When not inducing holes and when there is a hole between
        -:  365:                     the end of the previous extent and the beginning of the
        -:  366:                     current one, write zeros to the destination file.  */
    #####:  367:                  off_t nzeros = hole_size;
    #####:  368:                  if (empty_extent)
    #####:  369:                    nzeros = MIN (src_total_size - dest_pos, hole_size);
        -:  370:
    #####:  371:                  if (! write_zeros (dest_fd, nzeros))
        -:  372:                    {
    #####:  373:                      error (0, errno, _("%s: write failed"), quote (dst_name));
    #####:  374:                      goto fail;
        -:  375:                    }
        -:  376:
    #####:  377:                  dest_pos = MIN (src_total_size, ext_start);
        -:  378:                }
        -:  379:            }
        -:  380:
    #####:  381:          last_ext_start = ext_start;
        -:  382:
        -:  383:          /* Treat an unwritten but allocated extent much like a hole.
        -:  384:             I.E. don't read, but don't convert to a hole in the destination,
        -:  385:             unless SPARSE_ALWAYS.  */
        -:  386:          /* For now, do not treat FIEMAP_EXTENT_UNWRITTEN specially,
        -:  387:             because that (in combination with no sync) would lead to data
        -:  388:             loss at least on XFS and ext4 when using 2.6.39-rc3 kernels.  */
        -:  389:          if (0 && (scan.ext_info[i].ext_flags & FIEMAP_EXTENT_UNWRITTEN))
        -:  390:            {
        -:  391:              empty_extent = true;
        -:  392:              last_ext_len = 0;
        -:  393:              if (ext_len == 0) /* The last extent is empty and processed.  */
        -:  394:                empty_extent = false;
        -:  395:            }
        -:  396:          else
        -:  397:            {
        -:  398:              off_t n_read;
    #####:  399:              empty_extent = false;
    #####:  400:              last_ext_len = ext_len;
        -:  401:
    #####:  402:              if ( ! sparse_copy (src_fd, dest_fd, buf, buf_size,
        -:  403:                                  sparse_mode == SPARSE_ALWAYS,
        -:  404:                                  src_name, dst_name, ext_len, &n_read,
        -:  405:                                  &wrote_hole_at_eof))
    #####:  406:                goto fail;
        -:  407:
    #####:  408:              dest_pos = ext_start + n_read;
        -:  409:            }
        -:  410:
        -:  411:          /* If the file ends with unwritten extents not accounted for in the
        -:  412:             size, then skip processing them, and the associated redundant
        -:  413:             read() calls which will always return 0.  We will need to
        -:  414:             remove this when we add fallocate() so that we can maintain
        -:  415:             extents beyond the apparent size.  */
    #####:  416:          if (dest_pos == src_total_size)
        -:  417:            {
    #####:  418:              scan.hit_final_extent = true;
    #####:  419:              break;
        -:  420:            }
        -:  421:        }
        -:  422:
        -:  423:      /* Release the space allocated to scan->ext_info.  */
    #####:  424:      extent_scan_free (&scan);
        -:  425:
        -:  426:    }
    #####:  427:  while (! scan.hit_final_extent);
        -:  428:
        -:  429:  /* When the source file ends with a hole, we have to do a little more work,
        -:  430:     since the above copied only up to and including the final extent.
        -:  431:     In order to complete the copy, we may have to insert a hole or write
        -:  432:     zeros in the destination corresponding to the source file's hole-at-EOF.
        -:  433:
        -:  434:     In addition, if the final extent was a block of zeros at EOF and we've
        -:  435:     just converted them to a hole in the destination, we must call ftruncate
        -:  436:     here in order to record the proper length in the destination.  */
    #####:  437:  if ((dest_pos < src_total_size || wrote_hole_at_eof)
    #####:  438:      && (sparse_mode != SPARSE_NEVER
    #####:  439:          ? ftruncate (dest_fd, src_total_size)
    #####:  440:          : ! write_zeros (dest_fd, src_total_size - dest_pos)))
        -:  441:    {
    #####:  442:      error (0, errno, _("failed to extend %s"), quote (dst_name));
    #####:  443:      return false;
        -:  444:    }
        -:  445:
    #####:  446:  return true;
        -:  447:}
        -:  448:
        -:  449:/* FIXME: describe */
        -:  450:/* FIXME: rewrite this to use a hash table so we avoid the quadratic
        -:  451:   performance hit that's probably noticeable only on trees deeper
        -:  452:   than a few hundred levels.  See use of active_dir_map in remove.c  */
        -:  453:
        -:  454:static bool _GL_ATTRIBUTE_PURE
    #####:  455:is_ancestor (const struct stat *sb, const struct dir_list *ancestors)
        -:  456:{
    #####:  457:  while (ancestors != 0)
        -:  458:    {
    #####:  459:      if (ancestors->ino == sb->st_ino && ancestors->dev == sb->st_dev)
    #####:  460:        return true;
    #####:  461:      ancestors = ancestors->parent;
        -:  462:    }
    #####:  463:  return false;
        -:  464:}
        -:  465:
        -:  466:static bool
    #####:  467:errno_unsupported (int err)
        -:  468:{
    #####:  469:  return err == ENOTSUP || err == ENODATA;
        -:  470:}
        -:  471:
        -:  472:#if USE_XATTR
        -:  473:static void
        -:  474:copy_attr_error (struct error_context *ctx ATTRIBUTE_UNUSED,
        -:  475:                 char const *fmt, ...)
        -:  476:{
        -:  477:  if (!errno_unsupported (errno))
        -:  478:    {
        -:  479:      int err = errno;
        -:  480:      va_list ap;
        -:  481:
        -:  482:      /* use verror module to print error message */
        -:  483:      va_start (ap, fmt);
        -:  484:      verror (0, err, fmt, ap);
        -:  485:      va_end (ap);
        -:  486:    }
        -:  487:}
        -:  488:
        -:  489:static void
        -:  490:copy_attr_allerror (struct error_context *ctx ATTRIBUTE_UNUSED,
        -:  491:                 char const *fmt, ...)
        -:  492:{
        -:  493:  int err = errno;
        -:  494:  va_list ap;
        -:  495:
        -:  496:  /* use verror module to print error message */
        -:  497:  va_start (ap, fmt);
        -:  498:  verror (0, err, fmt, ap);
        -:  499:  va_end (ap);
        -:  500:}
        -:  501:
        -:  502:static char const *
        -:  503:copy_attr_quote (struct error_context *ctx ATTRIBUTE_UNUSED, char const *str)
        -:  504:{
        -:  505:  return quote (str);
        -:  506:}
        -:  507:
        -:  508:static void
        -:  509:copy_attr_free (struct error_context *ctx ATTRIBUTE_UNUSED,
        -:  510:                char const *str ATTRIBUTE_UNUSED)
        -:  511:{
        -:  512:}
        -:  513:
        -:  514:/* If positive SRC_FD and DST_FD descriptors are passed,
        -:  515:   then copy by fd, otherwise copy by name.  */
        -:  516:
        -:  517:static bool
        -:  518:copy_attr (char const *src_path, int src_fd,
        -:  519:           char const *dst_path, int dst_fd, struct cp_options const *x)
        -:  520:{
        -:  521:  int ret;
        -:  522:  bool all_errors = (!x->data_copy_required || x->require_preserve_xattr);
        -:  523:  bool some_errors = (!all_errors && !x->reduce_diagnostics);
        -:  524:  struct error_context ctx =
        -:  525:  {
        -:  526:    .error = all_errors ? copy_attr_allerror : copy_attr_error,
        -:  527:    .quote = copy_attr_quote,
        -:  528:    .quote_free = copy_attr_free
        -:  529:  };
        -:  530:  if (0 <= src_fd && 0 <= dst_fd)
        -:  531:    ret = attr_copy_fd (src_path, src_fd, dst_path, dst_fd, 0,
        -:  532:                        (all_errors || some_errors ? &ctx : NULL));
        -:  533:  else
        -:  534:    ret = attr_copy_file (src_path, dst_path, 0,
        -:  535:                          (all_errors || some_errors ? &ctx : NULL));
        -:  536:
        -:  537:  return ret == 0;
        -:  538:}
        -:  539:#else /* USE_XATTR */
        -:  540:
        -:  541:static bool
        4:  542:copy_attr (char const *src_path ATTRIBUTE_UNUSED,
        -:  543:           int src_fd ATTRIBUTE_UNUSED,
        -:  544:           char const *dst_path ATTRIBUTE_UNUSED,
        -:  545:           int dst_fd ATTRIBUTE_UNUSED,
        -:  546:           struct cp_options const *x ATTRIBUTE_UNUSED)
        -:  547:{
        4:  548:  return true;
        -:  549:}
        -:  550:#endif /* USE_XATTR */
        -:  551:
        -:  552:/* Read the contents of the directory SRC_NAME_IN, and recursively
        -:  553:   copy the contents to DST_NAME_IN.  NEW_DST is true if
        -:  554:   DST_NAME_IN is a directory that was created previously in the
        -:  555:   recursion.   SRC_SB and ANCESTORS describe SRC_NAME_IN.
        -:  556:   Set *COPY_INTO_SELF if SRC_NAME_IN is a parent of
        -:  557:   (or the same as) DST_NAME_IN; otherwise, clear it.
        -:  558:   Propagate *FIRST_DIR_CREATED_PER_COMMAND_LINE_ARG from
        -:  559:   caller to each invocation of copy_internal.  Be careful to
        -:  560:   pass the address of a temporary, and to update
        -:  561:   *FIRST_DIR_CREATED_PER_COMMAND_LINE_ARG only upon completion.
        -:  562:   Return true if successful.  */
        -:  563:
        -:  564:static bool
    #####:  565:copy_dir (char const *src_name_in, char const *dst_name_in, bool new_dst,
        -:  566:          const struct stat *src_sb, struct dir_list *ancestors,
        -:  567:          const struct cp_options *x,
        -:  568:          bool *first_dir_created_per_command_line_arg,
        -:  569:          bool *copy_into_self)
        -:  570:{
        -:  571:  char *name_space;
        -:  572:  char *namep;
    #####:  573:  struct cp_options non_command_line_options = *x;
    #####:  574:  bool ok = true;
        -:  575:
    #####:  576:  name_space = savedir (src_name_in);
    #####:  577:  if (name_space == NULL)
        -:  578:    {
        -:  579:      /* This diagnostic is a bit vague because savedir can fail in
        -:  580:         several different ways.  */
    #####:  581:      error (0, errno, _("cannot access %s"), quote (src_name_in));
    #####:  582:      return false;
        -:  583:    }
        -:  584:
        -:  585:  /* For cp's -H option, dereference command line arguments, but do not
        -:  586:     dereference symlinks that are found via recursive traversal.  */
    #####:  587:  if (x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)
    #####:  588:    non_command_line_options.dereference = DEREF_NEVER;
        -:  589:
    #####:  590:  bool new_first_dir_created = false;
    #####:  591:  namep = name_space;
    #####:  592:  while (*namep != '\0')
        -:  593:    {
        -:  594:      bool local_copy_into_self;
    #####:  595:      char *src_name = file_name_concat (src_name_in, namep, NULL);
    #####:  596:      char *dst_name = file_name_concat (dst_name_in, namep, NULL);
    #####:  597:      bool first_dir_created = *first_dir_created_per_command_line_arg;
        -:  598:
    #####:  599:      ok &= copy_internal (src_name, dst_name, new_dst, src_sb->st_dev,
        -:  600:                           ancestors, &non_command_line_options, false,
        -:  601:                           &first_dir_created,
        -:  602:                           &local_copy_into_self, NULL);
    #####:  603:      *copy_into_self |= local_copy_into_self;
        -:  604:
    #####:  605:      free (dst_name);
    #####:  606:      free (src_name);
        -:  607:
        -:  608:      /* If we're copying into self, there's no point in continuing,
        -:  609:         and in fact, that would even infloop, now that we record only
        -:  610:         the first created directory per command line argument.  */
    #####:  611:      if (local_copy_into_self)
    #####:  612:        break;
        -:  613:
    #####:  614:      new_first_dir_created |= first_dir_created;
    #####:  615:      namep += strlen (namep) + 1;
        -:  616:    }
    #####:  617:  free (name_space);
    #####:  618:  *first_dir_created_per_command_line_arg = new_first_dir_created;
        -:  619:
    #####:  620:  return ok;
        -:  621:}
        -:  622:
        -:  623:/* Set the owner and owning group of DEST_DESC to the st_uid and
        -:  624:   st_gid fields of SRC_SB.  If DEST_DESC is undefined (-1), set
        -:  625:   the owner and owning group of DST_NAME instead; for
        -:  626:   safety prefer lchown if the system supports it since no
        -:  627:   symbolic links should be involved.  DEST_DESC must
        -:  628:   refer to the same file as DEST_NAME if defined.
        -:  629:   Upon failure to set both UID and GID, try to set only the GID.
        -:  630:   NEW_DST is true if the file was newly created; otherwise,
        -:  631:   DST_SB is the status of the destination.
        -:  632:   Return 1 if the initial syscall succeeds, 0 if it fails but it's OK
        -:  633:   not to preserve ownership, -1 otherwise.  */
        -:  634:
        -:  635:static int
        4:  636:set_owner (const struct cp_options *x, char const *dst_name, int dest_desc,
        -:  637:           struct stat const *src_sb, bool new_dst,
        -:  638:           struct stat const *dst_sb)
        -:  639:{
        4:  640:  uid_t uid = src_sb->st_uid;
        4:  641:  gid_t gid = src_sb->st_gid;
        -:  642:
        -:  643:  /* Naively changing the ownership of an already-existing file before
        -:  644:     changing its permissions would create a window of vulnerability if
        -:  645:     the file's old permissions are too generous for the new owner and
        -:  646:     group.  Avoid the window by first changing to a restrictive
        -:  647:     temporary mode if necessary.  */
        -:  648:
        4:  649:  if (!new_dst && (x->preserve_mode || x->move_mode || x->set_mode))
        -:  650:    {
    #####:  651:      mode_t old_mode = dst_sb->st_mode;
    #####:  652:      mode_t new_mode =
    #####:  653:        (x->preserve_mode || x->move_mode ? src_sb->st_mode : x->mode);
    #####:  654:      mode_t restrictive_temp_mode = old_mode & new_mode & S_IRWXU;
        -:  655:
    #####:  656:      if ((USE_ACL
        -:  657:           || (old_mode & CHMOD_MODE_BITS
    #####:  658:               & (~new_mode | S_ISUID | S_ISGID | S_ISVTX)))
    #####:  659:          && qset_acl (dst_name, dest_desc, restrictive_temp_mode) != 0)
        -:  660:        {
    #####:  661:          if (! owner_failure_ok (x))
    #####:  662:            error (0, errno, _("clearing permissions for %s"),
        -:  663:                   quote (dst_name));
    #####:  664:          return -x->require_preserve;
        -:  665:        }
        -:  666:    }
        -:  667:
        4:  668:  if (HAVE_FCHOWN && dest_desc != -1)
        -:  669:    {
        4:  670:      if (fchown (dest_desc, uid, gid) == 0)
        4:  671:        return 1;
    #####:  672:      if (errno == EPERM || errno == EINVAL)
        -:  673:        {
        -:  674:          /* We've failed to set *both*.  Now, try to set just the group
        -:  675:             ID, but ignore any failure here, and don't change errno.  */
    #####:  676:          int saved_errno = errno;
    #####:  677:          ignore_value (fchown (dest_desc, -1, gid));
    #####:  678:          errno = saved_errno;
        -:  679:        }
        -:  680:    }
        -:  681:  else
        -:  682:    {
    #####:  683:      if (lchown (dst_name, uid, gid) == 0)
    #####:  684:        return 1;
    #####:  685:      if (errno == EPERM || errno == EINVAL)
        -:  686:        {
        -:  687:          /* We've failed to set *both*.  Now, try to set just the group
        -:  688:             ID, but ignore any failure here, and don't change errno.  */
    #####:  689:          int saved_errno = errno;
    #####:  690:          ignore_value (lchown (dst_name, -1, gid));
    #####:  691:          errno = saved_errno;
        -:  692:        }
        -:  693:    }
        -:  694:
    #####:  695:  if (! chown_failure_ok (x))
        -:  696:    {
    #####:  697:      error (0, errno, _("failed to preserve ownership for %s"),
        -:  698:             quote (dst_name));
    #####:  699:      if (x->require_preserve)
    #####:  700:        return -1;
        -:  701:    }
        -:  702:
    #####:  703:  return 0;
        -:  704:}
        -:  705:
        -:  706:/* Set the st_author field of DEST_DESC to the st_author field of
        -:  707:   SRC_SB. If DEST_DESC is undefined (-1), set the st_author field
        -:  708:   of DST_NAME instead.  DEST_DESC must refer to the same file as
        -:  709:   DEST_NAME if defined.  */
        -:  710:
        -:  711:static void
        4:  712:set_author (const char *dst_name, int dest_desc, const struct stat *src_sb)
        -:  713:{
        -:  714:#if HAVE_STRUCT_STAT_ST_AUTHOR
        -:  715:  /* FIXME: Modify the following code so that it does not
        -:  716:     follow symbolic links.  */
        -:  717:
        -:  718:  /* Preserve the st_author field.  */
        -:  719:  file_t file = (dest_desc < 0
        -:  720:                 ? file_name_lookup (dst_name, 0, 0)
        -:  721:                 : getdport (dest_desc));
        -:  722:  if (file == MACH_PORT_NULL)
        -:  723:    error (0, errno, _("failed to lookup file %s"), quote (dst_name));
        -:  724:  else
        -:  725:    {
        -:  726:      error_t err = file_chauthor (file, src_sb->st_author);
        -:  727:      if (err)
        -:  728:        error (0, err, _("failed to preserve authorship for %s"),
        -:  729:               quote (dst_name));
        -:  730:      mach_port_deallocate (mach_task_self (), file);
        -:  731:    }
        -:  732:#else
        -:  733:  (void) dst_name;
        -:  734:  (void) dest_desc;
        -:  735:  (void) src_sb;
        -:  736:#endif
        4:  737:}
        -:  738:
        -:  739:/* Change the file mode bits of the file identified by DESC or NAME to MODE.
        -:  740:   Use DESC if DESC is valid and fchmod is available, NAME otherwise.  */
        -:  741:
        -:  742:static int
    #####:  743:fchmod_or_lchmod (int desc, char const *name, mode_t mode)
        -:  744:{
        -:  745:#if HAVE_FCHMOD
    #####:  746:  if (0 <= desc)
    #####:  747:    return fchmod (desc, mode);
        -:  748:#endif
    #####:  749:  return lchmod (name, mode);
        -:  750:}
        -:  751:
        -:  752:#ifndef HAVE_STRUCT_STAT_ST_BLOCKS
        -:  753:# define HAVE_STRUCT_STAT_ST_BLOCKS 0
        -:  754:#endif
        -:  755:
        -:  756:/* Use a heuristic to determine whether stat buffer SB comes from a file
        -:  757:   with sparse blocks.  If the file has fewer blocks than would normally
        -:  758:   be needed for a file of its size, then at least one of the blocks in
        -:  759:   the file is a hole.  In that case, return true.  */
        -:  760:static bool
        4:  761:is_probably_sparse (struct stat const *sb)
        -:  762:{
        4:  763:  return (HAVE_STRUCT_STAT_ST_BLOCKS
        4:  764:          && S_ISREG (sb->st_mode)
        4:  765:          && ST_NBLOCKS (*sb) < sb->st_size / ST_NBLOCKSIZE);
        -:  766:}
        -:  767:
        -:  768:
        -:  769:/* Copy a regular file from SRC_NAME to DST_NAME.
        -:  770:   If the source file contains holes, copies holes and blocks of zeros
        -:  771:   in the source file as holes in the destination file.
        -:  772:   (Holes are read as zeroes by the 'read' system call.)
        -:  773:   When creating the destination, use DST_MODE & ~OMITTED_PERMISSIONS
        -:  774:   as the third argument in the call to open, adding
        -:  775:   OMITTED_PERMISSIONS after copying as needed.
        -:  776:   X provides many option settings.
        -:  777:   Return true if successful.
        -:  778:   *NEW_DST is as in copy_internal.
        -:  779:   SRC_SB is the result of calling XSTAT (aka stat) on SRC_NAME.  */
        -:  780:
        -:  781:static bool
        4:  782:copy_reg (char const *src_name, char const *dst_name,
        -:  783:          const struct cp_options *x,
        -:  784:          mode_t dst_mode, mode_t omitted_permissions, bool *new_dst,
        -:  785:          struct stat const *src_sb)
        -:  786:{
        -:  787:  char *buf;
        4:  788:  char *buf_alloc = NULL;
        4:  789:  char *name_alloc = NULL;
        -:  790:  int dest_desc;
        -:  791:  int dest_errno;
        -:  792:  int source_desc;
        4:  793:  mode_t src_mode = src_sb->st_mode;
        -:  794:  struct stat sb;
        -:  795:  struct stat src_open_sb;
        4:  796:  bool return_val = true;
        4:  797:  bool data_copy_required = x->data_copy_required;
        -:  798:
        4:  799:  source_desc = open (src_name,
        -:  800:                      (O_RDONLY | O_BINARY
        4:  801:                       | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
        4:  802:  if (source_desc < 0)
        -:  803:    {
    #####:  804:      error (0, errno, _("cannot open %s for reading"), quote (src_name));
    #####:  805:      return false;
        -:  806:    }
        -:  807:
        4:  808:  if (fstat (source_desc, &src_open_sb) != 0)
        -:  809:    {
    #####:  810:      error (0, errno, _("cannot fstat %s"), quote (src_name));
    #####:  811:      return_val = false;
    #####:  812:      goto close_src_desc;
        -:  813:    }
        -:  814:
        -:  815:  /* Compare the source dev/ino from the open file to the incoming,
        -:  816:     saved ones obtained via a previous call to stat.  */
        4:  817:  if (! SAME_INODE (*src_sb, src_open_sb))
        -:  818:    {
    #####:  819:      error (0, 0,
        -:  820:             _("skipping file %s, as it was replaced while being copied"),
        -:  821:             quote (src_name));
    #####:  822:      return_val = false;
    #####:  823:      goto close_src_desc;
        -:  824:    }
        -:  825:
        -:  826:  /* The semantics of the following open calls are mandated
        -:  827:     by the specs for both cp and mv.  */
        4:  828:  if (! *new_dst)
        -:  829:    {
    #####:  830:      int open_flags =
    #####:  831:        O_WRONLY | O_BINARY | (x->data_copy_required ? O_TRUNC : 0);
    #####:  832:      dest_desc = open (dst_name, open_flags);
    #####:  833:      dest_errno = errno;
        -:  834:
        -:  835:      /* When using cp --preserve=context to copy to an existing destination,
        -:  836:         use the default context rather than that of the source.  Why?
        -:  837:         1) the src context may prohibit writing, and
        -:  838:         2) because it's more consistent to use the same context
        -:  839:         that is used when the destination file doesn't already exist.  */
    #####:  840:      if (x->preserve_security_context && 0 <= dest_desc)
        -:  841:        {
    #####:  842:          bool all_errors = (!x->data_copy_required
    #####:  843:                             || x->require_preserve_context);
    #####:  844:          bool some_errors = !all_errors && !x->reduce_diagnostics;
    #####:  845:          security_context_t con = NULL;
        -:  846:
    #####:  847:          if (getfscreatecon (&con) < 0)
        -:  848:            {
    #####:  849:              if (all_errors || (some_errors && !errno_unsupported (errno)))
    #####:  850:                error (0, errno, _("failed to get file system create context"));
    #####:  851:              if (x->require_preserve_context)
        -:  852:                {
    #####:  853:                  return_val = false;
    #####:  854:                  goto close_src_and_dst_desc;
        -:  855:                }
        -:  856:            }
        -:  857:
    #####:  858:          if (con)
        -:  859:            {
    #####:  860:              if (fsetfilecon (dest_desc, con) < 0)
        -:  861:                {
    #####:  862:                  if (all_errors || (some_errors && !errno_unsupported (errno)))
    #####:  863:                    error (0, errno,
        -:  864:                           _("failed to set the security context of %s to %s"),
        -:  865:                           quote_n (0, dst_name), quote_n (1, con));
    #####:  866:                  if (x->require_preserve_context)
        -:  867:                    {
    #####:  868:                      return_val = false;
    #####:  869:                      freecon (con);
    #####:  870:                      goto close_src_and_dst_desc;
        -:  871:                    }
        -:  872:                }
    #####:  873:              freecon (con);
        -:  874:            }
        -:  875:        }
        -:  876:
    #####:  877:      if (dest_desc < 0 && x->unlink_dest_after_failed_open)
        -:  878:        {
    #####:  879:          if (unlink (dst_name) != 0)
        -:  880:            {
    #####:  881:              error (0, errno, _("cannot remove %s"), quote (dst_name));
    #####:  882:              return_val = false;
    #####:  883:              goto close_src_desc;
        -:  884:            }
    #####:  885:          if (x->verbose)
    #####:  886:            printf (_("removed %s\n"), quote (dst_name));
        -:  887:
        -:  888:          /* Tell caller that the destination file was unlinked.  */
    #####:  889:          *new_dst = true;
        -:  890:        }
        -:  891:    }
        -:  892:
        4:  893:  if (*new_dst)
        -:  894:    {
        -:  895:    open_with_O_CREAT:;
        -:  896:
        4:  897:      int open_flags = O_WRONLY | O_CREAT | O_BINARY;
        4:  898:      dest_desc = open (dst_name, open_flags | O_EXCL,
        4:  899:                        dst_mode & ~omitted_permissions);
        4:  900:      dest_errno = errno;
        -:  901:
        -:  902:      /* When trying to copy through a dangling destination symlink,
        -:  903:         the above open fails with EEXIST.  If that happens, and
        -:  904:         lstat'ing the DST_NAME shows that it is a symlink, then we
        -:  905:         have a problem: trying to resolve this dangling symlink to
        -:  906:         a directory/destination-entry pair is fundamentally racy,
        -:  907:         so punt.  If x->open_dangling_dest_symlink is set (cp sets
        -:  908:         that when POSIXLY_CORRECT is set in the environment), simply
        -:  909:         call open again, but without O_EXCL (potentially dangerous).
        -:  910:         If not, fail with a diagnostic.  These shenanigans are necessary
        -:  911:         only when copying, i.e., not in move_mode.  */
        4:  912:      if (dest_desc < 0 && dest_errno == EEXIST && ! x->move_mode)
        -:  913:        {
        -:  914:          struct stat dangling_link_sb;
    #####:  915:          if (lstat (dst_name, &dangling_link_sb) == 0
    #####:  916:              && S_ISLNK (dangling_link_sb.st_mode))
        -:  917:            {
    #####:  918:              if (x->open_dangling_dest_symlink)
        -:  919:                {
    #####:  920:                  dest_desc = open (dst_name, open_flags,
    #####:  921:                                    dst_mode & ~omitted_permissions);
    #####:  922:                  dest_errno = errno;
        -:  923:                }
        -:  924:              else
        -:  925:                {
    #####:  926:                  error (0, 0, _("not writing through dangling symlink %s"),
        -:  927:                         quote (dst_name));
    #####:  928:                  return_val = false;
    #####:  929:                  goto close_src_desc;
        -:  930:                }
        -:  931:            }
        -:  932:        }
        -:  933:
        -:  934:      /* Improve quality of diagnostic when a nonexistent dst_name
        -:  935:         ends in a slash and open fails with errno == EISDIR.  */
        4:  936:      if (dest_desc < 0 && dest_errno == EISDIR
    #####:  937:          && *dst_name && dst_name[strlen (dst_name) - 1] == '/')
    #####:  938:        dest_errno = ENOTDIR;
        -:  939:    }
        -:  940:  else
        -:  941:    {
    #####:  942:      omitted_permissions = 0;
        -:  943:    }
        -:  944:
        4:  945:  if (dest_desc < 0)
        -:  946:    {
        -:  947:      /* If we've just failed due to ENOENT for an ostensibly preexisting
        -:  948:         destination (*new_dst was 0), that's a bit of a contradiction/race:
        -:  949:         the prior stat/lstat said the file existed (*new_dst was 0), yet
        -:  950:         the subsequent open-existing-file failed with ENOENT.  With NFS,
        -:  951:         the race window is wider still, since its meta-data caching tends
        -:  952:         to make the stat succeed for a just-removed remote file, while the
        -:  953:         more-definitive initial open call will fail with ENOENT.  When this
        -:  954:         situation arises, we attempt to open again, but this time with
        -:  955:         O_CREAT.  Do this only when not in move-mode, since when handling
        -:  956:         a cross-device move, we must never open an existing destination.  */
    #####:  957:      if (dest_errno == ENOENT && ! *new_dst && ! x->move_mode)
        -:  958:        {
    #####:  959:          *new_dst = 1;
    #####:  960:          goto open_with_O_CREAT;
        -:  961:        }
        -:  962:
        -:  963:      /* Otherwise, it's an error.  */
    #####:  964:      error (0, dest_errno, _("cannot create regular file %s"),
        -:  965:             quote (dst_name));
    #####:  966:      return_val = false;
    #####:  967:      goto close_src_desc;
        -:  968:    }
        -:  969:
        4:  970:  if (fstat (dest_desc, &sb) != 0)
        -:  971:    {
    #####:  972:      error (0, errno, _("cannot fstat %s"), quote (dst_name));
    #####:  973:      return_val = false;
    #####:  974:      goto close_src_and_dst_desc;
        -:  975:    }
        -:  976:
        -:  977:  /* --attributes-only overrides --reflink.  */
        4:  978:  if (data_copy_required && x->reflink_mode)
        -:  979:    {
    #####:  980:      bool clone_ok = clone_file (dest_desc, source_desc) == 0;
    #####:  981:      if (clone_ok || x->reflink_mode == REFLINK_ALWAYS)
        -:  982:        {
    #####:  983:          if (!clone_ok)
        -:  984:            {
    #####:  985:              error (0, errno, _("failed to clone %s from %s"),
        -:  986:                     quote_n (0, dst_name), quote_n (1, src_name));
    #####:  987:              return_val = false;
    #####:  988:              goto close_src_and_dst_desc;
        -:  989:            }
    #####:  990:          data_copy_required = false;
        -:  991:        }
        -:  992:    }
        -:  993:
        4:  994:  if (data_copy_required)
        -:  995:    {
        -:  996:      typedef uintptr_t word;
        -:  997:
        -:  998:      /* Choose a suitable buffer size; it may be adjusted later.  */
        4:  999:      size_t buf_alignment = lcm (getpagesize (), sizeof (word));
        4: 1000:      size_t buf_alignment_slop = sizeof (word) + buf_alignment - 1;
        4: 1001:      size_t buf_size = io_blksize (sb);
        -: 1002:
        4: 1003:      fdadvise (source_desc, 0, 0, FADVISE_SEQUENTIAL);
        -: 1004:
        -: 1005:      /* Deal with sparse files.  */
        4: 1006:      bool make_holes = false;
        4: 1007:      bool sparse_src = false;
        -: 1008:
        4: 1009:      if (S_ISREG (sb.st_mode))
        -: 1010:        {
        -: 1011:          /* Even with --sparse=always, try to create holes only
        -: 1012:             if the destination is a regular file.  */
        4: 1013:          if (x->sparse_mode == SPARSE_ALWAYS)
    #####: 1014:            make_holes = true;
        -: 1015:
        -: 1016:          /* Use a heuristic to determine whether SRC_NAME contains any sparse
        -: 1017:             blocks.  If the file has fewer blocks than would normally be
        -: 1018:             needed for a file of its size, then at least one of the blocks in
        -: 1019:             the file is a hole.  */
        4: 1020:          sparse_src = is_probably_sparse (&src_open_sb);
        4: 1021:          if (x->sparse_mode == SPARSE_AUTO && sparse_src)
    #####: 1022:            make_holes = true;
        -: 1023:        }
        -: 1024:
        -: 1025:      /* If not making a sparse file, try to use a more-efficient
        -: 1026:         buffer size.  */
        4: 1027:      if (! make_holes)
        -: 1028:        {
        -: 1029:          /* Compute the least common multiple of the input and output
        -: 1030:             buffer sizes, adjusting for outlandish values.  */
        4: 1031:          size_t blcm_max = MIN (SIZE_MAX, SSIZE_MAX) - buf_alignment_slop;
        4: 1032:          size_t blcm = buffer_lcm (io_blksize (src_open_sb), buf_size,
        -: 1033:                                    blcm_max);
        -: 1034:
        -: 1035:          /* Do not bother with a buffer larger than the input file, plus one
        -: 1036:             byte to make sure the file has not grown while reading it.  */
        4: 1037:          if (S_ISREG (src_open_sb.st_mode) && src_open_sb.st_size < buf_size)
        4: 1038:            buf_size = src_open_sb.st_size + 1;
        -: 1039:
        -: 1040:          /* However, stick with a block size that is a positive multiple of
        -: 1041:             blcm, overriding the above adjustments.  Watch out for
        -: 1042:             overflow.  */
        4: 1043:          buf_size += blcm - 1;
        4: 1044:          buf_size -= buf_size % blcm;
        4: 1045:          if (buf_size == 0 || blcm_max < buf_size)
    #####: 1046:            buf_size = blcm;
        -: 1047:        }
        -: 1048:
        -: 1049:      /* Make a buffer with space for a sentinel at the end.  */
        4: 1050:      buf_alloc = xmalloc (buf_size + buf_alignment_slop);
        4: 1051:      buf = ptr_align (buf_alloc, buf_alignment);
        -: 1052:
        4: 1053:      if (sparse_src)
        -: 1054:        {
        -: 1055:          bool normal_copy_required;
        -: 1056:
        -: 1057:          /* Perform an efficient extent-based copy, falling back to the
        -: 1058:             standard copy only if the initial extent scan fails.  If the
        -: 1059:             '--sparse=never' option is specified, write all data but use
        -: 1060:             any extents to read more efficiently.  */
    #####: 1061:          if (extent_copy (source_desc, dest_desc, buf, buf_size,
        -: 1062:                           src_open_sb.st_size,
    #####: 1063:                           S_ISREG (sb.st_mode) ? x->sparse_mode : SPARSE_NEVER,
        -: 1064:                           src_name, dst_name, &normal_copy_required))
    #####: 1065:            goto preserve_metadata;
        -: 1066:
    #####: 1067:          if (! normal_copy_required)
        -: 1068:            {
    #####: 1069:              return_val = false;
    #####: 1070:              goto close_src_and_dst_desc;
        -: 1071:            }
        -: 1072:        }
        -: 1073:
        -: 1074:      off_t n_read;
        -: 1075:      bool wrote_hole_at_eof;
        4: 1076:      if ( ! sparse_copy (source_desc, dest_desc, buf, buf_size,
        -: 1077:                          make_holes, src_name, dst_name,
        -: 1078:                          UINTMAX_MAX, &n_read,
        -: 1079:                          &wrote_hole_at_eof)
        4: 1080:           || (wrote_hole_at_eof
    #####: 1081:               && ftruncate (dest_desc, n_read) < 0))
        -: 1082:        {
    #####: 1083:          error (0, errno, _("failed to extend %s"), quote (dst_name));
    #####: 1084:          return_val = false;
    #####: 1085:          goto close_src_and_dst_desc;
        -: 1086:        }
        -: 1087:    }
        -: 1088:
        -: 1089:preserve_metadata:
        4: 1090:  if (x->preserve_timestamps)
        -: 1091:    {
        -: 1092:      struct timespec timespec[2];
        4: 1093:      timespec[0] = get_stat_atime (src_sb);
        4: 1094:      timespec[1] = get_stat_mtime (src_sb);
        -: 1095:
        4: 1096:      if (fdutimens (dest_desc, dst_name, timespec) != 0)
        -: 1097:        {
    #####: 1098:          error (0, errno, _("preserving times for %s"), quote (dst_name));
    #####: 1099:          if (x->require_preserve)
        -: 1100:            {
    #####: 1101:              return_val = false;
    #####: 1102:              goto close_src_and_dst_desc;
        -: 1103:            }
        -: 1104:        }
        -: 1105:    }
        -: 1106:
        -: 1107:  /* Set ownership before xattrs as changing owners will
        -: 1108:     clear capabilities.  */
        4: 1109:  if (x->preserve_ownership && ! SAME_OWNER_AND_GROUP (*src_sb, sb))
        -: 1110:    {
        4: 1111:      switch (set_owner (x, dst_name, dest_desc, src_sb, *new_dst, &sb))
        -: 1112:        {
        -: 1113:        case -1:
    #####: 1114:          return_val = false;
    #####: 1115:          goto close_src_and_dst_desc;
        -: 1116:
        -: 1117:        case 0:
    #####: 1118:          src_mode &= ~ (S_ISUID | S_ISGID | S_ISVTX);
    #####: 1119:          break;
        -: 1120:        }
        -: 1121:    }
        -: 1122:
        -: 1123:  /* To allow copying xattrs on read-only files, temporarily chmod u+rw.
        -: 1124:     This workaround is required as an inode permission check is done
        -: 1125:     by xattr_permission() in fs/xattr.c of the GNU/Linux kernel tree.  */
        4: 1126:  if (x->preserve_xattr)
        -: 1127:    {
        4: 1128:      bool access_changed = false;
        -: 1129:
        4: 1130:      if (!(sb.st_mode & S_IWUSR) && geteuid () != 0)
    #####: 1131:        access_changed = fchmod_or_lchmod (dest_desc, dst_name, 0600) == 0;
        -: 1132:
        4: 1133:      if (!copy_attr (src_name, source_desc, dst_name, dest_desc, x)
    #####: 1134:          && x->require_preserve_xattr)
    #####: 1135:        return_val = false;
        -: 1136:
        4: 1137:      if (access_changed)
    #####: 1138:        fchmod_or_lchmod (dest_desc, dst_name, dst_mode & ~omitted_permissions);
        -: 1139:    }
        -: 1140:
        4: 1141:  set_author (dst_name, dest_desc, src_sb);
        -: 1142:
        4: 1143:  if (x->preserve_mode || x->move_mode)
        -: 1144:    {
        8: 1145:      if (copy_acl (src_name, source_desc, dst_name, dest_desc, src_mode) != 0
    #####: 1146:          && x->require_preserve)
    #####: 1147:        return_val = false;
        -: 1148:    }
    #####: 1149:  else if (x->set_mode)
        -: 1150:    {
    #####: 1151:      if (set_acl (dst_name, dest_desc, x->mode) != 0)
    #####: 1152:        return_val = false;
        -: 1153:    }
    #####: 1154:  else if (omitted_permissions)
        -: 1155:    {
    #####: 1156:      omitted_permissions &= ~ cached_umask ();
    #####: 1157:      if (omitted_permissions
    #####: 1158:          && fchmod_or_lchmod (dest_desc, dst_name, dst_mode) != 0)
        -: 1159:        {
    #####: 1160:          error (0, errno, _("preserving permissions for %s"),
        -: 1161:                 quote (dst_name));
    #####: 1162:          if (x->require_preserve)
    #####: 1163:            return_val = false;
        -: 1164:        }
        -: 1165:    }
        -: 1166:
        -: 1167:close_src_and_dst_desc:
        4: 1168:  if (close (dest_desc) < 0)
        -: 1169:    {
    #####: 1170:      error (0, errno, _("closing %s"), quote (dst_name));
    #####: 1171:      return_val = false;
        -: 1172:    }
        -: 1173:close_src_desc:
        4: 1174:  if (close (source_desc) < 0)
        -: 1175:    {
    #####: 1176:      error (0, errno, _("closing %s"), quote (src_name));
    #####: 1177:      return_val = false;
        -: 1178:    }
        -: 1179:
        4: 1180:  free (buf_alloc);
        4: 1181:  free (name_alloc);
        4: 1182:  return return_val;
        -: 1183:}
        -: 1184:
        -: 1185:/* Return true if it's ok that the source and destination
        -: 1186:   files are the 'same' by some measure.  The goal is to avoid
        -: 1187:   making the 'copy' operation remove both copies of the file
        -: 1188:   in that case, while still allowing the user to e.g., move or
        -: 1189:   copy a regular file onto a symlink that points to it.
        -: 1190:   Try to minimize the cost of this function in the common case.
        -: 1191:   Set *RETURN_NOW if we've determined that the caller has no more
        -: 1192:   work to do and should return successfully, right away.
        -: 1193:
        -: 1194:   Set *UNLINK_SRC if we've determined that the caller wants to do
        -: 1195:   'rename (a, b)' where 'a' and 'b' are distinct hard links to the same
        -: 1196:   file. In that case, the caller should try to unlink 'a' and then return
        -: 1197:   successfully.  Ideally, we wouldn't have to do that, and we'd be
        -: 1198:   able to rely on rename to remove the source file.  However, POSIX
        -: 1199:   mistakenly requires that such a rename call do *nothing* and return
        -: 1200:   successfully.  */
        -: 1201:
        -: 1202:static bool
    #####: 1203:same_file_ok (char const *src_name, struct stat const *src_sb,
        -: 1204:              char const *dst_name, struct stat const *dst_sb,
        -: 1205:              const struct cp_options *x, bool *return_now, bool *unlink_src)
        -: 1206:{
        -: 1207:  const struct stat *src_sb_link;
        -: 1208:  const struct stat *dst_sb_link;
        -: 1209:  struct stat tmp_dst_sb;
        -: 1210:  struct stat tmp_src_sb;
        -: 1211:
        -: 1212:  bool same_link;
    #####: 1213:  bool same = SAME_INODE (*src_sb, *dst_sb);
        -: 1214:
    #####: 1215:  *return_now = false;
    #####: 1216:  *unlink_src = false;
        -: 1217:
        -: 1218:  /* FIXME: this should (at the very least) be moved into the following
        -: 1219:     if-block.  More likely, it should be removed, because it inhibits
        -: 1220:     making backups.  But removing it will result in a change in behavior
        -: 1221:     that will probably have to be documented -- and tests will have to
        -: 1222:     be updated.  */
    #####: 1223:  if (same && x->hard_link)
        -: 1224:    {
    #####: 1225:      *return_now = true;
    #####: 1226:      return true;
        -: 1227:    }
        -: 1228:
    #####: 1229:  if (x->dereference == DEREF_NEVER)
        -: 1230:    {
    #####: 1231:      same_link = same;
        -: 1232:
        -: 1233:      /* If both the source and destination files are symlinks (and we'll
        -: 1234:         know this here IFF preserving symlinks), then it's usually ok
        -: 1235:         when they are distinct.  */
    #####: 1236:      if (S_ISLNK (src_sb->st_mode) && S_ISLNK (dst_sb->st_mode))
        -: 1237:        {
    #####: 1238:          bool sn = same_name (src_name, dst_name);
    #####: 1239:          if ( ! sn)
        -: 1240:            {
        -: 1241:              /* It's fine when we're making any type of backup.  */
    #####: 1242:              if (x->backup_type != no_backups)
    #####: 1243:                return true;
        -: 1244:
        -: 1245:              /* Here we have two symlinks that are hard-linked together,
        -: 1246:                 and we're not making backups.  In this unusual case, simply
        -: 1247:                 returning true would lead to mv calling "rename(A,B)",
        -: 1248:                 which would do nothing and return 0.  I.e., A would
        -: 1249:                 not be removed.  Hence, the solution is to tell the
        -: 1250:                 caller that all it must do is unlink A and return.  */
    #####: 1251:              if (same_link)
        -: 1252:                {
    #####: 1253:                  *unlink_src = true;
    #####: 1254:                  *return_now = true;
    #####: 1255:                  return true;
        -: 1256:                }
        -: 1257:            }
        -: 1258:
    #####: 1259:          return ! sn;
        -: 1260:        }
        -: 1261:
    #####: 1262:      src_sb_link = src_sb;
    #####: 1263:      dst_sb_link = dst_sb;
        -: 1264:    }
        -: 1265:  else
        -: 1266:    {
    #####: 1267:      if (!same)
    #####: 1268:        return true;
        -: 1269:
    #####: 1270:      if (lstat (dst_name, &tmp_dst_sb) != 0
    #####: 1271:          || lstat (src_name, &tmp_src_sb) != 0)
    #####: 1272:        return true;
        -: 1273:
    #####: 1274:      src_sb_link = &tmp_src_sb;
    #####: 1275:      dst_sb_link = &tmp_dst_sb;
        -: 1276:
    #####: 1277:      same_link = SAME_INODE (*src_sb_link, *dst_sb_link);
        -: 1278:
        -: 1279:      /* If both are symlinks, then it's ok, but only if the destination
        -: 1280:         will be unlinked before being opened.  This is like the test
        -: 1281:         above, but with the addition of the unlink_dest_before_opening
        -: 1282:         conjunct because otherwise, with two symlinks to the same target,
        -: 1283:         we'd end up truncating the source file.  */
    #####: 1284:      if (S_ISLNK (src_sb_link->st_mode) && S_ISLNK (dst_sb_link->st_mode)
    #####: 1285:          && x->unlink_dest_before_opening)
    #####: 1286:        return true;
        -: 1287:    }
        -: 1288:
        -: 1289:  /* The backup code ensures there's a copy, so it's usually ok to
        -: 1290:     remove any destination file.  One exception is when both
        -: 1291:     source and destination are the same directory entry.  In that
        -: 1292:     case, moving the destination file aside (in making the backup)
        -: 1293:     would also rename the source file and result in an error.  */
    #####: 1294:  if (x->backup_type != no_backups)
        -: 1295:    {
    #####: 1296:      if (!same_link)
        -: 1297:        {
        -: 1298:          /* In copy mode when dereferencing symlinks, if the source is a
        -: 1299:             symlink and the dest is not, then backing up the destination
        -: 1300:             (moving it aside) would make it a dangling symlink, and the
        -: 1301:             subsequent attempt to open it in copy_reg would fail with
        -: 1302:             a misleading diagnostic.  Avoid that by returning zero in
        -: 1303:             that case so the caller can make cp (or mv when it has to
        -: 1304:             resort to reading the source file) fail now.  */
        -: 1305:
        -: 1306:          /* FIXME-note: even with the following kludge, we can still provoke
        -: 1307:             the offending diagnostic.  It's just a little harder to do :-)
        -: 1308:             $ rm -f a b c; touch c; ln -s c b; ln -s b a; cp -b a b
        -: 1309:             cp: cannot open 'a' for reading: No such file or directory
        -: 1310:             That's misleading, since a subsequent 'ls' shows that 'a'
        -: 1311:             is still there.
        -: 1312:             One solution would be to open the source file *before* moving
        -: 1313:             aside the destination, but that'd involve a big rewrite. */
    #####: 1314:          if ( ! x->move_mode
    #####: 1315:               && x->dereference != DEREF_NEVER
    #####: 1316:               && S_ISLNK (src_sb_link->st_mode)
    #####: 1317:               && ! S_ISLNK (dst_sb_link->st_mode))
    #####: 1318:            return false;
        -: 1319:
    #####: 1320:          return true;
        -: 1321:        }
        -: 1322:
    #####: 1323:      return ! same_name (src_name, dst_name);
        -: 1324:    }
        -: 1325:
        -: 1326:#if 0
        -: 1327:  /* FIXME: use or remove */
        -: 1328:
        -: 1329:  /* If we're making a backup, we'll detect the problem case in
        -: 1330:     copy_reg because SRC_NAME will no longer exist.  Allowing
        -: 1331:     the test to be deferred lets cp do some useful things.
        -: 1332:     But when creating hardlinks and SRC_NAME is a symlink
        -: 1333:     but DST_NAME is not we must test anyway.  */
        -: 1334:  if (x->hard_link
        -: 1335:      || !S_ISLNK (src_sb_link->st_mode)
        -: 1336:      || S_ISLNK (dst_sb_link->st_mode))
        -: 1337:    return true;
        -: 1338:
        -: 1339:  if (x->dereference != DEREF_NEVER)
        -: 1340:    return true;
        -: 1341:#endif
        -: 1342:
        -: 1343:  /* They may refer to the same file if we're in move mode and the
        -: 1344:     target is a symlink.  That is ok, since we remove any existing
        -: 1345:     destination file before opening it -- via 'rename' if they're on
        -: 1346:     the same file system, via 'unlink (DST_NAME)' otherwise.
        -: 1347:     It's also ok if they're distinct hard links to the same file.  */
    #####: 1348:  if (x->move_mode || x->unlink_dest_before_opening)
        -: 1349:    {
    #####: 1350:      if (S_ISLNK (dst_sb_link->st_mode))
    #####: 1351:        return true;
        -: 1352:
    #####: 1353:      if (same_link
    #####: 1354:          && 1 < dst_sb_link->st_nlink
    #####: 1355:          && ! same_name (src_name, dst_name))
        -: 1356:        {
    #####: 1357:          if (x->move_mode)
        -: 1358:            {
    #####: 1359:              *unlink_src = true;
    #####: 1360:              *return_now = true;
        -: 1361:            }
    #####: 1362:          return true;
        -: 1363:        }
        -: 1364:    }
        -: 1365:
        -: 1366:  /* If neither is a symlink, then it's ok as long as they aren't
        -: 1367:     hard links to the same file.  */
    #####: 1368:  if (!S_ISLNK (src_sb_link->st_mode) && !S_ISLNK (dst_sb_link->st_mode))
        -: 1369:    {
    #####: 1370:      if (!SAME_INODE (*src_sb_link, *dst_sb_link))
    #####: 1371:        return true;
        -: 1372:
        -: 1373:      /* If they are the same file, it's ok if we're making hard links.  */
    #####: 1374:      if (x->hard_link)
        -: 1375:        {
    #####: 1376:          *return_now = true;
    #####: 1377:          return true;
        -: 1378:        }
        -: 1379:    }
        -: 1380:
        -: 1381:  /* At this point, it is normally an error (data loss) to move a symlink
        -: 1382:     onto its referent, but in at least one narrow case, it is not:
        -: 1383:     In move mode, when
        -: 1384:     1) src is a symlink,
        -: 1385:     2) dest has a link count of 2 or more and
        -: 1386:     3) dest and the referent of src are not the same directory entry,
        -: 1387:     then it's ok, since while we'll lose one of those hard links,
        -: 1388:     src will still point to a remaining link.
        -: 1389:     Note that technically, condition #3 obviates condition #2, but we
        -: 1390:     retain the 1 < st_nlink condition because that means fewer invocations
        -: 1391:     of the more expensive #3.
        -: 1392:
        -: 1393:     Given this,
        -: 1394:       $ touch f && ln f l && ln -s f s
        -: 1395:       $ ls -og f l s
        -: 1396:       -rw-------. 2  0 Jan  4 22:46 f
        -: 1397:       -rw-------. 2  0 Jan  4 22:46 l
        -: 1398:       lrwxrwxrwx. 1  1 Jan  4 22:46 s -> f
        -: 1399:     this must fail: mv s f
        -: 1400:     this must succeed: mv s l */
    #####: 1401:  if (x->move_mode
    #####: 1402:      && S_ISLNK (src_sb->st_mode)
    #####: 1403:      && 1 < dst_sb_link->st_nlink)
        -: 1404:    {
    #####: 1405:      char *abs_src = canonicalize_file_name (src_name);
    #####: 1406:      if (abs_src)
        -: 1407:        {
    #####: 1408:          bool result = ! same_name (abs_src, dst_name);
    #####: 1409:          free (abs_src);
    #####: 1410:          return result;
        -: 1411:        }
        -: 1412:    }
        -: 1413:
        -: 1414:  /* It's ok to remove a destination symlink.  But that works only when we
        -: 1415:     unlink before opening the destination and when the source and destination
        -: 1416:     files are on the same partition.  */
    #####: 1417:  if (x->unlink_dest_before_opening
    #####: 1418:      && S_ISLNK (dst_sb_link->st_mode))
    #####: 1419:    return dst_sb_link->st_dev == src_sb_link->st_dev;
        -: 1420:
    #####: 1421:  if (x->dereference == DEREF_NEVER)
        -: 1422:    {
    #####: 1423:      if ( ! S_ISLNK (src_sb_link->st_mode))
    #####: 1424:        tmp_src_sb = *src_sb_link;
    #####: 1425:      else if (stat (src_name, &tmp_src_sb) != 0)
    #####: 1426:        return true;
        -: 1427:
    #####: 1428:      if ( ! S_ISLNK (dst_sb_link->st_mode))
    #####: 1429:        tmp_dst_sb = *dst_sb_link;
    #####: 1430:      else if (stat (dst_name, &tmp_dst_sb) != 0)
    #####: 1431:        return true;
        -: 1432:
    #####: 1433:      if ( ! SAME_INODE (tmp_src_sb, tmp_dst_sb))
    #####: 1434:        return true;
        -: 1435:
        -: 1436:      /* FIXME: shouldn't this be testing whether we're making symlinks?  */
    #####: 1437:      if (x->hard_link)
        -: 1438:        {
    #####: 1439:          *return_now = true;
    #####: 1440:          return true;
        -: 1441:        }
        -: 1442:    }
        -: 1443:
    #####: 1444:  return false;
        -: 1445:}
        -: 1446:
        -: 1447:/* Return true if FILE, with mode MODE, is writable in the sense of 'mv'.
        -: 1448:   Always consider a symbolic link to be writable.  */
        -: 1449:static bool
    #####: 1450:writable_destination (char const *file, mode_t mode)
        -: 1451:{
    #####: 1452:  return (S_ISLNK (mode)
    #####: 1453:          || can_write_any_file ()
    #####: 1454:          || euidaccess (file, W_OK) == 0);
        -: 1455:}
        -: 1456:
        -: 1457:static void
    #####: 1458:overwrite_prompt (char const *dst_name, struct stat const *dst_sb)
        -: 1459:{
    #####: 1460:  if (! writable_destination (dst_name, dst_sb->st_mode))
        -: 1461:    {
        -: 1462:      char perms[12];		/* "-rwxrwxrwx " ls-style modes. */
    #####: 1463:      strmode (dst_sb->st_mode, perms);
    #####: 1464:      perms[10] = '\0';
    #####: 1465:      fprintf (stderr,
        -: 1466:               _("%s: try to overwrite %s, overriding mode %04lo (%s)? "),
        -: 1467:               program_name, quote (dst_name),
    #####: 1468:               (unsigned long int) (dst_sb->st_mode & CHMOD_MODE_BITS),
        -: 1469:               &perms[1]);
        -: 1470:    }
        -: 1471:  else
        -: 1472:    {
    #####: 1473:      fprintf (stderr, _("%s: overwrite %s? "),
        -: 1474:               program_name, quote (dst_name));
        -: 1475:    }
    #####: 1476:}
        -: 1477:
        -: 1478:/* Initialize the hash table implementing a set of F_triple entries
        -: 1479:   corresponding to destination files.  */
        -: 1480:extern void
    #####: 1481:dest_info_init (struct cp_options *x)
        -: 1482:{
        -: 1483:  x->dest_info
    #####: 1484:    = hash_initialize (DEST_INFO_INITIAL_CAPACITY,
        -: 1485:                       NULL,
        -: 1486:                       triple_hash,
        -: 1487:                       triple_compare,
        -: 1488:                       triple_free);
    #####: 1489:}
        -: 1490:
        -: 1491:/* Initialize the hash table implementing a set of F_triple entries
        -: 1492:   corresponding to source files listed on the command line.  */
        -: 1493:extern void
    #####: 1494:src_info_init (struct cp_options *x)
        -: 1495:{
        -: 1496:
        -: 1497:  /* Note that we use triple_hash_no_name here.
        -: 1498:     Contrast with the use of triple_hash above.
        -: 1499:     That is necessary because a source file may be specified
        -: 1500:     in many different ways.  We want to warn about this
        -: 1501:       cp a a d/
        -: 1502:     as well as this:
        -: 1503:       cp a ./a d/
        -: 1504:  */
        -: 1505:  x->src_info
    #####: 1506:    = hash_initialize (DEST_INFO_INITIAL_CAPACITY,
        -: 1507:                       NULL,
        -: 1508:                       triple_hash_no_name,
        -: 1509:                       triple_compare,
        -: 1510:                       triple_free);
    #####: 1511:}
        -: 1512:
        -: 1513:/* When effecting a move (e.g., for mv(1)), and given the name DST_NAME
        -: 1514:   of the destination and a corresponding stat buffer, DST_SB, return
        -: 1515:   true if the logical 'move' operation should _not_ proceed.
        -: 1516:   Otherwise, return false.
        -: 1517:   Depending on options specified in X, this code may issue an
        -: 1518:   interactive prompt asking whether it's ok to overwrite DST_NAME.  */
        -: 1519:static bool
    #####: 1520:abandon_move (const struct cp_options *x,
        -: 1521:              char const *dst_name,
        -: 1522:              struct stat const *dst_sb)
        -: 1523:{
    #####: 1524:  assert (x->move_mode);
    #####: 1525:  return (x->interactive == I_ALWAYS_NO
    #####: 1526:          || ((x->interactive == I_ASK_USER
    #####: 1527:               || (x->interactive == I_UNSPECIFIED
    #####: 1528:                   && x->stdin_tty
    #####: 1529:                   && ! writable_destination (dst_name, dst_sb->st_mode)))
    #####: 1530:              && (overwrite_prompt (dst_name, dst_sb), 1)
    #####: 1531:              && ! yesno ()));
        -: 1532:}
        -: 1533:
        -: 1534:/* Print --verbose output on standard output, e.g. 'new' -> 'old'.
        -: 1535:   If BACKUP_DST_NAME is non-NULL, then also indicate that it is
        -: 1536:   the name of a backup file.  */
        -: 1537:static void
    #####: 1538:emit_verbose (char const *src, char const *dst, char const *backup_dst_name)
        -: 1539:{
    #####: 1540:  printf ("%s -> %s", quote_n (0, src), quote_n (1, dst));
    #####: 1541:  if (backup_dst_name)
    #####: 1542:    printf (_(" (backup: %s)"), quote (backup_dst_name));
    #####: 1543:  putchar ('\n');
    #####: 1544:}
        -: 1545:
        -: 1546:/* A wrapper around "setfscreatecon (NULL)" that exits upon failure.  */
        -: 1547:static void
    #####: 1548:restore_default_fscreatecon_or_die (void)
        -: 1549:{
    #####: 1550:  if (setfscreatecon (NULL) != 0)
    #####: 1551:    error (EXIT_FAILURE, errno,
        -: 1552:           _("failed to restore the default file creation context"));
    #####: 1553:}
        -: 1554:
        -: 1555:/* Create a hard link DST_NAME to SRC_NAME, honoring the REPLACE and
        -: 1556:   VERBOSE settings.  Return true upon success.  Otherwise, diagnose
        -: 1557:   the failure and return false.
        -: 1558:   If SRC_NAME is a symbolic link it will not be followed.  If the system
        -: 1559:   doesn't support hard links to symbolic links, then DST_NAME will
        -: 1560:   be created as a symbolic link to SRC_NAME.  */
        -: 1561:static bool
    #####: 1562:create_hard_link (char const *src_name, char const *dst_name,
        -: 1563:                  bool replace, bool verbose)
        -: 1564:{
        -: 1565:  /* We want to guarantee that symlinks are not followed.  */
    #####: 1566:  bool link_failed = (linkat (AT_FDCWD, src_name, AT_FDCWD, dst_name, 0) != 0);
        -: 1567:
        -: 1568:  /* If the link failed because of an existing destination,
        -: 1569:     remove that file and then call link again.  */
    #####: 1570:  if (link_failed && replace && errno == EEXIST)
        -: 1571:    {
    #####: 1572:      if (unlink (dst_name) != 0)
        -: 1573:        {
    #####: 1574:          error (0, errno, _("cannot remove %s"), quote (dst_name));
    #####: 1575:          return false;
        -: 1576:        }
    #####: 1577:      if (verbose)
    #####: 1578:        printf (_("removed %s\n"), quote (dst_name));
    #####: 1579:      link_failed = (linkat (AT_FDCWD, src_name, AT_FDCWD, dst_name, 0) != 0);
        -: 1580:    }
        -: 1581:
    #####: 1582:  if (link_failed)
        -: 1583:    {
    #####: 1584:      error (0, errno, _("cannot create hard link %s to %s"),
        -: 1585:             quote_n (0, dst_name), quote_n (1, src_name));
    #####: 1586:      return false;
        -: 1587:    }
        -: 1588:
    #####: 1589:  return true;
        -: 1590:}
        -: 1591:
        -: 1592:/* Copy the file SRC_NAME to the file DST_NAME.  The files may be of
        -: 1593:   any type.  NEW_DST should be true if the file DST_NAME cannot
        -: 1594:   exist because its parent directory was just created; NEW_DST should
        -: 1595:   be false if DST_NAME might already exist.  DEVICE is the device
        -: 1596:   number of the parent directory, or 0 if the parent of this file is
        -: 1597:   not known.  ANCESTORS points to a linked, null terminated list of
        -: 1598:   devices and inodes of parent directories of SRC_NAME.  COMMAND_LINE_ARG
        -: 1599:   is true iff SRC_NAME was specified on the command line.
        -: 1600:   FIRST_DIR_CREATED_PER_COMMAND_LINE_ARG is both input and output.
        -: 1601:   Set *COPY_INTO_SELF if SRC_NAME is a parent of (or the
        -: 1602:   same as) DST_NAME; otherwise, clear it.
        -: 1603:   Return true if successful.  */
        -: 1604:static bool
        5: 1605:copy_internal (char const *src_name, char const *dst_name,
        -: 1606:               bool new_dst,
        -: 1607:               dev_t device,
        -: 1608:               struct dir_list *ancestors,
        -: 1609:               const struct cp_options *x,
        -: 1610:               bool command_line_arg,
        -: 1611:               bool *first_dir_created_per_command_line_arg,
        -: 1612:               bool *copy_into_self,
        -: 1613:               bool *rename_succeeded)
        -: 1614:{
        -: 1615:  struct stat src_sb;
        -: 1616:  struct stat dst_sb;
        -: 1617:  mode_t src_mode;
        -: 1618:  mode_t dst_mode IF_LINT ( = 0);
        -: 1619:  mode_t dst_mode_bits;
        -: 1620:  mode_t omitted_permissions;
        5: 1621:  bool restore_dst_mode = false;
        5: 1622:  char *earlier_file = NULL;
        5: 1623:  char *dst_backup = NULL;
        5: 1624:  bool backup_succeeded = false;
        -: 1625:  bool delayed_ok;
        5: 1626:  bool copied_as_regular = false;
        5: 1627:  bool dest_is_symlink = false;
        5: 1628:  bool have_dst_lstat = false;
        -: 1629:
        5: 1630:  if (x->move_mode && rename_succeeded)
        5: 1631:    *rename_succeeded = false;
        -: 1632:
        5: 1633:  *copy_into_self = false;
        -: 1634:
        5: 1635:  if (XSTAT (x, src_name, &src_sb) != 0)
        -: 1636:    {
    #####: 1637:      error (0, errno, _("cannot stat %s"), quote (src_name));
    #####: 1638:      return false;
        -: 1639:    }
        -: 1640:
        5: 1641:  src_mode = src_sb.st_mode;
        -: 1642:
        5: 1643:  if (S_ISDIR (src_mode) && !x->recursive)
        -: 1644:    {
    #####: 1645:      error (0, 0, _("omitting directory %s"), quote (src_name));
    #####: 1646:      return false;
        -: 1647:    }
        -: 1648:
        -: 1649:  /* Detect the case in which the same source file appears more than
        -: 1650:     once on the command line and no backup option has been selected.
        -: 1651:     If so, simply warn and don't copy it the second time.
        -: 1652:     This check is enabled only if x->src_info is non-NULL.  */
        5: 1653:  if (command_line_arg)
        -: 1654:    {
        5: 1655:      if ( ! S_ISDIR (src_sb.st_mode)
        5: 1656:           && x->backup_type == no_backups
        5: 1657:           && seen_file (x->src_info, src_name, &src_sb))
        -: 1658:        {
    #####: 1659:          error (0, 0, _("warning: source file %s specified more than once"),
        -: 1660:                 quote (src_name));
    #####: 1661:          return true;
        -: 1662:        }
        -: 1663:
        5: 1664:      record_file (x->src_info, src_name, &src_sb);
        -: 1665:    }
        -: 1666:
        5: 1667:  if (!new_dst)
        -: 1668:    {
        -: 1669:      /* Regular files can be created by writing through symbolic
        -: 1670:         links, but other files cannot.  So use stat on the
        -: 1671:         destination when copying a regular file, and lstat otherwise.
        -: 1672:         However, if we intend to unlink or remove the destination
        -: 1673:         first, use lstat, since a copy won't actually be made to the
        -: 1674:         destination in that case.  */
        5: 1675:      bool use_stat =
        5: 1676:        ((S_ISREG (src_mode)
    #####: 1677:          || (x->copy_as_regular
    #####: 1678:              && ! (S_ISDIR (src_mode) || S_ISLNK (src_mode))))
       10: 1679:         && ! (x->move_mode || x->symbolic_link || x->hard_link
    #####: 1680:               || x->backup_type != no_backups
    #####: 1681:               || x->unlink_dest_before_opening));
        5: 1682:      if ((use_stat
    #####: 1683:           ? stat (dst_name, &dst_sb)
        5: 1684:           : lstat (dst_name, &dst_sb))
       10: 1685:          != 0)
        -: 1686:        {
        5: 1687:          if (errno != ENOENT)
        -: 1688:            {
    #####: 1689:              error (0, errno, _("cannot stat %s"), quote (dst_name));
    #####: 1690:              return false;
        -: 1691:            }
        -: 1692:          else
        -: 1693:            {
        5: 1694:              new_dst = true;
        -: 1695:            }
        -: 1696:        }
        -: 1697:      else
        -: 1698:        { /* Here, we know that dst_name exists, at least to the point
        -: 1699:             that it is stat'able or lstat'able.  */
        -: 1700:          bool return_now;
        -: 1701:          bool unlink_src;
        -: 1702:
    #####: 1703:          have_dst_lstat = !use_stat;
    #####: 1704:          if (! same_file_ok (src_name, &src_sb, dst_name, &dst_sb,
        -: 1705:                              x, &return_now, &unlink_src))
        -: 1706:            {
    #####: 1707:              error (0, 0, _("%s and %s are the same file"),
        -: 1708:                     quote_n (0, src_name), quote_n (1, dst_name));
    #####: 1709:              return false;
        -: 1710:            }
        -: 1711:
    #####: 1712:          if (!S_ISDIR (src_mode) && x->update)
        -: 1713:            {
        -: 1714:              /* When preserving time stamps (but not moving within a file
        -: 1715:                 system), don't worry if the destination time stamp is
        -: 1716:                 less than the source merely because of time stamp
        -: 1717:                 truncation.  */
    #####: 1718:              int options = ((x->preserve_timestamps
    #####: 1719:                              && ! (x->move_mode
    #####: 1720:                                    && dst_sb.st_dev == src_sb.st_dev))
        -: 1721:                             ? UTIMECMP_TRUNCATE_SOURCE
    #####: 1722:                             : 0);
        -: 1723:
    #####: 1724:              if (0 <= utimecmp (dst_name, &dst_sb, &src_sb, options))
        -: 1725:                {
        -: 1726:                  /* We're using --update and the destination is not older
        -: 1727:                     than the source, so do not copy or move.  Pretend the
        -: 1728:                     rename succeeded, so the caller (if it's mv) doesn't
        -: 1729:                     end up removing the source file.  */
    #####: 1730:                  if (rename_succeeded)
    #####: 1731:                    *rename_succeeded = true;
        -: 1732:
        -: 1733:                  /* However, we still must record that we've processed
        -: 1734:                     this src/dest pair, in case this source file is
        -: 1735:                     hard-linked to another one.  In that case, we'll use
        -: 1736:                     the mapping information to link the corresponding
        -: 1737:                     destination names.  */
    #####: 1738:                  earlier_file = remember_copied (dst_name, src_sb.st_ino,
        -: 1739:                                                  src_sb.st_dev);
    #####: 1740:                  if (earlier_file)
        -: 1741:                    {
        -: 1742:                      /* Note we currently replace DST_NAME unconditionally,
        -: 1743:                         even if it was a newer separate file.  */
    #####: 1744:                      if (! create_hard_link (earlier_file, dst_name, true,
    #####: 1745:                                              x->verbose))
        -: 1746:                        {
    #####: 1747:                          goto un_backup;
        -: 1748:                        }
        -: 1749:                    }
        -: 1750:
    #####: 1751:                  return true;
        -: 1752:                }
        -: 1753:            }
        -: 1754:
        -: 1755:          /* When there is an existing destination file, we may end up
        -: 1756:             returning early, and hence not copying/moving the file.
        -: 1757:             This may be due to an interactive 'negative' reply to the
        -: 1758:             prompt about the existing file.  It may also be due to the
        -: 1759:             use of the --reply=no option.
        -: 1760:
        -: 1761:             cp and mv treat -i and -f differently.  */
    #####: 1762:          if (x->move_mode)
        -: 1763:            {
    #####: 1764:              if (abandon_move (x, dst_name, &dst_sb)
    #####: 1765:                  || (unlink_src && unlink (src_name) == 0))
        -: 1766:                {
        -: 1767:                  /* Pretend the rename succeeded, so the caller (mv)
        -: 1768:                     doesn't end up removing the source file.  */
    #####: 1769:                  if (rename_succeeded)
    #####: 1770:                    *rename_succeeded = true;
    #####: 1771:                  if (unlink_src && x->verbose)
    #####: 1772:                    printf (_("removed %s\n"), quote (src_name));
    #####: 1773:                  return true;
        -: 1774:                }
    #####: 1775:              if (unlink_src)
        -: 1776:                {
    #####: 1777:                  error (0, errno, _("cannot remove %s"), quote (src_name));
    #####: 1778:                  return false;
        -: 1779:                }
        -: 1780:            }
        -: 1781:          else
        -: 1782:            {
    #####: 1783:              if (! S_ISDIR (src_mode)
    #####: 1784:                  && (x->interactive == I_ALWAYS_NO
    #####: 1785:                      || (x->interactive == I_ASK_USER
    #####: 1786:                          && (overwrite_prompt (dst_name, &dst_sb), 1)
    #####: 1787:                          && ! yesno ())))
    #####: 1788:                return true;
        -: 1789:            }
        -: 1790:
    #####: 1791:          if (return_now)
    #####: 1792:            return true;
        -: 1793:
    #####: 1794:          if (!S_ISDIR (dst_sb.st_mode))
        -: 1795:            {
    #####: 1796:              if (S_ISDIR (src_mode))
        -: 1797:                {
    #####: 1798:                  if (x->move_mode && x->backup_type != no_backups)
        -: 1799:                    {
        -: 1800:                      /* Moving a directory onto an existing
        -: 1801:                         non-directory is ok only with --backup.  */
        -: 1802:                    }
        -: 1803:                  else
        -: 1804:                    {
    #####: 1805:                      error (0, 0,
        -: 1806:                       _("cannot overwrite non-directory %s with directory %s"),
        -: 1807:                             quote_n (0, dst_name), quote_n (1, src_name));
    #####: 1808:                      return false;
        -: 1809:                    }
        -: 1810:                }
        -: 1811:
        -: 1812:              /* Don't let the user destroy their data, even if they try hard:
        -: 1813:                 This mv command must fail (likewise for cp):
        -: 1814:                   rm -rf a b c; mkdir a b c; touch a/f b/f; mv a/f b/f c
        -: 1815:                 Otherwise, the contents of b/f would be lost.
        -: 1816:                 In the case of 'cp', b/f would be lost if the user simulated
        -: 1817:                 a move using cp and rm.
        -: 1818:                 Note that it works fine if you use --backup=numbered.  */
    #####: 1819:              if (command_line_arg
    #####: 1820:                  && x->backup_type != numbered_backups
    #####: 1821:                  && seen_file (x->dest_info, dst_name, &dst_sb))
        -: 1822:                {
    #####: 1823:                  error (0, 0,
        -: 1824:                         _("will not overwrite just-created %s with %s"),
        -: 1825:                         quote_n (0, dst_name), quote_n (1, src_name));
    #####: 1826:                  return false;
        -: 1827:                }
        -: 1828:            }
        -: 1829:
    #####: 1830:          if (!S_ISDIR (src_mode))
        -: 1831:            {
    #####: 1832:              if (S_ISDIR (dst_sb.st_mode))
        -: 1833:                {
    #####: 1834:                  if (x->move_mode && x->backup_type != no_backups)
        -: 1835:                    {
        -: 1836:                      /* Moving a non-directory onto an existing
        -: 1837:                         directory is ok only with --backup.  */
        -: 1838:                    }
        -: 1839:                  else
        -: 1840:                    {
    #####: 1841:                      error (0, 0,
        -: 1842:                         _("cannot overwrite directory %s with non-directory"),
        -: 1843:                             quote (dst_name));
    #####: 1844:                      return false;
        -: 1845:                    }
        -: 1846:                }
        -: 1847:            }
        -: 1848:
    #####: 1849:          if (x->move_mode)
        -: 1850:            {
        -: 1851:              /* Don't allow user to move a directory onto a non-directory.  */
    #####: 1852:              if (S_ISDIR (src_sb.st_mode) && !S_ISDIR (dst_sb.st_mode)
    #####: 1853:                  && x->backup_type == no_backups)
        -: 1854:                {
    #####: 1855:                  error (0, 0,
        -: 1856:                       _("cannot move directory onto non-directory: %s -> %s"),
        -: 1857:                         quote_n (0, src_name), quote_n (0, dst_name));
    #####: 1858:                  return false;
        -: 1859:                }
        -: 1860:            }
        -: 1861:
    #####: 1862:          if (x->backup_type != no_backups
        -: 1863:              /* Don't try to back up a destination if the last
        -: 1864:                 component of src_name is "." or "..".  */
    #####: 1865:              && ! dot_or_dotdot (last_component (src_name))
        -: 1866:              /* Create a backup of each destination directory in move mode,
        -: 1867:                 but not in copy mode.  FIXME: it might make sense to add an
        -: 1868:                 option to suppress backup creation also for move mode.
        -: 1869:                 That would let one use mv to merge new content into an
        -: 1870:                 existing hierarchy.  */
    #####: 1871:              && (x->move_mode || ! S_ISDIR (dst_sb.st_mode)))
    #####: 1872:            {
    #####: 1873:              char *tmp_backup = find_backup_file_name (dst_name,
        -: 1874:                                                        x->backup_type);
        -: 1875:
        -: 1876:              /* Detect (and fail) when creating the backup file would
        -: 1877:                 destroy the source file.  Before, running the commands
        -: 1878:                 cd /tmp; rm -f a a~; : > a; echo A > a~; cp --b=simple a~ a
        -: 1879:                 would leave two zero-length files: a and a~.  */
        -: 1880:              /* FIXME: but simply change e.g., the final a~ to './a~'
        -: 1881:                 and the source will still be destroyed.  */
    #####: 1882:              if (STREQ (tmp_backup, src_name))
        -: 1883:                {
        -: 1884:                  const char *fmt;
    #####: 1885:                  fmt = (x->move_mode
        -: 1886:                 ? _("backing up %s would destroy source;  %s not moved")
    #####: 1887:                 : _("backing up %s would destroy source;  %s not copied"));
    #####: 1888:                  error (0, 0, fmt,
        -: 1889:                         quote_n (0, dst_name),
        -: 1890:                         quote_n (1, src_name));
    #####: 1891:                  free (tmp_backup);
    #####: 1892:                  return false;
        -: 1893:                }
        -: 1894:
        -: 1895:              /* FIXME: use fts:
        -: 1896:                 Using alloca for a file name that may be arbitrarily
        -: 1897:                 long is not recommended.  In fact, even forming such a name
        -: 1898:                 should be discouraged.  Eventually, this code will be rewritten
        -: 1899:                 to use fts, so using alloca here will be less of a problem.  */
    #####: 1900:              ASSIGN_STRDUPA (dst_backup, tmp_backup);
    #####: 1901:              free (tmp_backup);
        -: 1902:              /* In move mode, when src_name and dst_name are on the
        -: 1903:                 same partition (FIXME, and when they are non-directories),
        -: 1904:                 make the operation atomic: link dest
        -: 1905:                 to backup, then rename src to dest.  */
    #####: 1906:              if (rename (dst_name, dst_backup) != 0)
        -: 1907:                {
    #####: 1908:                  if (errno != ENOENT)
        -: 1909:                    {
    #####: 1910:                      error (0, errno, _("cannot backup %s"), quote (dst_name));
    #####: 1911:                      return false;
        -: 1912:                    }
        -: 1913:                  else
        -: 1914:                    {
    #####: 1915:                      dst_backup = NULL;
        -: 1916:                    }
        -: 1917:                }
        -: 1918:              else
        -: 1919:                {
    #####: 1920:                  backup_succeeded = true;
        -: 1921:                }
    #####: 1922:              new_dst = true;
        -: 1923:            }
    #####: 1924:          else if (! S_ISDIR (dst_sb.st_mode)
        -: 1925:                   /* Never unlink dst_name when in move mode.  */
    #####: 1926:                   && ! x->move_mode
    #####: 1927:                   && (x->unlink_dest_before_opening
    #####: 1928:                       || (x->preserve_links && 1 < dst_sb.st_nlink)
    #####: 1929:                       || (x->dereference == DEREF_NEVER
    #####: 1930:                           && ! S_ISREG (src_sb.st_mode))
        -: 1931:                       ))
        -: 1932:            {
    #####: 1933:              if (unlink (dst_name) != 0 && errno != ENOENT)
        -: 1934:                {
    #####: 1935:                  error (0, errno, _("cannot remove %s"), quote (dst_name));
    #####: 1936:                  return false;
        -: 1937:                }
    #####: 1938:              new_dst = true;
    #####: 1939:              if (x->verbose)
    #####: 1940:                printf (_("removed %s\n"), quote (dst_name));
        -: 1941:            }
        -: 1942:        }
        -: 1943:    }
        -: 1944:
        -: 1945:  /* Ensure we don't try to copy through a symlink that was
        -: 1946:     created by a prior call to this function.  */
        5: 1947:  if (command_line_arg
        5: 1948:      && x->dest_info
    #####: 1949:      && ! x->move_mode
    #####: 1950:      && x->backup_type == no_backups)
        -: 1951:    {
    #####: 1952:      bool lstat_ok = true;
        -: 1953:      struct stat tmp_buf;
        -: 1954:      struct stat *dst_lstat_sb;
        -: 1955:
        -: 1956:      /* If we called lstat above, good: use that data.
        -: 1957:         Otherwise, call lstat here, in case dst_name is a symlink.  */
    #####: 1958:      if (have_dst_lstat)
    #####: 1959:        dst_lstat_sb = &dst_sb;
        -: 1960:      else
        -: 1961:        {
    #####: 1962:          if (lstat (dst_name, &tmp_buf) == 0)
    #####: 1963:            dst_lstat_sb = &tmp_buf;
        -: 1964:          else
    #####: 1965:            lstat_ok = false;
        -: 1966:        }
        -: 1967:
        -: 1968:      /* Never copy through a symlink we've just created.  */
    #####: 1969:      if (lstat_ok
    #####: 1970:          && S_ISLNK (dst_lstat_sb->st_mode)
    #####: 1971:          && seen_file (x->dest_info, dst_name, dst_lstat_sb))
        -: 1972:        {
    #####: 1973:          error (0, 0,
        -: 1974:                 _("will not copy %s through just-created symlink %s"),
        -: 1975:                 quote_n (0, src_name), quote_n (1, dst_name));
    #####: 1976:          return false;
        -: 1977:        }
        -: 1978:    }
        -: 1979:
        -: 1980:  /* If the source is a directory, we don't always create the destination
        -: 1981:     directory.  So --verbose should not announce anything until we're
        -: 1982:     sure we'll create a directory. */
        5: 1983:  if (x->verbose && !S_ISDIR (src_mode))
    #####: 1984:    emit_verbose (src_name, dst_name, backup_succeeded ? dst_backup : NULL);
        -: 1985:
        -: 1986:  /* Associate the destination file name with the source device and inode
        -: 1987:     so that if we encounter a matching dev/ino pair in the source tree
        -: 1988:     we can arrange to create a hard link between the corresponding names
        -: 1989:     in the destination tree.
        -: 1990:
        -: 1991:     When using the --link (-l) option, there is no need to take special
        -: 1992:     measures, because (barring race conditions) files that are hard-linked
        -: 1993:     in the source tree will also be hard-linked in the destination tree.
        -: 1994:
        -: 1995:     Sometimes, when preserving links, we have to record dev/ino even
        -: 1996:     though st_nlink == 1:
        -: 1997:     - when in move_mode, since we may be moving a group of N hard-linked
        -: 1998:        files (via two or more command line arguments) to a different
        -: 1999:        partition; the links may be distributed among the command line
        -: 2000:        arguments (possibly hierarchies) so that the link count of
        -: 2001:        the final, once-linked source file is reduced to 1 when it is
        -: 2002:        considered below.  But in this case (for mv) we don't need to
        -: 2003:        incur the expense of recording the dev/ino => name mapping; all we
        -: 2004:        really need is a lookup, to see if the dev/ino pair has already
        -: 2005:        been copied.
        -: 2006:     - when using -H and processing a command line argument;
        -: 2007:        that command line argument could be a symlink pointing to another
        -: 2008:        command line argument.  With 'cp -H --preserve=link', we hard-link
        -: 2009:        those two destination files.
        -: 2010:     - likewise for -L except that it applies to all files, not just
        -: 2011:        command line arguments.
        -: 2012:
        -: 2013:     Also, with --recursive, record dev/ino of each command-line directory.
        -: 2014:     We'll use that info to detect this problem: cp -R dir dir.  */
        -: 2015:
        5: 2016:  if (x->move_mode && src_sb.st_nlink == 1)
        -: 2017:    {
        5: 2018:      earlier_file = src_to_dest_lookup (src_sb.st_ino, src_sb.st_dev);
        -: 2019:    }
    #####: 2020:  else if (x->preserve_links
    #####: 2021:           && !x->hard_link
    #####: 2022:           && (1 < src_sb.st_nlink
    #####: 2023:               || (command_line_arg
    #####: 2024:                   && x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)
    #####: 2025:               || x->dereference == DEREF_ALWAYS))
        -: 2026:    {
    #####: 2027:      earlier_file = remember_copied (dst_name, src_sb.st_ino, src_sb.st_dev);
        -: 2028:    }
    #####: 2029:  else if (x->recursive && S_ISDIR (src_mode))
        -: 2030:    {
    #####: 2031:      if (command_line_arg)
    #####: 2032:        earlier_file = remember_copied (dst_name, src_sb.st_ino, src_sb.st_dev);
        -: 2033:      else
    #####: 2034:        earlier_file = src_to_dest_lookup (src_sb.st_ino, src_sb.st_dev);
        -: 2035:    }
        -: 2036:
        -: 2037:  /* Did we copy this inode somewhere else (in this command line argument)
        -: 2038:     and therefore this is a second hard link to the inode?  */
        -: 2039:
        5: 2040:  if (earlier_file)
        -: 2041:    {
        -: 2042:      /* Avoid damaging the destination file system by refusing to preserve
        -: 2043:         hard-linked directories (which are found at least in Netapp snapshot
        -: 2044:         directories).  */
    #####: 2045:      if (S_ISDIR (src_mode))
        -: 2046:        {
        -: 2047:          /* If src_name and earlier_file refer to the same directory entry,
        -: 2048:             then warn about copying a directory into itself.  */
    #####: 2049:          if (same_name (src_name, earlier_file))
        -: 2050:            {
    #####: 2051:              error (0, 0, _("cannot copy a directory, %s, into itself, %s"),
        -: 2052:                     quote_n (0, top_level_src_name),
        -: 2053:                     quote_n (1, top_level_dst_name));
    #####: 2054:              *copy_into_self = true;
    #####: 2055:              goto un_backup;
        -: 2056:            }
    #####: 2057:          else if (x->dereference == DEREF_ALWAYS)
        -: 2058:            {
        -: 2059:              /* This happens when e.g., encountering a directory for the
        -: 2060:                 second or subsequent time via symlinks when cp is invoked
        -: 2061:                 with -R and -L.  E.g.,
        -: 2062:                 rm -rf a b c d; mkdir a b c d; ln -s ../c a; ln -s ../c b;
        -: 2063:                 cp -RL a b d
        -: 2064:              */
        -: 2065:            }
        -: 2066:          else
        -: 2067:            {
    #####: 2068:              error (0, 0, _("will not create hard link %s to directory %s"),
        -: 2069:                     quote_n (0, dst_name), quote_n (1, earlier_file));
    #####: 2070:              goto un_backup;
        -: 2071:            }
        -: 2072:        }
        -: 2073:      else
        -: 2074:        {
    #####: 2075:          if (! create_hard_link (earlier_file, dst_name, true, x->verbose))
    #####: 2076:            goto un_backup;
        -: 2077:
    #####: 2078:          return true;
        -: 2079:        }
        -: 2080:    }
        -: 2081:
        5: 2082:  if (x->move_mode)
        -: 2083:    {
        5: 2084:      if (rename (src_name, dst_name) == 0)
        -: 2085:        {
        1: 2086:          if (x->verbose && S_ISDIR (src_mode))
    #####: 2087:            emit_verbose (src_name, dst_name,
        -: 2088:                          backup_succeeded ? dst_backup : NULL);
        -: 2089:
        1: 2090:          if (rename_succeeded)
        1: 2091:            *rename_succeeded = true;
        -: 2092:
        1: 2093:          if (command_line_arg)
        -: 2094:            {
        -: 2095:              /* Record destination dev/ino/name, so that if we are asked
        -: 2096:                 to overwrite that file again, we can detect it and fail.  */
        -: 2097:              /* It's fine to use the _source_ stat buffer (src_sb) to get the
        -: 2098:                 _destination_ dev/ino, since the rename above can't have
        -: 2099:                 changed those, and 'mv' always uses lstat.
        -: 2100:                 We could limit it further by operating
        -: 2101:                 only on non-directories.  */
        1: 2102:              record_file (x->dest_info, dst_name, &src_sb);
        -: 2103:            }
        -: 2104:
        1: 2105:          return true;
        -: 2106:        }
        -: 2107:
        -: 2108:      /* FIXME: someday, consider what to do when moving a directory into
        -: 2109:         itself but when source and destination are on different devices.  */
        -: 2110:
        -: 2111:      /* This happens when attempting to rename a directory to a
        -: 2112:         subdirectory of itself.  */
        4: 2113:      if (errno == EINVAL)
        -: 2114:        {
        -: 2115:          /* FIXME: this is a little fragile in that it relies on rename(2)
        -: 2116:             failing with a specific errno value.  Expect problems on
        -: 2117:             non-POSIX systems.  */
    #####: 2118:          error (0, 0, _("cannot move %s to a subdirectory of itself, %s"),
        -: 2119:                 quote_n (0, top_level_src_name),
        -: 2120:                 quote_n (1, top_level_dst_name));
        -: 2121:
        -: 2122:          /* Note that there is no need to call forget_created here,
        -: 2123:             (compare with the other calls in this file) since the
        -: 2124:             destination directory didn't exist before.  */
        -: 2125:
    #####: 2126:          *copy_into_self = true;
        -: 2127:          /* FIXME-cleanup: Don't return true here; adjust mv.c accordingly.
        -: 2128:             The only caller that uses this code (mv.c) ends up setting its
        -: 2129:             exit status to nonzero when copy_into_self is nonzero.  */
    #####: 2130:          return true;
        -: 2131:        }
        -: 2132:
        -: 2133:      /* WARNING: there probably exist systems for which an inter-device
        -: 2134:         rename fails with a value of errno not handled here.
        -: 2135:         If/as those are reported, add them to the condition below.
        -: 2136:         If this happens to you, please do the following and send the output
        -: 2137:         to the bug-reporting address (e.g., in the output of cp --help):
        -: 2138:           touch k; perl -e 'rename "k","/tmp/k" or print "$!(",$!+0,")\n"'
        -: 2139:         where your current directory is on one partion and /tmp is the other.
        -: 2140:         Also, please try to find the E* errno macro name corresponding to
        -: 2141:         the diagnostic and parenthesized integer, and include that in your
        -: 2142:         e-mail.  One way to do that is to run a command like this
        -: 2143:           find /usr/include/. -type f \
        -: 2144:             | xargs grep 'define.*\<E[A-Z]*\>.*\<18\>' /dev/null
        -: 2145:         where you'd replace '18' with the integer in parentheses that
        -: 2146:         was output from the perl one-liner above.
        -: 2147:         If necessary, of course, change '/tmp' to some other directory.  */
        4: 2148:      if (errno != EXDEV)
        -: 2149:        {
        -: 2150:          /* There are many ways this can happen due to a race condition.
        -: 2151:             When something happens between the initial XSTAT and the
        -: 2152:             subsequent rename, we can get many different types of errors.
        -: 2153:             For example, if the destination is initially a non-directory
        -: 2154:             or non-existent, but it is created as a directory, the rename
        -: 2155:             fails.  If two 'mv' commands try to rename the same file at
        -: 2156:             about the same time, one will succeed and the other will fail.
        -: 2157:             If the permissions on the directory containing the source or
        -: 2158:             destination file are made too restrictive, the rename will
        -: 2159:             fail.  Etc.  */
    #####: 2160:          error (0, errno,
        -: 2161:                 _("cannot move %s to %s"),
        -: 2162:                 quote_n (0, src_name), quote_n (1, dst_name));
    #####: 2163:          forget_created (src_sb.st_ino, src_sb.st_dev);
    #####: 2164:          return false;
        -: 2165:        }
        -: 2166:
        -: 2167:      /* The rename attempt has failed.  Remove any existing destination
        -: 2168:         file so that a cross-device 'mv' acts as if it were really using
        -: 2169:         the rename syscall.  */
        4: 2170:      if (unlink (dst_name) != 0 && errno != ENOENT)
        -: 2171:        {
    #####: 2172:          error (0, errno,
        -: 2173:             _("inter-device move failed: %s to %s; unable to remove target"),
        -: 2174:                 quote_n (0, src_name), quote_n (1, dst_name));
    #####: 2175:          forget_created (src_sb.st_ino, src_sb.st_dev);
    #####: 2176:          return false;
        -: 2177:        }
        -: 2178:
        4: 2179:      new_dst = true;
        -: 2180:    }
        -: 2181:
        -: 2182:  /* If the ownership might change, or if it is a directory (whose
        -: 2183:     special mode bits may change after the directory is created),
        -: 2184:     omit some permissions at first, so unauthorized users cannot nip
        -: 2185:     in before the file is ready.  */
        4: 2186:  dst_mode_bits = (x->set_mode ? x->mode : src_mode) & CHMOD_MODE_BITS;
        4: 2187:  omitted_permissions =
        -: 2188:    (dst_mode_bits
        4: 2189:     & (x->preserve_ownership ? S_IRWXG | S_IRWXO
    #####: 2190:        : S_ISDIR (src_mode) ? S_IWGRP | S_IWOTH
        -: 2191:        : 0));
        -: 2192:
        4: 2193:  delayed_ok = true;
        -: 2194:
        4: 2195:  if (x->preserve_security_context)
        -: 2196:    {
    #####: 2197:      bool all_errors = !x->data_copy_required || x->require_preserve_context;
    #####: 2198:      bool some_errors = !all_errors && !x->reduce_diagnostics;
        -: 2199:      security_context_t con;
        -: 2200:
    #####: 2201:      if (0 <= lgetfilecon (src_name, &con))
        -: 2202:        {
    #####: 2203:          if (setfscreatecon (con) < 0)
        -: 2204:            {
    #####: 2205:              if (all_errors || (some_errors && !errno_unsupported (errno)))
    #####: 2206:                error (0, errno,
        -: 2207:                       _("failed to set default file creation context to %s"),
        -: 2208:                       quote (con));
    #####: 2209:              if (x->require_preserve_context)
        -: 2210:                {
    #####: 2211:                  freecon (con);
    #####: 2212:                  return false;
        -: 2213:                }
        -: 2214:            }
    #####: 2215:          freecon (con);
        -: 2216:        }
        -: 2217:      else
        -: 2218:        {
    #####: 2219:          if (all_errors || (some_errors && !errno_unsupported (errno)))
        -: 2220:            {
    #####: 2221:              error (0, errno,
        -: 2222:                     _("failed to get security context of %s"),
        -: 2223:                     quote (src_name));
        -: 2224:            }
    #####: 2225:          if (x->require_preserve_context)
    #####: 2226:            return false;
        -: 2227:        }
        -: 2228:    }
        -: 2229:
        4: 2230:  if (S_ISDIR (src_mode))
        -: 2231:    {
        -: 2232:      struct dir_list *dir;
        -: 2233:
        -: 2234:      /* If this directory has been copied before during the
        -: 2235:         recursion, there is a symbolic link to an ancestor
        -: 2236:         directory of the symbolic link.  It is impossible to
        -: 2237:         continue to copy this, unless we've got an infinite disk.  */
        -: 2238:
    #####: 2239:      if (is_ancestor (&src_sb, ancestors))
        -: 2240:        {
    #####: 2241:          error (0, 0, _("cannot copy cyclic symbolic link %s"),
        -: 2242:                 quote (src_name));
    #####: 2243:          goto un_backup;
        -: 2244:        }
        -: 2245:
        -: 2246:      /* Insert the current directory in the list of parents.  */
        -: 2247:
    #####: 2248:      dir = alloca (sizeof *dir);
    #####: 2249:      dir->parent = ancestors;
    #####: 2250:      dir->ino = src_sb.st_ino;
    #####: 2251:      dir->dev = src_sb.st_dev;
        -: 2252:
    #####: 2253:      if (new_dst || !S_ISDIR (dst_sb.st_mode))
        -: 2254:        {
        -: 2255:          /* POSIX says mkdir's behavior is implementation-defined when
        -: 2256:             (src_mode & ~S_IRWXUGO) != 0.  However, common practice is
        -: 2257:             to ask mkdir to copy all the CHMOD_MODE_BITS, letting mkdir
        -: 2258:             decide what to do with S_ISUID | S_ISGID | S_ISVTX.  */
    #####: 2259:          if (mkdir (dst_name, dst_mode_bits & ~omitted_permissions) != 0)
        -: 2260:            {
    #####: 2261:              error (0, errno, _("cannot create directory %s"),
        -: 2262:                     quote (dst_name));
    #####: 2263:              goto un_backup;
        -: 2264:            }
        -: 2265:
        -: 2266:          /* We need search and write permissions to the new directory
        -: 2267:             for writing the directory's contents. Check if these
        -: 2268:             permissions are there.  */
        -: 2269:
    #####: 2270:          if (lstat (dst_name, &dst_sb) != 0)
        -: 2271:            {
    #####: 2272:              error (0, errno, _("cannot stat %s"), quote (dst_name));
    #####: 2273:              goto un_backup;
        -: 2274:            }
    #####: 2275:          else if ((dst_sb.st_mode & S_IRWXU) != S_IRWXU)
        -: 2276:            {
        -: 2277:              /* Make the new directory searchable and writable.  */
        -: 2278:
    #####: 2279:              dst_mode = dst_sb.st_mode;
    #####: 2280:              restore_dst_mode = true;
        -: 2281:
    #####: 2282:              if (lchmod (dst_name, dst_mode | S_IRWXU) != 0)
        -: 2283:                {
    #####: 2284:                  error (0, errno, _("setting permissions for %s"),
        -: 2285:                         quote (dst_name));
    #####: 2286:                  goto un_backup;
        -: 2287:                }
        -: 2288:            }
        -: 2289:
        -: 2290:          /* Record the created directory's inode and device numbers into
        -: 2291:             the search structure, so that we can avoid copying it again.
        -: 2292:             Do this only for the first directory that is created for each
        -: 2293:             source command line argument.  */
    #####: 2294:          if (!*first_dir_created_per_command_line_arg)
        -: 2295:            {
    #####: 2296:              remember_copied (dst_name, dst_sb.st_ino, dst_sb.st_dev);
    #####: 2297:              *first_dir_created_per_command_line_arg = true;
        -: 2298:            }
        -: 2299:
    #####: 2300:          if (x->verbose)
    #####: 2301:            emit_verbose (src_name, dst_name, NULL);
        -: 2302:        }
        -: 2303:      else
        -: 2304:        {
    #####: 2305:          omitted_permissions = 0;
        -: 2306:        }
        -: 2307:
        -: 2308:      /* Decide whether to copy the contents of the directory.  */
    #####: 2309:      if (x->one_file_system && device != 0 && device != src_sb.st_dev)
        -: 2310:        {
        -: 2311:          /* Here, we are crossing a file system boundary and cp's -x option
        -: 2312:             is in effect: so don't copy the contents of this directory. */
        -: 2313:        }
        -: 2314:      else
        -: 2315:        {
        -: 2316:          /* Copy the contents of the directory.  Don't just return if
        -: 2317:             this fails -- otherwise, the failure to read a single file
        -: 2318:             in a source directory would cause the containing destination
        -: 2319:             directory not to have owner/perms set properly.  */
    #####: 2320:          delayed_ok = copy_dir (src_name, dst_name, new_dst, &src_sb, dir, x,
        -: 2321:                                 first_dir_created_per_command_line_arg,
        -: 2322:                                 copy_into_self);
        -: 2323:        }
        -: 2324:    }
        4: 2325:  else if (x->symbolic_link)
        -: 2326:    {
    #####: 2327:      dest_is_symlink = true;
    #####: 2328:      if (*src_name != '/')
        -: 2329:        {
        -: 2330:          /* Check that DST_NAME denotes a file in the current directory.  */
        -: 2331:          struct stat dot_sb;
        -: 2332:          struct stat dst_parent_sb;
        -: 2333:          char *dst_parent;
        -: 2334:          bool in_current_dir;
        -: 2335:
    #####: 2336:          dst_parent = dir_name (dst_name);
        -: 2337:
    #####: 2338:          in_current_dir = (STREQ (".", dst_parent)
        -: 2339:                            /* If either stat call fails, it's ok not to report
        -: 2340:                               the failure and say dst_name is in the current
        -: 2341:                               directory.  Other things will fail later.  */
    #####: 2342:                            || stat (".", &dot_sb) != 0
    #####: 2343:                            || stat (dst_parent, &dst_parent_sb) != 0
    #####: 2344:                            || SAME_INODE (dot_sb, dst_parent_sb));
    #####: 2345:          free (dst_parent);
        -: 2346:
    #####: 2347:          if (! in_current_dir)
        -: 2348:            {
    #####: 2349:              error (0, 0,
        -: 2350:           _("%s: can make relative symbolic links only in current directory"),
        -: 2351:                     quote (dst_name));
    #####: 2352:              goto un_backup;
        -: 2353:            }
        -: 2354:        }
    #####: 2355:      if (symlink (src_name, dst_name) != 0)
        -: 2356:        {
    #####: 2357:          error (0, errno, _("cannot create symbolic link %s to %s"),
        -: 2358:                 quote_n (0, dst_name), quote_n (1, src_name));
    #####: 2359:          goto un_backup;
        -: 2360:        }
        -: 2361:    }
        -: 2362:
        -: 2363:  /* POSIX 2008 states that it is implementation-defined whether
        -: 2364:     link() on a symlink creates a hard-link to the symlink, or only
        -: 2365:     to the referent (effectively dereferencing the symlink) (POSIX
        -: 2366:     2001 required the latter behavior, although many systems provided
        -: 2367:     the former).  Yet cp, invoked with '--link --no-dereference',
        -: 2368:     should not follow the link.  We can approximate the desired
        -: 2369:     behavior by skipping this hard-link creating block and instead
        -: 2370:     copying the symlink, via the 'S_ISLNK'- copying code below.
        -: 2371:     LINK_FOLLOWS_SYMLINKS is tri-state; if it is -1, we don't know
        -: 2372:     how link() behaves, so we use the fallback case for safety.
        -: 2373:
        -: 2374:     Note gnulib's linkat module, guarantees that the symlink is not
        -: 2375:     dereferenced.  However its emulation currently doesn't maintain
        -: 2376:     timestamps or ownership so we only call it when we know the
        -: 2377:     emulation will not be needed.  */
        4: 2378:  else if (x->hard_link
        -: 2379:           && !(LINK_FOLLOWS_SYMLINKS && S_ISLNK (src_mode)
        -: 2380:                && x->dereference == DEREF_NEVER))
        -: 2381:    {
    #####: 2382:      if (! create_hard_link (src_name, dst_name, false, false))
    #####: 2383:        goto un_backup;
        -: 2384:    }
        4: 2385:  else if (S_ISREG (src_mode)
    #####: 2386:           || (x->copy_as_regular && !S_ISLNK (src_mode)))
        -: 2387:    {
        4: 2388:      copied_as_regular = true;
        -: 2389:      /* POSIX says the permission bits of the source file must be
        -: 2390:         used as the 3rd argument in the open call.  Historical
        -: 2391:         practice passed all the source mode bits to 'open', but the extra
        -: 2392:         bits were ignored, so it should be the same either way.  */
        8: 2393:      if (! copy_reg (src_name, dst_name, x, src_mode & S_IRWXUGO,
        -: 2394:                      omitted_permissions, &new_dst, &src_sb))
    #####: 2395:        goto un_backup;
        -: 2396:    }
    #####: 2397:  else if (S_ISFIFO (src_mode))
        -: 2398:    {
        -: 2399:      /* Use mknod, rather than mkfifo, because the former preserves
        -: 2400:         the special mode bits of a fifo on Solaris 10, while mkfifo
        -: 2401:         does not.  But fall back on mkfifo, because on some BSD systems,
        -: 2402:         mknod always fails when asked to create a FIFO.  */
    #####: 2403:      if (mknod (dst_name, src_mode & ~omitted_permissions, 0) != 0)
    #####: 2404:        if (mkfifo (dst_name, src_mode & ~S_IFIFO & ~omitted_permissions) != 0)
        -: 2405:          {
    #####: 2406:            error (0, errno, _("cannot create fifo %s"), quote (dst_name));
    #####: 2407:            goto un_backup;
        -: 2408:          }
        -: 2409:    }
    #####: 2410:  else if (S_ISBLK (src_mode) || S_ISCHR (src_mode) || S_ISSOCK (src_mode))
        -: 2411:    {
    #####: 2412:      if (mknod (dst_name, src_mode & ~omitted_permissions, src_sb.st_rdev)
        -: 2413:          != 0)
        -: 2414:        {
    #####: 2415:          error (0, errno, _("cannot create special file %s"),
        -: 2416:                 quote (dst_name));
    #####: 2417:          goto un_backup;
        -: 2418:        }
        -: 2419:    }
    #####: 2420:  else if (S_ISLNK (src_mode))
        -: 2421:    {
    #####: 2422:      char *src_link_val = areadlink_with_size (src_name, src_sb.st_size);
    #####: 2423:      dest_is_symlink = true;
    #####: 2424:      if (src_link_val == NULL)
        -: 2425:        {
    #####: 2426:          error (0, errno, _("cannot read symbolic link %s"), quote (src_name));
    #####: 2427:          goto un_backup;
        -: 2428:        }
        -: 2429:
    #####: 2430:      if (symlink (src_link_val, dst_name) == 0)
    #####: 2431:        free (src_link_val);
        -: 2432:      else
        -: 2433:        {
    #####: 2434:          int saved_errno = errno;
    #####: 2435:          bool same_link = false;
    #####: 2436:          if (x->update && !new_dst && S_ISLNK (dst_sb.st_mode)
    #####: 2437:              && dst_sb.st_size == strlen (src_link_val))
        -: 2438:            {
        -: 2439:              /* See if the destination is already the desired symlink.
        -: 2440:                 FIXME: This behavior isn't documented, and seems wrong
        -: 2441:                 in some cases, e.g., if the destination symlink has the
        -: 2442:                 wrong ownership, permissions, or time stamps.  */
    #####: 2443:              char *dest_link_val =
    #####: 2444:                areadlink_with_size (dst_name, dst_sb.st_size);
    #####: 2445:              if (dest_link_val && STREQ (dest_link_val, src_link_val))
    #####: 2446:                same_link = true;
    #####: 2447:              free (dest_link_val);
        -: 2448:            }
    #####: 2449:          free (src_link_val);
        -: 2450:
    #####: 2451:          if (! same_link)
        -: 2452:            {
    #####: 2453:              error (0, saved_errno, _("cannot create symbolic link %s"),
        -: 2454:                     quote (dst_name));
    #####: 2455:              goto un_backup;
        -: 2456:            }
        -: 2457:        }
        -: 2458:
    #####: 2459:      if (x->preserve_security_context)
    #####: 2460:        restore_default_fscreatecon_or_die ();
        -: 2461:
    #####: 2462:      if (x->preserve_ownership)
        -: 2463:        {
        -: 2464:          /* Preserve the owner and group of the just-'copied'
        -: 2465:             symbolic link, if possible.  */
    #####: 2466:          if (HAVE_LCHOWN
    #####: 2467:              && lchown (dst_name, src_sb.st_uid, src_sb.st_gid) != 0
    #####: 2468:              && ! chown_failure_ok (x))
        -: 2469:            {
    #####: 2470:              error (0, errno, _("failed to preserve ownership for %s"),
        -: 2471:                     dst_name);
    #####: 2472:              goto un_backup;
        -: 2473:            }
        -: 2474:          else
        -: 2475:            {
        -: 2476:              /* Can't preserve ownership of symlinks.
        -: 2477:                 FIXME: maybe give a warning or even error for symlinks
        -: 2478:                 in directories with the sticky bit set -- there, not
        -: 2479:                 preserving owner/group is a potential security problem.  */
        -: 2480:            }
        -: 2481:        }
        -: 2482:    }
        -: 2483:  else
        -: 2484:    {
    #####: 2485:      error (0, 0, _("%s has unknown file type"), quote (src_name));
    #####: 2486:      goto un_backup;
        -: 2487:    }
        -: 2488:
        4: 2489:  if (command_line_arg && x->dest_info)
        -: 2490:    {
        -: 2491:      /* Now that the destination file is very likely to exist,
        -: 2492:         add its info to the set.  */
        -: 2493:      struct stat sb;
    #####: 2494:      if (lstat (dst_name, &sb) == 0)
    #####: 2495:        record_file (x->dest_info, dst_name, &sb);
        -: 2496:    }
        -: 2497:
        -: 2498:  /* If we've just created a hard-link due to cp's --link option,
        -: 2499:     we're done.  */
        4: 2500:  if (x->hard_link && ! S_ISDIR (src_mode)
    #####: 2501:      && !(LINK_FOLLOWS_SYMLINKS && S_ISLNK (src_mode)
        -: 2502:           && x->dereference == DEREF_NEVER))
    #####: 2503:    return delayed_ok;
        -: 2504:
        4: 2505:  if (copied_as_regular)
        4: 2506:    return delayed_ok;
        -: 2507:
        -: 2508:  /* POSIX says that 'cp -p' must restore the following:
        -: 2509:     - permission bits
        -: 2510:     - setuid, setgid bits
        -: 2511:     - owner and group
        -: 2512:     If it fails to restore any of those, we may give a warning but
        -: 2513:     the destination must not be removed.
        -: 2514:     FIXME: implement the above. */
        -: 2515:
        -: 2516:  /* Adjust the times (and if possible, ownership) for the copy.
        -: 2517:     chown turns off set[ug]id bits for non-root,
        -: 2518:     so do the chmod last.  */
        -: 2519:
    #####: 2520:  if (x->preserve_timestamps)
        -: 2521:    {
        -: 2522:      struct timespec timespec[2];
    #####: 2523:      timespec[0] = get_stat_atime (&src_sb);
    #####: 2524:      timespec[1] = get_stat_mtime (&src_sb);
        -: 2525:
    #####: 2526:      if ((dest_is_symlink
    #####: 2527:           ? utimens_symlink (dst_name, timespec)
    #####: 2528:           : utimens (dst_name, timespec))
    #####: 2529:          != 0)
        -: 2530:        {
    #####: 2531:          error (0, errno, _("preserving times for %s"), quote (dst_name));
    #####: 2532:          if (x->require_preserve)
    #####: 2533:            return false;
        -: 2534:        }
        -: 2535:    }
        -: 2536:
        -: 2537:  /* The operations beyond this point may dereference a symlink.  */
    #####: 2538:  if (dest_is_symlink)
    #####: 2539:    return delayed_ok;
        -: 2540:
        -: 2541:  /* Avoid calling chown if we know it's not necessary.  */
    #####: 2542:  if (x->preserve_ownership
    #####: 2543:      && (new_dst || !SAME_OWNER_AND_GROUP (src_sb, dst_sb)))
        -: 2544:    {
    #####: 2545:      switch (set_owner (x, dst_name, -1, &src_sb, new_dst, &dst_sb))
        -: 2546:        {
        -: 2547:        case -1:
    #####: 2548:          return false;
        -: 2549:
        -: 2550:        case 0:
    #####: 2551:          src_mode &= ~ (S_ISUID | S_ISGID | S_ISVTX);
    #####: 2552:          break;
        -: 2553:        }
        -: 2554:    }
        -: 2555:
    #####: 2556:  set_author (dst_name, -1, &src_sb);
        -: 2557:
    #####: 2558:  if (x->preserve_xattr && ! copy_attr (src_name, -1, dst_name, -1, x)
    #####: 2559:      && x->require_preserve_xattr)
    #####: 2560:    return false;
        -: 2561:
    #####: 2562:  if (x->preserve_mode || x->move_mode)
        -: 2563:    {
    #####: 2564:      if (copy_acl (src_name, -1, dst_name, -1, src_mode) != 0
    #####: 2565:          && x->require_preserve)
    #####: 2566:        return false;
        -: 2567:    }
    #####: 2568:  else if (x->set_mode)
        -: 2569:    {
    #####: 2570:      if (set_acl (dst_name, -1, x->mode) != 0)
    #####: 2571:        return false;
        -: 2572:    }
        -: 2573:  else
        -: 2574:    {
    #####: 2575:      if (omitted_permissions)
        -: 2576:        {
    #####: 2577:          omitted_permissions &= ~ cached_umask ();
        -: 2578:
    #####: 2579:          if (omitted_permissions && !restore_dst_mode)
        -: 2580:            {
        -: 2581:              /* Permissions were deliberately omitted when the file
        -: 2582:                 was created due to security concerns.  See whether
        -: 2583:                 they need to be re-added now.  It'd be faster to omit
        -: 2584:                 the lstat, but deducing the current destination mode
        -: 2585:                 is tricky in the presence of implementation-defined
        -: 2586:                 rules for special mode bits.  */
    #####: 2587:              if (new_dst && lstat (dst_name, &dst_sb) != 0)
        -: 2588:                {
    #####: 2589:                  error (0, errno, _("cannot stat %s"), quote (dst_name));
    #####: 2590:                  return false;
        -: 2591:                }
    #####: 2592:              dst_mode = dst_sb.st_mode;
    #####: 2593:              if (omitted_permissions & ~dst_mode)
    #####: 2594:                restore_dst_mode = true;
        -: 2595:            }
        -: 2596:        }
        -: 2597:
    #####: 2598:      if (restore_dst_mode)
        -: 2599:        {
    #####: 2600:          if (lchmod (dst_name, dst_mode | omitted_permissions) != 0)
        -: 2601:            {
    #####: 2602:              error (0, errno, _("preserving permissions for %s"),
        -: 2603:                     quote (dst_name));
    #####: 2604:              if (x->require_preserve)
    #####: 2605:                return false;
        -: 2606:            }
        -: 2607:        }
        -: 2608:    }
        -: 2609:
    #####: 2610:  return delayed_ok;
        -: 2611:
        -: 2612:un_backup:
        -: 2613:
    #####: 2614:  if (x->preserve_security_context)
    #####: 2615:    restore_default_fscreatecon_or_die ();
        -: 2616:
        -: 2617:  /* We have failed to create the destination file.
        -: 2618:     If we've just added a dev/ino entry via the remember_copied
        -: 2619:     call above (i.e., unless we've just failed to create a hard link),
        -: 2620:     remove the entry associating the source dev/ino with the
        -: 2621:     destination file name, so we don't try to 'preserve' a link
        -: 2622:     to a file we didn't create.  */
    #####: 2623:  if (earlier_file == NULL)
    #####: 2624:    forget_created (src_sb.st_ino, src_sb.st_dev);
        -: 2625:
    #####: 2626:  if (dst_backup)
        -: 2627:    {
    #####: 2628:      if (rename (dst_backup, dst_name) != 0)
    #####: 2629:        error (0, errno, _("cannot un-backup %s"), quote (dst_name));
        -: 2630:      else
        -: 2631:        {
    #####: 2632:          if (x->verbose)
    #####: 2633:            printf (_("%s -> %s (unbackup)\n"),
        -: 2634:                    quote_n (0, dst_backup), quote_n (1, dst_name));
        -: 2635:        }
        -: 2636:    }
    #####: 2637:  return false;
        -: 2638:}
        -: 2639:
        -: 2640:static bool _GL_ATTRIBUTE_PURE
        5: 2641:valid_options (const struct cp_options *co)
        -: 2642:{
        5: 2643:  assert (co != NULL);
        5: 2644:  assert (VALID_BACKUP_TYPE (co->backup_type));
        5: 2645:  assert (VALID_SPARSE_MODE (co->sparse_mode));
        5: 2646:  assert (VALID_REFLINK_MODE (co->reflink_mode));
        5: 2647:  assert (!(co->hard_link && co->symbolic_link));
        5: 2648:  assert (!
        -: 2649:          (co->reflink_mode == REFLINK_ALWAYS
        -: 2650:           && co->sparse_mode != SPARSE_AUTO));
        5: 2651:  return true;
        -: 2652:}
        -: 2653:
        -: 2654:/* Copy the file SRC_NAME to the file DST_NAME.  The files may be of
        -: 2655:   any type.  NONEXISTENT_DST should be true if the file DST_NAME
        -: 2656:   is known not to exist (e.g., because its parent directory was just
        -: 2657:   created);  NONEXISTENT_DST should be false if DST_NAME might already
        -: 2658:   exist.  OPTIONS is ... FIXME-describe
        -: 2659:   Set *COPY_INTO_SELF if SRC_NAME is a parent of (or the
        -: 2660:   same as) DST_NAME; otherwise, set clear it.
        -: 2661:   Return true if successful.  */
        -: 2662:
        -: 2663:extern bool
        5: 2664:copy (char const *src_name, char const *dst_name,
        -: 2665:      bool nonexistent_dst, const struct cp_options *options,
        -: 2666:      bool *copy_into_self, bool *rename_succeeded)
        -: 2667:{
        5: 2668:  assert (valid_options (options));
        -: 2669:
        -: 2670:  /* Record the file names: they're used in case of error, when copying
        -: 2671:     a directory into itself.  I don't like to make these tools do *any*
        -: 2672:     extra work in the common case when that work is solely to handle
        -: 2673:     exceptional cases, but in this case, I don't see a way to derive the
        -: 2674:     top level source and destination directory names where they're used.
        -: 2675:     An alternative is to use COPY_INTO_SELF and print the diagnostic
        -: 2676:     from every caller -- but I don't want to do that.  */
        5: 2677:  top_level_src_name = src_name;
        5: 2678:  top_level_dst_name = dst_name;
        -: 2679:
        5: 2680:  bool first_dir_created_per_command_line_arg = false;
        5: 2681:  return copy_internal (src_name, dst_name, nonexistent_dst, 0, NULL,
        -: 2682:                        options, true,
        -: 2683:                        &first_dir_created_per_command_line_arg,
        -: 2684:                        copy_into_self, rename_succeeded);
        -: 2685:}
        -: 2686:
        -: 2687:/* Set *X to the default options for a value of type struct cp_options.  */
        -: 2688:
        -: 2689:extern void
        5: 2690:cp_options_default (struct cp_options *x)
        -: 2691:{
        5: 2692:  memset (x, 0, sizeof *x);
        -: 2693:#ifdef PRIV_FILE_CHOWN
        -: 2694:  {
        -: 2695:    priv_set_t *pset = priv_allocset ();
        -: 2696:    if (!pset)
        -: 2697:      xalloc_die ();
        -: 2698:    if (getppriv (PRIV_EFFECTIVE, pset) == 0)
        -: 2699:      {
        -: 2700:        x->chown_privileges = priv_ismember (pset, PRIV_FILE_CHOWN);
        -: 2701:        x->owner_privileges = priv_ismember (pset, PRIV_FILE_OWNER);
        -: 2702:      }
        -: 2703:    priv_freeset (pset);
        -: 2704:  }
        -: 2705:#else
        5: 2706:  x->chown_privileges = x->owner_privileges = (geteuid () == 0);
        -: 2707:#endif
        5: 2708:}
        -: 2709:
        -: 2710:/* Return true if it's OK for chown to fail, where errno is
        -: 2711:   the error number that chown failed with and X is the copying
        -: 2712:   option set.  */
        -: 2713:
        -: 2714:extern bool
    #####: 2715:chown_failure_ok (struct cp_options const *x)
        -: 2716:{
        -: 2717:  /* If non-root uses -p, it's ok if we can't preserve ownership.
        -: 2718:     But root probably wants to know, e.g. if NFS disallows it,
        -: 2719:     or if the target system doesn't support file ownership.  */
        -: 2720:
    #####: 2721:  return ((errno == EPERM || errno == EINVAL) && !x->chown_privileges);
        -: 2722:}
        -: 2723:
        -: 2724:/* Similarly, return true if it's OK for chmod and similar operations
        -: 2725:   to fail, where errno is the error number that chmod failed with and
        -: 2726:   X is the copying option set.  */
        -: 2727:
        -: 2728:static bool
    #####: 2729:owner_failure_ok (struct cp_options const *x)
        -: 2730:{
    #####: 2731:  return ((errno == EPERM || errno == EINVAL) && !x->owner_privileges);
        -: 2732:}
        -: 2733:
        -: 2734:/* Return the user's umask, caching the result.  */
        -: 2735:
        -: 2736:extern mode_t
    #####: 2737:cached_umask (void)
        -: 2738:{
        -: 2739:  static mode_t mask = (mode_t) -1;
    #####: 2740:  if (mask == (mode_t) -1)
        -: 2741:    {
    #####: 2742:      mask = umask (0);
    #####: 2743:      umask (mask);
        -: 2744:    }
    #####: 2745:  return mask;
        -: 2746:}
