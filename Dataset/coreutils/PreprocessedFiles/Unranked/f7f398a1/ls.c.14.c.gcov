        -:    0:Source:ls.c
        -:    0:Graph:ls.gcno
        -:    0:Data:ls.gcda
        -:    0:Runs:10
        -:    0:Programs:1
        -:    1:/* 'dir', 'vdir' and 'ls' directory listing programs for GNU.
        -:    2:   Copyright (C) 1985-2012 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* If ls_mode is LS_MULTI_COL,
        -:   18:   the multi-column format is the default regardless
        -:   19:   of the type of output device.
        -:   20:   This is for the 'dir' program.
        -:   21:
        -:   22:   If ls_mode is LS_LONG_FORMAT,
        -:   23:   the long format is the default regardless of the
        -:   24:   type of output device.
        -:   25:   This is for the 'vdir' program.
        -:   26:
        -:   27:   If ls_mode is LS_LS,
        -:   28:   the output format depends on whether the output
        -:   29:   device is a terminal.
        -:   30:   This is for the 'ls' program.  */
        -:   31:
        -:   32:/* Written by Richard Stallman and David MacKenzie.  */
        -:   33:
        -:   34:/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis
        -:   35:   Flaherty <dennisf@denix.elk.miles.com> based on original patches by
        -:   36:   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */
        -:   37:
        -:   38:#include <config.h>
        -:   39:#include <sys/types.h>
        -:   40:
        -:   41:#include <termios.h>
        -:   42:#if HAVE_STROPTS_H
        -:   43:# include <stropts.h>
        -:   44:#endif
        -:   45:#include <sys/ioctl.h>
        -:   46:
        -:   47:#ifdef WINSIZE_IN_PTEM
        -:   48:# include <sys/stream.h>
        -:   49:# include <sys/ptem.h>
        -:   50:#endif
        -:   51:
        -:   52:#include <stdio.h>
        -:   53:#include <assert.h>
        -:   54:#include <setjmp.h>
        -:   55:#include <pwd.h>
        -:   56:#include <getopt.h>
        -:   57:#include <signal.h>
        -:   58:#include <selinux/selinux.h>
        -:   59:#include <wchar.h>
        -:   60:
        -:   61:#if HAVE_LANGINFO_CODESET
        -:   62:# include <langinfo.h>
        -:   63:#endif
        -:   64:
        -:   65:/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
        -:   66:   present.  */
        -:   67:#ifndef SA_NOCLDSTOP
        -:   68:# define SA_NOCLDSTOP 0
        -:   69:# define sigprocmask(How, Set, Oset) /* empty */
        -:   70:# define sigset_t int
        -:   71:# if ! HAVE_SIGINTERRUPT
        -:   72:#  define siginterrupt(sig, flag) /* empty */
        -:   73:# endif
        -:   74:#endif
        -:   75:
        -:   76:/* NonStop circa 2011 lacks both SA_RESTART and siginterrupt, so don't
        -:   77:   restart syscalls after a signal handler fires.  This may cause
        -:   78:   colors to get messed up on the screen if 'ls' is interrupted, but
        -:   79:   that's the best we can do on such a platform.  */
        -:   80:#ifndef SA_RESTART
        -:   81:# define SA_RESTART 0
        -:   82:#endif
        -:   83:
        -:   84:#include "system.h"
        -:   85:#include <fnmatch.h>
        -:   86:
        -:   87:#include "acl.h"
        -:   88:#include "argmatch.h"
        -:   89:#include "dev-ino.h"
        -:   90:#include "error.h"
        -:   91:#include "filenamecat.h"
        -:   92:#include "hard-locale.h"
        -:   93:#include "hash.h"
        -:   94:#include "human.h"
        -:   95:#include "filemode.h"
        -:   96:#include "filevercmp.h"
        -:   97:#include "idcache.h"
        -:   98:#include "ls.h"
        -:   99:#include "mbswidth.h"
        -:  100:#include "mpsort.h"
        -:  101:#include "obstack.h"
        -:  102:#include "quote.h"
        -:  103:#include "quotearg.h"
        -:  104:#include "stat-size.h"
        -:  105:#include "stat-time.h"
        -:  106:#include "strftime.h"
        -:  107:#include "xstrtol.h"
        -:  108:#include "areadlink.h"
        -:  109:#include "mbsalign.h"
        -:  110:
        -:  111:/* Include <sys/capability.h> last to avoid a clash of <sys/types.h>
        -:  112:   include guards with some premature versions of libcap.
        -:  113:   For more details, see <http://bugzilla.redhat.com/483548>.  */
        -:  114:#ifdef HAVE_CAP
        -:  115:# include <sys/capability.h>
        -:  116:#endif
        -:  117:
        -:  118:#define PROGRAM_NAME (ls_mode == LS_LS ? "ls" \
        -:  119:                      : (ls_mode == LS_MULTI_COL \
        -:  120:                         ? "dir" : "vdir"))
        -:  121:
        -:  122:#define AUTHORS \
        -:  123:  proper_name ("Richard M. Stallman"), \
        -:  124:  proper_name ("David MacKenzie")
        -:  125:
        -:  126:#define obstack_chunk_alloc malloc
        -:  127:#define obstack_chunk_free free
        -:  128:
        -:  129:/* Return an int indicating the result of comparing two integers.
        -:  130:   Subtracting doesn't always work, due to overflow.  */
        -:  131:#define longdiff(a, b) ((a) < (b) ? -1 : (a) > (b))
        -:  132:
        -:  133:/* Unix-based readdir implementations have historically returned a dirent.d_ino
        -:  134:   value that is sometimes not equal to the stat-obtained st_ino value for
        -:  135:   that same entry.  This error occurs for a readdir entry that refers
        -:  136:   to a mount point.  readdir's error is to return the inode number of
        -:  137:   the underlying directory -- one that typically cannot be stat'ed, as
        -:  138:   long as a file system is mounted on that directory.  RELIABLE_D_INO
        -:  139:   encapsulates whether we can use the more efficient approach of relying
        -:  140:   on readdir-supplied d_ino values, or whether we must incur the cost of
        -:  141:   calling stat or lstat to obtain each guaranteed-valid inode number.  */
        -:  142:
        -:  143:#ifndef READDIR_LIES_ABOUT_MOUNTPOINT_D_INO
        -:  144:# define READDIR_LIES_ABOUT_MOUNTPOINT_D_INO 1
        -:  145:#endif
        -:  146:
        -:  147:#if READDIR_LIES_ABOUT_MOUNTPOINT_D_INO
        -:  148:# define RELIABLE_D_INO(dp) NOT_AN_INODE_NUMBER
        -:  149:#else
        -:  150:# define RELIABLE_D_INO(dp) D_INO (dp)
        -:  151:#endif
        -:  152:
        -:  153:#if ! HAVE_STRUCT_STAT_ST_AUTHOR
        -:  154:# define st_author st_uid
        -:  155:#endif
        -:  156:
        -:  157:enum filetype
        -:  158:  {
        -:  159:    unknown,
        -:  160:    fifo,
        -:  161:    chardev,
        -:  162:    directory,
        -:  163:    blockdev,
        -:  164:    normal,
        -:  165:    symbolic_link,
        -:  166:    sock,
        -:  167:    whiteout,
        -:  168:    arg_directory
        -:  169:  };
        -:  170:
        -:  171:/* Display letters and indicators for each filetype.
        -:  172:   Keep these in sync with enum filetype.  */
        -:  173:static char const filetype_letter[] = "?pcdb-lswd";
        -:  174:
        -:  175:/* Ensure that filetype and filetype_letter have the same
        -:  176:   number of elements.  */
        -:  177:verify (sizeof filetype_letter - 1 == arg_directory + 1);
        -:  178:
        -:  179:#define FILETYPE_INDICATORS				\
        -:  180:  {							\
        -:  181:    C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE,	\
        -:  182:    C_LINK, C_SOCK, C_FILE, C_DIR			\
        -:  183:  }
        -:  184:
        -:  185:enum acl_type
        -:  186:  {
        -:  187:    ACL_T_NONE,
        -:  188:    ACL_T_SELINUX_ONLY,
        -:  189:    ACL_T_YES
        -:  190:  };
        -:  191:
        -:  192:struct fileinfo
        -:  193:  {
        -:  194:    /* The file name.  */
        -:  195:    char *name;
        -:  196:
        -:  197:    /* For symbolic link, name of the file linked to, otherwise zero.  */
        -:  198:    char *linkname;
        -:  199:
        -:  200:    struct stat stat;
        -:  201:
        -:  202:    enum filetype filetype;
        -:  203:
        -:  204:    /* For symbolic link and long listing, st_mode of file linked to, otherwise
        -:  205:       zero.  */
        -:  206:    mode_t linkmode;
        -:  207:
        -:  208:    /* SELinux security context.  */
        -:  209:    security_context_t scontext;
        -:  210:
        -:  211:    bool stat_ok;
        -:  212:
        -:  213:    /* For symbolic link and color printing, true if linked-to file
        -:  214:       exists, otherwise false.  */
        -:  215:    bool linkok;
        -:  216:
        -:  217:    /* For long listings, true if the file has an access control list,
        -:  218:       or an SELinux security context.  */
        -:  219:    enum acl_type acl_type;
        -:  220:
        -:  221:    /* For color listings, true if a regular file has capability info.  */
        -:  222:    bool has_capability;
        -:  223:  };
        -:  224:
        -:  225:#define LEN_STR_PAIR(s) sizeof (s) - 1, s
        -:  226:
        -:  227:/* Null is a valid character in a color indicator (think about Epson
        -:  228:   printers, for example) so we have to use a length/buffer string
        -:  229:   type.  */
        -:  230:
        -:  231:struct bin_str
        -:  232:  {
        -:  233:    size_t len;			/* Number of bytes */
        -:  234:    const char *string;		/* Pointer to the same */
        -:  235:  };
        -:  236:
        -:  237:#if ! HAVE_TCGETPGRP
        -:  238:# define tcgetpgrp(Fd) 0
        -:  239:#endif
        -:  240:
        -:  241:static size_t quote_name (FILE *out, const char *name,
        -:  242:                          struct quoting_options const *options,
        -:  243:                          size_t *width);
        -:  244:static char *make_link_name (char const *name, char const *linkname);
        -:  245:static int decode_switches (int argc, char **argv);
        -:  246:static bool file_ignored (char const *name);
        -:  247:static uintmax_t gobble_file (char const *name, enum filetype type,
        -:  248:                              ino_t inode, bool command_line_arg,
        -:  249:                              char const *dirname);
        -:  250:static bool print_color_indicator (const struct fileinfo *f,
        -:  251:                                   bool symlink_target);
        -:  252:static void put_indicator (const struct bin_str *ind);
        -:  253:static void add_ignore_pattern (const char *pattern);
        -:  254:static void attach (char *dest, const char *dirname, const char *name);
        -:  255:static void clear_files (void);
        -:  256:static void extract_dirs_from_files (char const *dirname,
        -:  257:                                     bool command_line_arg);
        -:  258:static void get_link_name (char const *filename, struct fileinfo *f,
        -:  259:                           bool command_line_arg);
        -:  260:static void indent (size_t from, size_t to);
        -:  261:static size_t calculate_columns (bool by_columns);
        -:  262:static void print_current_files (void);
        -:  263:static void print_dir (char const *name, char const *realname,
        -:  264:                       bool command_line_arg);
        -:  265:static size_t print_file_name_and_frills (const struct fileinfo *f,
        -:  266:                                          size_t start_col);
        -:  267:static void print_horizontal (void);
        -:  268:static int format_user_width (uid_t u);
        -:  269:static int format_group_width (gid_t g);
        -:  270:static void print_long_format (const struct fileinfo *f);
        -:  271:static void print_many_per_line (void);
        -:  272:static size_t print_name_with_quoting (const struct fileinfo *f,
        -:  273:                                       bool symlink_target,
        -:  274:                                       struct obstack *stack,
        -:  275:                                       size_t start_col);
        -:  276:static void prep_non_filename_text (void);
        -:  277:static bool print_type_indicator (bool stat_ok, mode_t mode,
        -:  278:                                  enum filetype type);
        -:  279:static void print_with_commas (void);
        -:  280:static void queue_directory (char const *name, char const *realname,
        -:  281:                             bool command_line_arg);
        -:  282:static void sort_files (void);
        -:  283:static void parse_ls_color (void);
        -:  284:
        -:  285:/* Initial size of hash table.
        -:  286:   Most hierarchies are likely to be shallower than this.  */
        -:  287:#define INITIAL_TABLE_SIZE 30
        -:  288:
        -:  289:/* The set of 'active' directories, from the current command-line argument
        -:  290:   to the level in the hierarchy at which files are being listed.
        -:  291:   A directory is represented by its device and inode numbers (struct dev_ino).
        -:  292:   A directory is added to this set when ls begins listing it or its
        -:  293:   entries, and it is removed from the set just after ls has finished
        -:  294:   processing it.  This set is used solely to detect loops, e.g., with
        -:  295:   mkdir loop; cd loop; ln -s ../loop sub; ls -RL  */
        -:  296:static Hash_table *active_dir_set;
        -:  297:
        -:  298:#define LOOP_DETECT (!!active_dir_set)
        -:  299:
        -:  300:/* The table of files in the current directory:
        -:  301:
        -:  302:   'cwd_file' points to a vector of 'struct fileinfo', one per file.
        -:  303:   'cwd_n_alloc' is the number of elements space has been allocated for.
        -:  304:   'cwd_n_used' is the number actually in use.  */
        -:  305:
        -:  306:/* Address of block containing the files that are described.  */
        -:  307:static struct fileinfo *cwd_file;
        -:  308:
        -:  309:/* Length of block that 'cwd_file' points to, measured in files.  */
        -:  310:static size_t cwd_n_alloc;
        -:  311:
        -:  312:/* Index of first unused slot in 'cwd_file'.  */
        -:  313:static size_t cwd_n_used;
        -:  314:
        -:  315:/* Vector of pointers to files, in proper sorted order, and the number
        -:  316:   of entries allocated for it.  */
        -:  317:static void **sorted_file;
        -:  318:static size_t sorted_file_alloc;
        -:  319:
        -:  320:/* When true, in a color listing, color each symlink name according to the
        -:  321:   type of file it points to.  Otherwise, color them according to the 'ln'
        -:  322:   directive in LS_COLORS.  Dangling (orphan) symlinks are treated specially,
        -:  323:   regardless.  This is set when 'ln=target' appears in LS_COLORS.  */
        -:  324:
        -:  325:static bool color_symlink_as_referent;
        -:  326:
        -:  327:/* mode of appropriate file for colorization */
        -:  328:#define FILE_OR_LINK_MODE(File) \
        -:  329:    ((color_symlink_as_referent && (File)->linkok) \
        -:  330:     ? (File)->linkmode : (File)->stat.st_mode)
        -:  331:
        -:  332:
        -:  333:/* Record of one pending directory waiting to be listed.  */
        -:  334:
        -:  335:struct pending
        -:  336:  {
        -:  337:    char *name;
        -:  338:    /* If the directory is actually the file pointed to by a symbolic link we
        -:  339:       were told to list, 'realname' will contain the name of the symbolic
        -:  340:       link, otherwise zero.  */
        -:  341:    char *realname;
        -:  342:    bool command_line_arg;
        -:  343:    struct pending *next;
        -:  344:  };
        -:  345:
        -:  346:static struct pending *pending_dirs;
        -:  347:
        -:  348:/* Current time in seconds and nanoseconds since 1970, updated as
        -:  349:   needed when deciding whether a file is recent.  */
        -:  350:
        -:  351:static struct timespec current_time;
        -:  352:
        -:  353:static bool print_scontext;
        -:  354:static char UNKNOWN_SECURITY_CONTEXT[] = "?";
        -:  355:
        -:  356:/* Whether any of the files has an ACL.  This affects the width of the
        -:  357:   mode column.  */
        -:  358:
        -:  359:static bool any_has_acl;
        -:  360:
        -:  361:/* The number of columns to use for columns containing inode numbers,
        -:  362:   block sizes, link counts, owners, groups, authors, major device
        -:  363:   numbers, minor device numbers, and file sizes, respectively.  */
        -:  364:
        -:  365:static int inode_number_width;
        -:  366:static int block_size_width;
        -:  367:static int nlink_width;
        -:  368:static int scontext_width;
        -:  369:static int owner_width;
        -:  370:static int group_width;
        -:  371:static int author_width;
        -:  372:static int major_device_number_width;
        -:  373:static int minor_device_number_width;
        -:  374:static int file_size_width;
        -:  375:
        -:  376:/* Option flags */
        -:  377:
        -:  378:/* long_format for lots of info, one per line.
        -:  379:   one_per_line for just names, one per line.
        -:  380:   many_per_line for just names, many per line, sorted vertically.
        -:  381:   horizontal for just names, many per line, sorted horizontally.
        -:  382:   with_commas for just names, many per line, separated by commas.
        -:  383:
        -:  384:   -l (and other options that imply -l), -1, -C, -x and -m control
        -:  385:   this parameter.  */
        -:  386:
        -:  387:enum format
        -:  388:  {
        -:  389:    long_format,		/* -l and other options that imply -l */
        -:  390:    one_per_line,		/* -1 */
        -:  391:    many_per_line,		/* -C */
        -:  392:    horizontal,			/* -x */
        -:  393:    with_commas			/* -m */
        -:  394:  };
        -:  395:
        -:  396:static enum format format;
        -:  397:
        -:  398:/* 'full-iso' uses full ISO-style dates and times.  'long-iso' uses longer
        -:  399:   ISO-style time stamps, though shorter than 'full-iso'.  'iso' uses shorter
        -:  400:   ISO-style time stamps.  'locale' uses locale-dependent time stamps.  */
        -:  401:enum time_style
        -:  402:  {
        -:  403:    full_iso_time_style,	/* --time-style=full-iso */
        -:  404:    long_iso_time_style,	/* --time-style=long-iso */
        -:  405:    iso_time_style,		/* --time-style=iso */
        -:  406:    locale_time_style		/* --time-style=locale */
        -:  407:  };
        -:  408:
        -:  409:static char const *const time_style_args[] =
        -:  410:{
        -:  411:  "full-iso", "long-iso", "iso", "locale", NULL
        -:  412:};
        -:  413:static enum time_style const time_style_types[] =
        -:  414:{
        -:  415:  full_iso_time_style, long_iso_time_style, iso_time_style,
        -:  416:  locale_time_style
        -:  417:};
        -:  418:ARGMATCH_VERIFY (time_style_args, time_style_types);
        -:  419:
        -:  420:/* Type of time to print or sort by.  Controlled by -c and -u.
        -:  421:   The values of each item of this enum are important since they are
        -:  422:   used as indices in the sort functions array (see sort_files()).  */
        -:  423:
        -:  424:enum time_type
        -:  425:  {
        -:  426:    time_mtime,			/* default */
        -:  427:    time_ctime,			/* -c */
        -:  428:    time_atime,			/* -u */
        -:  429:    time_numtypes		/* the number of elements of this enum */
        -:  430:  };
        -:  431:
        -:  432:static enum time_type time_type;
        -:  433:
        -:  434:/* The file characteristic to sort by.  Controlled by -t, -S, -U, -X, -v.
        -:  435:   The values of each item of this enum are important since they are
        -:  436:   used as indices in the sort functions array (see sort_files()).  */
        -:  437:
        -:  438:enum sort_type
        -:  439:  {
        -:  440:    sort_none = -1,		/* -U */
        -:  441:    sort_name,			/* default */
        -:  442:    sort_extension,		/* -X */
        -:  443:    sort_size,			/* -S */
        -:  444:    sort_version,		/* -v */
        -:  445:    sort_time,			/* -t */
        -:  446:    sort_numtypes		/* the number of elements of this enum */
        -:  447:  };
        -:  448:
        -:  449:static enum sort_type sort_type;
        -:  450:
        -:  451:/* Direction of sort.
        -:  452:   false means highest first if numeric,
        -:  453:   lowest first if alphabetic;
        -:  454:   these are the defaults.
        -:  455:   true means the opposite order in each case.  -r  */
        -:  456:
        -:  457:static bool sort_reverse;
        -:  458:
        -:  459:/* True means to display owner information.  -g turns this off.  */
        -:  460:
        -:  461:static bool print_owner = true;
        -:  462:
        -:  463:/* True means to display author information.  */
        -:  464:
        -:  465:static bool print_author;
        -:  466:
        -:  467:/* True means to display group information.  -G and -o turn this off.  */
        -:  468:
        -:  469:static bool print_group = true;
        -:  470:
        -:  471:/* True means print the user and group id's as numbers rather
        -:  472:   than as names.  -n  */
        -:  473:
        -:  474:static bool numeric_ids;
        -:  475:
        -:  476:/* True means mention the size in blocks of each file.  -s  */
        -:  477:
        -:  478:static bool print_block_size;
        -:  479:
        -:  480:/* Human-readable options for output, when printing block counts.  */
        -:  481:static int human_output_opts;
        -:  482:
        -:  483:/* The units to use when printing block counts.  */
        -:  484:static uintmax_t output_block_size;
        -:  485:
        -:  486:/* Likewise, but for file sizes.  */
        -:  487:static int file_human_output_opts;
        -:  488:static uintmax_t file_output_block_size = 1;
        -:  489:
        -:  490:/* Follow the output with a special string.  Using this format,
        -:  491:   Emacs' dired mode starts up twice as fast, and can handle all
        -:  492:   strange characters in file names.  */
        -:  493:static bool dired;
        -:  494:
        -:  495:/* 'none' means don't mention the type of files.
        -:  496:   'slash' means mention directories only, with a '/'.
        -:  497:   'file_type' means mention file types.
        -:  498:   'classify' means mention file types and mark executables.
        -:  499:
        -:  500:   Controlled by -F, -p, and --indicator-style.  */
        -:  501:
        -:  502:enum indicator_style
        -:  503:  {
        -:  504:    none,	/*     --indicator-style=none */
        -:  505:    slash,	/* -p, --indicator-style=slash */
        -:  506:    file_type,	/*     --indicator-style=file-type */
        -:  507:    classify	/* -F, --indicator-style=classify */
        -:  508:  };
        -:  509:
        -:  510:static enum indicator_style indicator_style;
        -:  511:
        -:  512:/* Names of indicator styles.  */
        -:  513:static char const *const indicator_style_args[] =
        -:  514:{
        -:  515:  "none", "slash", "file-type", "classify", NULL
        -:  516:};
        -:  517:static enum indicator_style const indicator_style_types[] =
        -:  518:{
        -:  519:  none, slash, file_type, classify
        -:  520:};
        -:  521:ARGMATCH_VERIFY (indicator_style_args, indicator_style_types);
        -:  522:
        -:  523:/* True means use colors to mark types.  Also define the different
        -:  524:   colors as well as the stuff for the LS_COLORS environment variable.
        -:  525:   The LS_COLORS variable is now in a termcap-like format.  */
        -:  526:
        -:  527:static bool print_with_color;
        -:  528:
        -:  529:/* Whether we used any colors in the output so far.  If so, we will
        -:  530:   need to restore the default color later.  If not, we will need to
        -:  531:   call prep_non_filename_text before using color for the first time. */
        -:  532:
        -:  533:static bool used_color = false;
        -:  534:
        -:  535:enum color_type
        -:  536:  {
        -:  537:    color_never,		/* 0: default or --color=never */
        -:  538:    color_always,		/* 1: --color=always */
        -:  539:    color_if_tty		/* 2: --color=tty */
        -:  540:  };
        -:  541:
        -:  542:enum Dereference_symlink
        -:  543:  {
        -:  544:    DEREF_UNDEFINED = 1,
        -:  545:    DEREF_NEVER,
        -:  546:    DEREF_COMMAND_LINE_ARGUMENTS,	/* -H */
        -:  547:    DEREF_COMMAND_LINE_SYMLINK_TO_DIR,	/* the default, in certain cases */
        -:  548:    DEREF_ALWAYS			/* -L */
        -:  549:  };
        -:  550:
        -:  551:enum indicator_no
        -:  552:  {
        -:  553:    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,
        -:  554:    C_FIFO, C_SOCK,
        -:  555:    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,
        -:  556:    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,
        -:  557:    C_CLR_TO_EOL
        -:  558:  };
        -:  559:
        -:  560:static const char *const indicator_name[]=
        -:  561:  {
        -:  562:    "lc", "rc", "ec", "rs", "no", "fi", "di", "ln", "pi", "so",
        -:  563:    "bd", "cd", "mi", "or", "ex", "do", "su", "sg", "st",
        -:  564:    "ow", "tw", "ca", "mh", "cl", NULL
        -:  565:  };
        -:  566:
        -:  567:struct color_ext_type
        -:  568:  {
        -:  569:    struct bin_str ext;		/* The extension we're looking for */
        -:  570:    struct bin_str seq;		/* The sequence to output when we do */
        -:  571:    struct color_ext_type *next;	/* Next in list */
        -:  572:  };
        -:  573:
        -:  574:static struct bin_str color_indicator[] =
        -:  575:  {
        -:  576:    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
        -:  577:    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
        -:  578:    { 0, NULL },			/* ec: End color (replaces lc+no+rc) */
        -:  579:    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
        -:  580:    { 0, NULL },			/* no: Normal */
        -:  581:    { 0, NULL },			/* fi: File: default */
        -:  582:    { LEN_STR_PAIR ("01;34") },		/* di: Directory: bright blue */
        -:  583:    { LEN_STR_PAIR ("01;36") },		/* ln: Symlink: bright cyan */
        -:  584:    { LEN_STR_PAIR ("33") },		/* pi: Pipe: yellow/brown */
        -:  585:    { LEN_STR_PAIR ("01;35") },		/* so: Socket: bright magenta */
        -:  586:    { LEN_STR_PAIR ("01;33") },		/* bd: Block device: bright yellow */
        -:  587:    { LEN_STR_PAIR ("01;33") },		/* cd: Char device: bright yellow */
        -:  588:    { 0, NULL },			/* mi: Missing file: undefined */
        -:  589:    { 0, NULL },			/* or: Orphaned symlink: undefined */
        -:  590:    { LEN_STR_PAIR ("01;32") },		/* ex: Executable: bright green */
        -:  591:    { LEN_STR_PAIR ("01;35") },		/* do: Door: bright magenta */
        -:  592:    { LEN_STR_PAIR ("37;41") },		/* su: setuid: white on red */
        -:  593:    { LEN_STR_PAIR ("30;43") },		/* sg: setgid: black on yellow */
        -:  594:    { LEN_STR_PAIR ("37;44") },		/* st: sticky: black on blue */
        -:  595:    { LEN_STR_PAIR ("34;42") },		/* ow: other-writable: blue on green */
        -:  596:    { LEN_STR_PAIR ("30;42") },		/* tw: ow w/ sticky: black on green */
        -:  597:    { LEN_STR_PAIR ("30;41") },		/* ca: black on red */
        -:  598:    { 0, NULL },			/* mh: disabled by default */
        -:  599:    { LEN_STR_PAIR ("\033[K") },	/* cl: clear to end of line */
        -:  600:  };
        -:  601:
        -:  602:/* FIXME: comment  */
        -:  603:static struct color_ext_type *color_ext_list = NULL;
        -:  604:
        -:  605:/* Buffer for color sequences */
        -:  606:static char *color_buf;
        -:  607:
        -:  608:/* True means to check for orphaned symbolic link, for displaying
        -:  609:   colors.  */
        -:  610:
        -:  611:static bool check_symlink_color;
        -:  612:
        -:  613:/* True means mention the inode number of each file.  -i  */
        -:  614:
        -:  615:static bool print_inode;
        -:  616:
        -:  617:/* What to do with symbolic links.  Affected by -d, -F, -H, -l (and
        -:  618:   other options that imply -l), and -L.  */
        -:  619:
        -:  620:static enum Dereference_symlink dereference;
        -:  621:
        -:  622:/* True means when a directory is found, display info on its
        -:  623:   contents.  -R  */
        -:  624:
        -:  625:static bool recursive;
        -:  626:
        -:  627:/* True means when an argument is a directory name, display info
        -:  628:   on it itself.  -d  */
        -:  629:
        -:  630:static bool immediate_dirs;
        -:  631:
        -:  632:/* True means that directories are grouped before files. */
        -:  633:
        -:  634:static bool directories_first;
        -:  635:
        -:  636:/* Which files to ignore.  */
        -:  637:
        -:  638:static enum
        -:  639:{
        -:  640:  /* Ignore files whose names start with '.', and files specified by
        -:  641:     --hide and --ignore.  */
        -:  642:  IGNORE_DEFAULT,
        -:  643:
        -:  644:  /* Ignore '.', '..', and files specified by --ignore.  */
        -:  645:  IGNORE_DOT_AND_DOTDOT,
        -:  646:
        -:  647:  /* Ignore only files specified by --ignore.  */
        -:  648:  IGNORE_MINIMAL
        -:  649:} ignore_mode;
        -:  650:
        -:  651:/* A linked list of shell-style globbing patterns.  If a non-argument
        -:  652:   file name matches any of these patterns, it is ignored.
        -:  653:   Controlled by -I.  Multiple -I options accumulate.
        -:  654:   The -B option adds '*~' and '.*~' to this list.  */
        -:  655:
        -:  656:struct ignore_pattern
        -:  657:  {
        -:  658:    const char *pattern;
        -:  659:    struct ignore_pattern *next;
        -:  660:  };
        -:  661:
        -:  662:static struct ignore_pattern *ignore_patterns;
        -:  663:
        -:  664:/* Similar to IGNORE_PATTERNS, except that -a or -A causes this
        -:  665:   variable itself to be ignored.  */
        -:  666:static struct ignore_pattern *hide_patterns;
        -:  667:
        -:  668:/* True means output nongraphic chars in file names as '?'.
        -:  669:   (-q, --hide-control-chars)
        -:  670:   qmark_funny_chars and the quoting style (-Q, --quoting-style=WORD) are
        -:  671:   independent.  The algorithm is: first, obey the quoting style to get a
        -:  672:   string representing the file name;  then, if qmark_funny_chars is set,
        -:  673:   replace all nonprintable chars in that string with '?'.  It's necessary
        -:  674:   to replace nonprintable chars even in quoted strings, because we don't
        -:  675:   want to mess up the terminal if control chars get sent to it, and some
        -:  676:   quoting methods pass through control chars as-is.  */
        -:  677:static bool qmark_funny_chars;
        -:  678:
        -:  679:/* Quoting options for file and dir name output.  */
        -:  680:
        -:  681:static struct quoting_options *filename_quoting_options;
        -:  682:static struct quoting_options *dirname_quoting_options;
        -:  683:
        -:  684:/* The number of chars per hardware tab stop.  Setting this to zero
        -:  685:   inhibits the use of TAB characters for separating columns.  -T */
        -:  686:static size_t tabsize;
        -:  687:
        -:  688:/* True means print each directory name before listing it.  */
        -:  689:
        -:  690:static bool print_dir_name;
        -:  691:
        -:  692:/* The line length to use for breaking lines in many-per-line format.
        -:  693:   Can be set with -w.  */
        -:  694:
        -:  695:static size_t line_length;
        -:  696:
        -:  697:/* If true, the file listing format requires that stat be called on
        -:  698:   each file.  */
        -:  699:
        -:  700:static bool format_needs_stat;
        -:  701:
        -:  702:/* Similar to 'format_needs_stat', but set if only the file type is
        -:  703:   needed.  */
        -:  704:
        -:  705:static bool format_needs_type;
        -:  706:
        -:  707:/* An arbitrary limit on the number of bytes in a printed time stamp.
        -:  708:   This is set to a relatively small value to avoid the need to worry
        -:  709:   about denial-of-service attacks on servers that run "ls" on behalf
        -:  710:   of remote clients.  1000 bytes should be enough for any practical
        -:  711:   time stamp format.  */
        -:  712:
        -:  713:enum { TIME_STAMP_LEN_MAXIMUM = MAX (1000, INT_STRLEN_BOUND (time_t)) };
        -:  714:
        -:  715:/* strftime formats for non-recent and recent files, respectively, in
        -:  716:   -l output.  */
        -:  717:
        -:  718:static char const *long_time_format[2] =
        -:  719:  {
        -:  720:    /* strftime format for non-recent files (older than 6 months), in
        -:  721:       -l output.  This should contain the year, month and day (at
        -:  722:       least), in an order that is understood by people in your
        -:  723:       locale's territory.  Please try to keep the number of used
        -:  724:       screen columns small, because many people work in windows with
        -:  725:       only 80 columns.  But make this as wide as the other string
        -:  726:       below, for recent files.  */
        -:  727:    /* TRANSLATORS: ls output needs to be aligned for ease of reading,
        -:  728:       so be wary of using variable width fields from the locale.
        -:  729:       Note %b is handled specially by ls and aligned correctly.
        -:  730:       Note also that specifying a width as in %5b is erroneous as strftime
        -:  731:       will count bytes rather than characters in multibyte locales.  */
        -:  732:    N_("%b %e  %Y"),
        -:  733:    /* strftime format for recent files (younger than 6 months), in -l
        -:  734:       output.  This should contain the month, day and time (at
        -:  735:       least), in an order that is understood by people in your
        -:  736:       locale's territory.  Please try to keep the number of used
        -:  737:       screen columns small, because many people work in windows with
        -:  738:       only 80 columns.  But make this as wide as the other string
        -:  739:       above, for non-recent files.  */
        -:  740:    /* TRANSLATORS: ls output needs to be aligned for ease of reading,
        -:  741:       so be wary of using variable width fields from the locale.
        -:  742:       Note %b is handled specially by ls and aligned correctly.
        -:  743:       Note also that specifying a width as in %5b is erroneous as strftime
        -:  744:       will count bytes rather than characters in multibyte locales.  */
        -:  745:    N_("%b %e %H:%M")
        -:  746:  };
        -:  747:
        -:  748:/* The set of signals that are caught.  */
        -:  749:
        -:  750:static sigset_t caught_signals;
        -:  751:
        -:  752:/* If nonzero, the value of the pending fatal signal.  */
        -:  753:
        -:  754:static sig_atomic_t volatile interrupt_signal;
        -:  755:
        -:  756:/* A count of the number of pending stop signals that have been received.  */
        -:  757:
        -:  758:static sig_atomic_t volatile stop_signal_count;
        -:  759:
        -:  760:/* Desired exit status.  */
        -:  761:
        -:  762:static int exit_status;
        -:  763:
        -:  764:/* Exit statuses.  */
        -:  765:enum
        -:  766:  {
        -:  767:    /* "ls" had a minor problem.  E.g., while processing a directory,
        -:  768:       ls obtained the name of an entry via readdir, yet was later
        -:  769:       unable to stat that name.  This happens when listing a directory
        -:  770:       in which entries are actively being removed or renamed.  */
        -:  771:    LS_MINOR_PROBLEM = 1,
        -:  772:
        -:  773:    /* "ls" had more serious trouble (e.g., memory exhausted, invalid
        -:  774:       option or failure to stat a command line argument.  */
        -:  775:    LS_FAILURE = 2
        -:  776:  };
        -:  777:
        -:  778:/* For long options that have no equivalent short option, use a
        -:  779:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  780:enum
        -:  781:{
        -:  782:  AUTHOR_OPTION = CHAR_MAX + 1,
        -:  783:  BLOCK_SIZE_OPTION,
        -:  784:  COLOR_OPTION,
        -:  785:  DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION,
        -:  786:  FILE_TYPE_INDICATOR_OPTION,
        -:  787:  FORMAT_OPTION,
        -:  788:  FULL_TIME_OPTION,
        -:  789:  GROUP_DIRECTORIES_FIRST_OPTION,
        -:  790:  HIDE_OPTION,
        -:  791:  INDICATOR_STYLE_OPTION,
        -:  792:  QUOTING_STYLE_OPTION,
        -:  793:  SHOW_CONTROL_CHARS_OPTION,
        -:  794:  SI_OPTION,
        -:  795:  SORT_OPTION,
        -:  796:  TIME_OPTION,
        -:  797:  TIME_STYLE_OPTION
        -:  798:};
        -:  799:
        -:  800:static struct option const long_options[] =
        -:  801:{
        -:  802:  {"all", no_argument, NULL, 'a'},
        -:  803:  {"escape", no_argument, NULL, 'b'},
        -:  804:  {"directory", no_argument, NULL, 'd'},
        -:  805:  {"dired", no_argument, NULL, 'D'},
        -:  806:  {"full-time", no_argument, NULL, FULL_TIME_OPTION},
        -:  807:  {"group-directories-first", no_argument, NULL,
        -:  808:   GROUP_DIRECTORIES_FIRST_OPTION},
        -:  809:  {"human-readable", no_argument, NULL, 'h'},
        -:  810:  {"inode", no_argument, NULL, 'i'},
        -:  811:  {"kibibytes", no_argument, NULL, 'k'},
        -:  812:  {"numeric-uid-gid", no_argument, NULL, 'n'},
        -:  813:  {"no-group", no_argument, NULL, 'G'},
        -:  814:  {"hide-control-chars", no_argument, NULL, 'q'},
        -:  815:  {"reverse", no_argument, NULL, 'r'},
        -:  816:  {"size", no_argument, NULL, 's'},
        -:  817:  {"width", required_argument, NULL, 'w'},
        -:  818:  {"almost-all", no_argument, NULL, 'A'},
        -:  819:  {"ignore-backups", no_argument, NULL, 'B'},
        -:  820:  {"classify", no_argument, NULL, 'F'},
        -:  821:  {"file-type", no_argument, NULL, FILE_TYPE_INDICATOR_OPTION},
        -:  822:  {"si", no_argument, NULL, SI_OPTION},
        -:  823:  {"dereference-command-line", no_argument, NULL, 'H'},
        -:  824:  {"dereference-command-line-symlink-to-dir", no_argument, NULL,
        -:  825:   DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION},
        -:  826:  {"hide", required_argument, NULL, HIDE_OPTION},
        -:  827:  {"ignore", required_argument, NULL, 'I'},
        -:  828:  {"indicator-style", required_argument, NULL, INDICATOR_STYLE_OPTION},
        -:  829:  {"dereference", no_argument, NULL, 'L'},
        -:  830:  {"literal", no_argument, NULL, 'N'},
        -:  831:  {"quote-name", no_argument, NULL, 'Q'},
        -:  832:  {"quoting-style", required_argument, NULL, QUOTING_STYLE_OPTION},
        -:  833:  {"recursive", no_argument, NULL, 'R'},
        -:  834:  {"format", required_argument, NULL, FORMAT_OPTION},
        -:  835:  {"show-control-chars", no_argument, NULL, SHOW_CONTROL_CHARS_OPTION},
        -:  836:  {"sort", required_argument, NULL, SORT_OPTION},
        -:  837:  {"tabsize", required_argument, NULL, 'T'},
        -:  838:  {"time", required_argument, NULL, TIME_OPTION},
        -:  839:  {"time-style", required_argument, NULL, TIME_STYLE_OPTION},
        -:  840:  {"color", optional_argument, NULL, COLOR_OPTION},
        -:  841:  {"block-size", required_argument, NULL, BLOCK_SIZE_OPTION},
        -:  842:  {"context", no_argument, 0, 'Z'},
        -:  843:  {"author", no_argument, NULL, AUTHOR_OPTION},
        -:  844:  {GETOPT_HELP_OPTION_DECL},
        -:  845:  {GETOPT_VERSION_OPTION_DECL},
        -:  846:  {NULL, 0, NULL, 0}
        -:  847:};
        -:  848:
        -:  849:static char const *const format_args[] =
        -:  850:{
        -:  851:  "verbose", "long", "commas", "horizontal", "across",
        -:  852:  "vertical", "single-column", NULL
        -:  853:};
        -:  854:static enum format const format_types[] =
        -:  855:{
        -:  856:  long_format, long_format, with_commas, horizontal, horizontal,
        -:  857:  many_per_line, one_per_line
        -:  858:};
        -:  859:ARGMATCH_VERIFY (format_args, format_types);
        -:  860:
        -:  861:static char const *const sort_args[] =
        -:  862:{
        -:  863:  "none", "time", "size", "extension", "version", NULL
        -:  864:};
        -:  865:static enum sort_type const sort_types[] =
        -:  866:{
        -:  867:  sort_none, sort_time, sort_size, sort_extension, sort_version
        -:  868:};
        -:  869:ARGMATCH_VERIFY (sort_args, sort_types);
        -:  870:
        -:  871:static char const *const time_args[] =
        -:  872:{
        -:  873:  "atime", "access", "use", "ctime", "status", NULL
        -:  874:};
        -:  875:static enum time_type const time_types[] =
        -:  876:{
        -:  877:  time_atime, time_atime, time_atime, time_ctime, time_ctime
        -:  878:};
        -:  879:ARGMATCH_VERIFY (time_args, time_types);
        -:  880:
        -:  881:static char const *const color_args[] =
        -:  882:{
        -:  883:  /* force and none are for compatibility with another color-ls version */
        -:  884:  "always", "yes", "force",
        -:  885:  "never", "no", "none",
        -:  886:  "auto", "tty", "if-tty", NULL
        -:  887:};
        -:  888:static enum color_type const color_types[] =
        -:  889:{
        -:  890:  color_always, color_always, color_always,
        -:  891:  color_never, color_never, color_never,
        -:  892:  color_if_tty, color_if_tty, color_if_tty
        -:  893:};
        -:  894:ARGMATCH_VERIFY (color_args, color_types);
        -:  895:
        -:  896:/* Information about filling a column.  */
        -:  897:struct column_info
        -:  898:{
        -:  899:  bool valid_len;
        -:  900:  size_t line_len;
        -:  901:  size_t *col_arr;
        -:  902:};
        -:  903:
        -:  904:/* Array with information about column filledness.  */
        -:  905:static struct column_info *column_info;
        -:  906:
        -:  907:/* Maximum number of columns ever possible for this display.  */
        -:  908:static size_t max_idx;
        -:  909:
        -:  910:/* The minimum width of a column is 3: 1 character for the name and 2
        -:  911:   for the separating white space.  */
        -:  912:#define MIN_COLUMN_WIDTH	3
        -:  913:
        -:  914:
        -:  915:/* This zero-based index is used solely with the --dired option.
        -:  916:   When that option is in effect, this counter is incremented for each
        -:  917:   byte of output generated by this program so that the beginning
        -:  918:   and ending indices (in that output) of every file name can be recorded
        -:  919:   and later output themselves.  */
        -:  920:static size_t dired_pos;
        -:  921:
        -:  922:#define DIRED_PUTCHAR(c) do {putchar ((c)); ++dired_pos;} while (0)
        -:  923:
        -:  924:/* Write S to STREAM and increment DIRED_POS by S_LEN.  */
        -:  925:#define DIRED_FPUTS(s, stream, s_len) \
        -:  926:    do {fputs (s, stream); dired_pos += s_len;} while (0)
        -:  927:
        -:  928:/* Like DIRED_FPUTS, but for use when S is a literal string.  */
        -:  929:#define DIRED_FPUTS_LITERAL(s, stream) \
        -:  930:    do {fputs (s, stream); dired_pos += sizeof (s) - 1;} while (0)
        -:  931:
        -:  932:#define DIRED_INDENT()							\
        -:  933:    do									\
        -:  934:      {									\
        -:  935:        if (dired)							\
        -:  936:          DIRED_FPUTS_LITERAL ("  ", stdout);				\
        -:  937:      }									\
        -:  938:    while (0)
        -:  939:
        -:  940:/* With --dired, store pairs of beginning and ending indices of filenames.  */
        -:  941:static struct obstack dired_obstack;
        -:  942:
        -:  943:/* With --dired, store pairs of beginning and ending indices of any
        -:  944:   directory names that appear as headers (just before 'total' line)
        -:  945:   for lists of directory entries.  Such directory names are seen when
        -:  946:   listing hierarchies using -R and when a directory is listed with at
        -:  947:   least one other command line argument.  */
        -:  948:static struct obstack subdired_obstack;
        -:  949:
        -:  950:/* Save the current index on the specified obstack, OBS.  */
        -:  951:#define PUSH_CURRENT_DIRED_POS(obs)					\
        -:  952:  do									\
        -:  953:    {									\
        -:  954:      if (dired)							\
        -:  955:        obstack_grow (obs, &dired_pos, sizeof (dired_pos));		\
        -:  956:    }									\
        -:  957:  while (0)
        -:  958:
        -:  959:/* With -R, this stack is used to help detect directory cycles.
        -:  960:   The device/inode pairs on this stack mirror the pairs in the
        -:  961:   active_dir_set hash table.  */
        -:  962:static struct obstack dev_ino_obstack;
        -:  963:
        -:  964:/* Push a pair onto the device/inode stack.  */
        -:  965:#define DEV_INO_PUSH(Dev, Ino)						\
        -:  966:  do									\
        -:  967:    {									\
        -:  968:      struct dev_ino *di;						\
        -:  969:      obstack_blank (&dev_ino_obstack, sizeof (struct dev_ino));	\
        -:  970:      di = -1 + (struct dev_ino *) obstack_next_free (&dev_ino_obstack); \
        -:  971:      di->st_dev = (Dev);						\
        -:  972:      di->st_ino = (Ino);						\
        -:  973:    }									\
        -:  974:  while (0)
        -:  975:
        -:  976:/* Pop a dev/ino struct off the global dev_ino_obstack
        -:  977:   and return that struct.  */
        -:  978:static struct dev_ino
    #####:  979:dev_ino_pop (void)
        -:  980:{
    #####:  981:  assert (sizeof (struct dev_ino) <= obstack_object_size (&dev_ino_obstack));
    #####:  982:  obstack_blank (&dev_ino_obstack, -(int) (sizeof (struct dev_ino)));
    #####:  983:  return *(struct dev_ino *) obstack_next_free (&dev_ino_obstack);
        -:  984:}
        -:  985:
        -:  986:/* Note the use commented out below:
        -:  987:#define ASSERT_MATCHING_DEV_INO(Name, Di)	\
        -:  988:  do						\
        -:  989:    {						\
        -:  990:      struct stat sb;				\
        -:  991:      assert (Name);				\
        -:  992:      assert (0 <= stat (Name, &sb));		\
        -:  993:      assert (sb.st_dev == Di.st_dev);		\
        -:  994:      assert (sb.st_ino == Di.st_ino);		\
        -:  995:    }						\
        -:  996:  while (0)
        -:  997:*/
        -:  998:
        -:  999:/* Write to standard output PREFIX, followed by the quoting style and
        -: 1000:   a space-separated list of the integers stored in OS all on one line.  */
        -: 1001:
        -: 1002:static void
    #####: 1003:dired_dump_obstack (const char *prefix, struct obstack *os)
        -: 1004:{
        -: 1005:  size_t n_pos;
        -: 1006:
    #####: 1007:  n_pos = obstack_object_size (os) / sizeof (dired_pos);
    #####: 1008:  if (n_pos > 0)
        -: 1009:    {
        -: 1010:      size_t i;
        -: 1011:      size_t *pos;
        -: 1012:
    #####: 1013:      pos = (size_t *) obstack_finish (os);
    #####: 1014:      fputs (prefix, stdout);
    #####: 1015:      for (i = 0; i < n_pos; i++)
    #####: 1016:        printf (" %lu", (unsigned long int) pos[i]);
    #####: 1017:      putchar ('\n');
        -: 1018:    }
    #####: 1019:}
        -: 1020:
        -: 1021:/* Read the abbreviated month names from the locale, to align them
        -: 1022:   and to determine the max width of the field and to truncate names
        -: 1023:   greater than our max allowed.
        -: 1024:   Note even though this handles multibyte locales correctly
        -: 1025:   it's not restricted to them as single byte locales can have
        -: 1026:   variable width abbreviated months and also precomputing/caching
        -: 1027:   the names was seen to increase the performance of ls significantly.  */
        -: 1028:
        -: 1029:/* max number of display cells to use */
        -: 1030:enum { MAX_MON_WIDTH = 5 };
        -: 1031:/* In the unlikely event that the abmon[] storage is not big enough
        -: 1032:   an error message will be displayed, and we revert to using
        -: 1033:   unmodified abbreviated month names from the locale database.  */
        -: 1034:static char abmon[12][MAX_MON_WIDTH * 2 * MB_LEN_MAX + 1];
        -: 1035:/* minimum width needed to align %b, 0 => don't use precomputed values.  */
        -: 1036:static size_t required_mon_width;
        -: 1037:
        -: 1038:static size_t
        1: 1039:abmon_init (void)
        -: 1040:{
        -: 1041:#ifdef HAVE_NL_LANGINFO
        1: 1042:  required_mon_width = MAX_MON_WIDTH;
        -: 1043:  size_t curr_max_width;
        -: 1044:  do
        -: 1045:    {
        2: 1046:      curr_max_width = required_mon_width;
        2: 1047:      required_mon_width = 0;
       26: 1048:      for (int i = 0; i < 12; i++)
        -: 1049:        {
       24: 1050:          size_t width = curr_max_width;
        -: 1051:
       24: 1052:          size_t req = mbsalign (nl_langinfo (ABMON_1 + i),
       24: 1053:                                 abmon[i], sizeof (abmon[i]),
        -: 1054:                                 &width, MBS_ALIGN_LEFT, 0);
        -: 1055:
       24: 1056:          if (req == (size_t) -1 || req >= sizeof (abmon[i]))
        -: 1057:            {
    #####: 1058:              required_mon_width = 0; /* ignore precomputed strings.  */
    #####: 1059:              return required_mon_width;
        -: 1060:            }
        -: 1061:
       24: 1062:          required_mon_width = MAX (required_mon_width, width);
        -: 1063:        }
        -: 1064:    }
        2: 1065:  while (curr_max_width > required_mon_width);
        -: 1066:#endif
        -: 1067:
        1: 1068:  return required_mon_width;
        -: 1069:}
        -: 1070:
        -: 1071:static size_t
    #####: 1072:dev_ino_hash (void const *x, size_t table_size)
        -: 1073:{
    #####: 1074:  struct dev_ino const *p = x;
    #####: 1075:  return (uintmax_t) p->st_ino % table_size;
        -: 1076:}
        -: 1077:
        -: 1078:static bool
    #####: 1079:dev_ino_compare (void const *x, void const *y)
        -: 1080:{
    #####: 1081:  struct dev_ino const *a = x;
    #####: 1082:  struct dev_ino const *b = y;
    #####: 1083:  return SAME_INODE (*a, *b) ? true : false;
        -: 1084:}
        -: 1085:
        -: 1086:static void
    #####: 1087:dev_ino_free (void *x)
        -: 1088:{
    #####: 1089:  free (x);
    #####: 1090:}
        -: 1091:
        -: 1092:/* Add the device/inode pair (P->st_dev/P->st_ino) to the set of
        -: 1093:   active directories.  Return true if there is already a matching
        -: 1094:   entry in the table.  */
        -: 1095:
        -: 1096:static bool
    #####: 1097:visit_dir (dev_t dev, ino_t ino)
        -: 1098:{
        -: 1099:  struct dev_ino *ent;
        -: 1100:  struct dev_ino *ent_from_table;
        -: 1101:  bool found_match;
        -: 1102:
    #####: 1103:  ent = xmalloc (sizeof *ent);
    #####: 1104:  ent->st_ino = ino;
    #####: 1105:  ent->st_dev = dev;
        -: 1106:
        -: 1107:  /* Attempt to insert this entry into the table.  */
    #####: 1108:  ent_from_table = hash_insert (active_dir_set, ent);
        -: 1109:
    #####: 1110:  if (ent_from_table == NULL)
        -: 1111:    {
        -: 1112:      /* Insertion failed due to lack of memory.  */
    #####: 1113:      xalloc_die ();
        -: 1114:    }
        -: 1115:
    #####: 1116:  found_match = (ent_from_table != ent);
        -: 1117:
    #####: 1118:  if (found_match)
        -: 1119:    {
        -: 1120:      /* ent was not inserted, so free it.  */
    #####: 1121:      free (ent);
        -: 1122:    }
        -: 1123:
    #####: 1124:  return found_match;
        -: 1125:}
        -: 1126:
        -: 1127:static void
    #####: 1128:free_pending_ent (struct pending *p)
        -: 1129:{
    #####: 1130:  free (p->name);
    #####: 1131:  free (p->realname);
    #####: 1132:  free (p);
    #####: 1133:}
        -: 1134:
        -: 1135:static bool
    #####: 1136:is_colored (enum indicator_no type)
        -: 1137:{
    #####: 1138:  size_t len = color_indicator[type].len;
    #####: 1139:  char const *s = color_indicator[type].string;
    #####: 1140:  return ! (len == 0
    #####: 1141:            || (len == 1 && STRNCMP_LIT (s, "0") == 0)
    #####: 1142:            || (len == 2 && STRNCMP_LIT (s, "00") == 0));
        -: 1143:}
        -: 1144:
        -: 1145:static void
    #####: 1146:restore_default_color (void)
        -: 1147:{
    #####: 1148:  put_indicator (&color_indicator[C_LEFT]);
    #####: 1149:  put_indicator (&color_indicator[C_RIGHT]);
    #####: 1150:}
        -: 1151:
        -: 1152:static void
       28: 1153:set_normal_color (void)
        -: 1154:{
       28: 1155:  if (print_with_color && is_colored (C_NORM))
        -: 1156:    {
    #####: 1157:      put_indicator (&color_indicator[C_LEFT]);
    #####: 1158:      put_indicator (&color_indicator[C_NORM]);
    #####: 1159:      put_indicator (&color_indicator[C_RIGHT]);
        -: 1160:    }
       28: 1161:}
        -: 1162:
        -: 1163:/* An ordinary signal was received; arrange for the program to exit.  */
        -: 1164:
        -: 1165:static void
    #####: 1166:sighandler (int sig)
        -: 1167:{
        -: 1168:  if (! SA_NOCLDSTOP)
        -: 1169:    signal (sig, SIG_IGN);
    #####: 1170:  if (! interrupt_signal)
    #####: 1171:    interrupt_signal = sig;
    #####: 1172:}
        -: 1173:
        -: 1174:/* A SIGTSTP was received; arrange for the program to suspend itself.  */
        -: 1175:
        -: 1176:static void
    #####: 1177:stophandler (int sig)
        -: 1178:{
        -: 1179:  if (! SA_NOCLDSTOP)
        -: 1180:    signal (sig, stophandler);
    #####: 1181:  if (! interrupt_signal)
    #####: 1182:    stop_signal_count++;
    #####: 1183:}
        -: 1184:
        -: 1185:/* Process any pending signals.  If signals are caught, this function
        -: 1186:   should be called periodically.  Ideally there should never be an
        -: 1187:   unbounded amount of time when signals are not being processed.
        -: 1188:   Signal handling can restore the default colors, so callers must
        -: 1189:   immediately change colors after invoking this function.  */
        -: 1190:
        -: 1191:static void
       28: 1192:process_signals (void)
        -: 1193:{
       56: 1194:  while (interrupt_signal || stop_signal_count)
        -: 1195:    {
        -: 1196:      int sig;
        -: 1197:      int stops;
        -: 1198:      sigset_t oldset;
        -: 1199:
    #####: 1200:      if (used_color)
    #####: 1201:        restore_default_color ();
    #####: 1202:      fflush (stdout);
        -: 1203:
    #####: 1204:      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
        -: 1205:
        -: 1206:      /* Reload interrupt_signal and stop_signal_count, in case a new
        -: 1207:         signal was handled before sigprocmask took effect.  */
    #####: 1208:      sig = interrupt_signal;
    #####: 1209:      stops = stop_signal_count;
        -: 1210:
        -: 1211:      /* SIGTSTP is special, since the application can receive that signal
        -: 1212:         more than once.  In this case, don't set the signal handler to the
        -: 1213:         default.  Instead, just raise the uncatchable SIGSTOP.  */
    #####: 1214:      if (stops)
        -: 1215:        {
    #####: 1216:          stop_signal_count = stops - 1;
    #####: 1217:          sig = SIGSTOP;
        -: 1218:        }
        -: 1219:      else
    #####: 1220:        signal (sig, SIG_DFL);
        -: 1221:
        -: 1222:      /* Exit or suspend the program.  */
    #####: 1223:      raise (sig);
    #####: 1224:      sigprocmask (SIG_SETMASK, &oldset, NULL);
        -: 1225:
        -: 1226:      /* If execution reaches here, then the program has been
        -: 1227:         continued (after being suspended).  */
        -: 1228:    }
       28: 1229:}
        -: 1230:
        -: 1231:int
       10: 1232:main (int argc, char **argv)
        -: 1233:{
        -: 1234:  int i;
        -: 1235:  struct pending *thispend;
        -: 1236:  int n_files;
        -: 1237:
        -: 1238:  /* The signals that are trapped, and the number of such signals.  */
        -: 1239:  static int const sig[] =
        -: 1240:    {
        -: 1241:      /* This one is handled specially.  */
        -: 1242:      SIGTSTP,
        -: 1243:
        -: 1244:      /* The usual suspects.  */
        -: 1245:      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
        -: 1246:#ifdef SIGPOLL
        -: 1247:      SIGPOLL,
        -: 1248:#endif
        -: 1249:#ifdef SIGPROF
        -: 1250:      SIGPROF,
        -: 1251:#endif
        -: 1252:#ifdef SIGVTALRM
        -: 1253:      SIGVTALRM,
        -: 1254:#endif
        -: 1255:#ifdef SIGXCPU
        -: 1256:      SIGXCPU,
        -: 1257:#endif
        -: 1258:#ifdef SIGXFSZ
        -: 1259:      SIGXFSZ,
        -: 1260:#endif
        -: 1261:    };
        -: 1262:  enum { nsigs = ARRAY_CARDINALITY (sig) };
        -: 1263:
        -: 1264:#if ! SA_NOCLDSTOP
        -: 1265:  bool caught_sig[nsigs];
        -: 1266:#endif
        -: 1267:
        -: 1268:  initialize_main (&argc, &argv);
       10: 1269:  set_program_name (argv[0]);
       10: 1270:  setlocale (LC_ALL, "");
        -: 1271:  bindtextdomain (PACKAGE, LOCALEDIR);
        -: 1272:  textdomain (PACKAGE);
        -: 1273:
       10: 1274:  initialize_exit_failure (LS_FAILURE);
       10: 1275:  atexit (close_stdout);
        -: 1276:
        -: 1277:  assert (ARRAY_CARDINALITY (color_indicator) + 1
        -: 1278:          == ARRAY_CARDINALITY (indicator_name));
        -: 1279:
       10: 1280:  exit_status = EXIT_SUCCESS;
       10: 1281:  print_dir_name = true;
       10: 1282:  pending_dirs = NULL;
        -: 1283:
       10: 1284:  current_time.tv_sec = TYPE_MINIMUM (time_t);
       10: 1285:  current_time.tv_nsec = -1;
        -: 1286:
       10: 1287:  i = decode_switches (argc, argv);
        -: 1288:
       10: 1289:  if (print_with_color)
    #####: 1290:    parse_ls_color ();
        -: 1291:
        -: 1292:  /* Test print_with_color again, because the call to parse_ls_color
        -: 1293:     may have just reset it -- e.g., if LS_COLORS is invalid.  */
       10: 1294:  if (print_with_color)
        -: 1295:    {
        -: 1296:      /* Avoid following symbolic links when possible.  */
    #####: 1297:      if (is_colored (C_ORPHAN)
    #####: 1298:          || (is_colored (C_EXEC) && color_symlink_as_referent)
    #####: 1299:          || (is_colored (C_MISSING) && format == long_format))
    #####: 1300:        check_symlink_color = true;
        -: 1301:
        -: 1302:      /* If the standard output is a controlling terminal, watch out
        -: 1303:         for signals, so that the colors can be restored to the
        -: 1304:         default state if "ls" is suspended or interrupted.  */
        -: 1305:
    #####: 1306:      if (0 <= tcgetpgrp (STDOUT_FILENO))
        -: 1307:        {
        -: 1308:          int j;
        -: 1309:#if SA_NOCLDSTOP
        -: 1310:          struct sigaction act;
        -: 1311:
    #####: 1312:          sigemptyset (&caught_signals);
    #####: 1313:          for (j = 0; j < nsigs; j++)
        -: 1314:            {
    #####: 1315:              sigaction (sig[j], NULL, &act);
    #####: 1316:              if (act.sa_handler != SIG_IGN)
    #####: 1317:                sigaddset (&caught_signals, sig[j]);
        -: 1318:            }
        -: 1319:
    #####: 1320:          act.sa_mask = caught_signals;
    #####: 1321:          act.sa_flags = SA_RESTART;
        -: 1322:
    #####: 1323:          for (j = 0; j < nsigs; j++)
    #####: 1324:            if (sigismember (&caught_signals, sig[j]))
        -: 1325:              {
    #####: 1326:                act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
    #####: 1327:                sigaction (sig[j], &act, NULL);
        -: 1328:              }
        -: 1329:#else
        -: 1330:          for (j = 0; j < nsigs; j++)
        -: 1331:            {
        -: 1332:              caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
        -: 1333:              if (caught_sig[j])
        -: 1334:                {
        -: 1335:                  signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
        -: 1336:                  siginterrupt (sig[j], 0);
        -: 1337:                }
        -: 1338:            }
        -: 1339:#endif
        -: 1340:        }
        -: 1341:    }
        -: 1342:
       10: 1343:  if (dereference == DEREF_UNDEFINED)
       19: 1344:    dereference = ((immediate_dirs
        1: 1345:                    || indicator_style == classify
        1: 1346:                    || format == long_format)
        -: 1347:                   ? DEREF_NEVER
        -: 1348:                   : DEREF_COMMAND_LINE_SYMLINK_TO_DIR);
        -: 1349:
        -: 1350:  /* When using -R, initialize a data structure we'll use to
        -: 1351:     detect any directory cycles.  */
       10: 1352:  if (recursive)
        -: 1353:    {
    #####: 1354:      active_dir_set = hash_initialize (INITIAL_TABLE_SIZE, NULL,
        -: 1355:                                        dev_ino_hash,
        -: 1356:                                        dev_ino_compare,
        -: 1357:                                        dev_ino_free);
    #####: 1358:      if (active_dir_set == NULL)
    #####: 1359:        xalloc_die ();
        -: 1360:
    #####: 1361:      obstack_init (&dev_ino_obstack);
        -: 1362:    }
        -: 1363:
       30: 1364:  format_needs_stat = sort_type == sort_time || sort_type == sort_size
       10: 1365:    || format == long_format
        9: 1366:    || print_scontext
       19: 1367:    || print_block_size;
       20: 1368:  format_needs_type = (! format_needs_stat
       10: 1369:                       && (recursive
        9: 1370:                           || print_with_color
        9: 1371:                           || indicator_style != none
        9: 1372:                           || directories_first));
        -: 1373:
       10: 1374:  if (dired)
        -: 1375:    {
    #####: 1376:      obstack_init (&dired_obstack);
    #####: 1377:      obstack_init (&subdired_obstack);
        -: 1378:    }
        -: 1379:
       10: 1380:  cwd_n_alloc = 100;
       10: 1381:  cwd_file = xnmalloc (cwd_n_alloc, sizeof *cwd_file);
       10: 1382:  cwd_n_used = 0;
        -: 1383:
       10: 1384:  clear_files ();
        -: 1385:
       10: 1386:  n_files = argc - i;
        -: 1387:
       10: 1388:  if (n_files <= 0)
        -: 1389:    {
    #####: 1390:      if (immediate_dirs)
    #####: 1391:        gobble_file (".", directory, NOT_AN_INODE_NUMBER, true, "");
        -: 1392:      else
    #####: 1393:        queue_directory (".", NULL, true);
        -: 1394:    }
        -: 1395:  else
        -: 1396:    do
       28: 1397:      gobble_file (argv[i++], unknown, NOT_AN_INODE_NUMBER, true, "");
       28: 1398:    while (i < argc);
        -: 1399:
       10: 1400:  if (cwd_n_used)
        -: 1401:    {
       10: 1402:      sort_files ();
       10: 1403:      if (!immediate_dirs)
        1: 1404:        extract_dirs_from_files (NULL, true);
        -: 1405:      /* 'cwd_n_used' might be zero now.  */
        -: 1406:    }
        -: 1407:
        -: 1408:  /* In the following if/else blocks, it is sufficient to test 'pending_dirs'
        -: 1409:     (and not pending_dirs->name) because there may be no markers in the queue
        -: 1410:     at this point.  A marker may be enqueued when extract_dirs_from_files is
        -: 1411:     called with a non-empty string or via print_dir.  */
       10: 1412:  if (cwd_n_used)
        -: 1413:    {
       10: 1414:      print_current_files ();
       10: 1415:      if (pending_dirs)
    #####: 1416:        DIRED_PUTCHAR ('\n');
        -: 1417:    }
    #####: 1418:  else if (n_files <= 1 && pending_dirs && pending_dirs->next == 0)
    #####: 1419:    print_dir_name = false;
        -: 1420:
       20: 1421:  while (pending_dirs)
        -: 1422:    {
    #####: 1423:      thispend = pending_dirs;
    #####: 1424:      pending_dirs = pending_dirs->next;
        -: 1425:
    #####: 1426:      if (LOOP_DETECT)
        -: 1427:        {
    #####: 1428:          if (thispend->name == NULL)
        -: 1429:            {
        -: 1430:              /* thispend->name == NULL means this is a marker entry
        -: 1431:                 indicating we've finished processing the directory.
        -: 1432:                 Use its dev/ino numbers to remove the corresponding
        -: 1433:                 entry from the active_dir_set hash table.  */
    #####: 1434:              struct dev_ino di = dev_ino_pop ();
    #####: 1435:              struct dev_ino *found = hash_delete (active_dir_set, &di);
        -: 1436:              /* ASSERT_MATCHING_DEV_INO (thispend->realname, di); */
    #####: 1437:              assert (found);
    #####: 1438:              dev_ino_free (found);
    #####: 1439:              free_pending_ent (thispend);
    #####: 1440:              continue;
        -: 1441:            }
        -: 1442:        }
        -: 1443:
    #####: 1444:      print_dir (thispend->name, thispend->realname,
    #####: 1445:                 thispend->command_line_arg);
        -: 1446:
    #####: 1447:      free_pending_ent (thispend);
    #####: 1448:      print_dir_name = true;
        -: 1449:    }
        -: 1450:
       10: 1451:  if (print_with_color)
        -: 1452:    {
        -: 1453:      int j;
        -: 1454:
    #####: 1455:      if (used_color)
        -: 1456:        {
        -: 1457:          /* Skip the restore when it would be a no-op, i.e.,
        -: 1458:             when left is "\033[" and right is "m".  */
    #####: 1459:          if (!(color_indicator[C_LEFT].len == 2
    #####: 1460:                && memcmp (color_indicator[C_LEFT].string, "\033[", 2) == 0
    #####: 1461:                && color_indicator[C_RIGHT].len == 1
    #####: 1462:                && color_indicator[C_RIGHT].string[0] == 'm'))
    #####: 1463:            restore_default_color ();
        -: 1464:        }
    #####: 1465:      fflush (stdout);
        -: 1466:
        -: 1467:      /* Restore the default signal handling.  */
        -: 1468:#if SA_NOCLDSTOP
    #####: 1469:      for (j = 0; j < nsigs; j++)
    #####: 1470:        if (sigismember (&caught_signals, sig[j]))
    #####: 1471:          signal (sig[j], SIG_DFL);
        -: 1472:#else
        -: 1473:      for (j = 0; j < nsigs; j++)
        -: 1474:        if (caught_sig[j])
        -: 1475:          signal (sig[j], SIG_DFL);
        -: 1476:#endif
        -: 1477:
        -: 1478:      /* Act on any signals that arrived before the default was restored.
        -: 1479:         This can process signals out of order, but there doesn't seem to
        -: 1480:         be an easy way to do them in order, and the order isn't that
        -: 1481:         important anyway.  */
    #####: 1482:      for (j = stop_signal_count; j; j--)
    #####: 1483:        raise (SIGSTOP);
    #####: 1484:      j = interrupt_signal;
    #####: 1485:      if (j)
    #####: 1486:        raise (j);
        -: 1487:    }
        -: 1488:
       10: 1489:  if (dired)
        -: 1490:    {
        -: 1491:      /* No need to free these since we're about to exit.  */
    #####: 1492:      dired_dump_obstack ("//DIRED//", &dired_obstack);
    #####: 1493:      dired_dump_obstack ("//SUBDIRED//", &subdired_obstack);
    #####: 1494:      printf ("//DIRED-OPTIONS// --quoting-style=%s\n",
    #####: 1495:              quoting_style_args[get_quoting_style (filename_quoting_options)]);
        -: 1496:    }
        -: 1497:
       10: 1498:  if (LOOP_DETECT)
        -: 1499:    {
    #####: 1500:      assert (hash_get_n_entries (active_dir_set) == 0);
    #####: 1501:      hash_free (active_dir_set);
        -: 1502:    }
        -: 1503:
       10: 1504:  exit (exit_status);
        -: 1505:}
        -: 1506:
        -: 1507:/* Set all the option flags according to the switches specified.
        -: 1508:   Return the index of the first non-option argument.  */
        -: 1509:
        -: 1510:static int
       10: 1511:decode_switches (int argc, char **argv)
        -: 1512:{
       10: 1513:  char *time_style_option = NULL;
        -: 1514:
       10: 1515:  bool sort_type_specified = false;
       10: 1516:  bool kibibytes_specified = false;
        -: 1517:
       10: 1518:  qmark_funny_chars = false;
        -: 1519:
        -: 1520:  /* initialize all switches to default settings */
        -: 1521:
       10: 1522:  switch (ls_mode)
        -: 1523:    {
        -: 1524:    case LS_MULTI_COL:
        -: 1525:      /* This is for the 'dir' program.  */
    #####: 1526:      format = many_per_line;
    #####: 1527:      set_quoting_style (NULL, escape_quoting_style);
    #####: 1528:      break;
        -: 1529:
        -: 1530:    case LS_LONG_FORMAT:
        -: 1531:      /* This is for the 'vdir' program.  */
    #####: 1532:      format = long_format;
    #####: 1533:      set_quoting_style (NULL, escape_quoting_style);
    #####: 1534:      break;
        -: 1535:
        -: 1536:    case LS_LS:
        -: 1537:      /* This is for the 'ls' program.  */
       10: 1538:      if (isatty (STDOUT_FILENO))
        -: 1539:        {
    #####: 1540:          format = many_per_line;
        -: 1541:          /* See description of qmark_funny_chars, above.  */
    #####: 1542:          qmark_funny_chars = true;
        -: 1543:        }
        -: 1544:      else
        -: 1545:        {
       10: 1546:          format = one_per_line;
       10: 1547:          qmark_funny_chars = false;
        -: 1548:        }
       10: 1549:      break;
        -: 1550:
        -: 1551:    default:
    #####: 1552:      abort ();
        -: 1553:    }
        -: 1554:
       10: 1555:  time_type = time_mtime;
       10: 1556:  sort_type = sort_name;
       10: 1557:  sort_reverse = false;
       10: 1558:  numeric_ids = false;
       10: 1559:  print_block_size = false;
       10: 1560:  indicator_style = none;
       10: 1561:  print_inode = false;
       10: 1562:  dereference = DEREF_UNDEFINED;
       10: 1563:  recursive = false;
       10: 1564:  immediate_dirs = false;
       10: 1565:  ignore_mode = IGNORE_DEFAULT;
       10: 1566:  ignore_patterns = NULL;
       10: 1567:  hide_patterns = NULL;
       10: 1568:  print_scontext = false;
        -: 1569:
        -: 1570:  /* FIXME: put this in a function.  */
        -: 1571:  {
       10: 1572:    char const *q_style = getenv ("QUOTING_STYLE");
       10: 1573:    if (q_style)
        -: 1574:      {
    #####: 1575:        int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);
    #####: 1576:        if (0 <= i)
    #####: 1577:          set_quoting_style (NULL, quoting_style_vals[i]);
        -: 1578:        else
    #####: 1579:          error (0, 0,
        -: 1580:         _("ignoring invalid value of environment variable QUOTING_STYLE: %s"),
        -: 1581:                 quotearg (q_style));
        -: 1582:      }
        -: 1583:  }
        -: 1584:
       10: 1585:  line_length = 80;
        -: 1586:  {
       10: 1587:    char const *p = getenv ("COLUMNS");
       10: 1588:    if (p && *p)
        -: 1589:      {
        -: 1590:        unsigned long int tmp_ulong;
    #####: 1591:        if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
    #####: 1592:            && 0 < tmp_ulong && tmp_ulong <= SIZE_MAX)
        -: 1593:          {
    #####: 1594:            line_length = tmp_ulong;
        -: 1595:          }
        -: 1596:        else
        -: 1597:          {
    #####: 1598:            error (0, 0,
        -: 1599:               _("ignoring invalid width in environment variable COLUMNS: %s"),
        -: 1600:                   quotearg (p));
        -: 1601:          }
        -: 1602:      }
        -: 1603:  }
        -: 1604:
        -: 1605:#ifdef TIOCGWINSZ
        -: 1606:  {
        -: 1607:    struct winsize ws;
        -: 1608:
       10: 1609:    if (ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws) != -1
    #####: 1610:        && 0 < ws.ws_col && ws.ws_col == (size_t) ws.ws_col)
    #####: 1611:      line_length = ws.ws_col;
        -: 1612:  }
        -: 1613:#endif
        -: 1614:
        -: 1615:  {
       10: 1616:    char const *p = getenv ("TABSIZE");
       10: 1617:    tabsize = 8;
       10: 1618:    if (p)
        -: 1619:      {
        -: 1620:        unsigned long int tmp_ulong;
    #####: 1621:        if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
        -: 1622:            && tmp_ulong <= SIZE_MAX)
        -: 1623:          {
    #####: 1624:            tabsize = tmp_ulong;
        -: 1625:          }
        -: 1626:        else
        -: 1627:          {
    #####: 1628:            error (0, 0,
        -: 1629:             _("ignoring invalid tab size in environment variable TABSIZE: %s"),
        -: 1630:                   quotearg (p));
        -: 1631:          }
        -: 1632:      }
        -: 1633:  }
        -: 1634:
        -: 1635:  while (true)
        -: 1636:    {
       22: 1637:      int oi = -1;
       22: 1638:      int c = getopt_long (argc, argv,
        -: 1639:                           "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",
        -: 1640:                           long_options, &oi);
       22: 1641:      if (c == -1)
       10: 1642:        break;
        -: 1643:
       12: 1644:      switch (c)
        -: 1645:        {
        -: 1646:        case 'a':
    #####: 1647:          ignore_mode = IGNORE_MINIMAL;
    #####: 1648:          break;
        -: 1649:
        -: 1650:        case 'b':
    #####: 1651:          set_quoting_style (NULL, escape_quoting_style);
    #####: 1652:          break;
        -: 1653:
        -: 1654:        case 'c':
    #####: 1655:          time_type = time_ctime;
    #####: 1656:          break;
        -: 1657:
        -: 1658:        case 'd':
        9: 1659:          immediate_dirs = true;
        9: 1660:          break;
        -: 1661:
        -: 1662:        case 'f':
        -: 1663:          /* Same as enabling -a -U and disabling -l -s.  */
    #####: 1664:          ignore_mode = IGNORE_MINIMAL;
    #####: 1665:          sort_type = sort_none;
    #####: 1666:          sort_type_specified = true;
        -: 1667:          /* disable -l */
    #####: 1668:          if (format == long_format)
    #####: 1669:            format = (isatty (STDOUT_FILENO) ? many_per_line : one_per_line);
    #####: 1670:          print_block_size = false;	/* disable -s */
    #####: 1671:          print_with_color = false;	/* disable --color */
    #####: 1672:          break;
        -: 1673:
        -: 1674:        case FILE_TYPE_INDICATOR_OPTION: /* --file-type */
    #####: 1675:          indicator_style = file_type;
    #####: 1676:          break;
        -: 1677:
        -: 1678:        case 'g':
        1: 1679:          format = long_format;
        1: 1680:          print_owner = false;
        1: 1681:          break;
        -: 1682:
        -: 1683:        case 'h':
    #####: 1684:          file_human_output_opts = human_output_opts =
        -: 1685:            human_autoscale | human_SI | human_base_1024;
    #####: 1686:          file_output_block_size = output_block_size = 1;
    #####: 1687:          break;
        -: 1688:
        -: 1689:        case 'i':
    #####: 1690:          print_inode = true;
    #####: 1691:          break;
        -: 1692:
        -: 1693:        case 'k':
    #####: 1694:          kibibytes_specified = true;
    #####: 1695:          break;
        -: 1696:
        -: 1697:        case 'l':
    #####: 1698:          format = long_format;
    #####: 1699:          break;
        -: 1700:
        -: 1701:        case 'm':
    #####: 1702:          format = with_commas;
    #####: 1703:          break;
        -: 1704:
        -: 1705:        case 'n':
    #####: 1706:          numeric_ids = true;
    #####: 1707:          format = long_format;
    #####: 1708:          break;
        -: 1709:
        -: 1710:        case 'o':  /* Just like -l, but don't display group info.  */
        1: 1711:          format = long_format;
        1: 1712:          print_group = false;
        1: 1713:          break;
        -: 1714:
        -: 1715:        case 'p':
    #####: 1716:          indicator_style = slash;
    #####: 1717:          break;
        -: 1718:
        -: 1719:        case 'q':
    #####: 1720:          qmark_funny_chars = true;
    #####: 1721:          break;
        -: 1722:
        -: 1723:        case 'r':
    #####: 1724:          sort_reverse = true;
    #####: 1725:          break;
        -: 1726:
        -: 1727:        case 's':
    #####: 1728:          print_block_size = true;
    #####: 1729:          break;
        -: 1730:
        -: 1731:        case 't':
    #####: 1732:          sort_type = sort_time;
    #####: 1733:          sort_type_specified = true;
    #####: 1734:          break;
        -: 1735:
        -: 1736:        case 'u':
    #####: 1737:          time_type = time_atime;
    #####: 1738:          break;
        -: 1739:
        -: 1740:        case 'v':
    #####: 1741:          sort_type = sort_version;
    #####: 1742:          sort_type_specified = true;
    #####: 1743:          break;
        -: 1744:
        -: 1745:        case 'w':
        -: 1746:          {
        -: 1747:            unsigned long int tmp_ulong;
    #####: 1748:            if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK
    #####: 1749:                || ! (0 < tmp_ulong && tmp_ulong <= SIZE_MAX))
    #####: 1750:              error (LS_FAILURE, 0, _("invalid line width: %s"),
        -: 1751:                     quotearg (optarg));
    #####: 1752:            line_length = tmp_ulong;
    #####: 1753:            break;
        -: 1754:          }
        -: 1755:
        -: 1756:        case 'x':
    #####: 1757:          format = horizontal;
    #####: 1758:          break;
        -: 1759:
        -: 1760:        case 'A':
    #####: 1761:          if (ignore_mode == IGNORE_DEFAULT)
    #####: 1762:            ignore_mode = IGNORE_DOT_AND_DOTDOT;
    #####: 1763:          break;
        -: 1764:
        -: 1765:        case 'B':
    #####: 1766:          add_ignore_pattern ("*~");
    #####: 1767:          add_ignore_pattern (".*~");
    #####: 1768:          break;
        -: 1769:
        -: 1770:        case 'C':
    #####: 1771:          format = many_per_line;
    #####: 1772:          break;
        -: 1773:
        -: 1774:        case 'D':
    #####: 1775:          dired = true;
    #####: 1776:          break;
        -: 1777:
        -: 1778:        case 'F':
    #####: 1779:          indicator_style = classify;
    #####: 1780:          break;
        -: 1781:
        -: 1782:        case 'G':		/* inhibit display of group info */
    #####: 1783:          print_group = false;
    #####: 1784:          break;
        -: 1785:
        -: 1786:        case 'H':
    #####: 1787:          dereference = DEREF_COMMAND_LINE_ARGUMENTS;
    #####: 1788:          break;
        -: 1789:
        -: 1790:        case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:
    #####: 1791:          dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;
    #####: 1792:          break;
        -: 1793:
        -: 1794:        case 'I':
    #####: 1795:          add_ignore_pattern (optarg);
    #####: 1796:          break;
        -: 1797:
        -: 1798:        case 'L':
    #####: 1799:          dereference = DEREF_ALWAYS;
    #####: 1800:          break;
        -: 1801:
        -: 1802:        case 'N':
    #####: 1803:          set_quoting_style (NULL, literal_quoting_style);
    #####: 1804:          break;
        -: 1805:
        -: 1806:        case 'Q':
    #####: 1807:          set_quoting_style (NULL, c_quoting_style);
    #####: 1808:          break;
        -: 1809:
        -: 1810:        case 'R':
    #####: 1811:          recursive = true;
    #####: 1812:          break;
        -: 1813:
        -: 1814:        case 'S':
    #####: 1815:          sort_type = sort_size;
    #####: 1816:          sort_type_specified = true;
    #####: 1817:          break;
        -: 1818:
        -: 1819:        case 'T':
        -: 1820:          {
        -: 1821:            unsigned long int tmp_ulong;
    #####: 1822:            if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK
        -: 1823:                || SIZE_MAX < tmp_ulong)
    #####: 1824:              error (LS_FAILURE, 0, _("invalid tab size: %s"),
        -: 1825:                     quotearg (optarg));
    #####: 1826:            tabsize = tmp_ulong;
    #####: 1827:            break;
        -: 1828:          }
        -: 1829:
        -: 1830:        case 'U':
    #####: 1831:          sort_type = sort_none;
    #####: 1832:          sort_type_specified = true;
    #####: 1833:          break;
        -: 1834:
        -: 1835:        case 'X':
    #####: 1836:          sort_type = sort_extension;
    #####: 1837:          sort_type_specified = true;
    #####: 1838:          break;
        -: 1839:
        -: 1840:        case '1':
        -: 1841:          /* -1 has no effect after -l.  */
        1: 1842:          if (format != long_format)
        1: 1843:            format = one_per_line;
        1: 1844:          break;
        -: 1845:
        -: 1846:        case AUTHOR_OPTION:
    #####: 1847:          print_author = true;
    #####: 1848:          break;
        -: 1849:
        -: 1850:        case HIDE_OPTION:
        -: 1851:          {
    #####: 1852:            struct ignore_pattern *hide = xmalloc (sizeof *hide);
    #####: 1853:            hide->pattern = optarg;
    #####: 1854:            hide->next = hide_patterns;
    #####: 1855:            hide_patterns = hide;
        -: 1856:          }
    #####: 1857:          break;
        -: 1858:
        -: 1859:        case SORT_OPTION:
    #####: 1860:          sort_type = XARGMATCH ("--sort", optarg, sort_args, sort_types);
    #####: 1861:          sort_type_specified = true;
    #####: 1862:          break;
        -: 1863:
        -: 1864:        case GROUP_DIRECTORIES_FIRST_OPTION:
    #####: 1865:          directories_first = true;
    #####: 1866:          break;
        -: 1867:
        -: 1868:        case TIME_OPTION:
    #####: 1869:          time_type = XARGMATCH ("--time", optarg, time_args, time_types);
    #####: 1870:          break;
        -: 1871:
        -: 1872:        case FORMAT_OPTION:
    #####: 1873:          format = XARGMATCH ("--format", optarg, format_args, format_types);
    #####: 1874:          break;
        -: 1875:
        -: 1876:        case FULL_TIME_OPTION:
    #####: 1877:          format = long_format;
    #####: 1878:          time_style_option = bad_cast ("full-iso");
    #####: 1879:          break;
        -: 1880:
        -: 1881:        case COLOR_OPTION:
        -: 1882:          {
        -: 1883:            int i;
    #####: 1884:            if (optarg)
    #####: 1885:              i = XARGMATCH ("--color", optarg, color_args, color_types);
        -: 1886:            else
        -: 1887:              /* Using --color with no argument is equivalent to using
        -: 1888:                 --color=always.  */
    #####: 1889:              i = color_always;
        -: 1890:
    #####: 1891:            print_with_color = (i == color_always
    #####: 1892:                                || (i == color_if_tty
    #####: 1893:                                    && isatty (STDOUT_FILENO)));
        -: 1894:
    #####: 1895:            if (print_with_color)
        -: 1896:              {
        -: 1897:                /* Don't use TAB characters in output.  Some terminal
        -: 1898:                   emulators can't handle the combination of tabs and
        -: 1899:                   color codes on the same line.  */
    #####: 1900:                tabsize = 0;
        -: 1901:              }
    #####: 1902:            break;
        -: 1903:          }
        -: 1904:
        -: 1905:        case INDICATOR_STYLE_OPTION:
    #####: 1906:          indicator_style = XARGMATCH ("--indicator-style", optarg,
        -: 1907:                                       indicator_style_args,
        -: 1908:                                       indicator_style_types);
    #####: 1909:          break;
        -: 1910:
        -: 1911:        case QUOTING_STYLE_OPTION:
    #####: 1912:          set_quoting_style (NULL,
    #####: 1913:                             XARGMATCH ("--quoting-style", optarg,
        -: 1914:                                        quoting_style_args,
        -: 1915:                                        quoting_style_vals));
    #####: 1916:          break;
        -: 1917:
        -: 1918:        case TIME_STYLE_OPTION:
    #####: 1919:          time_style_option = optarg;
    #####: 1920:          break;
        -: 1921:
        -: 1922:        case SHOW_CONTROL_CHARS_OPTION:
    #####: 1923:          qmark_funny_chars = false;
    #####: 1924:          break;
        -: 1925:
        -: 1926:        case BLOCK_SIZE_OPTION:
        -: 1927:          {
    #####: 1928:            enum strtol_error e = human_options (optarg, &human_output_opts,
        -: 1929:                                                 &output_block_size);
    #####: 1930:            if (e != LONGINT_OK)
    #####: 1931:              xstrtol_fatal (e, oi, 0, long_options, optarg);
    #####: 1932:            file_human_output_opts = human_output_opts;
    #####: 1933:            file_output_block_size = output_block_size;
        -: 1934:          }
    #####: 1935:          break;
        -: 1936:
        -: 1937:        case SI_OPTION:
    #####: 1938:          file_human_output_opts = human_output_opts =
        -: 1939:            human_autoscale | human_SI;
    #####: 1940:          file_output_block_size = output_block_size = 1;
    #####: 1941:          break;
        -: 1942:
        -: 1943:        case 'Z':
    #####: 1944:          print_scontext = true;
    #####: 1945:          break;
        -: 1946:
    #####: 1947:        case_GETOPT_HELP_CHAR;
        -: 1948:
    #####: 1949:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -: 1950:
        -: 1951:        default:
    #####: 1952:          usage (LS_FAILURE);
        -: 1953:        }
       12: 1954:    }
        -: 1955:
       10: 1956:  if (! output_block_size)
        -: 1957:    {
       10: 1958:      char const *ls_block_size = getenv ("LS_BLOCK_SIZE");
       10: 1959:      human_options (ls_block_size,
        -: 1960:                     &human_output_opts, &output_block_size);
       10: 1961:      if (ls_block_size || getenv ("BLOCK_SIZE"))
        -: 1962:        {
    #####: 1963:          file_human_output_opts = human_output_opts;
    #####: 1964:          file_output_block_size = output_block_size;
        -: 1965:        }
       10: 1966:      if (kibibytes_specified)
        -: 1967:        {
    #####: 1968:          human_output_opts = 0;
    #####: 1969:          output_block_size = 1024;
        -: 1970:        }
        -: 1971:    }
        -: 1972:
       10: 1973:  max_idx = MAX (1, line_length / MIN_COLUMN_WIDTH);
        -: 1974:
       10: 1975:  filename_quoting_options = clone_quoting_options (NULL);
       10: 1976:  if (get_quoting_style (filename_quoting_options) == escape_quoting_style)
    #####: 1977:    set_char_quoting (filename_quoting_options, ' ', 1);
       10: 1978:  if (file_type <= indicator_style)
        -: 1979:    {
        -: 1980:      char const *p;
    #####: 1981:      for (p = "*=>@|" + indicator_style - file_type; *p; p++)
    #####: 1982:        set_char_quoting (filename_quoting_options, *p, 1);
        -: 1983:    }
        -: 1984:
       10: 1985:  dirname_quoting_options = clone_quoting_options (NULL);
       10: 1986:  set_char_quoting (dirname_quoting_options, ':', 1);
        -: 1987:
        -: 1988:  /* --dired is meaningful only with --format=long (-l).
        -: 1989:     Otherwise, ignore it.  FIXME: warn about this?
        -: 1990:     Alternatively, make --dired imply --format=long?  */
       10: 1991:  if (dired && format != long_format)
    #####: 1992:    dired = false;
        -: 1993:
        -: 1994:  /* If -c or -u is specified and not -l (or any other option that implies -l),
        -: 1995:     and no sort-type was specified, then sort by the ctime (-c) or atime (-u).
        -: 1996:     The behavior of ls when using either -c or -u but with neither -l nor -t
        -: 1997:     appears to be unspecified by POSIX.  So, with GNU ls, '-u' alone means
        -: 1998:     sort by atime (this is the one that's not specified by the POSIX spec),
        -: 1999:     -lu means show atime and sort by name, -lut means show atime and sort
        -: 2000:     by atime.  */
        -: 2001:
       10: 2002:  if ((time_type == time_ctime || time_type == time_atime)
    #####: 2003:      && !sort_type_specified && format != long_format)
        -: 2004:    {
    #####: 2005:      sort_type = sort_time;
        -: 2006:    }
        -: 2007:
       10: 2008:  if (format == long_format)
        -: 2009:    {
        1: 2010:      char *style = time_style_option;
        -: 2011:      static char const posix_prefix[] = "posix-";
        -: 2012:
        1: 2013:      if (! style)
        1: 2014:        if (! (style = getenv ("TIME_STYLE")))
        1: 2015:          style = bad_cast ("locale");
        -: 2016:
        2: 2017:      while (STREQ_LEN (style, posix_prefix, sizeof posix_prefix - 1))
        -: 2018:        {
    #####: 2019:          if (! hard_locale (LC_TIME))
    #####: 2020:            return optind;
    #####: 2021:          style += sizeof posix_prefix - 1;
        -: 2022:        }
        -: 2023:
        1: 2024:      if (*style == '+')
        -: 2025:        {
    #####: 2026:          char *p0 = style + 1;
    #####: 2027:          char *p1 = strchr (p0, '\n');
    #####: 2028:          if (! p1)
    #####: 2029:            p1 = p0;
        -: 2030:          else
        -: 2031:            {
    #####: 2032:              if (strchr (p1 + 1, '\n'))
    #####: 2033:                error (LS_FAILURE, 0, _("invalid time style format %s"),
        -: 2034:                       quote (p0));
    #####: 2035:              *p1++ = '\0';
        -: 2036:            }
    #####: 2037:          long_time_format[0] = p0;
    #####: 2038:          long_time_format[1] = p1;
        -: 2039:        }
        -: 2040:      else
        -: 2041:        {
        1: 2042:          ptrdiff_t res = argmatch (style, time_style_args,
        -: 2043:                                    (char const *) time_style_types,
        -: 2044:                                    sizeof (*time_style_types));
        1: 2045:          if (res < 0)
        -: 2046:            {
        -: 2047:              /* This whole block used to be a simple use of XARGMATCH.
        -: 2048:                 but that didn't print the "posix-"-prefixed variants or
        -: 2049:                 the "+"-prefixed format string option upon failure.  */
    #####: 2050:              argmatch_invalid ("time style", style, res);
        -: 2051:
        -: 2052:              /* The following is a manual expansion of argmatch_valid,
        -: 2053:                 but with the added "+ ..." description and the [posix-]
        -: 2054:                 prefixes prepended.  Note that this simplification works
        -: 2055:                 only because all four existing time_style_types values
        -: 2056:                 are distinct.  */
    #####: 2057:              fputs (_("Valid arguments are:\n"), stderr);
    #####: 2058:              char const *const *p = time_style_args;
    #####: 2059:              while (*p)
    #####: 2060:                fprintf (stderr, "  - [posix-]%s\n", *p++);
    #####: 2061:              fputs (_("  - +FORMAT (e.g., +%H:%M) for a 'date'-style"
        -: 2062:                       " format\n"), stderr);
    #####: 2063:              usage (LS_FAILURE);
        -: 2064:            }
        1: 2065:          switch (res)
        -: 2066:            {
        -: 2067:            case full_iso_time_style:
    #####: 2068:              long_time_format[0] = long_time_format[1] =
        -: 2069:                "%Y-%m-%d %H:%M:%S.%N %z";
    #####: 2070:              break;
        -: 2071:
        -: 2072:            case long_iso_time_style:
    #####: 2073:              long_time_format[0] = long_time_format[1] = "%Y-%m-%d %H:%M";
    #####: 2074:              break;
        -: 2075:
        -: 2076:            case iso_time_style:
    #####: 2077:              long_time_format[0] = "%Y-%m-%d ";
    #####: 2078:              long_time_format[1] = "%m-%d %H:%M";
    #####: 2079:              break;
        -: 2080:
        -: 2081:            case locale_time_style:
        1: 2082:              if (hard_locale (LC_TIME))
        -: 2083:                {
        -: 2084:                  int i;
    #####: 2085:                  for (i = 0; i < 2; i++)
    #####: 2086:                    long_time_format[i] =
    #####: 2087:                      dcgettext (NULL, long_time_format[i], LC_TIME);
        -: 2088:                }
        -: 2089:            }
        -: 2090:        }
        -: 2091:
        -: 2092:      /* Note we leave %5b etc. alone so user widths/flags are honored.  */
        1: 2093:      if (strstr (long_time_format[0], "%b")
    #####: 2094:          || strstr (long_time_format[1], "%b"))
        1: 2095:        if (!abmon_init ())
    #####: 2096:          error (0, 0, _("error initializing month strings"));
        -: 2097:    }
        -: 2098:
       10: 2099:  return optind;
        -: 2100:}
        -: 2101:
        -: 2102:/* Parse a string as part of the LS_COLORS variable; this may involve
        -: 2103:   decoding all kinds of escape characters.  If equals_end is set an
        -: 2104:   unescaped equal sign ends the string, otherwise only a : or \0
        -: 2105:   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
        -: 2106:   true if successful.
        -: 2107:
        -: 2108:   The resulting string is *not* null-terminated, but may contain
        -: 2109:   embedded nulls.
        -: 2110:
        -: 2111:   Note that both dest and src are char **; on return they point to
        -: 2112:   the first free byte after the array and the character that ended
        -: 2113:   the input string, respectively.  */
        -: 2114:
        -: 2115:static bool
    #####: 2116:get_funky_string (char **dest, const char **src, bool equals_end,
        -: 2117:                  size_t *output_count)
        -: 2118:{
        -: 2119:  char num;			/* For numerical codes */
        -: 2120:  size_t count;			/* Something to count with */
        -: 2121:  enum {
        -: 2122:    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
        -: 2123:  } state;
        -: 2124:  const char *p;
        -: 2125:  char *q;
        -: 2126:
    #####: 2127:  p = *src;			/* We don't want to double-indirect */
    #####: 2128:  q = *dest;			/* the whole darn time.  */
        -: 2129:
    #####: 2130:  count = 0;			/* No characters counted in yet.  */
    #####: 2131:  num = 0;
        -: 2132:
    #####: 2133:  state = ST_GND;		/* Start in ground state.  */
    #####: 2134:  while (state < ST_END)
        -: 2135:    {
    #####: 2136:      switch (state)
        -: 2137:        {
        -: 2138:        case ST_GND:		/* Ground state (no escapes) */
    #####: 2139:          switch (*p)
        -: 2140:            {
        -: 2141:            case ':':
        -: 2142:            case '\0':
    #####: 2143:              state = ST_END;	/* End of string */
    #####: 2144:              break;
        -: 2145:            case '\\':
    #####: 2146:              state = ST_BACKSLASH; /* Backslash scape sequence */
    #####: 2147:              ++p;
    #####: 2148:              break;
        -: 2149:            case '^':
    #####: 2150:              state = ST_CARET; /* Caret escape */
    #####: 2151:              ++p;
    #####: 2152:              break;
        -: 2153:            case '=':
    #####: 2154:              if (equals_end)
        -: 2155:                {
    #####: 2156:                  state = ST_END; /* End */
    #####: 2157:                  break;
        -: 2158:                }
        -: 2159:              /* else fall through */
        -: 2160:            default:
    #####: 2161:              *(q++) = *(p++);
    #####: 2162:              ++count;
    #####: 2163:              break;
        -: 2164:            }
    #####: 2165:          break;
        -: 2166:
        -: 2167:        case ST_BACKSLASH:	/* Backslash escaped character */
    #####: 2168:          switch (*p)
        -: 2169:            {
        -: 2170:            case '0':
        -: 2171:            case '1':
        -: 2172:            case '2':
        -: 2173:            case '3':
        -: 2174:            case '4':
        -: 2175:            case '5':
        -: 2176:            case '6':
        -: 2177:            case '7':
    #####: 2178:              state = ST_OCTAL;	/* Octal sequence */
    #####: 2179:              num = *p - '0';
    #####: 2180:              break;
        -: 2181:            case 'x':
        -: 2182:            case 'X':
    #####: 2183:              state = ST_HEX;	/* Hex sequence */
    #####: 2184:              num = 0;
    #####: 2185:              break;
        -: 2186:            case 'a':		/* Bell */
    #####: 2187:              num = '\a';
    #####: 2188:              break;
        -: 2189:            case 'b':		/* Backspace */
    #####: 2190:              num = '\b';
    #####: 2191:              break;
        -: 2192:            case 'e':		/* Escape */
    #####: 2193:              num = 27;
    #####: 2194:              break;
        -: 2195:            case 'f':		/* Form feed */
    #####: 2196:              num = '\f';
    #####: 2197:              break;
        -: 2198:            case 'n':		/* Newline */
    #####: 2199:              num = '\n';
    #####: 2200:              break;
        -: 2201:            case 'r':		/* Carriage return */
    #####: 2202:              num = '\r';
    #####: 2203:              break;
        -: 2204:            case 't':		/* Tab */
    #####: 2205:              num = '\t';
    #####: 2206:              break;
        -: 2207:            case 'v':		/* Vtab */
    #####: 2208:              num = '\v';
    #####: 2209:              break;
        -: 2210:            case '?':		/* Delete */
    #####: 2211:              num = 127;
    #####: 2212:              break;
        -: 2213:            case '_':		/* Space */
    #####: 2214:              num = ' ';
    #####: 2215:              break;
        -: 2216:            case '\0':		/* End of string */
    #####: 2217:              state = ST_ERROR;	/* Error! */
    #####: 2218:              break;
        -: 2219:            default:		/* Escaped character like \ ^ : = */
    #####: 2220:              num = *p;
    #####: 2221:              break;
        -: 2222:            }
    #####: 2223:          if (state == ST_BACKSLASH)
        -: 2224:            {
    #####: 2225:              *(q++) = num;
    #####: 2226:              ++count;
    #####: 2227:              state = ST_GND;
        -: 2228:            }
    #####: 2229:          ++p;
    #####: 2230:          break;
        -: 2231:
        -: 2232:        case ST_OCTAL:		/* Octal sequence */
    #####: 2233:          if (*p < '0' || *p > '7')
        -: 2234:            {
    #####: 2235:              *(q++) = num;
    #####: 2236:              ++count;
    #####: 2237:              state = ST_GND;
        -: 2238:            }
        -: 2239:          else
    #####: 2240:            num = (num << 3) + (*(p++) - '0');
    #####: 2241:          break;
        -: 2242:
        -: 2243:        case ST_HEX:		/* Hex sequence */
    #####: 2244:          switch (*p)
        -: 2245:            {
        -: 2246:            case '0':
        -: 2247:            case '1':
        -: 2248:            case '2':
        -: 2249:            case '3':
        -: 2250:            case '4':
        -: 2251:            case '5':
        -: 2252:            case '6':
        -: 2253:            case '7':
        -: 2254:            case '8':
        -: 2255:            case '9':
    #####: 2256:              num = (num << 4) + (*(p++) - '0');
    #####: 2257:              break;
        -: 2258:            case 'a':
        -: 2259:            case 'b':
        -: 2260:            case 'c':
        -: 2261:            case 'd':
        -: 2262:            case 'e':
        -: 2263:            case 'f':
    #####: 2264:              num = (num << 4) + (*(p++) - 'a') + 10;
    #####: 2265:              break;
        -: 2266:            case 'A':
        -: 2267:            case 'B':
        -: 2268:            case 'C':
        -: 2269:            case 'D':
        -: 2270:            case 'E':
        -: 2271:            case 'F':
    #####: 2272:              num = (num << 4) + (*(p++) - 'A') + 10;
    #####: 2273:              break;
        -: 2274:            default:
    #####: 2275:              *(q++) = num;
    #####: 2276:              ++count;
    #####: 2277:              state = ST_GND;
    #####: 2278:              break;
        -: 2279:            }
    #####: 2280:          break;
        -: 2281:
        -: 2282:        case ST_CARET:		/* Caret escape */
    #####: 2283:          state = ST_GND;	/* Should be the next state... */
    #####: 2284:          if (*p >= '@' && *p <= '~')
        -: 2285:            {
    #####: 2286:              *(q++) = *(p++) & 037;
    #####: 2287:              ++count;
        -: 2288:            }
    #####: 2289:          else if (*p == '?')
        -: 2290:            {
    #####: 2291:              *(q++) = 127;
    #####: 2292:              ++count;
        -: 2293:            }
        -: 2294:          else
    #####: 2295:            state = ST_ERROR;
    #####: 2296:          break;
        -: 2297:
        -: 2298:        default:
    #####: 2299:          abort ();
        -: 2300:        }
        -: 2301:    }
        -: 2302:
    #####: 2303:  *dest = q;
    #####: 2304:  *src = p;
    #####: 2305:  *output_count = count;
        -: 2306:
    #####: 2307:  return state != ST_ERROR;
        -: 2308:}
        -: 2309:
        -: 2310:enum parse_state
        -: 2311:  {
        -: 2312:    PS_START = 1,
        -: 2313:    PS_2,
        -: 2314:    PS_3,
        -: 2315:    PS_4,
        -: 2316:    PS_DONE,
        -: 2317:    PS_FAIL
        -: 2318:  };
        -: 2319:
        -: 2320:static void
    #####: 2321:parse_ls_color (void)
        -: 2322:{
        -: 2323:  const char *p;		/* Pointer to character being parsed */
        -: 2324:  char *buf;			/* color_buf buffer pointer */
        -: 2325:  int ind_no;			/* Indicator number */
        -: 2326:  char label[3];		/* Indicator label */
        -: 2327:  struct color_ext_type *ext;	/* Extension we are working on */
        -: 2328:
    #####: 2329:  if ((p = getenv ("LS_COLORS")) == NULL || *p == '\0')
    #####: 2330:    return;
        -: 2331:
    #####: 2332:  ext = NULL;
    #####: 2333:  strcpy (label, "??");
        -: 2334:
        -: 2335:  /* This is an overly conservative estimate, but any possible
        -: 2336:     LS_COLORS string will *not* generate a color_buf longer than
        -: 2337:     itself, so it is a safe way of allocating a buffer in
        -: 2338:     advance.  */
    #####: 2339:  buf = color_buf = xstrdup (p);
        -: 2340:
    #####: 2341:  enum parse_state state = PS_START;
        -: 2342:  while (true)
        -: 2343:    {
    #####: 2344:      switch (state)
        -: 2345:        {
        -: 2346:        case PS_START:		/* First label character */
    #####: 2347:          switch (*p)
        -: 2348:            {
        -: 2349:            case ':':
    #####: 2350:              ++p;
    #####: 2351:              break;
        -: 2352:
        -: 2353:            case '*':
        -: 2354:              /* Allocate new extension block and add to head of
        -: 2355:                 linked list (this way a later definition will
        -: 2356:                 override an earlier one, which can be useful for
        -: 2357:                 having terminal-specific defs override global).  */
        -: 2358:
    #####: 2359:              ext = xmalloc (sizeof *ext);
    #####: 2360:              ext->next = color_ext_list;
    #####: 2361:              color_ext_list = ext;
        -: 2362:
    #####: 2363:              ++p;
    #####: 2364:              ext->ext.string = buf;
        -: 2365:
    #####: 2366:              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
        -: 2367:                       ? PS_4 : PS_FAIL);
    #####: 2368:              break;
        -: 2369:
        -: 2370:            case '\0':
    #####: 2371:              state = PS_DONE;	/* Done! */
    #####: 2372:              goto done;
        -: 2373:
        -: 2374:            default:	/* Assume it is file type label */
    #####: 2375:              label[0] = *(p++);
    #####: 2376:              state = PS_2;
    #####: 2377:              break;
        -: 2378:            }
    #####: 2379:          break;
        -: 2380:
        -: 2381:        case PS_2:		/* Second label character */
    #####: 2382:          if (*p)
        -: 2383:            {
    #####: 2384:              label[1] = *(p++);
    #####: 2385:              state = PS_3;
        -: 2386:            }
        -: 2387:          else
    #####: 2388:            state = PS_FAIL;	/* Error */
    #####: 2389:          break;
        -: 2390:
        -: 2391:        case PS_3:		/* Equal sign after indicator label */
    #####: 2392:          state = PS_FAIL;	/* Assume failure...  */
    #####: 2393:          if (*(p++) == '=')/* It *should* be...  */
        -: 2394:            {
    #####: 2395:              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
        -: 2396:                {
    #####: 2397:                  if (STREQ (label, indicator_name[ind_no]))
        -: 2398:                    {
    #####: 2399:                      color_indicator[ind_no].string = buf;
    #####: 2400:                      state = (get_funky_string (&buf, &p, false,
        -: 2401:                                                 &color_indicator[ind_no].len)
        -: 2402:                               ? PS_START : PS_FAIL);
    #####: 2403:                      break;
        -: 2404:                    }
        -: 2405:                }
    #####: 2406:              if (state == PS_FAIL)
    #####: 2407:                error (0, 0, _("unrecognized prefix: %s"), quotearg (label));
        -: 2408:            }
    #####: 2409:          break;
        -: 2410:
        -: 2411:        case PS_4:		/* Equal sign after *.ext */
    #####: 2412:          if (*(p++) == '=')
        -: 2413:            {
    #####: 2414:              ext->seq.string = buf;
    #####: 2415:              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
        -: 2416:                       ? PS_START : PS_FAIL);
        -: 2417:            }
        -: 2418:          else
    #####: 2419:            state = PS_FAIL;
    #####: 2420:          break;
        -: 2421:
        -: 2422:        case PS_FAIL:
    #####: 2423:          goto done;
        -: 2424:
        -: 2425:        default:
    #####: 2426:          abort ();
        -: 2427:        }
    #####: 2428:    }
        -: 2429: done:
        -: 2430:
    #####: 2431:  if (state == PS_FAIL)
        -: 2432:    {
        -: 2433:      struct color_ext_type *e;
        -: 2434:      struct color_ext_type *e2;
        -: 2435:
    #####: 2436:      error (0, 0,
        -: 2437:             _("unparsable value for LS_COLORS environment variable"));
    #####: 2438:      free (color_buf);
    #####: 2439:      for (e = color_ext_list; e != NULL; /* empty */)
        -: 2440:        {
    #####: 2441:          e2 = e;
    #####: 2442:          e = e->next;
    #####: 2443:          free (e2);
        -: 2444:        }
    #####: 2445:      print_with_color = false;
        -: 2446:    }
        -: 2447:
    #####: 2448:  if (color_indicator[C_LINK].len == 6
    #####: 2449:      && !STRNCMP_LIT (color_indicator[C_LINK].string, "target"))
    #####: 2450:    color_symlink_as_referent = true;
        -: 2451:}
        -: 2452:
        -: 2453:/* Set the exit status to report a failure.  If SERIOUS, it is a
        -: 2454:   serious failure; otherwise, it is merely a minor problem.  */
        -: 2455:
        -: 2456:static void
    #####: 2457:set_exit_status (bool serious)
        -: 2458:{
    #####: 2459:  if (serious)
    #####: 2460:    exit_status = LS_FAILURE;
    #####: 2461:  else if (exit_status == EXIT_SUCCESS)
    #####: 2462:    exit_status = LS_MINOR_PROBLEM;
    #####: 2463:}
        -: 2464:
        -: 2465:/* Assuming a failure is serious if SERIOUS, use the printf-style
        -: 2466:   MESSAGE to report the failure to access a file named FILE.  Assume
        -: 2467:   errno is set appropriately for the failure.  */
        -: 2468:
        -: 2469:static void
    #####: 2470:file_failure (bool serious, char const *message, char const *file)
        -: 2471:{
    #####: 2472:  error (0, errno, message, quotearg_colon (file));
    #####: 2473:  set_exit_status (serious);
    #####: 2474:}
        -: 2475:
        -: 2476:/* Request that the directory named NAME have its contents listed later.
        -: 2477:   If REALNAME is nonzero, it will be used instead of NAME when the
        -: 2478:   directory name is printed.  This allows symbolic links to directories
        -: 2479:   to be treated as regular directories but still be listed under their
        -: 2480:   real names.  NAME == NULL is used to insert a marker entry for the
        -: 2481:   directory named in REALNAME.
        -: 2482:   If NAME is non-NULL, we use its dev/ino information to save
        -: 2483:   a call to stat -- when doing a recursive (-R) traversal.
        -: 2484:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2485:
        -: 2486:static void
    #####: 2487:queue_directory (char const *name, char const *realname, bool command_line_arg)
        -: 2488:{
    #####: 2489:  struct pending *new = xmalloc (sizeof *new);
    #####: 2490:  new->realname = realname ? xstrdup (realname) : NULL;
    #####: 2491:  new->name = name ? xstrdup (name) : NULL;
    #####: 2492:  new->command_line_arg = command_line_arg;
    #####: 2493:  new->next = pending_dirs;
    #####: 2494:  pending_dirs = new;
    #####: 2495:}
        -: 2496:
        -: 2497:/* Read directory NAME, and list the files in it.
        -: 2498:   If REALNAME is nonzero, print its name instead of NAME;
        -: 2499:   this is used for symbolic links to directories.
        -: 2500:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2501:
        -: 2502:static void
    #####: 2503:print_dir (char const *name, char const *realname, bool command_line_arg)
        -: 2504:{
        -: 2505:  DIR *dirp;
        -: 2506:  struct dirent *next;
    #####: 2507:  uintmax_t total_blocks = 0;
        -: 2508:  static bool first = true;
        -: 2509:
    #####: 2510:  errno = 0;
    #####: 2511:  dirp = opendir (name);
    #####: 2512:  if (!dirp)
        -: 2513:    {
    #####: 2514:      file_failure (command_line_arg, _("cannot open directory %s"), name);
    #####: 2515:      return;
        -: 2516:    }
        -: 2517:
    #####: 2518:  if (LOOP_DETECT)
        -: 2519:    {
        -: 2520:      struct stat dir_stat;
    #####: 2521:      int fd = dirfd (dirp);
        -: 2522:
        -: 2523:      /* If dirfd failed, endure the overhead of using stat.  */
    #####: 2524:      if ((0 <= fd
    #####: 2525:           ? fstat (fd, &dir_stat)
    #####: 2526:           : stat (name, &dir_stat)) < 0)
        -: 2527:        {
    #####: 2528:          file_failure (command_line_arg,
        -: 2529:                        _("cannot determine device and inode of %s"), name);
    #####: 2530:          closedir (dirp);
    #####: 2531:          return;
        -: 2532:        }
        -: 2533:
        -: 2534:      /* If we've already visited this dev/inode pair, warn that
        -: 2535:         we've found a loop, and do not process this directory.  */
    #####: 2536:      if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))
        -: 2537:        {
    #####: 2538:          error (0, 0, _("%s: not listing already-listed directory"),
        -: 2539:                 quotearg_colon (name));
    #####: 2540:          closedir (dirp);
    #####: 2541:          set_exit_status (true);
    #####: 2542:          return;
        -: 2543:        }
        -: 2544:
    #####: 2545:      DEV_INO_PUSH (dir_stat.st_dev, dir_stat.st_ino);
        -: 2546:    }
        -: 2547:
    #####: 2548:  if (recursive || print_dir_name)
        -: 2549:    {
    #####: 2550:      if (!first)
    #####: 2551:        DIRED_PUTCHAR ('\n');
    #####: 2552:      first = false;
    #####: 2553:      DIRED_INDENT ();
    #####: 2554:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
    #####: 2555:      dired_pos += quote_name (stdout, realname ? realname : name,
        -: 2556:                               dirname_quoting_options, NULL);
    #####: 2557:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
    #####: 2558:      DIRED_FPUTS_LITERAL (":\n", stdout);
        -: 2559:    }
        -: 2560:
        -: 2561:  /* Read the directory entries, and insert the subfiles into the 'cwd_file'
        -: 2562:     table.  */
        -: 2563:
    #####: 2564:  clear_files ();
        -: 2565:
        -: 2566:  while (1)
        -: 2567:    {
        -: 2568:      /* Set errno to zero so we can distinguish between a readdir failure
        -: 2569:         and when readdir simply finds that there are no more entries.  */
    #####: 2570:      errno = 0;
    #####: 2571:      next = readdir (dirp);
    #####: 2572:      if (next)
        -: 2573:        {
    #####: 2574:          if (! file_ignored (next->d_name))
        -: 2575:            {
    #####: 2576:              enum filetype type = unknown;
        -: 2577:
        -: 2578:#if HAVE_STRUCT_DIRENT_D_TYPE
    #####: 2579:              switch (next->d_type)
        -: 2580:                {
    #####: 2581:                case DT_BLK:  type = blockdev;		break;
    #####: 2582:                case DT_CHR:  type = chardev;		break;
    #####: 2583:                case DT_DIR:  type = directory;		break;
    #####: 2584:                case DT_FIFO: type = fifo;		break;
    #####: 2585:                case DT_LNK:  type = symbolic_link;	break;
    #####: 2586:                case DT_REG:  type = normal;		break;
    #####: 2587:                case DT_SOCK: type = sock;		break;
        -: 2588:# ifdef DT_WHT
    #####: 2589:                case DT_WHT:  type = whiteout;		break;
        -: 2590:# endif
        -: 2591:                }
        -: 2592:#endif
    #####: 2593:              total_blocks += gobble_file (next->d_name, type,
        -: 2594:                                           RELIABLE_D_INO (next),
        -: 2595:                                           false, name);
        -: 2596:
        -: 2597:              /* In this narrow case, print out each name right away, so
        -: 2598:                 ls uses constant memory while processing the entries of
        -: 2599:                 this directory.  Useful when there are many (millions)
        -: 2600:                 of entries in a directory.  */
    #####: 2601:              if (format == one_per_line && sort_type == sort_none
    #####: 2602:                      && !print_block_size && !recursive)
        -: 2603:                {
        -: 2604:                  /* We must call sort_files in spite of
        -: 2605:                     "sort_type == sort_none" for its initialization
        -: 2606:                     of the sorted_file vector.  */
    #####: 2607:                  sort_files ();
    #####: 2608:                  print_current_files ();
    #####: 2609:                  clear_files ();
        -: 2610:                }
        -: 2611:            }
        -: 2612:        }
    #####: 2613:      else if (errno != 0)
        -: 2614:        {
    #####: 2615:          file_failure (command_line_arg, _("reading directory %s"), name);
    #####: 2616:          if (errno != EOVERFLOW)
    #####: 2617:            break;
        -: 2618:        }
        -: 2619:      else
    #####: 2620:        break;
        -: 2621:
        -: 2622:      /* When processing a very large directory, and since we've inhibited
        -: 2623:         interrupts, this loop would take so long that ls would be annoyingly
        -: 2624:         uninterruptible.  This ensures that it handles signals promptly.  */
    #####: 2625:      process_signals ();
    #####: 2626:    }
        -: 2627:
    #####: 2628:  if (closedir (dirp) != 0)
        -: 2629:    {
    #####: 2630:      file_failure (command_line_arg, _("closing directory %s"), name);
        -: 2631:      /* Don't return; print whatever we got.  */
        -: 2632:    }
        -: 2633:
        -: 2634:  /* Sort the directory contents.  */
    #####: 2635:  sort_files ();
        -: 2636:
        -: 2637:  /* If any member files are subdirectories, perhaps they should have their
        -: 2638:     contents listed rather than being mentioned here as files.  */
        -: 2639:
    #####: 2640:  if (recursive)
    #####: 2641:    extract_dirs_from_files (name, command_line_arg);
        -: 2642:
    #####: 2643:  if (format == long_format || print_block_size)
        -: 2644:    {
        -: 2645:      const char *p;
        -: 2646:      char buf[LONGEST_HUMAN_READABLE + 1];
        -: 2647:
    #####: 2648:      DIRED_INDENT ();
    #####: 2649:      p = _("total");
    #####: 2650:      DIRED_FPUTS (p, stdout, strlen (p));
    #####: 2651:      DIRED_PUTCHAR (' ');
    #####: 2652:      p = human_readable (total_blocks, buf, human_output_opts,
        -: 2653:                          ST_NBLOCKSIZE, output_block_size);
    #####: 2654:      DIRED_FPUTS (p, stdout, strlen (p));
    #####: 2655:      DIRED_PUTCHAR ('\n');
        -: 2656:    }
        -: 2657:
    #####: 2658:  if (cwd_n_used)
    #####: 2659:    print_current_files ();
        -: 2660:}
        -: 2661:
        -: 2662:/* Add 'pattern' to the list of patterns for which files that match are
        -: 2663:   not listed.  */
        -: 2664:
        -: 2665:static void
    #####: 2666:add_ignore_pattern (const char *pattern)
        -: 2667:{
        -: 2668:  struct ignore_pattern *ignore;
        -: 2669:
    #####: 2670:  ignore = xmalloc (sizeof *ignore);
    #####: 2671:  ignore->pattern = pattern;
        -: 2672:  /* Add it to the head of the linked list.  */
    #####: 2673:  ignore->next = ignore_patterns;
    #####: 2674:  ignore_patterns = ignore;
    #####: 2675:}
        -: 2676:
        -: 2677:/* Return true if one of the PATTERNS matches FILE.  */
        -: 2678:
        -: 2679:static bool
    #####: 2680:patterns_match (struct ignore_pattern const *patterns, char const *file)
        -: 2681:{
        -: 2682:  struct ignore_pattern const *p;
    #####: 2683:  for (p = patterns; p; p = p->next)
    #####: 2684:    if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)
    #####: 2685:      return true;
    #####: 2686:  return false;
        -: 2687:}
        -: 2688:
        -: 2689:/* Return true if FILE should be ignored.  */
        -: 2690:
        -: 2691:static bool
    #####: 2692:file_ignored (char const *name)
        -: 2693:{
    #####: 2694:  return ((ignore_mode != IGNORE_MINIMAL
    #####: 2695:           && name[0] == '.'
    #####: 2696:           && (ignore_mode == IGNORE_DEFAULT || ! name[1 + (name[1] == '.')]))
    #####: 2697:          || (ignore_mode == IGNORE_DEFAULT
    #####: 2698:              && patterns_match (hide_patterns, name))
    #####: 2699:          || patterns_match (ignore_patterns, name));
        -: 2700:}
        -: 2701:
        -: 2702:/* POSIX requires that a file size be printed without a sign, even
        -: 2703:   when negative.  Assume the typical case where negative sizes are
        -: 2704:   actually positive values that have wrapped around.  */
        -: 2705:
        -: 2706:static uintmax_t
        2: 2707:unsigned_file_size (off_t size)
        -: 2708:{
        2: 2709:  return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);
        -: 2710:}
        -: 2711:
        -: 2712:#ifdef HAVE_CAP
        -: 2713:/* Return true if NAME has a capability (see linux/capability.h) */
        -: 2714:static bool
        -: 2715:has_capability (char const *name)
        -: 2716:{
        -: 2717:  char *result;
        -: 2718:  bool has_cap;
        -: 2719:
        -: 2720:  cap_t cap_d = cap_get_file (name);
        -: 2721:  if (cap_d == NULL)
        -: 2722:    return false;
        -: 2723:
        -: 2724:  result = cap_to_text (cap_d, NULL);
        -: 2725:  cap_free (cap_d);
        -: 2726:  if (!result)
        -: 2727:    return false;
        -: 2728:
        -: 2729:  /* check if human-readable capability string is empty */
        -: 2730:  has_cap = !!*result;
        -: 2731:
        -: 2732:  cap_free (result);
        -: 2733:  return has_cap;
        -: 2734:}
        -: 2735:#else
        -: 2736:static bool
    #####: 2737:has_capability (char const *name ATTRIBUTE_UNUSED)
        -: 2738:{
    #####: 2739:  errno = ENOTSUP;
    #####: 2740:  return false;
        -: 2741:}
        -: 2742:#endif
        -: 2743:
        -: 2744:/* Enter and remove entries in the table 'cwd_file'.  */
        -: 2745:
        -: 2746:static void
    #####: 2747:free_ent (struct fileinfo *f)
        -: 2748:{
    #####: 2749:  free (f->name);
    #####: 2750:  free (f->linkname);
    #####: 2751:  if (f->scontext != UNKNOWN_SECURITY_CONTEXT)
    #####: 2752:    freecon (f->scontext);
    #####: 2753:}
        -: 2754:
        -: 2755:/* Empty the table of files.  */
        -: 2756:static void
       10: 2757:clear_files (void)
        -: 2758:{
        -: 2759:  size_t i;
        -: 2760:
       10: 2761:  for (i = 0; i < cwd_n_used; i++)
        -: 2762:    {
    #####: 2763:      struct fileinfo *f = sorted_file[i];
    #####: 2764:      free_ent (f);
        -: 2765:    }
        -: 2766:
       10: 2767:  cwd_n_used = 0;
       10: 2768:  any_has_acl = false;
       10: 2769:  inode_number_width = 0;
       10: 2770:  block_size_width = 0;
       10: 2771:  nlink_width = 0;
       10: 2772:  owner_width = 0;
       10: 2773:  group_width = 0;
       10: 2774:  author_width = 0;
       10: 2775:  scontext_width = 0;
       10: 2776:  major_device_number_width = 0;
       10: 2777:  minor_device_number_width = 0;
       10: 2778:  file_size_width = 0;
       10: 2779:}
        -: 2780:
        -: 2781:/* Return true if ERR implies lack-of-support failure by a
        -: 2782:   getxattr-calling function like getfilecon or file_has_acl.  */
        -: 2783:static bool
        2: 2784:errno_unsupported (int err)
        -: 2785:{
        2: 2786:  return (err == EINVAL
        2: 2787:          || err == ENOSYS
        2: 2788:          || err == ENOTSUP
        3: 2789:          || err == EOPNOTSUPP);
        -: 2790:}
        -: 2791:
        -: 2792:/* Cache *getfilecon failure, when it's trivial to do so.
        -: 2793:   Like getfilecon/lgetfilecon, but when F's st_dev says it's on a known-
        -: 2794:   SELinux-challenged file system, fail with ENOTSUP immediately.  */
        -: 2795:static int
        1: 2796:getfilecon_cache (char const *file, struct fileinfo *f, bool deref)
        -: 2797:{
        -: 2798:  /* st_dev of the most recently processed device for which we've
        -: 2799:     found that [l]getfilecon fails indicating lack of support.  */
        -: 2800:  static dev_t unsupported_device;
        -: 2801:
        1: 2802:  if (f->stat.st_dev == unsupported_device)
        -: 2803:    {
    #####: 2804:      errno = ENOTSUP;
    #####: 2805:      return -1;
        -: 2806:    }
        1: 2807:  int r = (deref
    #####: 2808:           ? getfilecon (file, &f->scontext)
        1: 2809:           : lgetfilecon (file, &f->scontext));
        1: 2810:  if (r < 0 && errno_unsupported (errno))
        1: 2811:    unsupported_device = f->stat.st_dev;
        1: 2812:  return r;
        -: 2813:}
        -: 2814:
        -: 2815:/* Cache file_has_acl failure, when it's trivial to do.
        -: 2816:   Like file_has_acl, but when F's st_dev says it's on a file
        -: 2817:   system lacking ACL support, return 0 with ENOTSUP immediately.  */
        -: 2818:static int
        1: 2819:file_has_acl_cache (char const *file, struct fileinfo *f)
        -: 2820:{
        -: 2821:  /* st_dev of the most recently processed device for which we've
        -: 2822:     found that file_has_acl fails indicating lack of support.  */
        -: 2823:  static dev_t unsupported_device;
        -: 2824:
        1: 2825:  if (f->stat.st_dev == unsupported_device)
        -: 2826:    {
    #####: 2827:      errno = ENOTSUP;
    #####: 2828:      return 0;
        -: 2829:    }
        -: 2830:
        -: 2831:  /* Zero errno so that we can distinguish between two 0-returning cases:
        -: 2832:     "has-ACL-support, but only a default ACL" and "no ACL support". */
        1: 2833:  errno = 0;
        1: 2834:  int n = file_has_acl (file, &f->stat);
        1: 2835:  if (n <= 0 && errno_unsupported (errno))
    #####: 2836:    unsupported_device = f->stat.st_dev;
        1: 2837:  return n;
        -: 2838:}
        -: 2839:
        -: 2840:/* Cache has_capability failure, when it's trivial to do.
        -: 2841:   Like has_capability, but when F's st_dev says it's on a file
        -: 2842:   system lacking capability support, return 0 with ENOTSUP immediately.  */
        -: 2843:static bool
    #####: 2844:has_capability_cache (char const *file, struct fileinfo *f)
        -: 2845:{
        -: 2846:  /* st_dev of the most recently processed device for which we've
        -: 2847:     found that has_capability fails indicating lack of support.  */
        -: 2848:  static dev_t unsupported_device;
        -: 2849:
    #####: 2850:  if (f->stat.st_dev == unsupported_device)
        -: 2851:    {
    #####: 2852:      errno = ENOTSUP;
    #####: 2853:      return 0;
        -: 2854:    }
        -: 2855:
    #####: 2856:  bool b = has_capability (file);
    #####: 2857:  if ( !b && errno_unsupported (errno))
    #####: 2858:    unsupported_device = f->stat.st_dev;
    #####: 2859:  return b;
        -: 2860:}
        -: 2861:
        -: 2862:/* Add a file to the current table of files.
        -: 2863:   Verify that the file exists, and print an error message if it does not.
        -: 2864:   Return the number of blocks that the file occupies.  */
        -: 2865:static uintmax_t
       28: 2866:gobble_file (char const *name, enum filetype type, ino_t inode,
        -: 2867:             bool command_line_arg, char const *dirname)
        -: 2868:{
       28: 2869:  uintmax_t blocks = 0;
        -: 2870:  struct fileinfo *f;
        -: 2871:
        -: 2872:  /* An inode value prior to gobble_file necessarily came from readdir,
        -: 2873:     which is not used for command line arguments.  */
       28: 2874:  assert (! command_line_arg || inode == NOT_AN_INODE_NUMBER);
        -: 2875:
       28: 2876:  if (cwd_n_used == cwd_n_alloc)
        -: 2877:    {
    #####: 2878:      cwd_file = xnrealloc (cwd_file, cwd_n_alloc, 2 * sizeof *cwd_file);
    #####: 2879:      cwd_n_alloc *= 2;
        -: 2880:    }
        -: 2881:
       28: 2882:  f = &cwd_file[cwd_n_used];
       28: 2883:  memset (f, '\0', sizeof *f);
       28: 2884:  f->stat.st_ino = inode;
       28: 2885:  f->filetype = type;
        -: 2886:
       28: 2887:  if (command_line_arg
    #####: 2888:      || format_needs_stat
        -: 2889:      /* When coloring a directory (we may know the type from
        -: 2890:         direct.d_type), we have to stat it in order to indicate
        -: 2891:         sticky and/or other-writable attributes.  */
    #####: 2892:      || (type == directory && print_with_color
    #####: 2893:          && (is_colored (C_OTHER_WRITABLE)
    #####: 2894:              || is_colored (C_STICKY)
    #####: 2895:              || is_colored (C_STICKY_OTHER_WRITABLE)))
        -: 2896:      /* When dereferencing symlinks, the inode and type must come from
        -: 2897:         stat, but readdir provides the inode and type of lstat.  */
    #####: 2898:      || ((print_inode || format_needs_type)
    #####: 2899:          && (type == symbolic_link || type == unknown)
    #####: 2900:          && (dereference == DEREF_ALWAYS
    #####: 2901:              || (command_line_arg && dereference != DEREF_NEVER)
    #####: 2902:              || color_symlink_as_referent || check_symlink_color))
        -: 2903:      /* Command line dereferences are already taken care of by the above
        -: 2904:         assertion that the inode number is not yet known.  */
    #####: 2905:      || (print_inode && inode == NOT_AN_INODE_NUMBER)
    #####: 2906:      || (format_needs_type
    #####: 2907:          && (type == unknown || command_line_arg
        -: 2908:              /* --indicator-style=classify (aka -F)
        -: 2909:                 requires that we stat each regular file
        -: 2910:                 to see if it's executable.  */
    #####: 2911:              || (type == normal && (indicator_style == classify
        -: 2912:                                     /* This is so that --color ends up
        -: 2913:                                        highlighting files with these mode
        -: 2914:                                        bits set even when options like -F are
        -: 2915:                                        not specified.  Note we do a redundant
        -: 2916:                                        stat in the very unlikely case where
        -: 2917:                                        C_CAP is set but not the others. */
    #####: 2918:                                     || (print_with_color
    #####: 2919:                                         && (is_colored (C_EXEC)
    #####: 2920:                                             || is_colored (C_SETUID)
    #####: 2921:                                             || is_colored (C_SETGID)
    #####: 2922:                                             || is_colored (C_CAP)))
        -: 2923:                                     )))))
        -: 2924:
        -: 2925:    {
        -: 2926:      /* Absolute name of this file.  */
        -: 2927:      char *absolute_name;
        -: 2928:      bool do_deref;
        -: 2929:      int err;
        -: 2930:
       28: 2931:      if (name[0] == '/' || dirname[0] == 0)
       28: 2932:        absolute_name = (char *) name;
        -: 2933:      else
        -: 2934:        {
    #####: 2935:          absolute_name = alloca (strlen (name) + strlen (dirname) + 2);
    #####: 2936:          attach (absolute_name, dirname, name);
        -: 2937:        }
        -: 2938:
       28: 2939:      switch (dereference)
        -: 2940:        {
        -: 2941:        case DEREF_ALWAYS:
    #####: 2942:          err = stat (absolute_name, &f->stat);
    #####: 2943:          do_deref = true;
    #####: 2944:          break;
        -: 2945:
        -: 2946:        case DEREF_COMMAND_LINE_ARGUMENTS:
        -: 2947:        case DEREF_COMMAND_LINE_SYMLINK_TO_DIR:
       19: 2948:          if (command_line_arg)
        -: 2949:            {
        -: 2950:              bool need_lstat;
       19: 2951:              err = stat (absolute_name, &f->stat);
       19: 2952:              do_deref = true;
        -: 2953:
       19: 2954:              if (dereference == DEREF_COMMAND_LINE_ARGUMENTS)
    #####: 2955:                break;
        -: 2956:
       19: 2957:              need_lstat = (err < 0
    #####: 2958:                            ? errno == ENOENT
       19: 2959:                            : ! S_ISDIR (f->stat.st_mode));
       19: 2960:              if (!need_lstat)
    #####: 2961:                break;
        -: 2962:
        -: 2963:              /* stat failed because of ENOENT, maybe indicating a dangling
        -: 2964:                 symlink.  Or stat succeeded, ABSOLUTE_NAME does not refer to a
        -: 2965:                 directory, and --dereference-command-line-symlink-to-dir is
        -: 2966:                 in effect.  Fall through so that we call lstat instead.  */
        -: 2967:            }
        -: 2968:
        -: 2969:        default: /* DEREF_NEVER */
       28: 2970:          err = lstat (absolute_name, &f->stat);
       28: 2971:          do_deref = false;
       28: 2972:          break;
        -: 2973:        }
        -: 2974:
       28: 2975:      if (err != 0)
        -: 2976:        {
        -: 2977:          /* Failure to stat a command line argument leads to
        -: 2978:             an exit status of 2.  For other files, stat failure
        -: 2979:             provokes an exit status of 1.  */
    #####: 2980:          file_failure (command_line_arg,
        -: 2981:                        _("cannot access %s"), absolute_name);
    #####: 2982:          if (command_line_arg)
    #####: 2983:            return 0;
        -: 2984:
    #####: 2985:          f->name = xstrdup (name);
    #####: 2986:          cwd_n_used++;
        -: 2987:
    #####: 2988:          return 0;
        -: 2989:        }
        -: 2990:
       28: 2991:      f->stat_ok = true;
        -: 2992:
        -: 2993:      /* Note has_capability() adds around 30% runtime to 'ls --color'  */
       28: 2994:      if ((type == normal || S_ISREG (f->stat.st_mode))
       19: 2995:          && print_with_color && is_colored (C_CAP))
    #####: 2996:        f->has_capability = has_capability_cache (absolute_name, f);
        -: 2997:
       28: 2998:      if (format == long_format || print_scontext)
        -: 2999:        {
        1: 3000:          bool have_selinux = false;
        1: 3001:          bool have_acl = false;
        1: 3002:          int attr_len = getfilecon_cache (absolute_name, f, do_deref);
        1: 3003:          err = (attr_len < 0);
        -: 3004:
        1: 3005:          if (err == 0)
    #####: 3006:            have_selinux = ! STREQ ("unlabeled", f->scontext);
        -: 3007:          else
        -: 3008:            {
        1: 3009:              f->scontext = UNKNOWN_SECURITY_CONTEXT;
        -: 3010:
        -: 3011:              /* When requesting security context information, don't make
        -: 3012:                 ls fail just because the file (even a command line argument)
        -: 3013:                 isn't on the right type of file system.  I.e., a getfilecon
        -: 3014:                 failure isn't in the same class as a stat failure.  */
        1: 3015:              if (errno == ENOTSUP || errno == EOPNOTSUPP || errno == ENODATA)
        1: 3016:                err = 0;
        -: 3017:            }
        -: 3018:
        1: 3019:          if (err == 0 && format == long_format)
        -: 3020:            {
        1: 3021:              int n = file_has_acl_cache (absolute_name, f);
        1: 3022:              err = (n < 0);
        1: 3023:              have_acl = (0 < n);
        -: 3024:            }
        -: 3025:
        1: 3026:          f->acl_type = (!have_selinux && !have_acl
        -: 3027:                         ? ACL_T_NONE
    #####: 3028:                         : (have_selinux && !have_acl
        -: 3029:                            ? ACL_T_SELINUX_ONLY
        -: 3030:                            : ACL_T_YES));
        1: 3031:          any_has_acl |= f->acl_type != ACL_T_NONE;
        -: 3032:
        1: 3033:          if (err)
    #####: 3034:            error (0, errno, "%s", quotearg_colon (absolute_name));
        -: 3035:        }
        -: 3036:
       28: 3037:      if (S_ISLNK (f->stat.st_mode)
    #####: 3038:          && (format == long_format || check_symlink_color))
        -: 3039:        {
        -: 3040:          char *linkname;
        -: 3041:          struct stat linkstats;
        -: 3042:
    #####: 3043:          get_link_name (absolute_name, f, command_line_arg);
    #####: 3044:          linkname = make_link_name (absolute_name, f->linkname);
        -: 3045:
        -: 3046:          /* Avoid following symbolic links when possible, ie, when
        -: 3047:             they won't be traced and when no indicator is needed.  */
    #####: 3048:          if (linkname
    #####: 3049:              && (file_type <= indicator_style || check_symlink_color)
    #####: 3050:              && stat (linkname, &linkstats) == 0)
        -: 3051:            {
    #####: 3052:              f->linkok = true;
        -: 3053:
        -: 3054:              /* Symbolic links to directories that are mentioned on the
        -: 3055:                 command line are automatically traced if not being
        -: 3056:                 listed as files.  */
    #####: 3057:              if (!command_line_arg || format == long_format
    #####: 3058:                  || !S_ISDIR (linkstats.st_mode))
        -: 3059:                {
        -: 3060:                  /* Get the linked-to file's mode for the filetype indicator
        -: 3061:                     in long listings.  */
    #####: 3062:                  f->linkmode = linkstats.st_mode;
        -: 3063:                }
        -: 3064:            }
    #####: 3065:          free (linkname);
        -: 3066:        }
        -: 3067:
        -: 3068:      /* When not distinguishing types of symlinks, pretend we know that
        -: 3069:         it is stat'able, so that it will be colored as a regular symlink,
        -: 3070:         and not as an orphan.  */
       28: 3071:      if (S_ISLNK (f->stat.st_mode) && !check_symlink_color)
    #####: 3072:        f->linkok = true;
        -: 3073:
       28: 3074:      if (S_ISLNK (f->stat.st_mode))
    #####: 3075:        f->filetype = symbolic_link;
       28: 3076:      else if (S_ISDIR (f->stat.st_mode))
        -: 3077:        {
        9: 3078:          if (command_line_arg && !immediate_dirs)
    #####: 3079:            f->filetype = arg_directory;
        -: 3080:          else
        9: 3081:            f->filetype = directory;
        -: 3082:        }
        -: 3083:      else
       19: 3084:        f->filetype = normal;
        -: 3085:
       28: 3086:      blocks = ST_NBLOCKS (f->stat);
       28: 3087:      if (format == long_format || print_block_size)
        -: 3088:        {
        -: 3089:          char buf[LONGEST_HUMAN_READABLE + 1];
        1: 3090:          int len = mbswidth (human_readable (blocks, buf, human_output_opts,
        -: 3091:                                              ST_NBLOCKSIZE, output_block_size),
        -: 3092:                              0);
        1: 3093:          if (block_size_width < len)
        1: 3094:            block_size_width = len;
        -: 3095:        }
        -: 3096:
       28: 3097:      if (format == long_format)
        -: 3098:        {
        1: 3099:          if (print_owner)
        -: 3100:            {
    #####: 3101:              int len = format_user_width (f->stat.st_uid);
    #####: 3102:              if (owner_width < len)
    #####: 3103:                owner_width = len;
        -: 3104:            }
        -: 3105:
        1: 3106:          if (print_group)
        -: 3107:            {
    #####: 3108:              int len = format_group_width (f->stat.st_gid);
    #####: 3109:              if (group_width < len)
    #####: 3110:                group_width = len;
        -: 3111:            }
        -: 3112:
        1: 3113:          if (print_author)
        -: 3114:            {
    #####: 3115:              int len = format_user_width (f->stat.st_author);
    #####: 3116:              if (author_width < len)
    #####: 3117:                author_width = len;
        -: 3118:            }
        -: 3119:        }
        -: 3120:
       28: 3121:      if (print_scontext)
        -: 3122:        {
    #####: 3123:          int len = strlen (f->scontext);
    #####: 3124:          if (scontext_width < len)
    #####: 3125:            scontext_width = len;
        -: 3126:        }
        -: 3127:
       28: 3128:      if (format == long_format)
        -: 3129:        {
        -: 3130:          char b[INT_BUFSIZE_BOUND (uintmax_t)];
        1: 3131:          int b_len = strlen (umaxtostr (f->stat.st_nlink, b));
        1: 3132:          if (nlink_width < b_len)
        1: 3133:            nlink_width = b_len;
        -: 3134:
        1: 3135:          if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))
    #####: 3136:            {
        -: 3137:              char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3138:              int len = strlen (umaxtostr (major (f->stat.st_rdev), buf));
    #####: 3139:              if (major_device_number_width < len)
    #####: 3140:                major_device_number_width = len;
    #####: 3141:              len = strlen (umaxtostr (minor (f->stat.st_rdev), buf));
    #####: 3142:              if (minor_device_number_width < len)
    #####: 3143:                minor_device_number_width = len;
    #####: 3144:              len = major_device_number_width + 2 + minor_device_number_width;
    #####: 3145:              if (file_size_width < len)
    #####: 3146:                file_size_width = len;
        -: 3147:            }
        -: 3148:          else
        -: 3149:            {
        -: 3150:              char buf[LONGEST_HUMAN_READABLE + 1];
        1: 3151:              uintmax_t size = unsigned_file_size (f->stat.st_size);
        1: 3152:              int len = mbswidth (human_readable (size, buf,
        -: 3153:                                                  file_human_output_opts,
        -: 3154:                                                  1, file_output_block_size),
        -: 3155:                                  0);
        1: 3156:              if (file_size_width < len)
        1: 3157:                file_size_width = len;
        -: 3158:            }
        -: 3159:        }
        -: 3160:    }
        -: 3161:
       28: 3162:  if (print_inode)
        -: 3163:    {
        -: 3164:      char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3165:      int len = strlen (umaxtostr (f->stat.st_ino, buf));
    #####: 3166:      if (inode_number_width < len)
    #####: 3167:        inode_number_width = len;
        -: 3168:    }
        -: 3169:
       28: 3170:  f->name = xstrdup (name);
       28: 3171:  cwd_n_used++;
        -: 3172:
       28: 3173:  return blocks;
        -: 3174:}
        -: 3175:
        -: 3176:/* Return true if F refers to a directory.  */
        -: 3177:static bool
       19: 3178:is_directory (const struct fileinfo *f)
        -: 3179:{
       19: 3180:  return f->filetype == directory || f->filetype == arg_directory;
        -: 3181:}
        -: 3182:
        -: 3183:/* Put the name of the file that FILENAME is a symbolic link to
        -: 3184:   into the LINKNAME field of 'f'.  COMMAND_LINE_ARG indicates whether
        -: 3185:   FILENAME is a command-line argument.  */
        -: 3186:
        -: 3187:static void
    #####: 3188:get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
        -: 3189:{
    #####: 3190:  f->linkname = areadlink_with_size (filename, f->stat.st_size);
    #####: 3191:  if (f->linkname == NULL)
    #####: 3192:    file_failure (command_line_arg, _("cannot read symbolic link %s"),
        -: 3193:                  filename);
    #####: 3194:}
        -: 3195:
        -: 3196:/* If 'linkname' is a relative name and 'name' contains one or more
        -: 3197:   leading directories, return 'linkname' with those directories
        -: 3198:   prepended; otherwise, return a copy of 'linkname'.
        -: 3199:   If 'linkname' is zero, return zero.  */
        -: 3200:
        -: 3201:static char *
    #####: 3202:make_link_name (char const *name, char const *linkname)
        -: 3203:{
        -: 3204:  char *linkbuf;
        -: 3205:  size_t bufsiz;
        -: 3206:
    #####: 3207:  if (!linkname)
    #####: 3208:    return NULL;
        -: 3209:
    #####: 3210:  if (*linkname == '/')
    #####: 3211:    return xstrdup (linkname);
        -: 3212:
        -: 3213:  /* The link is to a relative name.  Prepend any leading directory
        -: 3214:     in 'name' to the link name.  */
    #####: 3215:  linkbuf = strrchr (name, '/');
    #####: 3216:  if (linkbuf == 0)
    #####: 3217:    return xstrdup (linkname);
        -: 3218:
    #####: 3219:  bufsiz = linkbuf - name + 1;
    #####: 3220:  linkbuf = xmalloc (bufsiz + strlen (linkname) + 1);
    #####: 3221:  strncpy (linkbuf, name, bufsiz);
    #####: 3222:  strcpy (linkbuf + bufsiz, linkname);
    #####: 3223:  return linkbuf;
        -: 3224:}
        -: 3225:
        -: 3226:/* Return true if the last component of NAME is '.' or '..'
        -: 3227:   This is so we don't try to recurse on '././././. ...' */
        -: 3228:
        -: 3229:static bool
    #####: 3230:basename_is_dot_or_dotdot (const char *name)
        -: 3231:{
    #####: 3232:  char const *base = last_component (name);
    #####: 3233:  return dot_or_dotdot (base);
        -: 3234:}
        -: 3235:
        -: 3236:/* Remove any entries from CWD_FILE that are for directories,
        -: 3237:   and queue them to be listed as directories instead.
        -: 3238:   DIRNAME is the prefix to prepend to each dirname
        -: 3239:   to make it correct relative to ls's working dir;
        -: 3240:   if it is null, no prefix is needed and "." and ".." should not be ignored.
        -: 3241:   If COMMAND_LINE_ARG is true, this directory was mentioned at the top level,
        -: 3242:   This is desirable when processing directories recursively.  */
        -: 3243:
        -: 3244:static void
        1: 3245:extract_dirs_from_files (char const *dirname, bool command_line_arg)
        -: 3246:{
        -: 3247:  size_t i;
        -: 3248:  size_t j;
        1: 3249:  bool ignore_dot_and_dot_dot = (dirname != NULL);
        -: 3250:
        1: 3251:  if (dirname && LOOP_DETECT)
        -: 3252:    {
        -: 3253:      /* Insert a marker entry first.  When we dequeue this marker entry,
        -: 3254:         we'll know that DIRNAME has been processed and may be removed
        -: 3255:         from the set of active directories.  */
    #####: 3256:      queue_directory (NULL, dirname, false);
        -: 3257:    }
        -: 3258:
        -: 3259:  /* Queue the directories last one first, because queueing reverses the
        -: 3260:     order.  */
       21: 3261:  for (i = cwd_n_used; i-- != 0; )
        -: 3262:    {
       19: 3263:      struct fileinfo *f = sorted_file[i];
        -: 3264:
       19: 3265:      if (is_directory (f)
    #####: 3266:          && (! ignore_dot_and_dot_dot
    #####: 3267:              || ! basename_is_dot_or_dotdot (f->name)))
        -: 3268:        {
    #####: 3269:          if (!dirname || f->name[0] == '/')
    #####: 3270:            queue_directory (f->name, f->linkname, command_line_arg);
        -: 3271:          else
        -: 3272:            {
    #####: 3273:              char *name = file_name_concat (dirname, f->name, NULL);
    #####: 3274:              queue_directory (name, f->linkname, command_line_arg);
    #####: 3275:              free (name);
        -: 3276:            }
    #####: 3277:          if (f->filetype == arg_directory)
    #####: 3278:            free_ent (f);
        -: 3279:        }
        -: 3280:    }
        -: 3281:
        -: 3282:  /* Now delete the directories from the table, compacting all the remaining
        -: 3283:     entries.  */
        -: 3284:
       20: 3285:  for (i = 0, j = 0; i < cwd_n_used; i++)
        -: 3286:    {
       19: 3287:      struct fileinfo *f = sorted_file[i];
       19: 3288:      sorted_file[j] = f;
       19: 3289:      j += (f->filetype != arg_directory);
        -: 3290:    }
        1: 3291:  cwd_n_used = j;
        1: 3292:}
        -: 3293:
        -: 3294:/* Use strcoll to compare strings in this locale.  If an error occurs,
        -: 3295:   report an error and longjmp to failed_strcoll.  */
        -: 3296:
        -: 3297:static jmp_buf failed_strcoll;
        -: 3298:
        -: 3299:static int
       37: 3300:xstrcoll (char const *a, char const *b)
        -: 3301:{
        -: 3302:  int diff;
       37: 3303:  errno = 0;
       37: 3304:  diff = strcoll (a, b);
       37: 3305:  if (errno)
        -: 3306:    {
    #####: 3307:      error (0, errno, _("cannot compare file names %s and %s"),
        -: 3308:             quote_n (0, a), quote_n (1, b));
    #####: 3309:      set_exit_status (false);
    #####: 3310:      longjmp (failed_strcoll, 1);
        -: 3311:    }
       37: 3312:  return diff;
        -: 3313:}
        -: 3314:
        -: 3315:/* Comparison routines for sorting the files.  */
        -: 3316:
        -: 3317:typedef void const *V;
        -: 3318:typedef int (*qsortFunc)(V a, V b);
        -: 3319:
        -: 3320:/* Used below in DEFINE_SORT_FUNCTIONS for _df_ sort function variants.
        -: 3321:   The do { ... } while(0) makes it possible to use the macro more like
        -: 3322:   a statement, without violating C89 rules: */
        -: 3323:#define DIRFIRST_CHECK(a, b)						\
        -: 3324:  do									\
        -: 3325:    {									\
        -: 3326:      bool a_is_dir = is_directory ((struct fileinfo const *) a);	\
        -: 3327:      bool b_is_dir = is_directory ((struct fileinfo const *) b);	\
        -: 3328:      if (a_is_dir && !b_is_dir)					\
        -: 3329:        return -1;         /* a goes before b */			\
        -: 3330:      if (!a_is_dir && b_is_dir)					\
        -: 3331:        return 1;          /* b goes before a */			\
        -: 3332:    }									\
        -: 3333:  while (0)
        -: 3334:
        -: 3335:/* Define the 8 different sort function variants required for each sortkey.
        -: 3336:   KEY_NAME is a token describing the sort key, e.g., ctime, atime, size.
        -: 3337:   KEY_CMP_FUNC is a function to compare records based on that key, e.g.,
        -: 3338:   ctime_cmp, atime_cmp, size_cmp.  Append KEY_NAME to the string,
        -: 3339:   '[rev_][x]str{cmp|coll}[_df]_', to create each function name.  */
        -: 3340:#define DEFINE_SORT_FUNCTIONS(key_name, key_cmp_func)			\
        -: 3341:  /* direct, non-dirfirst versions */					\
        -: 3342:  static int xstrcoll_##key_name (V a, V b)				\
        -: 3343:  { return key_cmp_func (a, b, xstrcoll); }				\
        -: 3344:  static int strcmp_##key_name (V a, V b)				\
        -: 3345:  { return key_cmp_func (a, b, strcmp); }				\
        -: 3346:                                                                        \
        -: 3347:  /* reverse, non-dirfirst versions */					\
        -: 3348:  static int rev_xstrcoll_##key_name (V a, V b)				\
        -: 3349:  { return key_cmp_func (b, a, xstrcoll); }				\
        -: 3350:  static int rev_strcmp_##key_name (V a, V b)				\
        -: 3351:  { return key_cmp_func (b, a, strcmp); }				\
        -: 3352:                                                                        \
        -: 3353:  /* direct, dirfirst versions */					\
        -: 3354:  static int xstrcoll_df_##key_name (V a, V b)				\
        -: 3355:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, xstrcoll); }	\
        -: 3356:  static int strcmp_df_##key_name (V a, V b)				\
        -: 3357:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, strcmp); }	\
        -: 3358:                                                                        \
        -: 3359:  /* reverse, dirfirst versions */					\
        -: 3360:  static int rev_xstrcoll_df_##key_name (V a, V b)			\
        -: 3361:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, xstrcoll); }	\
        -: 3362:  static int rev_strcmp_df_##key_name (V a, V b)			\
        -: 3363:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, strcmp); }
        -: 3364:
        -: 3365:static inline int
    #####: 3366:cmp_ctime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3367:           int (*cmp) (char const *, char const *))
        -: 3368:{
    #####: 3369:  int diff = timespec_cmp (get_stat_ctime (&b->stat),
        -: 3370:                           get_stat_ctime (&a->stat));
    #####: 3371:  return diff ? diff : cmp (a->name, b->name);
        -: 3372:}
        -: 3373:
        -: 3374:static inline int
    #####: 3375:cmp_mtime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3376:           int (*cmp) (char const *, char const *))
        -: 3377:{
    #####: 3378:  int diff = timespec_cmp (get_stat_mtime (&b->stat),
        -: 3379:                           get_stat_mtime (&a->stat));
    #####: 3380:  return diff ? diff : cmp (a->name, b->name);
        -: 3381:}
        -: 3382:
        -: 3383:static inline int
    #####: 3384:cmp_atime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3385:           int (*cmp) (char const *, char const *))
        -: 3386:{
    #####: 3387:  int diff = timespec_cmp (get_stat_atime (&b->stat),
        -: 3388:                           get_stat_atime (&a->stat));
    #####: 3389:  return diff ? diff : cmp (a->name, b->name);
        -: 3390:}
        -: 3391:
        -: 3392:static inline int
    #####: 3393:cmp_size (struct fileinfo const *a, struct fileinfo const *b,
        -: 3394:          int (*cmp) (char const *, char const *))
        -: 3395:{
    #####: 3396:  int diff = longdiff (b->stat.st_size, a->stat.st_size);
    #####: 3397:  return diff ? diff : cmp (a->name, b->name);
        -: 3398:}
        -: 3399:
        -: 3400:static inline int
       37: 3401:cmp_name (struct fileinfo const *a, struct fileinfo const *b,
        -: 3402:          int (*cmp) (char const *, char const *))
        -: 3403:{
       37: 3404:  return cmp (a->name, b->name);
        -: 3405:}
        -: 3406:
        -: 3407:/* Compare file extensions.  Files with no extension are 'smallest'.
        -: 3408:   If extensions are the same, compare by filenames instead.  */
        -: 3409:
        -: 3410:static inline int
    #####: 3411:cmp_extension (struct fileinfo const *a, struct fileinfo const *b,
        -: 3412:               int (*cmp) (char const *, char const *))
        -: 3413:{
    #####: 3414:  char const *base1 = strrchr (a->name, '.');
    #####: 3415:  char const *base2 = strrchr (b->name, '.');
    #####: 3416:  int diff = cmp (base1 ? base1 : "", base2 ? base2 : "");
    #####: 3417:  return diff ? diff : cmp (a->name, b->name);
        -: 3418:}
        -: 3419:
    #####: 3420:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
    #####: 3421:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
    #####: 3422:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
    #####: 3423:DEFINE_SORT_FUNCTIONS (size, cmp_size)
       37: 3424:DEFINE_SORT_FUNCTIONS (name, cmp_name)
    #####: 3425:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
        -: 3426:
        -: 3427:/* Compare file versions.
        -: 3428:   Unlike all other compare functions above, cmp_version depends only
        -: 3429:   on filevercmp, which does not fail (even for locale reasons), and does not
        -: 3430:   need a secondary sort key. See lib/filevercmp.h for function description.
        -: 3431:
        -: 3432:   All the other sort options, in fact, need xstrcoll and strcmp variants,
        -: 3433:   because they all use a string comparison (either as the primary or secondary
        -: 3434:   sort key), and xstrcoll has the ability to do a longjmp if strcoll fails for
        -: 3435:   locale reasons.  Lastly, filevercmp is ALWAYS available with gnulib.  */
        -: 3436:static inline int
    #####: 3437:cmp_version (struct fileinfo const *a, struct fileinfo const *b)
        -: 3438:{
    #####: 3439:  return filevercmp (a->name, b->name);
        -: 3440:}
        -: 3441:
    #####: 3442:static int xstrcoll_version (V a, V b)
    #####: 3443:{ return cmp_version (a, b); }
    #####: 3444:static int rev_xstrcoll_version (V a, V b)
    #####: 3445:{ return cmp_version (b, a); }
    #####: 3446:static int xstrcoll_df_version (V a, V b)
    #####: 3447:{ DIRFIRST_CHECK (a, b); return cmp_version (a, b); }
    #####: 3448:static int rev_xstrcoll_df_version (V a, V b)
    #####: 3449:{ DIRFIRST_CHECK (a, b); return cmp_version (b, a); }
        -: 3450:
        -: 3451:
        -: 3452:/* We have 2^3 different variants for each sortkey function
        -: 3453:   (for 3 independent sort modes).
        -: 3454:   The function pointers stored in this array must be dereferenced as:
        -: 3455:
        -: 3456:    sort_variants[sort_key][use_strcmp][reverse][dirs_first]
        -: 3457:
        -: 3458:   Note that the order in which sortkeys are listed in the function pointer
        -: 3459:   array below is defined by the order of the elements in the time_type and
        -: 3460:   sort_type enums!  */
        -: 3461:
        -: 3462:#define LIST_SORTFUNCTION_VARIANTS(key_name)                        \
        -: 3463:  {                                                                 \
        -: 3464:    {                                                               \
        -: 3465:      { xstrcoll_##key_name, xstrcoll_df_##key_name },              \
        -: 3466:      { rev_xstrcoll_##key_name, rev_xstrcoll_df_##key_name },      \
        -: 3467:    },                                                              \
        -: 3468:    {                                                               \
        -: 3469:      { strcmp_##key_name, strcmp_df_##key_name },                  \
        -: 3470:      { rev_strcmp_##key_name, rev_strcmp_df_##key_name },          \
        -: 3471:    }                                                               \
        -: 3472:  }
        -: 3473:
        -: 3474:static qsortFunc const sort_functions[][2][2][2] =
        -: 3475:  {
        -: 3476:    LIST_SORTFUNCTION_VARIANTS (name),
        -: 3477:    LIST_SORTFUNCTION_VARIANTS (extension),
        -: 3478:    LIST_SORTFUNCTION_VARIANTS (size),
        -: 3479:
        -: 3480:    {
        -: 3481:      {
        -: 3482:        { xstrcoll_version, xstrcoll_df_version },
        -: 3483:        { rev_xstrcoll_version, rev_xstrcoll_df_version },
        -: 3484:      },
        -: 3485:
        -: 3486:      /* We use NULL for the strcmp variants of version comparison
        -: 3487:         since as explained in cmp_version definition, version comparison
        -: 3488:         does not rely on xstrcoll, so it will never longjmp, and never
        -: 3489:         need to try the strcmp fallback. */
        -: 3490:      {
        -: 3491:        { NULL, NULL },
        -: 3492:        { NULL, NULL },
        -: 3493:      }
        -: 3494:    },
        -: 3495:
        -: 3496:    /* last are time sort functions */
        -: 3497:    LIST_SORTFUNCTION_VARIANTS (mtime),
        -: 3498:    LIST_SORTFUNCTION_VARIANTS (ctime),
        -: 3499:    LIST_SORTFUNCTION_VARIANTS (atime)
        -: 3500:  };
        -: 3501:
        -: 3502:/* The number of sortkeys is calculated as
        -: 3503:     the number of elements in the sort_type enum (i.e. sort_numtypes) +
        -: 3504:     the number of elements in the time_type enum (i.e. time_numtypes) - 1
        -: 3505:   This is because when sort_type==sort_time, we have up to
        -: 3506:   time_numtypes possible sortkeys.
        -: 3507:
        -: 3508:   This line verifies at compile-time that the array of sort functions has been
        -: 3509:   initialized for all possible sortkeys. */
        -: 3510:verify (ARRAY_CARDINALITY (sort_functions)
        -: 3511:        == sort_numtypes + time_numtypes - 1 );
        -: 3512:
        -: 3513:/* Set up SORTED_FILE to point to the in-use entries in CWD_FILE, in order.  */
        -: 3514:
        -: 3515:static void
       10: 3516:initialize_ordering_vector (void)
        -: 3517:{
        -: 3518:  size_t i;
       38: 3519:  for (i = 0; i < cwd_n_used; i++)
       28: 3520:    sorted_file[i] = &cwd_file[i];
       10: 3521:}
        -: 3522:
        -: 3523:/* Sort the files now in the table.  */
        -: 3524:
        -: 3525:static void
       10: 3526:sort_files (void)
        -: 3527:{
        -: 3528:  bool use_strcmp;
        -: 3529:
       10: 3530:  if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)
        -: 3531:    {
       10: 3532:      free (sorted_file);
       10: 3533:      sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);
       10: 3534:      sorted_file_alloc = 3 * cwd_n_used;
        -: 3535:    }
        -: 3536:
       10: 3537:  initialize_ordering_vector ();
        -: 3538:
       10: 3539:  if (sort_type == sort_none)
       10: 3540:    return;
        -: 3541:
        -: 3542:  /* Try strcoll.  If it fails, fall back on strcmp.  We can't safely
        -: 3543:     ignore strcoll failures, as a failing strcoll might be a
        -: 3544:     comparison function that is not a total order, and if we ignored
        -: 3545:     the failure this might cause qsort to dump core.  */
        -: 3546:
       10: 3547:  if (! setjmp (failed_strcoll))
       10: 3548:    use_strcmp = false;      /* strcoll() succeeded */
        -: 3549:  else
        -: 3550:    {
    #####: 3551:      use_strcmp = true;
    #####: 3552:      assert (sort_type != sort_version);
    #####: 3553:      initialize_ordering_vector ();
        -: 3554:    }
        -: 3555:
        -: 3556:  /* When sort_type == sort_time, use time_type as subindex.  */
       20: 3557:  mpsort ((void const **) sorted_file, cwd_n_used,
       10: 3558:          sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]
        -: 3559:                        [use_strcmp][sort_reverse]
       10: 3560:                        [directories_first]);
        -: 3561:}
        -: 3562:
        -: 3563:/* List all the files now in the table.  */
        -: 3564:
        -: 3565:static void
       10: 3566:print_current_files (void)
        -: 3567:{
        -: 3568:  size_t i;
        -: 3569:
       10: 3570:  switch (format)
        -: 3571:    {
        -: 3572:    case one_per_line:
       36: 3573:      for (i = 0; i < cwd_n_used; i++)
        -: 3574:        {
       27: 3575:          print_file_name_and_frills (sorted_file[i], 0);
       27: 3576:          putchar ('\n');
        -: 3577:        }
        9: 3578:      break;
        -: 3579:
        -: 3580:    case many_per_line:
    #####: 3581:      print_many_per_line ();
    #####: 3582:      break;
        -: 3583:
        -: 3584:    case horizontal:
    #####: 3585:      print_horizontal ();
    #####: 3586:      break;
        -: 3587:
        -: 3588:    case with_commas:
    #####: 3589:      print_with_commas ();
    #####: 3590:      break;
        -: 3591:
        -: 3592:    case long_format:
        2: 3593:      for (i = 0; i < cwd_n_used; i++)
        -: 3594:        {
        1: 3595:          set_normal_color ();
        1: 3596:          print_long_format (sorted_file[i]);
        1: 3597:          DIRED_PUTCHAR ('\n');
        -: 3598:        }
        1: 3599:      break;
        -: 3600:    }
       10: 3601:}
        -: 3602:
        -: 3603:/* Replace the first %b with precomputed aligned month names.
        -: 3604:   Note on glibc-2.7 at least, this speeds up the whole 'ls -lU'
        -: 3605:   process by around 17%, compared to letting strftime() handle the %b.  */
        -: 3606:
        -: 3607:static size_t
        1: 3608:align_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,
        -: 3609:                 int __utc, int __ns)
        -: 3610:{
        1: 3611:  const char *nfmt = fmt;
        -: 3612:  /* In the unlikely event that rpl_fmt below is not large enough,
        -: 3613:     the replacement is not done.  A malloc here slows ls down by 2%  */
        -: 3614:  char rpl_fmt[sizeof (abmon[0]) + 100];
        -: 3615:  const char *pb;
        1: 3616:  if (required_mon_width && (pb = strstr (fmt, "%b")))
        -: 3617:    {
        1: 3618:      if (strlen (fmt) < (sizeof (rpl_fmt) - sizeof (abmon[0]) + 2))
        -: 3619:        {
        1: 3620:          char *pfmt = rpl_fmt;
        1: 3621:          nfmt = rpl_fmt;
        -: 3622:
        1: 3623:          pfmt = mempcpy (pfmt, fmt, pb - fmt);
        1: 3624:          pfmt = stpcpy (pfmt, abmon[tm->tm_mon]);
        1: 3625:          strcpy (pfmt, pb + 2);
        -: 3626:        }
        -: 3627:    }
        1: 3628:  size_t ret = nstrftime (buf, size, nfmt, tm, __utc, __ns);
        1: 3629:  return ret;
        -: 3630:}
        -: 3631:
        -: 3632:/* Return the expected number of columns in a long-format time stamp,
        -: 3633:   or zero if it cannot be calculated.  */
        -: 3634:
        -: 3635:static int
    #####: 3636:long_time_expected_width (void)
        -: 3637:{
        -: 3638:  static int width = -1;
        -: 3639:
    #####: 3640:  if (width < 0)
        -: 3641:    {
    #####: 3642:      time_t epoch = 0;
    #####: 3643:      struct tm const *tm = localtime (&epoch);
        -: 3644:      char buf[TIME_STAMP_LEN_MAXIMUM + 1];
        -: 3645:
        -: 3646:      /* In case you're wondering if localtime can fail with an input time_t
        -: 3647:         value of 0, let's just say it's very unlikely, but not inconceivable.
        -: 3648:         The TZ environment variable would have to specify a time zone that
        -: 3649:         is 2**31-1900 years or more ahead of UTC.  This could happen only on
        -: 3650:         a 64-bit system that blindly accepts e.g., TZ=UTC+20000000000000.
        -: 3651:         However, this is not possible with Solaris 10 or glibc-2.3.5, since
        -: 3652:         their implementations limit the offset to 167:59 and 24:00, resp.  */
    #####: 3653:      if (tm)
        -: 3654:        {
    #####: 3655:          size_t len =
    #####: 3656:            align_nstrftime (buf, sizeof buf, long_time_format[0], tm, 0, 0);
    #####: 3657:          if (len != 0)
    #####: 3658:            width = mbsnwidth (buf, len, 0);
        -: 3659:        }
        -: 3660:
    #####: 3661:      if (width < 0)
    #####: 3662:        width = 0;
        -: 3663:    }
        -: 3664:
    #####: 3665:  return width;
        -: 3666:}
        -: 3667:
        -: 3668:/* Print the user or group name NAME, with numeric id ID, using a
        -: 3669:   print width of WIDTH columns.  */
        -: 3670:
        -: 3671:static void
    #####: 3672:format_user_or_group (char const *name, unsigned long int id, int width)
        -: 3673:{
        -: 3674:  size_t len;
        -: 3675:
    #####: 3676:  if (name)
        -: 3677:    {
    #####: 3678:      int width_gap = width - mbswidth (name, 0);
    #####: 3679:      int pad = MAX (0, width_gap);
    #####: 3680:      fputs (name, stdout);
    #####: 3681:      len = strlen (name) + pad;
        -: 3682:
        -: 3683:      do
    #####: 3684:        putchar (' ');
    #####: 3685:      while (pad--);
        -: 3686:    }
        -: 3687:  else
        -: 3688:    {
    #####: 3689:      printf ("%*lu ", width, id);
    #####: 3690:      len = width;
        -: 3691:    }
        -: 3692:
    #####: 3693:  dired_pos += len + 1;
    #####: 3694:}
        -: 3695:
        -: 3696:/* Print the name or id of the user with id U, using a print width of
        -: 3697:   WIDTH.  */
        -: 3698:
        -: 3699:static void
    #####: 3700:format_user (uid_t u, int width, bool stat_ok)
        -: 3701:{
    #####: 3702:  format_user_or_group (! stat_ok ? "?" :
        -: 3703:                        (numeric_ids ? NULL : getuser (u)), u, width);
    #####: 3704:}
        -: 3705:
        -: 3706:/* Likewise, for groups.  */
        -: 3707:
        -: 3708:static void
    #####: 3709:format_group (gid_t g, int width, bool stat_ok)
        -: 3710:{
    #####: 3711:  format_user_or_group (! stat_ok ? "?" :
        -: 3712:                        (numeric_ids ? NULL : getgroup (g)), g, width);
    #####: 3713:}
        -: 3714:
        -: 3715:/* Return the number of columns that format_user_or_group will print.  */
        -: 3716:
        -: 3717:static int
    #####: 3718:format_user_or_group_width (char const *name, unsigned long int id)
        -: 3719:{
    #####: 3720:  if (name)
        -: 3721:    {
    #####: 3722:      int len = mbswidth (name, 0);
    #####: 3723:      return MAX (0, len);
        -: 3724:    }
        -: 3725:  else
        -: 3726:    {
        -: 3727:      char buf[INT_BUFSIZE_BOUND (id)];
    #####: 3728:      sprintf (buf, "%lu", id);
    #####: 3729:      return strlen (buf);
        -: 3730:    }
        -: 3731:}
        -: 3732:
        -: 3733:/* Return the number of columns that format_user will print.  */
        -: 3734:
        -: 3735:static int
    #####: 3736:format_user_width (uid_t u)
        -: 3737:{
    #####: 3738:  return format_user_or_group_width (numeric_ids ? NULL : getuser (u), u);
        -: 3739:}
        -: 3740:
        -: 3741:/* Likewise, for groups.  */
        -: 3742:
        -: 3743:static int
    #####: 3744:format_group_width (gid_t g)
        -: 3745:{
    #####: 3746:  return format_user_or_group_width (numeric_ids ? NULL : getgroup (g), g);
        -: 3747:}
        -: 3748:
        -: 3749:/* Return a pointer to a formatted version of F->stat.st_ino,
        -: 3750:   possibly using buffer, BUF, of length BUFLEN, which must be at least
        -: 3751:   INT_BUFSIZE_BOUND (uintmax_t) bytes.  */
        -: 3752:static char *
    #####: 3753:format_inode (char *buf, size_t buflen, const struct fileinfo *f)
        -: 3754:{
    #####: 3755:  assert (INT_BUFSIZE_BOUND (uintmax_t) <= buflen);
    #####: 3756:  return (f->stat_ok && f->stat.st_ino != NOT_AN_INODE_NUMBER
    #####: 3757:          ? umaxtostr (f->stat.st_ino, buf)
    #####: 3758:          : (char *) "?");
        -: 3759:}
        -: 3760:
        -: 3761:/* Print information about F in long format.  */
        -: 3762:static void
        1: 3763:print_long_format (const struct fileinfo *f)
        -: 3764:{
        -: 3765:  char modebuf[12];
        -: 3766:  char buf
        -: 3767:    [LONGEST_HUMAN_READABLE + 1		/* inode */
        -: 3768:     + LONGEST_HUMAN_READABLE + 1	/* size in blocks */
        -: 3769:     + sizeof (modebuf) - 1 + 1		/* mode string */
        -: 3770:     + INT_BUFSIZE_BOUND (uintmax_t)	/* st_nlink */
        -: 3771:     + LONGEST_HUMAN_READABLE + 2	/* major device number */
        -: 3772:     + LONGEST_HUMAN_READABLE + 1	/* minor device number */
        -: 3773:     + TIME_STAMP_LEN_MAXIMUM + 1	/* max length of time/date */
        -: 3774:     ];
        -: 3775:  size_t s;
        -: 3776:  char *p;
        -: 3777:  struct timespec when_timespec;
        -: 3778:  struct tm *when_local;
        -: 3779:
        -: 3780:  /* Compute the mode string, except remove the trailing space if no
        -: 3781:     file in this directory has an ACL or SELinux security context.  */
        1: 3782:  if (f->stat_ok)
        1: 3783:    filemodestring (&f->stat, modebuf);
        -: 3784:  else
        -: 3785:    {
    #####: 3786:      modebuf[0] = filetype_letter[f->filetype];
    #####: 3787:      memset (modebuf + 1, '?', 10);
    #####: 3788:      modebuf[11] = '\0';
        -: 3789:    }
        1: 3790:  if (! any_has_acl)
        1: 3791:    modebuf[10] = '\0';
    #####: 3792:  else if (f->acl_type == ACL_T_SELINUX_ONLY)
    #####: 3793:    modebuf[10] = '.';
    #####: 3794:  else if (f->acl_type == ACL_T_YES)
    #####: 3795:    modebuf[10] = '+';
        -: 3796:
        1: 3797:  switch (time_type)
        -: 3798:    {
        -: 3799:    case time_ctime:
    #####: 3800:      when_timespec = get_stat_ctime (&f->stat);
    #####: 3801:      break;
        -: 3802:    case time_mtime:
        1: 3803:      when_timespec = get_stat_mtime (&f->stat);
        1: 3804:      break;
        -: 3805:    case time_atime:
    #####: 3806:      when_timespec = get_stat_atime (&f->stat);
    #####: 3807:      break;
        -: 3808:    default:
    #####: 3809:      abort ();
        -: 3810:    }
        -: 3811:
        1: 3812:  p = buf;
        -: 3813:
        1: 3814:  if (print_inode)
        -: 3815:    {
        -: 3816:      char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3817:      sprintf (p, "%*s ", inode_number_width,
        -: 3818:               format_inode (hbuf, sizeof hbuf, f));
        -: 3819:      /* Increment by strlen (p) here, rather than by inode_number_width + 1.
        -: 3820:         The latter is wrong when inode_number_width is zero.  */
    #####: 3821:      p += strlen (p);
        -: 3822:    }
        -: 3823:
        1: 3824:  if (print_block_size)
        -: 3825:    {
        -: 3826:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####: 3827:      char const *blocks =
    #####: 3828:        (! f->stat_ok
        -: 3829:         ? "?"
    #####: 3830:         : human_readable (ST_NBLOCKS (f->stat), hbuf, human_output_opts,
        -: 3831:                           ST_NBLOCKSIZE, output_block_size));
        -: 3832:      int pad;
    #####: 3833:      for (pad = block_size_width - mbswidth (blocks, 0); 0 < pad; pad--)
    #####: 3834:        *p++ = ' ';
    #####: 3835:      while ((*p++ = *blocks++))
    #####: 3836:        continue;
    #####: 3837:      p[-1] = ' ';
        -: 3838:    }
        -: 3839:
        -: 3840:  /* The last byte of the mode string is the POSIX
        -: 3841:     "optional alternate access method flag".  */
        -: 3842:  {
        -: 3843:    char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
        2: 3844:    sprintf (p, "%s %*s ", modebuf, nlink_width,
        2: 3845:             ! f->stat_ok ? "?" : umaxtostr (f->stat.st_nlink, hbuf));
        -: 3846:  }
        -: 3847:  /* Increment by strlen (p) here, rather than by, e.g.,
        -: 3848:     sizeof modebuf - 2 + any_has_acl + 1 + nlink_width + 1.
        -: 3849:     The latter is wrong when nlink_width is zero.  */
        1: 3850:  p += strlen (p);
        -: 3851:
        1: 3852:  DIRED_INDENT ();
        -: 3853:
        1: 3854:  if (print_owner || print_group || print_author || print_scontext)
        -: 3855:    {
    #####: 3856:      DIRED_FPUTS (buf, stdout, p - buf);
        -: 3857:
    #####: 3858:      if (print_owner)
    #####: 3859:        format_user (f->stat.st_uid, owner_width, f->stat_ok);
        -: 3860:
    #####: 3861:      if (print_group)
    #####: 3862:        format_group (f->stat.st_gid, group_width, f->stat_ok);
        -: 3863:
    #####: 3864:      if (print_author)
    #####: 3865:        format_user (f->stat.st_author, author_width, f->stat_ok);
        -: 3866:
    #####: 3867:      if (print_scontext)
    #####: 3868:        format_user_or_group (f->scontext, 0, scontext_width);
        -: 3869:
    #####: 3870:      p = buf;
        -: 3871:    }
        -: 3872:
        1: 3873:  if (f->stat_ok
        1: 3874:      && (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode)))
    #####: 3875:    {
        -: 3876:      char majorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
        -: 3877:      char minorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3878:      int blanks_width = (file_size_width
    #####: 3879:                          - (major_device_number_width + 2
    #####: 3880:                             + minor_device_number_width));
    #####: 3881:      sprintf (p, "%*s, %*s ",
    #####: 3882:               major_device_number_width + MAX (0, blanks_width),
    #####: 3883:               umaxtostr (major (f->stat.st_rdev), majorbuf),
        -: 3884:               minor_device_number_width,
    #####: 3885:               umaxtostr (minor (f->stat.st_rdev), minorbuf));
    #####: 3886:      p += file_size_width + 1;
        -: 3887:    }
        -: 3888:  else
        -: 3889:    {
        -: 3890:      char hbuf[LONGEST_HUMAN_READABLE + 1];
        1: 3891:      char const *size =
        1: 3892:        (! f->stat_ok
        -: 3893:         ? "?"
        1: 3894:         : human_readable (unsigned_file_size (f->stat.st_size),
        -: 3895:                           hbuf, file_human_output_opts, 1,
        -: 3896:                           file_output_block_size));
        -: 3897:      int pad;
        1: 3898:      for (pad = file_size_width - mbswidth (size, 0); 0 < pad; pad--)
    #####: 3899:        *p++ = ' ';
        6: 3900:      while ((*p++ = *size++))
        4: 3901:        continue;
        1: 3902:      p[-1] = ' ';
        -: 3903:    }
        -: 3904:
        1: 3905:  when_local = localtime (&when_timespec.tv_sec);
        1: 3906:  s = 0;
        1: 3907:  *p = '\1';
        -: 3908:
        1: 3909:  if (f->stat_ok && when_local)
        -: 3910:    {
        -: 3911:      struct timespec six_months_ago;
        -: 3912:      bool recent;
        -: 3913:      char const *fmt;
        -: 3914:
        -: 3915:      /* If the file appears to be in the future, update the current
        -: 3916:         time, in case the file happens to have been modified since
        -: 3917:         the last time we checked the clock.  */
        1: 3918:      if (timespec_cmp (current_time, when_timespec) < 0)
        -: 3919:        {
        -: 3920:          /* Note that gettime may call gettimeofday which, on some non-
        -: 3921:             compliant systems, clobbers the buffer used for localtime's result.
        -: 3922:             But it's ok here, because we use a gettimeofday wrapper that
        -: 3923:             saves and restores the buffer around the gettimeofday call.  */
        1: 3924:          gettime (&current_time);
        -: 3925:        }
        -: 3926:
        -: 3927:      /* Consider a time to be recent if it is within the past six
        -: 3928:         months.  A Gregorian year has 365.2425 * 24 * 60 * 60 ==
        -: 3929:         31556952 seconds on the average.  Write this value as an
        -: 3930:         integer constant to avoid floating point hassles.  */
        1: 3931:      six_months_ago.tv_sec = current_time.tv_sec - 31556952 / 2;
        1: 3932:      six_months_ago.tv_nsec = current_time.tv_nsec;
        -: 3933:
        2: 3934:      recent = (timespec_cmp (six_months_ago, when_timespec) < 0
        1: 3935:                && (timespec_cmp (when_timespec, current_time) < 0));
        1: 3936:      fmt = long_time_format[recent];
        -: 3937:
        -: 3938:      /* We assume here that all time zones are offset from UTC by a
        -: 3939:         whole number of seconds.  */
        1: 3940:      s = align_nstrftime (p, TIME_STAMP_LEN_MAXIMUM + 1, fmt,
        1: 3941:                           when_local, 0, when_timespec.tv_nsec);
        -: 3942:    }
        -: 3943:
        1: 3944:  if (s || !*p)
        -: 3945:    {
        1: 3946:      p += s;
        1: 3947:      *p++ = ' ';
        -: 3948:
        -: 3949:      /* NUL-terminate the string -- fputs (via DIRED_FPUTS) requires it.  */
        1: 3950:      *p = '\0';
        -: 3951:    }
        -: 3952:  else
        -: 3953:    {
        -: 3954:      /* The time cannot be converted using the desired format, so
        -: 3955:         print it as a huge integer number of seconds.  */
        -: 3956:      char hbuf[INT_BUFSIZE_BOUND (intmax_t)];
    #####: 3957:      sprintf (p, "%*s ", long_time_expected_width (),
    #####: 3958:               (! f->stat_ok
        -: 3959:                ? "?"
    #####: 3960:                : timetostr (when_timespec.tv_sec, hbuf)));
        -: 3961:      /* FIXME: (maybe) We discarded when_timespec.tv_nsec. */
    #####: 3962:      p += strlen (p);
        -: 3963:    }
        -: 3964:
        1: 3965:  DIRED_FPUTS (buf, stdout, p - buf);
        1: 3966:  size_t w = print_name_with_quoting (f, false, &dired_obstack, p - buf);
        -: 3967:
        1: 3968:  if (f->filetype == symbolic_link)
        -: 3969:    {
    #####: 3970:      if (f->linkname)
        -: 3971:        {
    #####: 3972:          DIRED_FPUTS_LITERAL (" -> ", stdout);
    #####: 3973:          print_name_with_quoting (f, true, NULL, (p - buf) + w + 4);
    #####: 3974:          if (indicator_style != none)
    #####: 3975:            print_type_indicator (true, f->linkmode, unknown);
        -: 3976:        }
        -: 3977:    }
        1: 3978:  else if (indicator_style != none)
    #####: 3979:    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
        1: 3980:}
        -: 3981:
        -: 3982:/* Output to OUT a quoted representation of the file name NAME,
        -: 3983:   using OPTIONS to control quoting.  Produce no output if OUT is NULL.
        -: 3984:   Store the number of screen columns occupied by NAME's quoted
        -: 3985:   representation into WIDTH, if non-NULL.  Return the number of bytes
        -: 3986:   produced.  */
        -: 3987:
        -: 3988:static size_t
       28: 3989:quote_name (FILE *out, const char *name, struct quoting_options const *options,
        -: 3990:            size_t *width)
        -: 3991:{
        -: 3992:  char smallbuf[BUFSIZ];
       28: 3993:  size_t len = quotearg_buffer (smallbuf, sizeof smallbuf, name, -1, options);
        -: 3994:  char *buf;
        -: 3995:  size_t displayed_width IF_LINT ( = 0);
        -: 3996:
       28: 3997:  if (len < sizeof smallbuf)
       28: 3998:    buf = smallbuf;
        -: 3999:  else
        -: 4000:    {
    #####: 4001:      buf = alloca (len + 1);
    #####: 4002:      quotearg_buffer (buf, len + 1, name, -1, options);
        -: 4003:    }
        -: 4004:
       28: 4005:  if (qmark_funny_chars)
        -: 4006:    {
    #####: 4007:      if (MB_CUR_MAX > 1)
        -: 4008:        {
    #####: 4009:          char const *p = buf;
    #####: 4010:          char const *plimit = buf + len;
    #####: 4011:          char *q = buf;
    #####: 4012:          displayed_width = 0;
        -: 4013:
    #####: 4014:          while (p < plimit)
    #####: 4015:            switch (*p)
        -: 4016:              {
        -: 4017:                case ' ': case '!': case '"': case '#': case '%':
        -: 4018:                case '&': case '\'': case '(': case ')': case '*':
        -: 4019:                case '+': case ',': case '-': case '.': case '/':
        -: 4020:                case '0': case '1': case '2': case '3': case '4':
        -: 4021:                case '5': case '6': case '7': case '8': case '9':
        -: 4022:                case ':': case ';': case '<': case '=': case '>':
        -: 4023:                case '?':
        -: 4024:                case 'A': case 'B': case 'C': case 'D': case 'E':
        -: 4025:                case 'F': case 'G': case 'H': case 'I': case 'J':
        -: 4026:                case 'K': case 'L': case 'M': case 'N': case 'O':
        -: 4027:                case 'P': case 'Q': case 'R': case 'S': case 'T':
        -: 4028:                case 'U': case 'V': case 'W': case 'X': case 'Y':
        -: 4029:                case 'Z':
        -: 4030:                case '[': case '\\': case ']': case '^': case '_':
        -: 4031:                case 'a': case 'b': case 'c': case 'd': case 'e':
        -: 4032:                case 'f': case 'g': case 'h': case 'i': case 'j':
        -: 4033:                case 'k': case 'l': case 'm': case 'n': case 'o':
        -: 4034:                case 'p': case 'q': case 'r': case 's': case 't':
        -: 4035:                case 'u': case 'v': case 'w': case 'x': case 'y':
        -: 4036:                case 'z': case '{': case '|': case '}': case '~':
        -: 4037:                  /* These characters are printable ASCII characters.  */
    #####: 4038:                  *q++ = *p++;
    #####: 4039:                  displayed_width += 1;
    #####: 4040:                  break;
        -: 4041:                default:
        -: 4042:                  /* If we have a multibyte sequence, copy it until we
        -: 4043:                     reach its end, replacing each non-printable multibyte
        -: 4044:                     character with a single question mark.  */
        -: 4045:                  {
    #####: 4046:                    mbstate_t mbstate = { 0, };
        -: 4047:                    do
        -: 4048:                      {
        -: 4049:                        wchar_t wc;
        -: 4050:                        size_t bytes;
        -: 4051:                        int w;
        -: 4052:
    #####: 4053:                        bytes = mbrtowc (&wc, p, plimit - p, &mbstate);
        -: 4054:
    #####: 4055:                        if (bytes == (size_t) -1)
        -: 4056:                          {
        -: 4057:                            /* An invalid multibyte sequence was
        -: 4058:                               encountered.  Skip one input byte, and
        -: 4059:                               put a question mark.  */
    #####: 4060:                            p++;
    #####: 4061:                            *q++ = '?';
    #####: 4062:                            displayed_width += 1;
    #####: 4063:                            break;
        -: 4064:                          }
        -: 4065:
    #####: 4066:                        if (bytes == (size_t) -2)
        -: 4067:                          {
        -: 4068:                            /* An incomplete multibyte character
        -: 4069:                               at the end.  Replace it entirely with
        -: 4070:                               a question mark.  */
    #####: 4071:                            p = plimit;
    #####: 4072:                            *q++ = '?';
    #####: 4073:                            displayed_width += 1;
    #####: 4074:                            break;
        -: 4075:                          }
        -: 4076:
    #####: 4077:                        if (bytes == 0)
        -: 4078:                          /* A null wide character was encountered.  */
    #####: 4079:                          bytes = 1;
        -: 4080:
    #####: 4081:                        w = wcwidth (wc);
    #####: 4082:                        if (w >= 0)
        -: 4083:                          {
        -: 4084:                            /* A printable multibyte character.
        -: 4085:                               Keep it.  */
    #####: 4086:                            for (; bytes > 0; --bytes)
    #####: 4087:                              *q++ = *p++;
    #####: 4088:                            displayed_width += w;
        -: 4089:                          }
        -: 4090:                        else
        -: 4091:                          {
        -: 4092:                            /* An unprintable multibyte character.
        -: 4093:                               Replace it entirely with a question
        -: 4094:                               mark.  */
    #####: 4095:                            p += bytes;
    #####: 4096:                            *q++ = '?';
    #####: 4097:                            displayed_width += 1;
        -: 4098:                          }
        -: 4099:                      }
    #####: 4100:                    while (! mbsinit (&mbstate));
        -: 4101:                  }
    #####: 4102:                  break;
        -: 4103:              }
        -: 4104:
        -: 4105:          /* The buffer may have shrunk.  */
    #####: 4106:          len = q - buf;
        -: 4107:        }
        -: 4108:      else
        -: 4109:        {
    #####: 4110:          char *p = buf;
    #####: 4111:          char const *plimit = buf + len;
        -: 4112:
    #####: 4113:          while (p < plimit)
        -: 4114:            {
    #####: 4115:              if (! isprint (to_uchar (*p)))
    #####: 4116:                *p = '?';
    #####: 4117:              p++;
        -: 4118:            }
    #####: 4119:          displayed_width = len;
        -: 4120:        }
        -: 4121:    }
       28: 4122:  else if (width != NULL)
        -: 4123:    {
    #####: 4124:      if (MB_CUR_MAX > 1)
    #####: 4125:        displayed_width = mbsnwidth (buf, len, 0);
        -: 4126:      else
        -: 4127:        {
    #####: 4128:          char const *p = buf;
    #####: 4129:          char const *plimit = buf + len;
        -: 4130:
    #####: 4131:          displayed_width = 0;
    #####: 4132:          while (p < plimit)
        -: 4133:            {
    #####: 4134:              if (isprint (to_uchar (*p)))
    #####: 4135:                displayed_width++;
    #####: 4136:              p++;
        -: 4137:            }
        -: 4138:        }
        -: 4139:    }
        -: 4140:
       28: 4141:  if (out != NULL)
       28: 4142:    fwrite (buf, 1, len, out);
       28: 4143:  if (width != NULL)
    #####: 4144:    *width = displayed_width;
       28: 4145:  return len;
        -: 4146:}
        -: 4147:
        -: 4148:static size_t
       28: 4149:print_name_with_quoting (const struct fileinfo *f,
        -: 4150:                         bool symlink_target,
        -: 4151:                         struct obstack *stack,
        -: 4152:                         size_t start_col)
        -: 4153:{
       28: 4154:  const char* name = symlink_target ? f->linkname : f->name;
        -: 4155:
       28: 4156:  bool used_color_this_time
        -: 4157:    = (print_with_color
       28: 4158:        && (print_color_indicator (f, symlink_target)
    #####: 4159:            || is_colored (C_NORM)));
        -: 4160:
       28: 4161:  if (stack)
        1: 4162:    PUSH_CURRENT_DIRED_POS (stack);
        -: 4163:
       28: 4164:  size_t width = quote_name (stdout, name, filename_quoting_options, NULL);
       28: 4165:  dired_pos += width;
        -: 4166:
       28: 4167:  if (stack)
        1: 4168:    PUSH_CURRENT_DIRED_POS (stack);
        -: 4169:
       28: 4170:  process_signals ();
       28: 4171:  if (used_color_this_time)
        -: 4172:    {
    #####: 4173:      prep_non_filename_text ();
    #####: 4174:      if (start_col / line_length != (start_col + width - 1) / line_length)
    #####: 4175:        put_indicator (&color_indicator[C_CLR_TO_EOL]);
        -: 4176:    }
        -: 4177:
       28: 4178:  return width;
        -: 4179:}
        -: 4180:
        -: 4181:static void
    #####: 4182:prep_non_filename_text (void)
        -: 4183:{
    #####: 4184:  if (color_indicator[C_END].string != NULL)
    #####: 4185:    put_indicator (&color_indicator[C_END]);
        -: 4186:  else
        -: 4187:    {
    #####: 4188:      put_indicator (&color_indicator[C_LEFT]);
    #####: 4189:      put_indicator (&color_indicator[C_RESET]);
    #####: 4190:      put_indicator (&color_indicator[C_RIGHT]);
        -: 4191:    }
    #####: 4192:}
        -: 4193:
        -: 4194:/* Print the file name of 'f' with appropriate quoting.
        -: 4195:   Also print file size, inode number, and filetype indicator character,
        -: 4196:   as requested by switches.  */
        -: 4197:
        -: 4198:static size_t
       27: 4199:print_file_name_and_frills (const struct fileinfo *f, size_t start_col)
        -: 4200:{
        -: 4201:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 4202:
       27: 4203:  set_normal_color ();
        -: 4204:
       27: 4205:  if (print_inode)
    #####: 4206:    printf ("%*s ", format == with_commas ? 0 : inode_number_width,
        -: 4207:            format_inode (buf, sizeof buf, f));
        -: 4208:
       27: 4209:  if (print_block_size)
    #####: 4210:    printf ("%*s ", format == with_commas ? 0 : block_size_width,
    #####: 4211:            ! f->stat_ok ? "?"
    #####: 4212:            : human_readable (ST_NBLOCKS (f->stat), buf, human_output_opts,
        -: 4213:                              ST_NBLOCKSIZE, output_block_size));
        -: 4214:
       27: 4215:  if (print_scontext)
    #####: 4216:    printf ("%*s ", format == with_commas ? 0 : scontext_width, f->scontext);
        -: 4217:
       27: 4218:  size_t width = print_name_with_quoting (f, false, NULL, start_col);
        -: 4219:
       27: 4220:  if (indicator_style != none)
    #####: 4221:    width += print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
        -: 4222:
       27: 4223:  return width;
        -: 4224:}
        -: 4225:
        -: 4226:/* Given these arguments describing a file, return the single-byte
        -: 4227:   type indicator, or 0.  */
        -: 4228:static char
    #####: 4229:get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 4230:{
        -: 4231:  char c;
        -: 4232:
    #####: 4233:  if (stat_ok ? S_ISREG (mode) : type == normal)
        -: 4234:    {
    #####: 4235:      if (stat_ok && indicator_style == classify && (mode & S_IXUGO))
    #####: 4236:        c = '*';
        -: 4237:      else
    #####: 4238:        c = 0;
        -: 4239:    }
        -: 4240:  else
        -: 4241:    {
    #####: 4242:      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)
    #####: 4243:        c = '/';
    #####: 4244:      else if (indicator_style == slash)
    #####: 4245:        c = 0;
    #####: 4246:      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)
    #####: 4247:        c = '@';
    #####: 4248:      else if (stat_ok ? S_ISFIFO (mode) : type == fifo)
    #####: 4249:        c = '|';
    #####: 4250:      else if (stat_ok ? S_ISSOCK (mode) : type == sock)
    #####: 4251:        c = '=';
        -: 4252:      else if (stat_ok && S_ISDOOR (mode))
        -: 4253:        c = '>';
        -: 4254:      else
    #####: 4255:        c = 0;
        -: 4256:    }
    #####: 4257:  return c;
        -: 4258:}
        -: 4259:
        -: 4260:static bool
    #####: 4261:print_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 4262:{
    #####: 4263:  char c = get_type_indicator (stat_ok, mode, type);
    #####: 4264:  if (c)
    #####: 4265:    DIRED_PUTCHAR (c);
    #####: 4266:  return !!c;
        -: 4267:}
        -: 4268:
        -: 4269:/* Returns whether any color sequence was printed. */
        -: 4270:static bool
    #####: 4271:print_color_indicator (const struct fileinfo *f, bool symlink_target)
        -: 4272:{
        -: 4273:  enum indicator_no type;
        -: 4274:  struct color_ext_type *ext;	/* Color extension */
        -: 4275:  size_t len;			/* Length of name */
        -: 4276:
        -: 4277:  const char* name;
        -: 4278:  mode_t mode;
        -: 4279:  int linkok;
    #####: 4280:  if (symlink_target)
        -: 4281:    {
    #####: 4282:      name = f->linkname;
    #####: 4283:      mode = f->linkmode;
    #####: 4284:      linkok = f->linkok ? 0 : -1;
        -: 4285:    }
        -: 4286:  else
        -: 4287:    {
    #####: 4288:      name = f->name;
    #####: 4289:      mode = FILE_OR_LINK_MODE (f);
    #####: 4290:      linkok = f->linkok;
        -: 4291:    }
        -: 4292:
        -: 4293:  /* Is this a nonexistent file?  If so, linkok == -1.  */
        -: 4294:
    #####: 4295:  if (linkok == -1 && color_indicator[C_MISSING].string != NULL)
    #####: 4296:    type = C_MISSING;
    #####: 4297:  else if (!f->stat_ok)
        -: 4298:    {
        -: 4299:      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;
    #####: 4300:      type = filetype_indicator[f->filetype];
        -: 4301:    }
        -: 4302:  else
        -: 4303:    {
    #####: 4304:      if (S_ISREG (mode))
        -: 4305:        {
    #####: 4306:          type = C_FILE;
        -: 4307:
    #####: 4308:          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))
    #####: 4309:            type = C_SETUID;
    #####: 4310:          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))
    #####: 4311:            type = C_SETGID;
    #####: 4312:          else if (is_colored (C_CAP) && f->has_capability)
    #####: 4313:            type = C_CAP;
    #####: 4314:          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))
    #####: 4315:            type = C_EXEC;
    #####: 4316:          else if ((1 < f->stat.st_nlink) && is_colored (C_MULTIHARDLINK))
    #####: 4317:            type = C_MULTIHARDLINK;
        -: 4318:        }
    #####: 4319:      else if (S_ISDIR (mode))
        -: 4320:        {
    #####: 4321:          type = C_DIR;
        -: 4322:
    #####: 4323:          if ((mode & S_ISVTX) && (mode & S_IWOTH)
    #####: 4324:              && is_colored (C_STICKY_OTHER_WRITABLE))
    #####: 4325:            type = C_STICKY_OTHER_WRITABLE;
    #####: 4326:          else if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))
    #####: 4327:            type = C_OTHER_WRITABLE;
    #####: 4328:          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))
    #####: 4329:            type = C_STICKY;
        -: 4330:        }
    #####: 4331:      else if (S_ISLNK (mode))
    #####: 4332:        type = C_LINK;
    #####: 4333:      else if (S_ISFIFO (mode))
    #####: 4334:        type = C_FIFO;
    #####: 4335:      else if (S_ISSOCK (mode))
    #####: 4336:        type = C_SOCK;
    #####: 4337:      else if (S_ISBLK (mode))
    #####: 4338:        type = C_BLK;
    #####: 4339:      else if (S_ISCHR (mode))
    #####: 4340:        type = C_CHR;
        -: 4341:      else if (S_ISDOOR (mode))
        -: 4342:        type = C_DOOR;
        -: 4343:      else
        -: 4344:        {
        -: 4345:          /* Classify a file of some other type as C_ORPHAN.  */
    #####: 4346:          type = C_ORPHAN;
        -: 4347:        }
        -: 4348:    }
        -: 4349:
        -: 4350:  /* Check the file's suffix only if still classified as C_FILE.  */
    #####: 4351:  ext = NULL;
    #####: 4352:  if (type == C_FILE)
        -: 4353:    {
        -: 4354:      /* Test if NAME has a recognized suffix.  */
        -: 4355:
    #####: 4356:      len = strlen (name);
    #####: 4357:      name += len;		/* Pointer to final \0.  */
    #####: 4358:      for (ext = color_ext_list; ext != NULL; ext = ext->next)
        -: 4359:        {
    #####: 4360:          if (ext->ext.len <= len
    #####: 4361:              && STREQ_LEN (name - ext->ext.len, ext->ext.string,
        -: 4362:                            ext->ext.len))
    #####: 4363:            break;
        -: 4364:        }
        -: 4365:    }
        -: 4366:
        -: 4367:  /* Adjust the color for orphaned symlinks.  */
    #####: 4368:  if (type == C_LINK && !linkok)
        -: 4369:    {
    #####: 4370:      if (color_symlink_as_referent
    #####: 4371:          || color_indicator[C_ORPHAN].string)
    #####: 4372:        type = C_ORPHAN;
        -: 4373:    }
        -: 4374:
        -: 4375:  {
    #####: 4376:    const struct bin_str *const s
        -: 4377:      = ext ? &(ext->seq) : &color_indicator[type];
    #####: 4378:    if (s->string != NULL)
        -: 4379:      {
        -: 4380:        /* Need to reset so not dealing with attribute combinations */
    #####: 4381:        if (is_colored (C_NORM))
    #####: 4382:          restore_default_color ();
    #####: 4383:        put_indicator (&color_indicator[C_LEFT]);
    #####: 4384:        put_indicator (s);
    #####: 4385:        put_indicator (&color_indicator[C_RIGHT]);
    #####: 4386:        return true;
        -: 4387:      }
        -: 4388:    else
    #####: 4389:      return false;
        -: 4390:  }
        -: 4391:}
        -: 4392:
        -: 4393:/* Output a color indicator (which may contain nulls).  */
        -: 4394:static void
    #####: 4395:put_indicator (const struct bin_str *ind)
        -: 4396:{
    #####: 4397:  if (! used_color)
        -: 4398:    {
    #####: 4399:      used_color = true;
    #####: 4400:      prep_non_filename_text ();
        -: 4401:    }
        -: 4402:
    #####: 4403:  fwrite (ind->string, ind->len, 1, stdout);
    #####: 4404:}
        -: 4405:
        -: 4406:static size_t
    #####: 4407:length_of_file_name_and_frills (const struct fileinfo *f)
        -: 4408:{
    #####: 4409:  size_t len = 0;
        -: 4410:  size_t name_width;
        -: 4411:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 4412:
    #####: 4413:  if (print_inode)
    #####: 4414:    len += 1 + (format == with_commas
    #####: 4415:                ? strlen (umaxtostr (f->stat.st_ino, buf))
        -: 4416:                : inode_number_width);
        -: 4417:
    #####: 4418:  if (print_block_size)
    #####: 4419:    len += 1 + (format == with_commas
    #####: 4420:                ? strlen (! f->stat_ok ? "?"
    #####: 4421:                          : human_readable (ST_NBLOCKS (f->stat), buf,
        -: 4422:                                            human_output_opts, ST_NBLOCKSIZE,
        -: 4423:                                            output_block_size))
        -: 4424:                : block_size_width);
        -: 4425:
    #####: 4426:  if (print_scontext)
    #####: 4427:    len += 1 + (format == with_commas ? strlen (f->scontext) : scontext_width);
        -: 4428:
    #####: 4429:  quote_name (NULL, f->name, filename_quoting_options, &name_width);
    #####: 4430:  len += name_width;
        -: 4431:
    #####: 4432:  if (indicator_style != none)
        -: 4433:    {
    #####: 4434:      char c = get_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
    #####: 4435:      len += (c != 0);
        -: 4436:    }
        -: 4437:
    #####: 4438:  return len;
        -: 4439:}
        -: 4440:
        -: 4441:static void
    #####: 4442:print_many_per_line (void)
        -: 4443:{
        -: 4444:  size_t row;			/* Current row.  */
    #####: 4445:  size_t cols = calculate_columns (true);
    #####: 4446:  struct column_info const *line_fmt = &column_info[cols - 1];
        -: 4447:
        -: 4448:  /* Calculate the number of rows that will be in each column except possibly
        -: 4449:     for a short column on the right.  */
    #####: 4450:  size_t rows = cwd_n_used / cols + (cwd_n_used % cols != 0);
        -: 4451:
    #####: 4452:  for (row = 0; row < rows; row++)
        -: 4453:    {
    #####: 4454:      size_t col = 0;
    #####: 4455:      size_t filesno = row;
    #####: 4456:      size_t pos = 0;
        -: 4457:
        -: 4458:      /* Print the next row.  */
        -: 4459:      while (1)
        -: 4460:        {
    #####: 4461:          struct fileinfo const *f = sorted_file[filesno];
    #####: 4462:          size_t name_length = length_of_file_name_and_frills (f);
    #####: 4463:          size_t max_name_length = line_fmt->col_arr[col++];
    #####: 4464:          print_file_name_and_frills (f, pos);
        -: 4465:
    #####: 4466:          filesno += rows;
    #####: 4467:          if (filesno >= cwd_n_used)
    #####: 4468:            break;
        -: 4469:
    #####: 4470:          indent (pos + name_length, pos + max_name_length);
    #####: 4471:          pos += max_name_length;
    #####: 4472:        }
    #####: 4473:      putchar ('\n');
        -: 4474:    }
    #####: 4475:}
        -: 4476:
        -: 4477:static void
    #####: 4478:print_horizontal (void)
        -: 4479:{
        -: 4480:  size_t filesno;
    #####: 4481:  size_t pos = 0;
    #####: 4482:  size_t cols = calculate_columns (false);
    #####: 4483:  struct column_info const *line_fmt = &column_info[cols - 1];
    #####: 4484:  struct fileinfo const *f = sorted_file[0];
    #####: 4485:  size_t name_length = length_of_file_name_and_frills (f);
    #####: 4486:  size_t max_name_length = line_fmt->col_arr[0];
        -: 4487:
        -: 4488:  /* Print first entry.  */
    #####: 4489:  print_file_name_and_frills (f, 0);
        -: 4490:
        -: 4491:  /* Now the rest.  */
    #####: 4492:  for (filesno = 1; filesno < cwd_n_used; ++filesno)
        -: 4493:    {
    #####: 4494:      size_t col = filesno % cols;
        -: 4495:
    #####: 4496:      if (col == 0)
        -: 4497:        {
    #####: 4498:          putchar ('\n');
    #####: 4499:          pos = 0;
        -: 4500:        }
        -: 4501:      else
        -: 4502:        {
    #####: 4503:          indent (pos + name_length, pos + max_name_length);
    #####: 4504:          pos += max_name_length;
        -: 4505:        }
        -: 4506:
    #####: 4507:      f = sorted_file[filesno];
    #####: 4508:      print_file_name_and_frills (f, pos);
        -: 4509:
    #####: 4510:      name_length = length_of_file_name_and_frills (f);
    #####: 4511:      max_name_length = line_fmt->col_arr[col];
        -: 4512:    }
    #####: 4513:  putchar ('\n');
    #####: 4514:}
        -: 4515:
        -: 4516:static void
    #####: 4517:print_with_commas (void)
        -: 4518:{
        -: 4519:  size_t filesno;
    #####: 4520:  size_t pos = 0;
        -: 4521:
    #####: 4522:  for (filesno = 0; filesno < cwd_n_used; filesno++)
        -: 4523:    {
    #####: 4524:      struct fileinfo const *f = sorted_file[filesno];
    #####: 4525:      size_t len = length_of_file_name_and_frills (f);
        -: 4526:
    #####: 4527:      if (filesno != 0)
        -: 4528:        {
        -: 4529:          char separator;
        -: 4530:
    #####: 4531:          if (pos + len + 2 < line_length)
        -: 4532:            {
    #####: 4533:              pos += 2;
    #####: 4534:              separator = ' ';
        -: 4535:            }
        -: 4536:          else
        -: 4537:            {
    #####: 4538:              pos = 0;
    #####: 4539:              separator = '\n';
        -: 4540:            }
        -: 4541:
    #####: 4542:          putchar (',');
    #####: 4543:          putchar (separator);
        -: 4544:        }
        -: 4545:
    #####: 4546:      print_file_name_and_frills (f, pos);
    #####: 4547:      pos += len;
        -: 4548:    }
    #####: 4549:  putchar ('\n');
    #####: 4550:}
        -: 4551:
        -: 4552:/* Assuming cursor is at position FROM, indent up to position TO.
        -: 4553:   Use a TAB character instead of two or more spaces whenever possible.  */
        -: 4554:
        -: 4555:static void
    #####: 4556:indent (size_t from, size_t to)
        -: 4557:{
    #####: 4558:  while (from < to)
        -: 4559:    {
    #####: 4560:      if (tabsize != 0 && to / tabsize > (from + 1) / tabsize)
        -: 4561:        {
    #####: 4562:          putchar ('\t');
    #####: 4563:          from += tabsize - from % tabsize;
        -: 4564:        }
        -: 4565:      else
        -: 4566:        {
    #####: 4567:          putchar (' ');
    #####: 4568:          from++;
        -: 4569:        }
        -: 4570:    }
    #####: 4571:}
        -: 4572:
        -: 4573:/* Put DIRNAME/NAME into DEST, handling '.' and '/' properly.  */
        -: 4574:/* FIXME: maybe remove this function someday.  See about using a
        -: 4575:   non-malloc'ing version of file_name_concat.  */
        -: 4576:
        -: 4577:static void
    #####: 4578:attach (char *dest, const char *dirname, const char *name)
        -: 4579:{
    #####: 4580:  const char *dirnamep = dirname;
        -: 4581:
        -: 4582:  /* Copy dirname if it is not ".".  */
    #####: 4583:  if (dirname[0] != '.' || dirname[1] != 0)
        -: 4584:    {
    #####: 4585:      while (*dirnamep)
    #####: 4586:        *dest++ = *dirnamep++;
        -: 4587:      /* Add '/' if 'dirname' doesn't already end with it.  */
    #####: 4588:      if (dirnamep > dirname && dirnamep[-1] != '/')
    #####: 4589:        *dest++ = '/';
        -: 4590:    }
    #####: 4591:  while (*name)
    #####: 4592:    *dest++ = *name++;
    #####: 4593:  *dest = 0;
    #####: 4594:}
        -: 4595:
        -: 4596:/* Allocate enough column info suitable for the current number of
        -: 4597:   files and display columns, and initialize the info to represent the
        -: 4598:   narrowest possible columns.  */
        -: 4599:
        -: 4600:static void
    #####: 4601:init_column_info (void)
        -: 4602:{
        -: 4603:  size_t i;
    #####: 4604:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4605:
        -: 4606:  /* Currently allocated columns in column_info.  */
        -: 4607:  static size_t column_info_alloc;
        -: 4608:
    #####: 4609:  if (column_info_alloc < max_cols)
        -: 4610:    {
        -: 4611:      size_t new_column_info_alloc;
        -: 4612:      size_t *p;
        -: 4613:
    #####: 4614:      if (max_cols < max_idx / 2)
        -: 4615:        {
        -: 4616:          /* The number of columns is far less than the display width
        -: 4617:             allows.  Grow the allocation, but only so that it's
        -: 4618:             double the current requirements.  If the display is
        -: 4619:             extremely wide, this avoids allocating a lot of memory
        -: 4620:             that is never needed.  */
    #####: 4621:          column_info = xnrealloc (column_info, max_cols,
        -: 4622:                                   2 * sizeof *column_info);
    #####: 4623:          new_column_info_alloc = 2 * max_cols;
        -: 4624:        }
        -: 4625:      else
        -: 4626:        {
    #####: 4627:          column_info = xnrealloc (column_info, max_idx, sizeof *column_info);
    #####: 4628:          new_column_info_alloc = max_idx;
        -: 4629:        }
        -: 4630:
        -: 4631:      /* Allocate the new size_t objects by computing the triangle
        -: 4632:         formula n * (n + 1) / 2, except that we don't need to
        -: 4633:         allocate the part of the triangle that we've already
        -: 4634:         allocated.  Check for address arithmetic overflow.  */
        -: 4635:      {
    #####: 4636:        size_t column_info_growth = new_column_info_alloc - column_info_alloc;
    #####: 4637:        size_t s = column_info_alloc + 1 + new_column_info_alloc;
    #####: 4638:        size_t t = s * column_info_growth;
    #####: 4639:        if (s < new_column_info_alloc || t / column_info_growth != s)
    #####: 4640:          xalloc_die ();
    #####: 4641:        p = xnmalloc (t / 2, sizeof *p);
        -: 4642:      }
        -: 4643:
        -: 4644:      /* Grow the triangle by parceling out the cells just allocated.  */
    #####: 4645:      for (i = column_info_alloc; i < new_column_info_alloc; i++)
        -: 4646:        {
    #####: 4647:          column_info[i].col_arr = p;
    #####: 4648:          p += i + 1;
        -: 4649:        }
        -: 4650:
    #####: 4651:      column_info_alloc = new_column_info_alloc;
        -: 4652:    }
        -: 4653:
    #####: 4654:  for (i = 0; i < max_cols; ++i)
        -: 4655:    {
        -: 4656:      size_t j;
        -: 4657:
    #####: 4658:      column_info[i].valid_len = true;
    #####: 4659:      column_info[i].line_len = (i + 1) * MIN_COLUMN_WIDTH;
    #####: 4660:      for (j = 0; j <= i; ++j)
    #####: 4661:        column_info[i].col_arr[j] = MIN_COLUMN_WIDTH;
        -: 4662:    }
    #####: 4663:}
        -: 4664:
        -: 4665:/* Calculate the number of columns needed to represent the current set
        -: 4666:   of files in the current display width.  */
        -: 4667:
        -: 4668:static size_t
    #####: 4669:calculate_columns (bool by_columns)
        -: 4670:{
        -: 4671:  size_t filesno;		/* Index into cwd_file.  */
        -: 4672:  size_t cols;			/* Number of files across.  */
        -: 4673:
        -: 4674:  /* Normally the maximum number of columns is determined by the
        -: 4675:     screen width.  But if few files are available this might limit it
        -: 4676:     as well.  */
    #####: 4677:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4678:
    #####: 4679:  init_column_info ();
        -: 4680:
        -: 4681:  /* Compute the maximum number of possible columns.  */
    #####: 4682:  for (filesno = 0; filesno < cwd_n_used; ++filesno)
        -: 4683:    {
    #####: 4684:      struct fileinfo const *f = sorted_file[filesno];
    #####: 4685:      size_t name_length = length_of_file_name_and_frills (f);
        -: 4686:      size_t i;
        -: 4687:
    #####: 4688:      for (i = 0; i < max_cols; ++i)
        -: 4689:        {
    #####: 4690:          if (column_info[i].valid_len)
        -: 4691:            {
    #####: 4692:              size_t idx = (by_columns
    #####: 4693:                            ? filesno / ((cwd_n_used + i) / (i + 1))
    #####: 4694:                            : filesno % (i + 1));
    #####: 4695:              size_t real_length = name_length + (idx == i ? 0 : 2);
        -: 4696:
    #####: 4697:              if (column_info[i].col_arr[idx] < real_length)
        -: 4698:                {
    #####: 4699:                  column_info[i].line_len += (real_length
    #####: 4700:                                              - column_info[i].col_arr[idx]);
    #####: 4701:                  column_info[i].col_arr[idx] = real_length;
    #####: 4702:                  column_info[i].valid_len = (column_info[i].line_len
    #####: 4703:                                              < line_length);
        -: 4704:                }
        -: 4705:            }
        -: 4706:        }
        -: 4707:    }
        -: 4708:
        -: 4709:  /* Find maximum allowed columns.  */
    #####: 4710:  for (cols = max_cols; 1 < cols; --cols)
        -: 4711:    {
    #####: 4712:      if (column_info[cols - 1].valid_len)
    #####: 4713:        break;
        -: 4714:    }
        -: 4715:
    #####: 4716:  return cols;
        -: 4717:}
        -: 4718:
        -: 4719:void
    #####: 4720:usage (int status)
        -: 4721:{
    #####: 4722:  if (status != EXIT_SUCCESS)
    #####: 4723:    emit_try_help ();
        -: 4724:  else
        -: 4725:    {
    #####: 4726:      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
    #####: 4727:      fputs (_("\
        -: 4728:List information about the FILEs (the current directory by default).\n\
        -: 4729:Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n\
        -: 4730:\n\
        -: 4731:"), stdout);
    #####: 4732:      fputs (_("\
        -: 4733:Mandatory arguments to long options are mandatory for short options too.\n\
        -: 4734:"), stdout);
    #####: 4735:      fputs (_("\
        -: 4736:  -a, --all                  do not ignore entries starting with .\n\
        -: 4737:  -A, --almost-all           do not list implied . and ..\n\
        -: 4738:      --author               with -l, print the author of each file\n\
        -: 4739:  -b, --escape               print C-style escapes for nongraphic characters\n\
        -: 4740:"), stdout);
    #####: 4741:      fputs (_("\
        -: 4742:      --block-size=SIZE      scale sizes by SIZE before printing them.  E.g.,\n\
        -: 4743:                               '--block-size=M' prints sizes in units of\n\
        -: 4744:                               1,048,576 bytes.  See SIZE format below.\n\
        -: 4745:  -B, --ignore-backups       do not list implied entries ending with ~\n\
        -: 4746:  -c                         with -lt: sort by, and show, ctime (time of last\n\
        -: 4747:                               modification of file status information)\n\
        -: 4748:                               with -l: show ctime and sort by name\n\
        -: 4749:                               otherwise: sort by ctime, newest first\n\
        -: 4750:"), stdout);
    #####: 4751:      fputs (_("\
        -: 4752:  -C                         list entries by columns\n\
        -: 4753:      --color[=WHEN]         colorize the output.  WHEN defaults to 'always'\n\
        -: 4754:                               or can be 'never' or 'auto'.  More info below\n\
        -: 4755:  -d, --directory            list directory entries instead of contents,\n\
        -: 4756:                               and do not dereference symbolic links\n\
        -: 4757:  -D, --dired                generate output designed for Emacs' dired mode\n\
        -: 4758:"), stdout);
    #####: 4759:      fputs (_("\
        -: 4760:  -f                         do not sort, enable -aU, disable -ls --color\n\
        -: 4761:  -F, --classify             append indicator (one of */=>@|) to entries\n\
        -: 4762:      --file-type            likewise, except do not append '*'\n\
        -: 4763:      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n\
        -: 4764:                               single-column -1, verbose -l, vertical -C\n\
        -: 4765:      --full-time            like -l --time-style=full-iso\n\
        -: 4766:"), stdout);
    #####: 4767:      fputs (_("\
        -: 4768:  -g                         like -l, but do not list owner\n\
        -: 4769:"), stdout);
    #####: 4770:      fputs (_("\
        -: 4771:      --group-directories-first\n\
        -: 4772:                             group directories before files.\n\
        -: 4773:                               augment with a --sort option, but any\n\
        -: 4774:                               use of --sort=none (-U) disables grouping\n\
        -: 4775:"), stdout);
    #####: 4776:      fputs (_("\
        -: 4777:  -G, --no-group             in a long listing, don't print group names\n\
        -: 4778:  -h, --human-readable       with -l, print sizes in human readable format\n\
        -: 4779:                               (e.g., 1K 234M 2G)\n\
        -: 4780:      --si                   likewise, but use powers of 1000 not 1024\n\
        -: 4781:"), stdout);
    #####: 4782:      fputs (_("\
        -: 4783:  -H, --dereference-command-line\n\
        -: 4784:                             follow symbolic links listed on the command line\n\
        -: 4785:      --dereference-command-line-symlink-to-dir\n\
        -: 4786:                             follow each command line symbolic link\n\
        -: 4787:                             that points to a directory\n\
        -: 4788:      --hide=PATTERN         do not list implied entries matching shell PATTERN\
        -: 4789:\n\
        -: 4790:                               (overridden by -a or -A)\n\
        -: 4791:"), stdout);
    #####: 4792:      fputs (_("\
        -: 4793:      --indicator-style=WORD  append indicator with style WORD to entry names:\
        -: 4794:\n\
        -: 4795:                               none (default), slash (-p),\n\
        -: 4796:                               file-type (--file-type), classify (-F)\n\
        -: 4797:  -i, --inode                print the index number of each file\n\
        -: 4798:  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\
        -: 4799:\n\
        -: 4800:  -k, --kibibytes            use 1024-byte blocks\n\
        -: 4801:"), stdout);
    #####: 4802:      fputs (_("\
        -: 4803:  -l                         use a long listing format\n\
        -: 4804:  -L, --dereference          when showing file information for a symbolic\n\
        -: 4805:                               link, show information for the file the link\n\
        -: 4806:                               references rather than for the link itself\n\
        -: 4807:  -m                         fill width with a comma separated list of entries\
        -: 4808:\n\
        -: 4809:"), stdout);
    #####: 4810:      fputs (_("\
        -: 4811:  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n\
        -: 4812:  -N, --literal              print raw entry names (don't treat e.g. control\n\
        -: 4813:                               characters specially)\n\
        -: 4814:  -o                         like -l, but do not list group information\n\
        -: 4815:  -p, --indicator-style=slash\n\
        -: 4816:                             append / indicator to directories\n\
        -: 4817:"), stdout);
    #####: 4818:      fputs (_("\
        -: 4819:  -q, --hide-control-chars   print ? instead of non graphic characters\n\
        -: 4820:      --show-control-chars   show non graphic characters as-is (default\n\
        -: 4821:                             unless program is 'ls' and output is a terminal)\n\
        -: 4822:  -Q, --quote-name           enclose entry names in double quotes\n\
        -: 4823:      --quoting-style=WORD   use quoting style WORD for entry names:\n\
        -: 4824:                               literal, locale, shell, shell-always, c, escape\
        -: 4825:\n\
        -: 4826:"), stdout);
    #####: 4827:      fputs (_("\
        -: 4828:  -r, --reverse              reverse order while sorting\n\
        -: 4829:  -R, --recursive            list subdirectories recursively\n\
        -: 4830:  -s, --size                 print the allocated size of each file, in blocks\n\
        -: 4831:"), stdout);
    #####: 4832:      fputs (_("\
        -: 4833:  -S                         sort by file size\n\
        -: 4834:      --sort=WORD            sort by WORD instead of name: none -U,\n\
        -: 4835:                             extension -X, size -S, time -t, version -v\n\
        -: 4836:      --time=WORD            with -l, show time as WORD instead of modification\
        -: 4837:\n\
        -: 4838:                             time: atime -u, access -u, use -u, ctime -c,\n\
        -: 4839:                             or status -c; use specified time as sort key\n\
        -: 4840:                             if --sort=time\n\
        -: 4841:"), stdout);
    #####: 4842:      fputs (_("\
        -: 4843:      --time-style=STYLE     with -l, show times using style STYLE:\n\
        -: 4844:                             full-iso, long-iso, iso, locale, +FORMAT.\n\
        -: 4845:                             FORMAT is interpreted like 'date'; if FORMAT is\n\
        -: 4846:                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n\
        -: 4847:                             non-recent files and FORMAT2 to recent files;\n\
        -: 4848:                             if STYLE is prefixed with 'posix-', STYLE\n\
        -: 4849:                             takes effect only outside the POSIX locale\n\
        -: 4850:"), stdout);
    #####: 4851:      fputs (_("\
        -: 4852:  -t                         sort by modification time, newest first\n\
        -: 4853:  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n\
        -: 4854:"), stdout);
    #####: 4855:      fputs (_("\
        -: 4856:  -u                         with -lt: sort by, and show, access time\n\
        -: 4857:                               with -l: show access time and sort by name\n\
        -: 4858:                               otherwise: sort by access time\n\
        -: 4859:  -U                         do not sort; list entries in directory order\n\
        -: 4860:  -v                         natural sort of (version) numbers within text\n\
        -: 4861:"), stdout);
    #####: 4862:      fputs (_("\
        -: 4863:  -w, --width=COLS           assume screen width instead of current value\n\
        -: 4864:  -x                         list entries by lines instead of by columns\n\
        -: 4865:  -X                         sort alphabetically by entry extension\n\
        -: 4866:  -Z, --context              print any SELinux security context of each file\n\
        -: 4867:  -1                         list one file per line\n\
        -: 4868:"), stdout);
    #####: 4869:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####: 4870:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####: 4871:      emit_size_note ();
    #####: 4872:      fputs (_("\
        -: 4873:\n\
        -: 4874:Using color to distinguish file types is disabled both by default and\n\
        -: 4875:with --color=never.  With --color=auto, ls emits color codes only when\n\
        -: 4876:standard output is connected to a terminal.  The LS_COLORS environment\n\
        -: 4877:variable can change the settings.  Use the dircolors command to set it.\n\
        -: 4878:"), stdout);
    #####: 4879:      fputs (_("\
        -: 4880:\n\
        -: 4881:Exit status:\n\
        -: 4882: 0  if OK,\n\
        -: 4883: 1  if minor problems (e.g., cannot access subdirectory),\n\
        -: 4884: 2  if serious trouble (e.g., cannot access command-line argument).\n\
        -: 4885:"), stdout);
    #####: 4886:      emit_ancillary_info ();
        -: 4887:    }
    #####: 4888:  exit (status);
        -: 4889:}
