        -:    0:Source:cp.c
        -:    0:Graph:cp.gcno
        -:    0:Data:cp.gcda
        -:    0:Runs:5
        -:    0:Programs:1
        -:    1:/* cp.c  -- file copying (main routines)
        -:    2:   Copyright (C) 1989-2012 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   16:
        -:   17:   Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering. */
        -:   18:
        -:   19:#include <config.h>
        -:   20:#include <stdio.h>
        -:   21:#include <sys/types.h>
        -:   22:#include <getopt.h>
        -:   23:#include <selinux/selinux.h>
        -:   24:
        -:   25:#include "system.h"
        -:   26:#include "argmatch.h"
        -:   27:#include "backupfile.h"
        -:   28:#include "copy.h"
        -:   29:#include "cp-hash.h"
        -:   30:#include "error.h"
        -:   31:#include "filenamecat.h"
        -:   32:#include "ignore-value.h"
        -:   33:#include "quote.h"
        -:   34:#include "stat-time.h"
        -:   35:#include "utimens.h"
        -:   36:#include "acl.h"
        -:   37:
        -:   38:#if ! HAVE_LCHOWN
        -:   39:# define lchown(name, uid, gid) chown (name, uid, gid)
        -:   40:#endif
        -:   41:
        -:   42:#define ASSIGN_BASENAME_STRDUPA(Dest, File_name)	\
        -:   43:  do							\
        -:   44:    {							\
        -:   45:      char *tmp_abns_;					\
        -:   46:      ASSIGN_STRDUPA (tmp_abns_, (File_name));		\
        -:   47:      Dest = last_component (tmp_abns_);		\
        -:   48:      strip_trailing_slashes (Dest);			\
        -:   49:    }							\
        -:   50:  while (0)
        -:   51:
        -:   52:/* The official name of this program (e.g., no 'g' prefix).  */
        -:   53:#define PROGRAM_NAME "cp"
        -:   54:
        -:   55:#define AUTHORS \
        -:   56:  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
        -:   57:  proper_name ("David MacKenzie"), \
        -:   58:  proper_name ("Jim Meyering")
        -:   59:
        -:   60:/* Used by do_copy, make_dir_parents_private, and re_protect
        -:   61:   to keep a list of leading directories whose protections
        -:   62:   need to be fixed after copying. */
        -:   63:struct dir_attr
        -:   64:{
        -:   65:  struct stat st;
        -:   66:  bool restore_mode;
        -:   67:  size_t slash_offset;
        -:   68:  struct dir_attr *next;
        -:   69:};
        -:   70:
        -:   71:/* For long options that have no equivalent short option, use a
        -:   72:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:   73:enum
        -:   74:{
        -:   75:  ATTRIBUTES_ONLY_OPTION = CHAR_MAX + 1,
        -:   76:  COPY_CONTENTS_OPTION,
        -:   77:  NO_PRESERVE_ATTRIBUTES_OPTION,
        -:   78:  PARENTS_OPTION,
        -:   79:  PRESERVE_ATTRIBUTES_OPTION,
        -:   80:  REFLINK_OPTION,
        -:   81:  SPARSE_OPTION,
        -:   82:  STRIP_TRAILING_SLASHES_OPTION,
        -:   83:  UNLINK_DEST_BEFORE_OPENING
        -:   84:};
        -:   85:
        -:   86:/* True if the kernel is SELinux enabled.  */
        -:   87:static bool selinux_enabled;
        -:   88:
        -:   89:/* If true, the command "cp x/e_file e_dir" uses "e_dir/x/e_file"
        -:   90:   as its destination instead of the usual "e_dir/e_file." */
        -:   91:static bool parents_option = false;
        -:   92:
        -:   93:/* Remove any trailing slashes from each SOURCE argument.  */
        -:   94:static bool remove_trailing_slashes;
        -:   95:
        -:   96:static char const *const sparse_type_string[] =
        -:   97:{
        -:   98:  "never", "auto", "always", NULL
        -:   99:};
        -:  100:static enum Sparse_type const sparse_type[] =
        -:  101:{
        -:  102:  SPARSE_NEVER, SPARSE_AUTO, SPARSE_ALWAYS
        -:  103:};
        -:  104:ARGMATCH_VERIFY (sparse_type_string, sparse_type);
        -:  105:
        -:  106:static char const *const reflink_type_string[] =
        -:  107:{
        -:  108:  "auto", "always", NULL
        -:  109:};
        -:  110:static enum Reflink_type const reflink_type[] =
        -:  111:{
        -:  112:  REFLINK_AUTO, REFLINK_ALWAYS
        -:  113:};
        -:  114:ARGMATCH_VERIFY (reflink_type_string, reflink_type);
        -:  115:
        -:  116:static struct option const long_opts[] =
        -:  117:{
        -:  118:  {"archive", no_argument, NULL, 'a'},
        -:  119:  {"attributes-only", no_argument, NULL, ATTRIBUTES_ONLY_OPTION},
        -:  120:  {"backup", optional_argument, NULL, 'b'},
        -:  121:  {"copy-contents", no_argument, NULL, COPY_CONTENTS_OPTION},
        -:  122:  {"dereference", no_argument, NULL, 'L'},
        -:  123:  {"force", no_argument, NULL, 'f'},
        -:  124:  {"interactive", no_argument, NULL, 'i'},
        -:  125:  {"link", no_argument, NULL, 'l'},
        -:  126:  {"no-clobber", no_argument, NULL, 'n'},
        -:  127:  {"no-dereference", no_argument, NULL, 'P'},
        -:  128:  {"no-preserve", required_argument, NULL, NO_PRESERVE_ATTRIBUTES_OPTION},
        -:  129:  {"no-target-directory", no_argument, NULL, 'T'},
        -:  130:  {"one-file-system", no_argument, NULL, 'x'},
        -:  131:  {"parents", no_argument, NULL, PARENTS_OPTION},
        -:  132:  {"path", no_argument, NULL, PARENTS_OPTION},   /* Deprecated.  */
        -:  133:  {"preserve", optional_argument, NULL, PRESERVE_ATTRIBUTES_OPTION},
        -:  134:  {"recursive", no_argument, NULL, 'R'},
        -:  135:  {"remove-destination", no_argument, NULL, UNLINK_DEST_BEFORE_OPENING},
        -:  136:  {"sparse", required_argument, NULL, SPARSE_OPTION},
        -:  137:  {"reflink", optional_argument, NULL, REFLINK_OPTION},
        -:  138:  {"strip-trailing-slashes", no_argument, NULL, STRIP_TRAILING_SLASHES_OPTION},
        -:  139:  {"suffix", required_argument, NULL, 'S'},
        -:  140:  {"symbolic-link", no_argument, NULL, 's'},
        -:  141:  {"target-directory", required_argument, NULL, 't'},
        -:  142:  {"update", no_argument, NULL, 'u'},
        -:  143:  {"verbose", no_argument, NULL, 'v'},
        -:  144:  {GETOPT_HELP_OPTION_DECL},
        -:  145:  {GETOPT_VERSION_OPTION_DECL},
        -:  146:  {NULL, 0, NULL, 0}
        -:  147:};
        -:  148:
        -:  149:void
    #####:  150:usage (int status)
        -:  151:{
    #####:  152:  if (status != EXIT_SUCCESS)
    #####:  153:    emit_try_help ();
        -:  154:  else
        -:  155:    {
    #####:  156:      printf (_("\
        -:  157:Usage: %s [OPTION]... [-T] SOURCE DEST\n\
        -:  158:  or:  %s [OPTION]... SOURCE... DIRECTORY\n\
        -:  159:  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n\
        -:  160:"),
        -:  161:              program_name, program_name, program_name);
    #####:  162:      fputs (_("\
        -:  163:Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n\
        -:  164:\n\
        -:  165:"), stdout);
    #####:  166:      fputs (_("\
        -:  167:Mandatory arguments to long options are mandatory for short options too.\n\
        -:  168:"), stdout);
    #####:  169:      fputs (_("\
        -:  170:  -a, --archive                same as -dR --preserve=all\n\
        -:  171:      --attributes-only        don't copy the file data, just the attributes\n\
        -:  172:      --backup[=CONTROL]       make a backup of each existing destination file\
        -:  173:\n\
        -:  174:  -b                           like --backup but does not accept an argument\n\
        -:  175:      --copy-contents          copy contents of special files when recursive\n\
        -:  176:  -d                           same as --no-dereference --preserve=links\n\
        -:  177:"), stdout);
    #####:  178:      fputs (_("\
        -:  179:  -f, --force                  if an existing destination file cannot be\n\
        -:  180:                                 opened, remove it and try again (redundant if\
        -:  181:\n\
        -:  182:                                 the -n option is used)\n\
        -:  183:  -i, --interactive            prompt before overwrite (overrides a previous -n\
        -:  184:\n\
        -:  185:                                  option)\n\
        -:  186:  -H                           follow command-line symbolic links in SOURCE\n\
        -:  187:"), stdout);
    #####:  188:      fputs (_("\
        -:  189:  -l, --link                   hard link files instead of copying\n\
        -:  190:  -L, --dereference            always follow symbolic links in SOURCE\n\
        -:  191:"), stdout);
    #####:  192:      fputs (_("\
        -:  193:  -n, --no-clobber             do not overwrite an existing file (overrides\n\
        -:  194:                                 a previous -i option)\n\
        -:  195:  -P, --no-dereference         never follow symbolic links in SOURCE\n\
        -:  196:"), stdout);
    #####:  197:      fputs (_("\
        -:  198:  -p                           same as --preserve=mode,ownership,timestamps\n\
        -:  199:      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n\
        -:  200:                                 mode,ownership,timestamps), if possible\n\
        -:  201:                                 additional attributes: context, links, xattr,\
        -:  202:\n\
        -:  203:                                 all\n\
        -:  204:"), stdout);
    #####:  205:      fputs (_("\
        -:  206:      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n\
        -:  207:      --parents                use full source file name under DIRECTORY\n\
        -:  208:"), stdout);
    #####:  209:      fputs (_("\
        -:  210:  -R, -r, --recursive          copy directories recursively\n\
        -:  211:      --reflink[=WHEN]         control clone/CoW copies. See below\n\
        -:  212:      --remove-destination     remove each existing destination file before\n\
        -:  213:                                 attempting to open it (contrast with --force)\
        -:  214:\n"), stdout);
    #####:  215:      fputs (_("\
        -:  216:      --sparse=WHEN            control creation of sparse files. See below\n\
        -:  217:      --strip-trailing-slashes  remove any trailing slashes from each SOURCE\n\
        -:  218:                                 argument\n\
        -:  219:"), stdout);
    #####:  220:      fputs (_("\
        -:  221:  -s, --symbolic-link          make symbolic links instead of copying\n\
        -:  222:  -S, --suffix=SUFFIX          override the usual backup suffix\n\
        -:  223:  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY\n\
        -:  224:  -T, --no-target-directory    treat DEST as a normal file\n\
        -:  225:"), stdout);
    #####:  226:      fputs (_("\
        -:  227:  -u, --update                 copy only when the SOURCE file is newer\n\
        -:  228:                                 than the destination file or when the\n\
        -:  229:                                 destination file is missing\n\
        -:  230:  -v, --verbose                explain what is being done\n\
        -:  231:  -x, --one-file-system        stay on this file system\n\
        -:  232:"), stdout);
    #####:  233:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####:  234:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####:  235:      fputs (_("\
        -:  236:\n\
        -:  237:By default, sparse SOURCE files are detected by a crude heuristic and the\n\
        -:  238:corresponding DEST file is made sparse as well.  That is the behavior\n\
        -:  239:selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n\
        -:  240:file whenever the SOURCE file contains a long enough sequence of zero bytes.\n\
        -:  241:Use --sparse=never to inhibit creation of sparse files.\n\
        -:  242:\n\
        -:  243:When --reflink[=always] is specified, perform a lightweight copy, where the\n\
        -:  244:data blocks are copied only when modified.  If this is not possible the copy\n\
        -:  245:fails, or if --reflink=auto is specified, fall back to a standard copy.\n\
        -:  246:"), stdout);
    #####:  247:      fputs (_("\
        -:  248:\n\
        -:  249:The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n\
        -:  250:The version control method may be selected via the --backup option or through\n\
        -:  251:the VERSION_CONTROL environment variable.  Here are the values:\n\
        -:  252:\n\
        -:  253:"), stdout);
    #####:  254:      fputs (_("\
        -:  255:  none, off       never make backups (even if --backup is given)\n\
        -:  256:  numbered, t     make numbered backups\n\
        -:  257:  existing, nil   numbered if numbered backups exist, simple otherwise\n\
        -:  258:  simple, never   always make simple backups\n\
        -:  259:"), stdout);
    #####:  260:      fputs (_("\
        -:  261:\n\
        -:  262:As a special case, cp makes a backup of SOURCE when the force and backup\n\
        -:  263:options are given and SOURCE and DEST are the same name for an existing,\n\
        -:  264:regular file.\n\
        -:  265:"), stdout);
    #####:  266:      emit_ancillary_info ();
        -:  267:    }
    #####:  268:  exit (status);
        -:  269:}
        -:  270:
        -:  271:/* Ensure that the parent directories of CONST_DST_NAME have the
        -:  272:   correct protections, for the --parents option.  This is done
        -:  273:   after all copying has been completed, to allow permissions
        -:  274:   that don't include user write/execute.
        -:  275:
        -:  276:   SRC_OFFSET is the index in CONST_DST_NAME of the beginning of the
        -:  277:   source directory name.
        -:  278:
        -:  279:   ATTR_LIST is a null-terminated linked list of structures that
        -:  280:   indicates the end of the filename of each intermediate directory
        -:  281:   in CONST_DST_NAME that may need to have its attributes changed.
        -:  282:   The command 'cp --parents --preserve a/b/c d/e_dir' changes the
        -:  283:   attributes of the directories d/e_dir/a and d/e_dir/a/b to match
        -:  284:   the corresponding source directories regardless of whether they
        -:  285:   existed before the 'cp' command was given.
        -:  286:
        -:  287:   Return true if the parent of CONST_DST_NAME and any intermediate
        -:  288:   directories specified by ATTR_LIST have the proper permissions
        -:  289:   when done.  */
        -:  290:
        -:  291:static bool
    #####:  292:re_protect (char const *const_dst_name, size_t src_offset,
        -:  293:            struct dir_attr *attr_list, const struct cp_options *x)
        -:  294:{
        -:  295:  struct dir_attr *p;
        -:  296:  char *dst_name;		/* A copy of CONST_DST_NAME we can change. */
        -:  297:  char *src_name;		/* The source name in 'dst_name'. */
        -:  298:
    #####:  299:  ASSIGN_STRDUPA (dst_name, const_dst_name);
    #####:  300:  src_name = dst_name + src_offset;
        -:  301:
    #####:  302:  for (p = attr_list; p; p = p->next)
        -:  303:    {
    #####:  304:      dst_name[p->slash_offset] = '\0';
        -:  305:
        -:  306:      /* Adjust the times (and if possible, ownership) for the copy.
        -:  307:         chown turns off set[ug]id bits for non-root,
        -:  308:         so do the chmod last.  */
        -:  309:
    #####:  310:      if (x->preserve_timestamps)
        -:  311:        {
        -:  312:          struct timespec timespec[2];
        -:  313:
    #####:  314:          timespec[0] = get_stat_atime (&p->st);
    #####:  315:          timespec[1] = get_stat_mtime (&p->st);
        -:  316:
    #####:  317:          if (utimens (dst_name, timespec))
        -:  318:            {
    #####:  319:              error (0, errno, _("failed to preserve times for %s"),
        -:  320:                     quote (dst_name));
    #####:  321:              return false;
        -:  322:            }
        -:  323:        }
        -:  324:
    #####:  325:      if (x->preserve_ownership)
        -:  326:        {
    #####:  327:          if (lchown (dst_name, p->st.st_uid, p->st.st_gid) != 0)
        -:  328:            {
    #####:  329:              if (! chown_failure_ok (x))
        -:  330:                {
    #####:  331:                  error (0, errno, _("failed to preserve ownership for %s"),
        -:  332:                         quote (dst_name));
    #####:  333:                  return false;
        -:  334:                }
        -:  335:              /* Failing to preserve ownership is OK. Still, try to preserve
        -:  336:                 the group, but ignore the possible error. */
    #####:  337:              ignore_value (lchown (dst_name, -1, p->st.st_gid));
        -:  338:            }
        -:  339:        }
        -:  340:
    #####:  341:      if (x->preserve_mode)
        -:  342:        {
    #####:  343:          if (copy_acl (src_name, -1, dst_name, -1, p->st.st_mode) != 0)
    #####:  344:            return false;
        -:  345:        }
    #####:  346:      else if (p->restore_mode)
        -:  347:        {
    #####:  348:          if (lchmod (dst_name, p->st.st_mode) != 0)
        -:  349:            {
    #####:  350:              error (0, errno, _("failed to preserve permissions for %s"),
        -:  351:                     quote (dst_name));
    #####:  352:              return false;
        -:  353:            }
        -:  354:        }
        -:  355:
    #####:  356:      dst_name[p->slash_offset] = '/';
        -:  357:    }
    #####:  358:  return true;
        -:  359:}
        -:  360:
        -:  361:/* Ensure that the parent directory of CONST_DIR exists, for
        -:  362:   the --parents option.
        -:  363:
        -:  364:   SRC_OFFSET is the index in CONST_DIR (which is a destination
        -:  365:   directory) of the beginning of the source directory name.
        -:  366:   Create any leading directories that don't already exist.
        -:  367:   If VERBOSE_FMT_STRING is nonzero, use it as a printf format
        -:  368:   string for printing a message after successfully making a directory.
        -:  369:   The format should take two string arguments: the names of the
        -:  370:   source and destination directories.
        -:  371:   Creates a linked list of attributes of intermediate directories,
        -:  372:   *ATTR_LIST, for re_protect to use after calling copy.
        -:  373:   Sets *NEW_DST if this function creates parent of CONST_DIR.
        -:  374:
        -:  375:   Return true if parent of CONST_DIR exists as a directory with the proper
        -:  376:   permissions when done.  */
        -:  377:
        -:  378:/* FIXME: Synch this function with the one in ../lib/mkdir-p.c.  */
        -:  379:
        -:  380:static bool
    #####:  381:make_dir_parents_private (char const *const_dir, size_t src_offset,
        -:  382:                          char const *verbose_fmt_string,
        -:  383:                          struct dir_attr **attr_list, bool *new_dst,
        -:  384:                          const struct cp_options *x)
        -:  385:{
        -:  386:  struct stat stats;
        -:  387:  char *dir;		/* A copy of CONST_DIR we can change.  */
        -:  388:  char *src;		/* Source name in DIR.  */
        -:  389:  char *dst_dir;	/* Leading directory of DIR.  */
        -:  390:  size_t dirlen;	/* Length of DIR.  */
        -:  391:
    #####:  392:  ASSIGN_STRDUPA (dir, const_dir);
        -:  393:
    #####:  394:  src = dir + src_offset;
        -:  395:
    #####:  396:  dirlen = dir_len (dir);
    #####:  397:  dst_dir = alloca (dirlen + 1);
    #####:  398:  memcpy (dst_dir, dir, dirlen);
    #####:  399:  dst_dir[dirlen] = '\0';
        -:  400:
    #####:  401:  *attr_list = NULL;
        -:  402:
    #####:  403:  if (stat (dst_dir, &stats) != 0)
        -:  404:    {
        -:  405:      /* A parent of CONST_DIR does not exist.
        -:  406:         Make all missing intermediate directories. */
        -:  407:      char *slash;
        -:  408:
    #####:  409:      slash = src;
    #####:  410:      while (*slash == '/')
    #####:  411:        slash++;
    #####:  412:      while ((slash = strchr (slash, '/')))
        -:  413:        {
        -:  414:          struct dir_attr *new IF_LINT ( = NULL);
        -:  415:          bool missing_dir;
        -:  416:
    #####:  417:          *slash = '\0';
    #####:  418:          missing_dir = (stat (dir, &stats) != 0);
        -:  419:
    #####:  420:          if (missing_dir || x->preserve_ownership || x->preserve_mode
    #####:  421:              || x->preserve_timestamps)
        -:  422:            {
        -:  423:              /* Add this directory to the list of directories whose
        -:  424:                 modes might need fixing later. */
        -:  425:              struct stat src_st;
    #####:  426:              int src_errno = (stat (src, &src_st) != 0
    #####:  427:                               ? errno
    #####:  428:                               : S_ISDIR (src_st.st_mode)
        -:  429:                               ? 0
    #####:  430:                               : ENOTDIR);
    #####:  431:              if (src_errno)
        -:  432:                {
    #####:  433:                  error (0, src_errno, _("failed to get attributes of %s"),
        -:  434:                         quote (src));
    #####:  435:                  return false;
        -:  436:                }
        -:  437:
    #####:  438:              new = xmalloc (sizeof *new);
    #####:  439:              new->st = src_st;
    #####:  440:              new->slash_offset = slash - dir;
    #####:  441:              new->restore_mode = false;
    #####:  442:              new->next = *attr_list;
    #####:  443:              *attr_list = new;
        -:  444:            }
        -:  445:
    #####:  446:          if (missing_dir)
        -:  447:            {
        -:  448:              mode_t src_mode;
        -:  449:              mode_t omitted_permissions;
        -:  450:              mode_t mkdir_mode;
        -:  451:
        -:  452:              /* This component does not exist.  We must set
        -:  453:                 *new_dst and new->st.st_mode inside this loop because,
        -:  454:                 for example, in the command 'cp --parents ../a/../b/c e_dir',
        -:  455:                 make_dir_parents_private creates only e_dir/../a if
        -:  456:                 ./b already exists. */
    #####:  457:              *new_dst = true;
    #####:  458:              src_mode = new->st.st_mode;
        -:  459:
        -:  460:              /* If the ownership or special mode bits might change,
        -:  461:                 omit some permissions at first, so unauthorized users
        -:  462:                 cannot nip in before the file is ready.  */
    #####:  463:              omitted_permissions = (src_mode
    #####:  464:                                     & (x->preserve_ownership
    #####:  465:                                        ? S_IRWXG | S_IRWXO
    #####:  466:                                        : x->preserve_mode
        -:  467:                                        ? S_IWGRP | S_IWOTH
        -:  468:                                        : 0));
        -:  469:
        -:  470:              /* POSIX says mkdir's behavior is implementation-defined when
        -:  471:                 (src_mode & ~S_IRWXUGO) != 0.  However, common practice is
        -:  472:                 to ask mkdir to copy all the CHMOD_MODE_BITS, letting mkdir
        -:  473:                 decide what to do with S_ISUID | S_ISGID | S_ISVTX.  */
    #####:  474:              mkdir_mode = src_mode & CHMOD_MODE_BITS & ~omitted_permissions;
    #####:  475:              if (mkdir (dir, mkdir_mode) != 0)
        -:  476:                {
    #####:  477:                  error (0, errno, _("cannot make directory %s"),
        -:  478:                         quote (dir));
    #####:  479:                  return false;
        -:  480:                }
        -:  481:              else
        -:  482:                {
    #####:  483:                  if (verbose_fmt_string != NULL)
    #####:  484:                    printf (verbose_fmt_string, src, dir);
        -:  485:                }
        -:  486:
        -:  487:              /* We need search and write permissions to the new directory
        -:  488:                 for writing the directory's contents. Check if these
        -:  489:                 permissions are there.  */
        -:  490:
    #####:  491:              if (lstat (dir, &stats))
        -:  492:                {
    #####:  493:                  error (0, errno, _("failed to get attributes of %s"),
        -:  494:                         quote (dir));
    #####:  495:                  return false;
        -:  496:                }
        -:  497:
        -:  498:
    #####:  499:              if (! x->preserve_mode)
        -:  500:                {
    #####:  501:                  if (omitted_permissions & ~stats.st_mode)
    #####:  502:                    omitted_permissions &= ~ cached_umask ();
    #####:  503:                  if (omitted_permissions & ~stats.st_mode
    #####:  504:                      || (stats.st_mode & S_IRWXU) != S_IRWXU)
        -:  505:                    {
    #####:  506:                      new->st.st_mode = stats.st_mode | omitted_permissions;
    #####:  507:                      new->restore_mode = true;
        -:  508:                    }
        -:  509:                }
        -:  510:
    #####:  511:              if ((stats.st_mode & S_IRWXU) != S_IRWXU)
        -:  512:                {
        -:  513:                  /* Make the new directory searchable and writable.
        -:  514:                     The original permissions will be restored later.  */
        -:  515:
    #####:  516:                  if (lchmod (dir, stats.st_mode | S_IRWXU) != 0)
        -:  517:                    {
    #####:  518:                      error (0, errno, _("setting permissions for %s"),
        -:  519:                             quote (dir));
    #####:  520:                      return false;
        -:  521:                    }
        -:  522:                }
        -:  523:            }
    #####:  524:          else if (!S_ISDIR (stats.st_mode))
        -:  525:            {
    #####:  526:              error (0, 0, _("%s exists but is not a directory"),
        -:  527:                     quote (dir));
    #####:  528:              return false;
        -:  529:            }
        -:  530:          else
    #####:  531:            *new_dst = false;
    #####:  532:          *slash++ = '/';
        -:  533:
        -:  534:          /* Avoid unnecessary calls to 'stat' when given
        -:  535:             file names containing multiple adjacent slashes.  */
    #####:  536:          while (*slash == '/')
    #####:  537:            slash++;
        -:  538:        }
        -:  539:    }
        -:  540:
        -:  541:  /* We get here if the parent of DIR already exists.  */
        -:  542:
    #####:  543:  else if (!S_ISDIR (stats.st_mode))
        -:  544:    {
    #####:  545:      error (0, 0, _("%s exists but is not a directory"), quote (dst_dir));
    #####:  546:      return false;
        -:  547:    }
        -:  548:  else
        -:  549:    {
    #####:  550:      *new_dst = false;
        -:  551:    }
    #####:  552:  return true;
        -:  553:}
        -:  554:
        -:  555:/* FILE is the last operand of this command.
        -:  556:   Return true if FILE is a directory.
        -:  557:   But report an error and exit if there is a problem accessing FILE,
        -:  558:   or if FILE does not exist but would have to refer to an existing
        -:  559:   directory if it referred to anything at all.
        -:  560:
        -:  561:   If the file exists, store the file's status into *ST.
        -:  562:   Otherwise, set *NEW_DST.  */
        -:  563:
        -:  564:static bool
        4:  565:target_directory_operand (char const *file, struct stat *st, bool *new_dst)
        -:  566:{
        4:  567:  int err = (stat (file, st) == 0 ? 0 : errno);
        4:  568:  bool is_a_dir = !err && S_ISDIR (st->st_mode);
        4:  569:  if (err)
        -:  570:    {
    #####:  571:      if (err != ENOENT)
    #####:  572:        error (EXIT_FAILURE, err, _("accessing %s"), quote (file));
    #####:  573:      *new_dst = true;
        -:  574:    }
        4:  575:  return is_a_dir;
        -:  576:}
        -:  577:
        -:  578:/* Scan the arguments, and copy each by calling copy.
        -:  579:   Return true if successful.  */
        -:  580:
        -:  581:static bool
        4:  582:do_copy (int n_files, char **file, const char *target_directory,
        -:  583:         bool no_target_directory, struct cp_options *x)
        -:  584:{
        -:  585:  struct stat sb;
        4:  586:  bool new_dst = false;
        4:  587:  bool ok = true;
        -:  588:
        4:  589:  if (n_files <= !target_directory)
        -:  590:    {
    #####:  591:      if (n_files <= 0)
    #####:  592:        error (0, 0, _("missing file operand"));
        -:  593:      else
    #####:  594:        error (0, 0, _("missing destination file operand after %s"),
        -:  595:               quote (file[0]));
    #####:  596:      usage (EXIT_FAILURE);
        -:  597:    }
        -:  598:
        4:  599:  if (no_target_directory)
        -:  600:    {
    #####:  601:      if (target_directory)
    #####:  602:        error (EXIT_FAILURE, 0,
        -:  603:               _("cannot combine --target-directory (-t) "
        -:  604:                 "and --no-target-directory (-T)"));
    #####:  605:      if (2 < n_files)
        -:  606:        {
    #####:  607:          error (0, 0, _("extra operand %s"), quote (file[2]));
    #####:  608:          usage (EXIT_FAILURE);
        -:  609:        }
        -:  610:      /* Update NEW_DST and SB, which may be checked below.  */
    #####:  611:      ignore_value (target_directory_operand (file[n_files -1], &sb, &new_dst));
        -:  612:    }
        4:  613:  else if (!target_directory)
        -:  614:    {
        4:  615:      if (2 <= n_files
        4:  616:          && target_directory_operand (file[n_files - 1], &sb, &new_dst))
        4:  617:        target_directory = file[--n_files];
    #####:  618:      else if (2 < n_files)
    #####:  619:        error (EXIT_FAILURE, 0, _("target %s is not a directory"),
    #####:  620:               quote (file[n_files - 1]));
        -:  621:    }
        -:  622:
        4:  623:  if (target_directory)
        -:  624:    {
        -:  625:      /* cp file1...filen edir
        -:  626:         Copy the files 'file1' through 'filen'
        -:  627:         to the existing directory 'edir'. */
        -:  628:      int i;
        -:  629:
        -:  630:      /* Initialize these hash tables only if we'll need them.
        -:  631:         The problems they're used to detect can arise only if
        -:  632:         there are two or more files to copy.  */
        4:  633:      if (2 <= n_files)
        -:  634:        {
        4:  635:          dest_info_init (x);
        4:  636:          src_info_init (x);
        -:  637:        }
        -:  638:
       12:  639:      for (i = 0; i < n_files; i++)
        -:  640:        {
        -:  641:          char *dst_name;
        8:  642:          bool parent_exists = true;  /* True if dir_name (dst_name) exists. */
        -:  643:          struct dir_attr *attr_list;
        8:  644:          char *arg_in_concat = NULL;
        8:  645:          char *arg = file[i];
        -:  646:
        -:  647:          /* Trailing slashes are meaningful (i.e., maybe worth preserving)
        -:  648:             only in the source file names.  */
        8:  649:          if (remove_trailing_slashes)
    #####:  650:            strip_trailing_slashes (arg);
        -:  651:
        8:  652:          if (parents_option)
        -:  653:            {
        -:  654:              char *arg_no_trailing_slash;
        -:  655:
        -:  656:              /* Use 'arg' without trailing slashes in constructing destination
        -:  657:                 file names.  Otherwise, we can end up trying to create a
        -:  658:                 directory via 'mkdir ("dst/foo/"...', which is not portable.
        -:  659:                 It fails, due to the trailing slash, on at least
        -:  660:                 NetBSD 1.[34] systems.  */
    #####:  661:              ASSIGN_STRDUPA (arg_no_trailing_slash, arg);
    #####:  662:              strip_trailing_slashes (arg_no_trailing_slash);
        -:  663:
        -:  664:              /* Append all of 'arg' (minus any trailing slash) to 'dest'.  */
    #####:  665:              dst_name = file_name_concat (target_directory,
        -:  666:                                           arg_no_trailing_slash,
        -:  667:                                           &arg_in_concat);
        -:  668:
        -:  669:              /* For --parents, we have to make sure that the directory
        -:  670:                 dir_name (dst_name) exists.  We may have to create a few
        -:  671:                 leading directories. */
    #####:  672:              parent_exists =
        -:  673:                (make_dir_parents_private
    #####:  674:                 (dst_name, arg_in_concat - dst_name,
    #####:  675:                  (x->verbose ? "%s -> %s\n" : NULL),
        -:  676:                  &attr_list, &new_dst, x));
        -:  677:            }
        -:  678:          else
        -:  679:            {
        -:  680:              char *arg_base;
        -:  681:              /* Append the last component of 'arg' to 'target_directory'.  */
        -:  682:
        8:  683:              ASSIGN_BASENAME_STRDUPA (arg_base, arg);
        -:  684:              /* For 'cp -R source/.. dest', don't copy into 'dest/..'. */
       16:  685:              dst_name = (STREQ (arg_base, "..")
        -:  686:                          ? xstrdup (target_directory)
        8:  687:                          : file_name_concat (target_directory, arg_base,
        -:  688:                                              NULL));
        -:  689:            }
        -:  690:
        8:  691:          if (!parent_exists)
        -:  692:            {
        -:  693:              /* make_dir_parents_private failed, so don't even
        -:  694:                 attempt the copy.  */
    #####:  695:              ok = false;
        -:  696:            }
        -:  697:          else
        -:  698:            {
        -:  699:              bool copy_into_self;
        8:  700:              ok &= copy (arg, dst_name, new_dst, x, &copy_into_self, NULL);
        -:  701:
        8:  702:              if (parents_option)
    #####:  703:                ok &= re_protect (dst_name, arg_in_concat - dst_name,
        -:  704:                                  attr_list, x);
        -:  705:            }
        -:  706:
        8:  707:          if (parents_option)
        -:  708:            {
    #####:  709:              while (attr_list)
        -:  710:                {
    #####:  711:                  struct dir_attr *p = attr_list;
    #####:  712:                  attr_list = attr_list->next;
    #####:  713:                  free (p);
        -:  714:                }
        -:  715:            }
        -:  716:
        8:  717:          free (dst_name);
        -:  718:        }
        -:  719:    }
        -:  720:  else /* !target_directory */
        -:  721:    {
        -:  722:      char const *new_dest;
    #####:  723:      char const *source = file[0];
    #####:  724:      char const *dest = file[1];
        -:  725:      bool unused;
        -:  726:
    #####:  727:      if (parents_option)
        -:  728:        {
    #####:  729:          error (0, 0,
        -:  730:                 _("with --parents, the destination must be a directory"));
    #####:  731:          usage (EXIT_FAILURE);
        -:  732:        }
        -:  733:
        -:  734:      /* When the force and backup options have been specified and
        -:  735:         the source and destination are the same name for an existing
        -:  736:         regular file, convert the user's command, e.g.,
        -:  737:         'cp --force --backup foo foo' to 'cp --force foo fooSUFFIX'
        -:  738:         where SUFFIX is determined by any version control options used.  */
        -:  739:
    #####:  740:      if (x->unlink_dest_after_failed_open
    #####:  741:          && x->backup_type != no_backups
    #####:  742:          && STREQ (source, dest)
    #####:  743:          && !new_dst && S_ISREG (sb.st_mode))
    #####:  744:        {
        -:  745:          static struct cp_options x_tmp;
        -:  746:
    #####:  747:          new_dest = find_backup_file_name (dest, x->backup_type);
        -:  748:          /* Set x->backup_type to 'no_backups' so that the normal backup
        -:  749:             mechanism is not used when performing the actual copy.
        -:  750:             backup_type must be set to 'no_backups' only *after* the above
        -:  751:             call to find_backup_file_name -- that function uses
        -:  752:             backup_type to determine the suffix it applies.  */
    #####:  753:          x_tmp = *x;
    #####:  754:          x_tmp.backup_type = no_backups;
    #####:  755:          x = &x_tmp;
        -:  756:        }
        -:  757:      else
        -:  758:        {
    #####:  759:          new_dest = dest;
        -:  760:        }
        -:  761:
    #####:  762:      ok = copy (source, new_dest, 0, x, &unused, NULL);
        -:  763:    }
        -:  764:
        4:  765:  return ok;
        -:  766:}
        -:  767:
        -:  768:static void
        5:  769:cp_option_init (struct cp_options *x)
        -:  770:{
        5:  771:  cp_options_default (x);
        5:  772:  x->copy_as_regular = true;
        5:  773:  x->dereference = DEREF_UNDEFINED;
        5:  774:  x->unlink_dest_before_opening = false;
        5:  775:  x->unlink_dest_after_failed_open = false;
        5:  776:  x->hard_link = false;
        5:  777:  x->interactive = I_UNSPECIFIED;
        5:  778:  x->move_mode = false;
        5:  779:  x->one_file_system = false;
        5:  780:  x->reflink_mode = REFLINK_NEVER;
        -:  781:
        5:  782:  x->preserve_ownership = false;
        5:  783:  x->preserve_links = false;
        5:  784:  x->preserve_mode = false;
        5:  785:  x->preserve_timestamps = false;
        5:  786:  x->preserve_security_context = false;
        5:  787:  x->require_preserve_context = false;
        5:  788:  x->preserve_xattr = false;
        5:  789:  x->reduce_diagnostics = false;
        5:  790:  x->require_preserve_xattr = false;
        -:  791:
        5:  792:  x->data_copy_required = true;
        5:  793:  x->require_preserve = false;
        5:  794:  x->recursive = false;
        5:  795:  x->sparse_mode = SPARSE_AUTO;
        5:  796:  x->symbolic_link = false;
        5:  797:  x->set_mode = false;
        5:  798:  x->mode = 0;
        -:  799:
        -:  800:  /* Not used.  */
        5:  801:  x->stdin_tty = false;
        -:  802:
        5:  803:  x->update = false;
        5:  804:  x->verbose = false;
        -:  805:
        -:  806:  /* By default, refuse to open a dangling destination symlink, because
        -:  807:     in general one cannot do that safely, give the current semantics of
        -:  808:     open's O_EXCL flag, (which POSIX doesn't even allow cp to use, btw).
        -:  809:     But POSIX requires it.  */
        5:  810:  x->open_dangling_dest_symlink = getenv ("POSIXLY_CORRECT") != NULL;
        -:  811:
        5:  812:  x->dest_info = NULL;
        5:  813:  x->src_info = NULL;
        5:  814:}
        -:  815:
        -:  816:/* Given a string, ARG, containing a comma-separated list of arguments
        -:  817:   to the --preserve option, set the appropriate fields of X to ON_OFF.  */
        -:  818:static void
    #####:  819:decode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)
        -:  820:{
        -:  821:  enum File_attribute
        -:  822:    {
        -:  823:      PRESERVE_MODE,
        -:  824:      PRESERVE_TIMESTAMPS,
        -:  825:      PRESERVE_OWNERSHIP,
        -:  826:      PRESERVE_LINK,
        -:  827:      PRESERVE_CONTEXT,
        -:  828:      PRESERVE_XATTR,
        -:  829:      PRESERVE_ALL
        -:  830:    };
        -:  831:  static enum File_attribute const preserve_vals[] =
        -:  832:    {
        -:  833:      PRESERVE_MODE, PRESERVE_TIMESTAMPS,
        -:  834:      PRESERVE_OWNERSHIP, PRESERVE_LINK, PRESERVE_CONTEXT, PRESERVE_XATTR,
        -:  835:      PRESERVE_ALL
        -:  836:    };
        -:  837:  /* Valid arguments to the '--preserve' option. */
        -:  838:  static char const* const preserve_args[] =
        -:  839:    {
        -:  840:      "mode", "timestamps",
        -:  841:      "ownership", "links", "context", "xattr", "all", NULL
        -:  842:    };
        -:  843:  ARGMATCH_VERIFY (preserve_args, preserve_vals);
        -:  844:
    #####:  845:  char *arg_writable = xstrdup (arg);
    #####:  846:  char *s = arg_writable;
        -:  847:  do
        -:  848:    {
        -:  849:      /* find next comma */
    #####:  850:      char *comma = strchr (s, ',');
        -:  851:      enum File_attribute val;
        -:  852:
        -:  853:      /* If we found a comma, put a NUL in its place and advance.  */
    #####:  854:      if (comma)
    #####:  855:        *comma++ = 0;
        -:  856:
        -:  857:      /* process S.  */
    #####:  858:      val = XARGMATCH ("--preserve", s, preserve_args, preserve_vals);
    #####:  859:      switch (val)
        -:  860:        {
        -:  861:        case PRESERVE_MODE:
    #####:  862:          x->preserve_mode = on_off;
    #####:  863:          break;
        -:  864:
        -:  865:        case PRESERVE_TIMESTAMPS:
    #####:  866:          x->preserve_timestamps = on_off;
    #####:  867:          break;
        -:  868:
        -:  869:        case PRESERVE_OWNERSHIP:
    #####:  870:          x->preserve_ownership = on_off;
    #####:  871:          break;
        -:  872:
        -:  873:        case PRESERVE_LINK:
    #####:  874:          x->preserve_links = on_off;
    #####:  875:          break;
        -:  876:
        -:  877:        case PRESERVE_CONTEXT:
    #####:  878:          x->preserve_security_context = on_off;
    #####:  879:          x->require_preserve_context = on_off;
    #####:  880:          break;
        -:  881:
        -:  882:        case PRESERVE_XATTR:
    #####:  883:          x->preserve_xattr = on_off;
    #####:  884:          x->require_preserve_xattr = on_off;
    #####:  885:          break;
        -:  886:
        -:  887:        case PRESERVE_ALL:
    #####:  888:          x->preserve_mode = on_off;
    #####:  889:          x->preserve_timestamps = on_off;
    #####:  890:          x->preserve_ownership = on_off;
    #####:  891:          x->preserve_links = on_off;
    #####:  892:          if (selinux_enabled)
    #####:  893:            x->preserve_security_context = on_off;
    #####:  894:          x->preserve_xattr = on_off;
    #####:  895:          break;
        -:  896:
        -:  897:        default:
    #####:  898:          abort ();
        -:  899:        }
    #####:  900:      s = comma;
        -:  901:    }
    #####:  902:  while (s);
        -:  903:
    #####:  904:  free (arg_writable);
    #####:  905:}
        -:  906:
        -:  907:int
        5:  908:main (int argc, char **argv)
        -:  909:{
        -:  910:  int c;
        -:  911:  bool ok;
        5:  912:  bool make_backups = false;
        -:  913:  char *backup_suffix_string;
        5:  914:  char *version_control_string = NULL;
        -:  915:  struct cp_options x;
        5:  916:  bool copy_contents = false;
        5:  917:  char *target_directory = NULL;
        5:  918:  bool no_target_directory = false;
        -:  919:
        -:  920:  initialize_main (&argc, &argv);
        5:  921:  set_program_name (argv[0]);
        5:  922:  setlocale (LC_ALL, "");
        -:  923:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  924:  textdomain (PACKAGE);
        -:  925:
        5:  926:  atexit (close_stdin);
        -:  927:
        5:  928:  selinux_enabled = (0 < is_selinux_enabled ());
        5:  929:  cp_option_init (&x);
        -:  930:
        -:  931:  /* FIXME: consider not calling getenv for SIMPLE_BACKUP_SUFFIX unless
        -:  932:     we'll actually use backup_suffix_string.  */
        5:  933:  backup_suffix_string = getenv ("SIMPLE_BACKUP_SUFFIX");
        -:  934:
        5:  935:  while ((c = getopt_long (argc, argv, "abdfHilLnprst:uvxPRS:T",
        -:  936:                           long_opts, NULL))
        -:  937:         != -1)
        -:  938:    {
        3:  939:      switch (c)
        -:  940:        {
        -:  941:        case SPARSE_OPTION:
    #####:  942:          x.sparse_mode = XARGMATCH ("--sparse", optarg,
        -:  943:                                     sparse_type_string, sparse_type);
    #####:  944:          break;
        -:  945:
        -:  946:        case REFLINK_OPTION:
    #####:  947:          if (optarg == NULL)
    #####:  948:            x.reflink_mode = REFLINK_ALWAYS;
        -:  949:          else
    #####:  950:            x.reflink_mode = XARGMATCH ("--reflink", optarg,
        -:  951:                                       reflink_type_string, reflink_type);
    #####:  952:          break;
        -:  953:
        -:  954:        case 'a':
        -:  955:          /* Like -dR --preserve=all with reduced failure diagnostics.  */
    #####:  956:          x.dereference = DEREF_NEVER;
    #####:  957:          x.preserve_links = true;
    #####:  958:          x.preserve_ownership = true;
    #####:  959:          x.preserve_mode = true;
    #####:  960:          x.preserve_timestamps = true;
    #####:  961:          x.require_preserve = true;
    #####:  962:          if (selinux_enabled)
    #####:  963:             x.preserve_security_context = true;
    #####:  964:          x.preserve_xattr = true;
    #####:  965:          x.reduce_diagnostics = true;
    #####:  966:          x.recursive = true;
    #####:  967:          break;
        -:  968:
        -:  969:        case 'b':
        2:  970:          make_backups = true;
        2:  971:          if (optarg)
        1:  972:            version_control_string = optarg;
        2:  973:          break;
        -:  974:
        -:  975:        case ATTRIBUTES_ONLY_OPTION:
    #####:  976:          x.data_copy_required = false;
    #####:  977:          break;
        -:  978:
        -:  979:        case COPY_CONTENTS_OPTION:
    #####:  980:          copy_contents = true;
    #####:  981:          break;
        -:  982:
        -:  983:        case 'd':
    #####:  984:          x.preserve_links = true;
    #####:  985:          x.dereference = DEREF_NEVER;
    #####:  986:          break;
        -:  987:
        -:  988:        case 'f':
    #####:  989:          x.unlink_dest_after_failed_open = true;
    #####:  990:          break;
        -:  991:
        -:  992:        case 'H':
    #####:  993:          x.dereference = DEREF_COMMAND_LINE_ARGUMENTS;
    #####:  994:          break;
        -:  995:
        -:  996:        case 'i':
    #####:  997:          x.interactive = I_ASK_USER;
    #####:  998:          break;
        -:  999:
        -: 1000:        case 'l':
    #####: 1001:          x.hard_link = true;
    #####: 1002:          break;
        -: 1003:
        -: 1004:        case 'L':
    #####: 1005:          x.dereference = DEREF_ALWAYS;
    #####: 1006:          break;
        -: 1007:
        -: 1008:        case 'n':
    #####: 1009:          x.interactive = I_ALWAYS_NO;
    #####: 1010:          break;
        -: 1011:
        -: 1012:        case 'P':
    #####: 1013:          x.dereference = DEREF_NEVER;
    #####: 1014:          break;
        -: 1015:
        -: 1016:        case NO_PRESERVE_ATTRIBUTES_OPTION:
    #####: 1017:          decode_preserve_arg (optarg, &x, false);
    #####: 1018:          break;
        -: 1019:
        -: 1020:        case PRESERVE_ATTRIBUTES_OPTION:
    #####: 1021:          if (optarg == NULL)
        -: 1022:            {
        -: 1023:              /* Fall through to the case for 'p' below.  */
        -: 1024:            }
        -: 1025:          else
        -: 1026:            {
    #####: 1027:              decode_preserve_arg (optarg, &x, true);
    #####: 1028:              x.require_preserve = true;
    #####: 1029:              break;
        -: 1030:            }
        -: 1031:
        -: 1032:        case 'p':
    #####: 1033:          x.preserve_ownership = true;
    #####: 1034:          x.preserve_mode = true;
    #####: 1035:          x.preserve_timestamps = true;
    #####: 1036:          x.require_preserve = true;
    #####: 1037:          break;
        -: 1038:
        -: 1039:        case PARENTS_OPTION:
    #####: 1040:          parents_option = true;
    #####: 1041:          break;
        -: 1042:
        -: 1043:        case 'r':
        -: 1044:        case 'R':
    #####: 1045:          x.recursive = true;
    #####: 1046:          break;
        -: 1047:
        -: 1048:        case UNLINK_DEST_BEFORE_OPENING:
    #####: 1049:          x.unlink_dest_before_opening = true;
    #####: 1050:          break;
        -: 1051:
        -: 1052:        case STRIP_TRAILING_SLASHES_OPTION:
    #####: 1053:          remove_trailing_slashes = true;
    #####: 1054:          break;
        -: 1055:
        -: 1056:        case 's':
    #####: 1057:          x.symbolic_link = true;
    #####: 1058:          break;
        -: 1059:
        -: 1060:        case 't':
    #####: 1061:          if (target_directory)
    #####: 1062:            error (EXIT_FAILURE, 0,
        -: 1063:                   _("multiple target directories specified"));
        -: 1064:          else
        -: 1065:            {
        -: 1066:              struct stat st;
    #####: 1067:              if (stat (optarg, &st) != 0)
    #####: 1068:                error (EXIT_FAILURE, errno, _("accessing %s"), quote (optarg));
    #####: 1069:              if (! S_ISDIR (st.st_mode))
    #####: 1070:                error (EXIT_FAILURE, 0, _("target %s is not a directory"),
        -: 1071:                       quote (optarg));
        -: 1072:            }
    #####: 1073:          target_directory = optarg;
    #####: 1074:          break;
        -: 1075:
        -: 1076:        case 'T':
    #####: 1077:          no_target_directory = true;
    #####: 1078:          break;
        -: 1079:
        -: 1080:        case 'u':
    #####: 1081:          x.update = true;
    #####: 1082:          break;
        -: 1083:
        -: 1084:        case 'v':
    #####: 1085:          x.verbose = true;
    #####: 1086:          break;
        -: 1087:
        -: 1088:        case 'x':
    #####: 1089:          x.one_file_system = true;
    #####: 1090:          break;
        -: 1091:
        -: 1092:        case 'S':
    #####: 1093:          make_backups = true;
    #####: 1094:          backup_suffix_string = optarg;
    #####: 1095:          break;
        -: 1096:
    #####: 1097:        case_GETOPT_HELP_CHAR;
        -: 1098:
        1: 1099:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -: 1100:
        -: 1101:        default:
    #####: 1102:          usage (EXIT_FAILURE);
        -: 1103:        }
        -: 1104:    }
        -: 1105:
        4: 1106:  if (x.hard_link && x.symbolic_link)
        -: 1107:    {
    #####: 1108:      error (0, 0, _("cannot make both hard and symbolic links"));
    #####: 1109:      usage (EXIT_FAILURE);
        -: 1110:    }
        -: 1111:
        4: 1112:  if (make_backups && x.interactive == I_ALWAYS_NO)
        -: 1113:    {
    #####: 1114:      error (0, 0,
        -: 1115:             _("options --backup and --no-clobber are mutually exclusive"));
    #####: 1116:      usage (EXIT_FAILURE);
        -: 1117:    }
        -: 1118:
        4: 1119:  if (x.reflink_mode == REFLINK_ALWAYS && x.sparse_mode != SPARSE_AUTO)
        -: 1120:    {
    #####: 1121:      error (0, 0, _("--reflink can be used only with --sparse=auto"));
    #####: 1122:      usage (EXIT_FAILURE);
        -: 1123:    }
        -: 1124:
        4: 1125:  if (backup_suffix_string)
    #####: 1126:    simple_backup_suffix = xstrdup (backup_suffix_string);
        -: 1127:
        4: 1128:  x.backup_type = (make_backups
        -: 1129:                   ? xget_version (_("backup type"),
        -: 1130:                                   version_control_string)
        -: 1131:                   : no_backups);
        -: 1132:
        4: 1133:  if (x.dereference == DEREF_UNDEFINED)
        -: 1134:    {
        4: 1135:      if (x.recursive)
        -: 1136:        /* This is compatible with FreeBSD.  */
    #####: 1137:        x.dereference = DEREF_NEVER;
        -: 1138:      else
        4: 1139:        x.dereference = DEREF_ALWAYS;
        -: 1140:    }
        -: 1141:
        4: 1142:  if (x.recursive)
    #####: 1143:    x.copy_as_regular = copy_contents;
        -: 1144:
        -: 1145:  /* If --force (-f) was specified and we're in link-creation mode,
        -: 1146:     first remove any existing destination file.  */
        4: 1147:  if (x.unlink_dest_after_failed_open && (x.hard_link || x.symbolic_link))
    #####: 1148:    x.unlink_dest_before_opening = true;
        -: 1149:
        4: 1150:  if (x.preserve_security_context)
        -: 1151:    {
    #####: 1152:      if (!selinux_enabled)
    #####: 1153:        error (EXIT_FAILURE, 0,
        -: 1154:               _("cannot preserve security context "
        -: 1155:                 "without an SELinux-enabled kernel"));
        -: 1156:    }
        -: 1157:
        -: 1158:#if !USE_XATTR
        4: 1159:  if (x.require_preserve_xattr)
    #####: 1160:    error (EXIT_FAILURE, 0, _("cannot preserve extended attributes, cp is "
        -: 1161:                              "built without xattr support"));
        -: 1162:#endif
        -: 1163:
        -: 1164:  /* Allocate space for remembering copied and created files.  */
        -: 1165:
        4: 1166:  hash_init ();
        -: 1167:
        4: 1168:  ok = do_copy (argc - optind, argv + optind,
        -: 1169:                target_directory, no_target_directory, &x);
        -: 1170:
        4: 1171:  forget_all ();
        -: 1172:
        4: 1173:  exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);
        -: 1174:}
