        -:    0:Source:sort.c
        -:    0:Graph:sort.gcno
        -:    0:Data:sort.gcda
        -:    0:Runs:12
        -:    0:Programs:1
        -:    1:/* sort - sort lines of text (with all kinds of options).
        -:    2:   Copyright (C) 1988, 1991-2007 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   16:
        -:   17:   Written December 1988 by Mike Haertel.
        -:   18:   The author may be reached (Email) at the address mike@gnu.ai.mit.edu,
        -:   19:   or (US mail) as Mike Haertel c/o Free Software Foundation.
        -:   20:
        -:   21:   Ã˜rn E. Hansen added NLS support in 1997.  */
        -:   22:
        -:   23:#include <config.h>
        -:   24:
        -:   25:#include <getopt.h>
        -:   26:#include <sys/types.h>
        -:   27:#include <sys/wait.h>
        -:   28:#include <signal.h>
        -:   29:#include "system.h"
        -:   30:#include "argmatch.h"
        -:   31:#include "error.h"
        -:   32:#include "hard-locale.h"
        -:   33:#include "hash.h"
        -:   34:#include "inttostr.h"
        -:   35:#include "md5.h"
        -:   36:#include "physmem.h"
        -:   37:#include "posixver.h"
        -:   38:#include "quote.h"
        -:   39:#include "randread.h"
        -:   40:#include "stdio--.h"
        -:   41:#include "stdlib--.h"
        -:   42:#include "strnumcmp.h"
        -:   43:#include "xmemcoll.h"
        -:   44:#include "xmemxfrm.h"
        -:   45:#include "xstrtol.h"
        -:   46:
        -:   47:#if HAVE_SYS_RESOURCE_H
        -:   48:# include <sys/resource.h>
        -:   49:#endif
        -:   50:#ifndef RLIMIT_DATA
        -:   51:struct rlimit { size_t rlim_cur; };
        -:   52:# define getrlimit(Resource, Rlp) (-1)
        -:   53:#endif
        -:   54:
        -:   55:/* The official name of this program (e.g., no `g' prefix).  */
        -:   56:#define PROGRAM_NAME "sort"
        -:   57:
        -:   58:#define AUTHORS "Mike Haertel", "Paul Eggert"
        -:   59:
        -:   60:#if HAVE_LANGINFO_CODESET
        -:   61:# include <langinfo.h>
        -:   62:#endif
        -:   63:
        -:   64:/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
        -:   65:   present.  */
        -:   66:#ifndef SA_NOCLDSTOP
        -:   67:# define SA_NOCLDSTOP 0
        -:   68:/* No sigprocmask.  Always 'return' zero. */
        -:   69:# define sigprocmask(How, Set, Oset) (0)
        -:   70:# define sigset_t int
        -:   71:# if ! HAVE_SIGINTERRUPT
        -:   72:#  define siginterrupt(sig, flag) /* empty */
        -:   73:# endif
        -:   74:#endif
        -:   75:
        -:   76:#ifndef STDC_HEADERS
        -:   77:double strtod ();
        -:   78:#endif
        -:   79:
        -:   80:#define UCHAR_LIM (UCHAR_MAX + 1)
        -:   81:
        -:   82:#ifndef DEFAULT_TMPDIR
        -:   83:# define DEFAULT_TMPDIR "/tmp"
        -:   84:#endif
        -:   85:
        -:   86:/* Exit statuses.  */
        -:   87:enum
        -:   88:  {
        -:   89:    /* POSIX says to exit with status 1 if invoked with -c and the
        -:   90:       input is not properly sorted.  */
        -:   91:    SORT_OUT_OF_ORDER = 1,
        -:   92:
        -:   93:    /* POSIX says any other irregular exit must exit with a status
        -:   94:       code greater than 1.  */
        -:   95:    SORT_FAILURE = 2
        -:   96:  };
        -:   97:
        -:   98:enum
        -:   99:  {
        -:  100:    /* The number of times we should try to fork a compression process
        -:  101:       (we retry if the fork call fails).  We don't _need_ to compress
        -:  102:       temp files, this is just to reduce disk access, so this number
        -:  103:       can be small.  */
        -:  104:    MAX_FORK_TRIES_COMPRESS = 2,
        -:  105:
        -:  106:    /* The number of times we should try to fork a decompression process.
        -:  107:       If we can't fork a decompression process, we can't sort, so this
        -:  108:       number should be big.  */
        -:  109:    MAX_FORK_TRIES_DECOMPRESS = 8
        -:  110:  };
        -:  111:
        -:  112:/* The representation of the decimal point in the current locale.  */
        -:  113:static int decimal_point;
        -:  114:
        -:  115:/* Thousands separator; if -1, then there isn't one.  */
        -:  116:static int thousands_sep;
        -:  117:
        -:  118:/* Nonzero if the corresponding locales are hard.  */
        -:  119:static bool hard_LC_COLLATE;
        -:  120:#if HAVE_NL_LANGINFO
        -:  121:static bool hard_LC_TIME;
        -:  122:#endif
        -:  123:
        -:  124:#define NONZERO(x) ((x) != 0)
        -:  125:
        -:  126:/* The kind of blanks for '-b' to skip in various options. */
        -:  127:enum blanktype { bl_start, bl_end, bl_both };
        -:  128:
        -:  129:/* The character marking end of line. Default to \n. */
        -:  130:static char eolchar = '\n';
        -:  131:
        -:  132:/* Lines are held in core as counted strings. */
        -:  133:struct line
        -:  134:{
        -:  135:  char *text;			/* Text of the line. */
        -:  136:  size_t length;		/* Length including final newline. */
        -:  137:  char *keybeg;			/* Start of first key. */
        -:  138:  char *keylim;			/* Limit of first key. */
        -:  139:};
        -:  140:
        -:  141:/* Input buffers. */
        -:  142:struct buffer
        -:  143:{
        -:  144:  char *buf;			/* Dynamically allocated buffer,
        -:  145:				   partitioned into 3 regions:
        -:  146:				   - input data;
        -:  147:				   - unused area;
        -:  148:				   - an array of lines, in reverse order.  */
        -:  149:  size_t used;			/* Number of bytes used for input data.  */
        -:  150:  size_t nlines;		/* Number of lines in the line array.  */
        -:  151:  size_t alloc;			/* Number of bytes allocated. */
        -:  152:  size_t left;			/* Number of bytes left from previous reads. */
        -:  153:  size_t line_bytes;		/* Number of bytes to reserve for each line. */
        -:  154:  bool eof;			/* An EOF has been read.  */
        -:  155:};
        -:  156:
        -:  157:struct keyfield
        -:  158:{
        -:  159:  size_t sword;			/* Zero-origin 'word' to start at. */
        -:  160:  size_t schar;			/* Additional characters to skip. */
        -:  161:  size_t eword;			/* Zero-origin first word after field. */
        -:  162:  size_t echar;			/* Additional characters in field. */
        -:  163:  bool const *ignore;		/* Boolean array of characters to ignore. */
        -:  164:  char const *translate;	/* Translation applied to characters. */
        -:  165:  bool skipsblanks;		/* Skip leading blanks when finding start.  */
        -:  166:  bool skipeblanks;		/* Skip leading blanks when finding end.  */
        -:  167:  bool numeric;			/* Flag for numeric comparison.  Handle
        -:  168:				   strings of digits with optional decimal
        -:  169:				   point, but no exponential notation. */
        -:  170:  bool random;			/* Sort by random hash of key.  */
        -:  171:  bool general_numeric;		/* Flag for general, numeric comparison.
        -:  172:				   Handle numbers in exponential notation. */
        -:  173:  bool month;			/* Flag for comparison by month name. */
        -:  174:  bool reverse;			/* Reverse the sense of comparison. */
        -:  175:  struct keyfield *next;	/* Next keyfield to try. */
        -:  176:};
        -:  177:
        -:  178:struct month
        -:  179:{
        -:  180:  char const *name;
        -:  181:  int val;
        -:  182:};
        -:  183:
        -:  184:/* The name this program was run with. */
        -:  185:char *program_name;
        -:  186:
        -:  187:/* FIXME: None of these tables work with multibyte character sets.
        -:  188:   Also, there are many other bugs when handling multibyte characters.
        -:  189:   One way to fix this is to rewrite `sort' to use wide characters
        -:  190:   internally, but doing this with good performance is a bit
        -:  191:   tricky.  */
        -:  192:
        -:  193:/* Table of blanks.  */
        -:  194:static bool blanks[UCHAR_LIM];
        -:  195:
        -:  196:/* Table of non-printing characters. */
        -:  197:static bool nonprinting[UCHAR_LIM];
        -:  198:
        -:  199:/* Table of non-dictionary characters (not letters, digits, or blanks). */
        -:  200:static bool nondictionary[UCHAR_LIM];
        -:  201:
        -:  202:/* Translation table folding lower case to upper.  */
        -:  203:static char fold_toupper[UCHAR_LIM];
        -:  204:
        -:  205:#define MONTHS_PER_YEAR 12
        -:  206:
        -:  207:/* Table mapping month names to integers.
        -:  208:   Alphabetic order allows binary search. */
        -:  209:static struct month monthtab[] =
        -:  210:{
        -:  211:  {"APR", 4},
        -:  212:  {"AUG", 8},
        -:  213:  {"DEC", 12},
        -:  214:  {"FEB", 2},
        -:  215:  {"JAN", 1},
        -:  216:  {"JUL", 7},
        -:  217:  {"JUN", 6},
        -:  218:  {"MAR", 3},
        -:  219:  {"MAY", 5},
        -:  220:  {"NOV", 11},
        -:  221:  {"OCT", 10},
        -:  222:  {"SEP", 9}
        -:  223:};
        -:  224:
        -:  225:/* During the merge phase, the number of files to merge at once. */
        -:  226:#define NMERGE 16
        -:  227:
        -:  228:/* Minimum size for a merge or check buffer.  */
        -:  229:#define MIN_MERGE_BUFFER_SIZE (2 + sizeof (struct line))
        -:  230:
        -:  231:/* Minimum sort size; the code might not work with smaller sizes.  */
        -:  232:#define MIN_SORT_SIZE (NMERGE * MIN_MERGE_BUFFER_SIZE)
        -:  233:
        -:  234:/* The number of bytes needed for a merge or check buffer, which can
        -:  235:   function relatively efficiently even if it holds only one line.  If
        -:  236:   a longer line is seen, this value is increased.  */
        -:  237:static size_t merge_buffer_size = MAX (MIN_MERGE_BUFFER_SIZE, 256 * 1024);
        -:  238:
        -:  239:/* The approximate maximum number of bytes of main memory to use, as
        -:  240:   specified by the user.  Zero if the user has not specified a size.  */
        -:  241:static size_t sort_size;
        -:  242:
        -:  243:/* The guessed size for non-regular files.  */
        -:  244:#define INPUT_FILE_SIZE_GUESS (1024 * 1024)
        -:  245:
        -:  246:/* Array of directory names in which any temporary files are to be created. */
        -:  247:static char const **temp_dirs;
        -:  248:
        -:  249:/* Number of temporary directory names used.  */
        -:  250:static size_t temp_dir_count;
        -:  251:
        -:  252:/* Number of allocated slots in temp_dirs.  */
        -:  253:static size_t temp_dir_alloc;
        -:  254:
        -:  255:/* Flag to reverse the order of all comparisons. */
        -:  256:static bool reverse;
        -:  257:
        -:  258:/* Flag for stable sort.  This turns off the last ditch bytewise
        -:  259:   comparison of lines, and instead leaves lines in the same order
        -:  260:   they were read if all keys compare equal.  */
        -:  261:static bool stable;
        -:  262:
        -:  263:/* If TAB has this value, blanks separate fields.  */
        -:  264:enum { TAB_DEFAULT = CHAR_MAX + 1 };
        -:  265:
        -:  266:/* Tab character separating fields.  If TAB_DEFAULT, then fields are
        -:  267:   separated by the empty string between a non-blank character and a blank
        -:  268:   character. */
        -:  269:static int tab = TAB_DEFAULT;
        -:  270:
        -:  271:/* Flag to remove consecutive duplicate lines from the output.
        -:  272:   Only the last of a sequence of equal lines will be output. */
        -:  273:static bool unique;
        -:  274:
        -:  275:/* Nonzero if any of the input files are the standard input. */
        -:  276:static bool have_read_stdin;
        -:  277:
        -:  278:/* List of key field comparisons to be tried.  */
        -:  279:static struct keyfield *keylist;
        -:  280:
        -:  281:/* Program used to (de)compress temp files.  Must accept -d.  */
        -:  282:static char const *compress_program;
        -:  283:
        -:  284:static void sortlines_temp (struct line *, size_t, struct line *);
        -:  285:
        -:  286:/* Report MESSAGE for FILE, then clean up and exit.
        -:  287:   If FILE is null, it represents standard output.  */
        -:  288:
        -:  289:static void die (char const *, char const *) ATTRIBUTE_NORETURN;
        -:  290:static void
    #####:  291:die (char const *message, char const *file)
        -:  292:{
    #####:  293:  error (0, errno, "%s: %s", message, file ? file : _("standard output"));
    #####:  294:  exit (SORT_FAILURE);
        -:  295:}
        -:  296:
        -:  297:void
    #####:  298:usage (int status)
        -:  299:{
    #####:  300:  if (status != EXIT_SUCCESS)
    #####:  301:    fprintf (stderr, _("Try `%s --help' for more information.\n"),
        -:  302:	     program_name);
        -:  303:  else
        -:  304:    {
    #####:  305:      printf (_("\
        -:  306:Usage: %s [OPTION]... [FILE]...\n\
        -:  307:"),
        -:  308:	      program_name);
    #####:  309:      fputs (_("\
        -:  310:Write sorted concatenation of all FILE(s) to standard output.\n\
        -:  311:\n\
        -:  312:"), stdout);
    #####:  313:      fputs (_("\
        -:  314:Mandatory arguments to long options are mandatory for short options too.\n\
        -:  315:"), stdout);
    #####:  316:      fputs (_("\
        -:  317:Ordering options:\n\
        -:  318:\n\
        -:  319:"), stdout);
    #####:  320:      fputs (_("\
        -:  321:  -b, --ignore-leading-blanks  ignore leading blanks\n\
        -:  322:  -d, --dictionary-order      consider only blanks and alphanumeric characters\n\
        -:  323:  -f, --ignore-case           fold lower case to upper case characters\n\
        -:  324:"), stdout);
    #####:  325:      fputs (_("\
        -:  326:  -g, --general-numeric-sort  compare according to general numerical value\n\
        -:  327:  -i, --ignore-nonprinting    consider only printable characters\n\
        -:  328:  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n\
        -:  329:  -n, --numeric-sort          compare according to string numerical value\n\
        -:  330:  -R, --random-sort           sort by random hash of keys\n\
        -:  331:      --random-source=FILE    get random bytes from FILE (default /dev/urandom)\n\
        -:  332:  -r, --reverse               reverse the result of comparisons\n\
        -:  333:\n\
        -:  334:"), stdout);
    #####:  335:      fputs (_("\
        -:  336:Other options:\n\
        -:  337:\n\
        -:  338:  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n\
        -:  339:  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\n\
        -:  340:      --compress-program=PROG  compress temporaries with PROG;\n\
        -:  341:                              decompress them with PROG -d\n\
        -:  342:  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS2 (origin 1)\n\
        -:  343:  -m, --merge               merge already sorted files; do not sort\n\
        -:  344:"), stdout);
    #####:  345:      fputs (_("\
        -:  346:  -o, --output=FILE         write result to FILE instead of standard output\n\
        -:  347:  -s, --stable              stabilize sort by disabling last-resort comparison\n\
        -:  348:  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n\
        -:  349:"), stdout);
    #####:  350:      printf (_("\
        -:  351:  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n\
        -:  352:  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n\
        -:  353:                              multiple options specify multiple directories\n\
        -:  354:  -u, --unique              with -c, check for strict ordering;\n\
        -:  355:                              without -c, output only the first of an equal run\n\
        -:  356:"), DEFAULT_TMPDIR);
    #####:  357:      fputs (_("\
        -:  358:  -z, --zero-terminated     end lines with 0 byte, not newline\n\
        -:  359:"), stdout);
    #####:  360:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####:  361:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####:  362:      fputs (_("\
        -:  363:\n\
        -:  364:POS is F[.C][OPTS], where F is the field number and C the character position\n\
        -:  365:in the field; both are origin 1.  If neither -t nor -b is in effect, characters\n\
        -:  366:in a field are counted from the beginning of the preceding whitespace.  OPTS is\n\
        -:  367:one or more single-letter ordering options, which override global ordering\n\
        -:  368:options for that key.  If no key is given, use the entire line as the key.\n\
        -:  369:\n\
        -:  370:SIZE may be followed by the following multiplicative suffixes:\n\
        -:  371:"), stdout);
    #####:  372:      fputs (_("\
        -:  373:% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n\
        -:  374:\n\
        -:  375:With no FILE, or when FILE is -, read standard input.\n\
        -:  376:\n\
        -:  377:*** WARNING ***\n\
        -:  378:The locale specified by the environment affects sort order.\n\
        -:  379:Set LC_ALL=C to get the traditional sort order that uses\n\
        -:  380:native byte values.\n\
        -:  381:"), stdout );
    #####:  382:      emit_bug_reporting_address ();
        -:  383:    }
        -:  384:
    #####:  385:  exit (status);
        -:  386:}
        -:  387:
        -:  388:/* For long options that have no equivalent short option, use a
        -:  389:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  390:enum
        -:  391:{
        -:  392:  CHECK_OPTION = CHAR_MAX + 1,
        -:  393:  COMPRESS_PROGRAM_OPTION,
        -:  394:  RANDOM_SOURCE_OPTION
        -:  395:};
        -:  396:
        -:  397:static char const short_options[] = "-bcCdfgik:mMno:rRsS:t:T:uy:z";
        -:  398:
        -:  399:static struct option const long_options[] =
        -:  400:{
        -:  401:  {"ignore-leading-blanks", no_argument, NULL, 'b'},
        -:  402:  {"check", optional_argument, NULL, CHECK_OPTION},
        -:  403:  {"compress-program", required_argument, NULL, COMPRESS_PROGRAM_OPTION},
        -:  404:  {"dictionary-order", no_argument, NULL, 'd'},
        -:  405:  {"ignore-case", no_argument, NULL, 'f'},
        -:  406:  {"general-numeric-sort", no_argument, NULL, 'g'},
        -:  407:  {"ignore-nonprinting", no_argument, NULL, 'i'},
        -:  408:  {"key", required_argument, NULL, 'k'},
        -:  409:  {"merge", no_argument, NULL, 'm'},
        -:  410:  {"month-sort", no_argument, NULL, 'M'},
        -:  411:  {"numeric-sort", no_argument, NULL, 'n'},
        -:  412:  {"random-sort", no_argument, NULL, 'R'},
        -:  413:  {"random-source", required_argument, NULL, RANDOM_SOURCE_OPTION},
        -:  414:  {"output", required_argument, NULL, 'o'},
        -:  415:  {"reverse", no_argument, NULL, 'r'},
        -:  416:  {"stable", no_argument, NULL, 's'},
        -:  417:  {"buffer-size", required_argument, NULL, 'S'},
        -:  418:  {"field-separator", required_argument, NULL, 't'},
        -:  419:  {"temporary-directory", required_argument, NULL, 'T'},
        -:  420:  {"unique", no_argument, NULL, 'u'},
        -:  421:  {"zero-terminated", no_argument, NULL, 'z'},
        -:  422:  {GETOPT_HELP_OPTION_DECL},
        -:  423:  {GETOPT_VERSION_OPTION_DECL},
        -:  424:  {NULL, 0, NULL, 0},
        -:  425:};
        -:  426:
        -:  427:static char const *const check_args[] =
        -:  428:{
        -:  429:  "quiet", "silent", "diagnose-first", NULL
        -:  430:};
        -:  431:static char const check_types[] =
        -:  432:{
        -:  433:  'C', 'C', 'c'
        -:  434:};
        -:  435:ARGMATCH_VERIFY (check_args, check_types);
        -:  436:
        -:  437:/* The set of signals that are caught.  */
        -:  438:static sigset_t caught_signals;
        -:  439:
        -:  440:/* Critical section status.  */
        -:  441:struct cs_status
        -:  442:{
        -:  443:  bool valid;
        -:  444:  sigset_t sigs;
        -:  445:};
        -:  446:
        -:  447:/* Enter a critical section.  */
        -:  448:static struct cs_status
    #####:  449:cs_enter (void)
        -:  450:{
        -:  451:  struct cs_status status;
    #####:  452:  status.valid = (sigprocmask (SIG_BLOCK, &caught_signals, &status.sigs) == 0);
    #####:  453:  return status;
        -:  454:}
        -:  455:
        -:  456:/* Leave a critical section.  */
        -:  457:static void
    #####:  458:cs_leave (struct cs_status status)
        -:  459:{
    #####:  460:  if (status.valid)
        -:  461:    {
        -:  462:      /* Ignore failure when restoring the signal mask. */
    #####:  463:      sigprocmask (SIG_SETMASK, &status.sigs, NULL);
        -:  464:    }
    #####:  465:}
        -:  466:
        -:  467:/* The list of temporary files. */
        -:  468:struct tempnode
        -:  469:{
        -:  470:  struct tempnode *volatile next;
        -:  471:  pid_t pid;     /* If compressed, the pid of compressor, else zero */
        -:  472:  char name[1];  /* Actual size is 1 + file name length.  */
        -:  473:};
        -:  474:static struct tempnode *volatile temphead;
        -:  475:static struct tempnode *volatile *temptail = &temphead;
        -:  476:
        -:  477:struct sortfile
        -:  478:{
        -:  479:  char const *name;
        -:  480:  pid_t pid;     /* If compressed, the pid of compressor, else zero */
        -:  481:};
        -:  482:
        -:  483:/* A table where we store compression process states.  We clean up all
        -:  484:   processes in a timely manner so as not to exhaust system resources,
        -:  485:   so we store the info on whether the process is still running, or has
        -:  486:   been reaped here.  */
        -:  487:static Hash_table *proctab;
        -:  488:
        -:  489:enum { INIT_PROCTAB_SIZE = 47 };
        -:  490:
        -:  491:enum procstate { ALIVE, ZOMBIE };
        -:  492:
        -:  493:/* A proctab entry.  The COUNT field is there in case we fork a new
        -:  494:   compression process that has the same PID as an old zombie process
        -:  495:   that is still in the table (because the process to decompress the
        -:  496:   temp file it was associated with hasn't started yet).  */
        -:  497:struct procnode
        -:  498:{
        -:  499:  pid_t pid;
        -:  500:  enum procstate state;
        -:  501:  size_t count;
        -:  502:};
        -:  503:
        -:  504:static size_t
    #####:  505:proctab_hasher (const void *entry, size_t tabsize)
        -:  506:{
    #####:  507:  const struct procnode *node = entry;
    #####:  508:  return node->pid % tabsize;
        -:  509:}
        -:  510:
        -:  511:static bool
    #####:  512:proctab_comparator (const void *e1, const void *e2)
        -:  513:{
    #####:  514:  const struct procnode *n1 = e1, *n2 = e2;
    #####:  515:  return n1->pid == n2->pid;
        -:  516:}
        -:  517:
        -:  518:/* The total number of forked processes (compressors and decompressors)
        -:  519:   that have not been reaped yet. */
        -:  520:static size_t nprocs;
        -:  521:
        -:  522:/* The number of child processes we'll allow before we try to reap some. */
        -:  523:enum { MAX_PROCS_BEFORE_REAP = 2 };
        -:  524:
        -:  525:/* If 0 < PID, wait for the child process with that PID to exit.
        -:  526:   If PID is -1, clean up a random child process which has finished and
        -:  527:   return the process ID of that child.  If PID is -1 and no processes
        -:  528:   have quit yet, return 0 without waiting.  */
        -:  529:
        -:  530:static pid_t
    #####:  531:reap (pid_t pid)
        -:  532:{
        -:  533:  int status;
    #####:  534:  pid_t cpid = waitpid (pid, &status, pid < 0 ? WNOHANG : 0);
        -:  535:
    #####:  536:  if (cpid < 0)
    #####:  537:    error (SORT_FAILURE, errno, _("waiting for %s [-d]"),
        -:  538:           compress_program);
    #####:  539:  else if (0 < cpid)
        -:  540:    {
    #####:  541:      if (! WIFEXITED (status) || WEXITSTATUS (status))
    #####:  542:	error (SORT_FAILURE, 0, _("%s [-d] terminated abnormally"),
        -:  543:	       compress_program);
    #####:  544:      --nprocs;
        -:  545:    }
        -:  546:
    #####:  547:  return cpid;
        -:  548:}
        -:  549:
        -:  550:/* Add the PID of a running compression process to proctab, or update
        -:  551:   the entry COUNT and STATE fields if it's already there.  This also
        -:  552:   creates the table for us the first time it's called.  */
        -:  553:
        -:  554:static void
    #####:  555:register_proc (pid_t pid)
        -:  556:{
        -:  557:  struct procnode test, *node;
        -:  558:
    #####:  559:  if (! proctab)
        -:  560:    {
    #####:  561:      proctab = hash_initialize (INIT_PROCTAB_SIZE, NULL,
        -:  562:				 proctab_hasher,
        -:  563:				 proctab_comparator,
        -:  564:				 free);
    #####:  565:      if (! proctab)
    #####:  566:	xalloc_die ();
        -:  567:    }
        -:  568:
    #####:  569:  test.pid = pid;
    #####:  570:  node = hash_lookup (proctab, &test);
    #####:  571:  if (node)
        -:  572:    {
    #####:  573:      node->state = ALIVE;
    #####:  574:      ++node->count;
        -:  575:    }
        -:  576:  else
        -:  577:    {
    #####:  578:      node = xmalloc (sizeof *node);
    #####:  579:      node->pid = pid;
    #####:  580:      node->state = ALIVE;
    #####:  581:      node->count = 1;
    #####:  582:      hash_insert (proctab, node);
        -:  583:    }
    #####:  584:}
        -:  585:
        -:  586:/* This is called when we reap a random process.  We don't know
        -:  587:   whether we have reaped a compression process or a decompression
        -:  588:   process until we look in the table.  If there's an ALIVE entry for
        -:  589:   it, then we have reaped a compression process, so change the state
        -:  590:   to ZOMBIE.  Otherwise, it's a decompression processes, so ignore it.  */
        -:  591:
        -:  592:static void
    #####:  593:update_proc (pid_t pid)
        -:  594:{
        -:  595:  struct procnode test, *node;
        -:  596:
    #####:  597:  test.pid = pid;
    #####:  598:  node = hash_lookup (proctab, &test);
    #####:  599:  if (node)
    #####:  600:    node->state = ZOMBIE;
    #####:  601:}
        -:  602:
        -:  603:/* This is for when we need to wait for a compression process to exit.
        -:  604:   If it has a ZOMBIE entry in the table then it's already dead and has
        -:  605:   been reaped.  Note that if there's an ALIVE entry for it, it still may
        -:  606:   already have died and been reaped if a second process was created with
        -:  607:   the same PID.  This is probably exceedingly rare, but to be on the safe
        -:  608:   side we will have to wait for any compression process with this PID.  */
        -:  609:
        -:  610:static void
    #####:  611:wait_proc (pid_t pid)
        -:  612:{
        -:  613:  struct procnode test, *node;
        -:  614:
    #####:  615:  test.pid = pid;
    #####:  616:  node = hash_lookup (proctab, &test);
    #####:  617:  if (node->state == ALIVE)
    #####:  618:    reap (pid);
        -:  619:
    #####:  620:  node->state = ZOMBIE;
    #####:  621:  if (! --node->count)
        -:  622:    {
    #####:  623:      hash_delete (proctab, node);
    #####:  624:      free (node);
        -:  625:    }
    #####:  626:}
        -:  627:
        -:  628:/* Keep reaping finished children as long as there are more to reap.
        -:  629:   This doesn't block waiting for any of them, it only reaps those
        -:  630:   that are already dead.  */
        -:  631:
        -:  632:static void
    #####:  633:reap_some (void)
        -:  634:{
        -:  635:  pid_t pid;
        -:  636:
    #####:  637:  while (0 < nprocs && (pid = reap (-1)))
    #####:  638:    update_proc (pid);
    #####:  639:}
        -:  640:
        -:  641:/* Clean up any remaining temporary files.  */
        -:  642:
        -:  643:static void
    #####:  644:cleanup (void)
        -:  645:{
        -:  646:  struct tempnode const *node;
        -:  647:
    #####:  648:  for (node = temphead; node; node = node->next)
    #####:  649:    unlink (node->name);
    #####:  650:  temphead = NULL;
    #####:  651:}
        -:  652:
        -:  653:/* Cleanup actions to take when exiting.  */
        -:  654:
        -:  655:static void
       12:  656:exit_cleanup (void)
        -:  657:{
       12:  658:  if (temphead)
        -:  659:    {
        -:  660:      /* Clean up any remaining temporary files in a critical section so
        -:  661:	 that a signal handler does not try to clean them too.  */
    #####:  662:      struct cs_status cs = cs_enter ();
    #####:  663:      cleanup ();
    #####:  664:      cs_leave (cs);
        -:  665:    }
        -:  666:
       12:  667:  close_stdout ();
       12:  668:}
        -:  669:
        -:  670:/* Create a new temporary file, returning its newly allocated tempnode.
        -:  671:   Store into *PFD the file descriptor open for writing.  */
        -:  672:
        -:  673:static struct tempnode *
    #####:  674:create_temp_file (int *pfd)
        -:  675:{
        -:  676:  static char const slashbase[] = "/sortXXXXXX";
        -:  677:  static size_t temp_dir_index;
        -:  678:  int fd;
        -:  679:  int saved_errno;
    #####:  680:  char const *temp_dir = temp_dirs[temp_dir_index];
    #####:  681:  size_t len = strlen (temp_dir);
    #####:  682:  struct tempnode *node =
    #####:  683:    xmalloc (offsetof (struct tempnode, name) + len + sizeof slashbase);
    #####:  684:  char *file = node->name;
        -:  685:  struct cs_status cs;
        -:  686:
    #####:  687:  memcpy (file, temp_dir, len);
    #####:  688:  memcpy (file + len, slashbase, sizeof slashbase);
    #####:  689:  node->next = NULL;
    #####:  690:  node->pid = 0;
    #####:  691:  if (++temp_dir_index == temp_dir_count)
    #####:  692:    temp_dir_index = 0;
        -:  693:
        -:  694:  /* Create the temporary file in a critical section, to avoid races.  */
    #####:  695:  cs = cs_enter ();
    #####:  696:  fd = mkstemp (file);
    #####:  697:  if (0 <= fd)
        -:  698:    {
    #####:  699:      *temptail = node;
    #####:  700:      temptail = &node->next;
        -:  701:    }
    #####:  702:  saved_errno = errno;
    #####:  703:  cs_leave (cs);
    #####:  704:  errno = saved_errno;
        -:  705:
    #####:  706:  if (fd < 0)
    #####:  707:    die (_("cannot create temporary file"), file);
        -:  708:
    #####:  709:  *pfd = fd;
    #####:  710:  return node;
        -:  711:}
        -:  712:
        -:  713:/* Return a stream for FILE, opened with mode HOW.  A null FILE means
        -:  714:   standard output; HOW should be "w".  When opening for input, "-"
        -:  715:   means standard input.  To avoid confusion, do not return file
        -:  716:   descriptors STDIN_FILENO, STDOUT_FILENO, or STDERR_FILENO when
        -:  717:   opening an ordinary FILE.  */
        -:  718:
        -:  719:static FILE *
       24:  720:xfopen (const char *file, const char *how)
        -:  721:{
        -:  722:  FILE *fp;
        -:  723:
       24:  724:  if (!file)
       12:  725:    fp = stdout;
       12:  726:  else if (STREQ (file, "-") && *how == 'r')
        -:  727:    {
       12:  728:      have_read_stdin = true;
       12:  729:      fp = stdin;
        -:  730:    }
        -:  731:  else
        -:  732:    {
    #####:  733:      fp = fopen (file, how);
    #####:  734:      if (! fp)
    #####:  735:	die (_("open failed"), file);
        -:  736:    }
        -:  737:
       24:  738:  return fp;
        -:  739:}
        -:  740:
        -:  741:/* Close FP, whose name is FILE, and report any errors.  */
        -:  742:
        -:  743:static void
       24:  744:xfclose (FILE *fp, char const *file)
        -:  745:{
       24:  746:  switch (fileno (fp))
        -:  747:    {
        -:  748:    case STDIN_FILENO:
        -:  749:      /* Allow reading stdin from tty more than once.  */
       12:  750:      if (feof (fp))
       12:  751:	clearerr (fp);
       12:  752:      break;
        -:  753:
        -:  754:    case STDOUT_FILENO:
        -:  755:      /* Don't close stdout just yet.  close_stdout does that.  */
       12:  756:      if (fflush (fp) != 0)
    #####:  757:	die (_("fflush failed"), file);
       12:  758:      break;
        -:  759:
        -:  760:    default:
    #####:  761:      if (fclose (fp) != 0)
    #####:  762:	die (_("close failed"), file);
    #####:  763:      break;
        -:  764:    }
       24:  765:}
        -:  766:
        -:  767:static void
    #####:  768:dup2_or_die (int oldfd, int newfd)
        -:  769:{
    #####:  770:  if (dup2 (oldfd, newfd) < 0)
    #####:  771:    error (SORT_FAILURE, errno, _("dup2 failed"));
    #####:  772:}
        -:  773:
        -:  774:/* Fork a child process for piping to and do common cleanup.  The
        -:  775:   TRIES parameter tells us how many times to try to fork before
        -:  776:   giving up.  Return the PID of the child or -1 if fork failed.  */
        -:  777:
        -:  778:static pid_t
    #####:  779:pipe_fork (int pipefds[2], size_t tries)
        -:  780:{
        -:  781:#if HAVE_WORKING_FORK
        -:  782:  struct tempnode *saved_temphead;
        -:  783:  int saved_errno;
    #####:  784:  unsigned int wait_retry = 1;
        -:  785:  pid_t pid IF_LINT (= -1);
        -:  786:  struct cs_status cs;
        -:  787:
    #####:  788:  if (pipe (pipefds) < 0)
    #####:  789:    return -1;
        -:  790:
    #####:  791:  while (tries--)
        -:  792:    {
        -:  793:      /* This is so the child process won't delete our temp files
        -:  794:	 if it receives a signal before exec-ing.  */
    #####:  795:      cs = cs_enter ();
    #####:  796:      saved_temphead = temphead;
    #####:  797:      temphead = NULL;
        -:  798:
    #####:  799:      pid = fork ();
    #####:  800:      saved_errno = errno;
    #####:  801:      if (pid)
    #####:  802:	temphead = saved_temphead;
        -:  803:
    #####:  804:      cs_leave (cs);
    #####:  805:      errno = saved_errno;
        -:  806:
    #####:  807:      if (0 <= pid || errno != EAGAIN)
        -:  808:	break;
        -:  809:      else
        -:  810:	{
    #####:  811:	  sleep (wait_retry);
    #####:  812:	  wait_retry *= 2;
    #####:  813:	  reap_some ();
        -:  814:	}
        -:  815:    }
        -:  816:
    #####:  817:  if (pid < 0)
        -:  818:    {
    #####:  819:      close (pipefds[0]);
    #####:  820:      close (pipefds[1]);
        -:  821:    }
    #####:  822:  else if (pid == 0)
        -:  823:    {
    #####:  824:      close (STDIN_FILENO);
    #####:  825:      close (STDOUT_FILENO);
        -:  826:    }
        -:  827:  else
    #####:  828:    ++nprocs;
        -:  829:
    #####:  830:  return pid;
        -:  831:
        -:  832:#else  /* ! HAVE_WORKING_FORK */
        -:  833:  return -1;
        -:  834:#endif
        -:  835:}
        -:  836:
        -:  837:/* Create a temporary file and start a compression program to filter output
        -:  838:   to that file.  Set *PFP to the file handle and if *PPID is non-NULL,
        -:  839:   set it to the PID of the newly-created process.  */
        -:  840:
        -:  841:static char *
    #####:  842:create_temp (FILE **pfp, pid_t *ppid)
        -:  843:{
        -:  844:  int tempfd;
    #####:  845:  struct tempnode *node = create_temp_file (&tempfd);
    #####:  846:  char *name = node->name;
        -:  847:
    #####:  848:  if (compress_program)
        -:  849:    {
        -:  850:      int pipefds[2];
        -:  851:
    #####:  852:      node->pid = pipe_fork (pipefds, MAX_FORK_TRIES_COMPRESS);
    #####:  853:      if (0 < node->pid)
        -:  854:	{
    #####:  855:	  close (tempfd);
    #####:  856:	  close (pipefds[0]);
    #####:  857:	  tempfd = pipefds[1];
        -:  858:
    #####:  859:	  register_proc (node->pid);
        -:  860:	}
    #####:  861:      else if (node->pid == 0)
        -:  862:	{
    #####:  863:	  close (pipefds[1]);
    #####:  864:	  dup2_or_die (tempfd, STDOUT_FILENO);
    #####:  865:	  close (tempfd);
    #####:  866:	  dup2_or_die (pipefds[0], STDIN_FILENO);
    #####:  867:	  close (pipefds[0]);
        -:  868:
    #####:  869:	  if (execlp (compress_program, compress_program, (char *) NULL) < 0)
    #####:  870:	    error (SORT_FAILURE, errno, _("couldn't execute %s"),
        -:  871:		   compress_program);
        -:  872:	}
        -:  873:      else
    #####:  874:	node->pid = 0;
        -:  875:    }
        -:  876:
    #####:  877:  *pfp = fdopen (tempfd, "w");
    #####:  878:  if (! *pfp)
    #####:  879:    die (_("couldn't create temporary file"), name);
        -:  880:
    #####:  881:  if (ppid)
    #####:  882:    *ppid = node->pid;
        -:  883:
    #####:  884:  return name;
        -:  885:}
        -:  886:
        -:  887:/* Open a compressed temp file and start a decompression process through
        -:  888:   which to filter the input.  PID must be the valid processes ID of the
        -:  889:   process used to compress the file.  */
        -:  890:
        -:  891:static FILE *
    #####:  892:open_temp (const char *name, pid_t pid)
        -:  893:{
        -:  894:  int tempfd, pipefds[2];
        -:  895:  pid_t child_pid;
        -:  896:  FILE *fp;
        -:  897:
    #####:  898:  wait_proc (pid);
        -:  899:
    #####:  900:  tempfd = open (name, O_RDONLY);
    #####:  901:  if (tempfd < 0)
    #####:  902:    die (_("couldn't open temporary file"), name);
        -:  903:
    #####:  904:  child_pid = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);
    #####:  905:  if (0 < child_pid)
        -:  906:    {
    #####:  907:      close (tempfd);
    #####:  908:      close (pipefds[1]);
        -:  909:    }
    #####:  910:  else if (child_pid == 0)
        -:  911:    {
    #####:  912:      close (pipefds[0]);
    #####:  913:      dup2_or_die (tempfd, STDIN_FILENO);
    #####:  914:      close (tempfd);
    #####:  915:      dup2_or_die (pipefds[1], STDOUT_FILENO);
    #####:  916:      close (pipefds[1]);
        -:  917:
    #####:  918:      if (execlp (compress_program, compress_program, "-d", (char *) NULL) < 0)
    #####:  919:	error (SORT_FAILURE, errno, _("couldn't execute %s -d"),
        -:  920:	       compress_program);
        -:  921:    }
        -:  922:  else
    #####:  923:    error (SORT_FAILURE, errno, _("couldn't create process for %s -d"),
        -:  924:	   compress_program);
        -:  925:
    #####:  926:  fp = fdopen (pipefds[0], "r");
    #####:  927:  if (! fp)
    #####:  928:    die (_("couldn't create temporary file"), name);
        -:  929:
    #####:  930:  return fp;
        -:  931:}
        -:  932:
        -:  933:static void
      874:  934:write_bytes (const char *buf, size_t n_bytes, FILE *fp, const char *output_file)
        -:  935:{
      874:  936:  if (fwrite (buf, 1, n_bytes, fp) != n_bytes)
    #####:  937:    die (_("write failed"), output_file);
      874:  938:}
        -:  939:
        -:  940:/* Append DIR to the array of temporary directory names.  */
        -:  941:static void
       12:  942:add_temp_dir (char const *dir)
        -:  943:{
       12:  944:  if (temp_dir_count == temp_dir_alloc)
       12:  945:    temp_dirs = X2NREALLOC (temp_dirs, &temp_dir_alloc);
        -:  946:
       12:  947:  temp_dirs[temp_dir_count++] = dir;
       12:  948:}
        -:  949:
        -:  950:/* Remove NAME from the list of temporary files.  */
        -:  951:
        -:  952:static void
    #####:  953:zaptemp (const char *name)
        -:  954:{
        -:  955:  struct tempnode *volatile *pnode;
        -:  956:  struct tempnode *node;
        -:  957:  struct tempnode *next;
        -:  958:  int unlink_status;
    #####:  959:  int unlink_errno = 0;
        -:  960:  struct cs_status cs;
        -:  961:
    #####:  962:  for (pnode = &temphead; (node = *pnode)->name != name; pnode = &node->next)
    #####:  963:    continue;
        -:  964:
        -:  965:  /* Unlink the temporary file in a critical section to avoid races.  */
    #####:  966:  next = node->next;
    #####:  967:  cs = cs_enter ();
    #####:  968:  unlink_status = unlink (name);
    #####:  969:  unlink_errno = errno;
    #####:  970:  *pnode = next;
    #####:  971:  cs_leave (cs);
        -:  972:
    #####:  973:  if (unlink_status != 0)
    #####:  974:    error (0, unlink_errno, _("warning: cannot remove: %s"), name);
    #####:  975:  if (! next)
    #####:  976:    temptail = pnode;
    #####:  977:  free (node);
    #####:  978:}
        -:  979:
        -:  980:#if HAVE_NL_LANGINFO
        -:  981:
        -:  982:static int
        -:  983:struct_month_cmp (const void *m1, const void *m2)
        -:  984:{
        -:  985:  struct month const *month1 = m1;
        -:  986:  struct month const *month2 = m2;
        -:  987:  return strcmp (month1->name, month2->name);
        -:  988:}
        -:  989:
        -:  990:#endif
        -:  991:
        -:  992:/* Initialize the character class tables. */
        -:  993:
        -:  994:static void
       12:  995:inittables (void)
        -:  996:{
        -:  997:  size_t i;
        -:  998:
     3084:  999:  for (i = 0; i < UCHAR_LIM; ++i)
        -: 1000:    {
     3072: 1001:      blanks[i] = !! isblank (i);
     3072: 1002:      nonprinting[i] = ! isprint (i);
     3072: 1003:      nondictionary[i] = ! isalnum (i) && ! isblank (i);
     3072: 1004:      fold_toupper[i] = toupper (i);
        -: 1005:    }
        -: 1006:
        -: 1007:#if HAVE_NL_LANGINFO
        -: 1008:  /* If we're not in the "C" locale, read different names for months.  */
        -: 1009:  if (hard_LC_TIME)
        -: 1010:    {
        -: 1011:      for (i = 0; i < MONTHS_PER_YEAR; i++)
        -: 1012:	{
        -: 1013:	  char const *s;
        -: 1014:	  size_t s_len;
        -: 1015:	  size_t j;
        -: 1016:	  char *name;
        -: 1017:
        -: 1018:	  s = (char *) nl_langinfo (ABMON_1 + i);
        -: 1019:	  s_len = strlen (s);
        -: 1020:	  monthtab[i].name = name = xmalloc (s_len + 1);
        -: 1021:	  monthtab[i].val = i + 1;
        -: 1022:
        -: 1023:	  for (j = 0; j < s_len; j++)
        -: 1024:	    name[j] = fold_toupper[to_uchar (s[j])];
        -: 1025:	  name[j] = '\0';
        -: 1026:	}
        -: 1027:      qsort ((void *) monthtab, MONTHS_PER_YEAR,
        -: 1028:	     sizeof *monthtab, struct_month_cmp);
        -: 1029:    }
        -: 1030:#endif
       12: 1031:}
        -: 1032:
        -: 1033:/* Specify the amount of main memory to use when sorting.  */
        -: 1034:static void
    #####: 1035:specify_sort_size (int oi, char c, char const *s)
        -: 1036:{
        -: 1037:  uintmax_t n;
        -: 1038:  char *suffix;
    #####: 1039:  enum strtol_error e = xstrtoumax (s, &suffix, 10, &n, "EgGkKmMPtTYZ");
        -: 1040:
        -: 1041:  /* The default unit is KiB.  */
    #####: 1042:  if (e == LONGINT_OK && ISDIGIT (suffix[-1]))
        -: 1043:    {
    #####: 1044:      if (n <= UINTMAX_MAX / 1024)
    #####: 1045:	n *= 1024;
        -: 1046:      else
    #####: 1047:	e = LONGINT_OVERFLOW;
        -: 1048:    }
        -: 1049:
        -: 1050:  /* A 'b' suffix means bytes; a '%' suffix means percent of memory.  */
    #####: 1051:  if (e == LONGINT_INVALID_SUFFIX_CHAR && ISDIGIT (suffix[-1]) && ! suffix[1])
    #####: 1052:    switch (suffix[0])
        -: 1053:      {
        -: 1054:      case 'b':
    #####: 1055:	e = LONGINT_OK;
    #####: 1056:	break;
        -: 1057:
        -: 1058:      case '%':
        -: 1059:	{
    #####: 1060:	  double mem = physmem_total () * n / 100;
        -: 1061:
        -: 1062:	  /* Use "<", not "<=", to avoid problems with rounding.  */
    #####: 1063:	  if (mem < UINTMAX_MAX)
        -: 1064:	    {
    #####: 1065:	      n = mem;
    #####: 1066:	      e = LONGINT_OK;
        -: 1067:	    }
        -: 1068:	  else
    #####: 1069:	    e = LONGINT_OVERFLOW;
        -: 1070:	}
    #####: 1071:	break;
        -: 1072:      }
        -: 1073:
    #####: 1074:  if (e == LONGINT_OK)
        -: 1075:    {
        -: 1076:      /* If multiple sort sizes are specified, take the maximum, so
        -: 1077:	 that option order does not matter.  */
    #####: 1078:      if (n < sort_size)
    #####: 1079:	return;
        -: 1080:
    #####: 1081:      sort_size = n;
    #####: 1082:      if (sort_size == n)
        -: 1083:	{
    #####: 1084:	  sort_size = MAX (sort_size, MIN_SORT_SIZE);
    #####: 1085:	  return;
        -: 1086:	}
        -: 1087:
    #####: 1088:      e = LONGINT_OVERFLOW;
        -: 1089:    }
        -: 1090:
    #####: 1091:  xstrtol_fatal (e, oi, c, long_options, s);
        -: 1092:}
        -: 1093:
        -: 1094:/* Return the default sort size.  */
        -: 1095:static size_t
       12: 1096:default_sort_size (void)
        -: 1097:{
        -: 1098:  /* Let MEM be available memory or 1/8 of total memory, whichever
        -: 1099:     is greater.  */
       12: 1100:  double avail = physmem_available ();
       12: 1101:  double total = physmem_total ();
       12: 1102:  double mem = MAX (avail, total / 8);
        -: 1103:  struct rlimit rlimit;
        -: 1104:
        -: 1105:  /* Let SIZE be MEM, but no more than the maximum object size or
        -: 1106:     system resource limits.  Avoid the MIN macro here, as it is not
        -: 1107:     quite right when only one argument is floating point.  Don't
        -: 1108:     bother to check for values like RLIM_INFINITY since in practice
        -: 1109:     they are not much less than SIZE_MAX.  */
       12: 1110:  size_t size = SIZE_MAX;
       12: 1111:  if (mem < size)
       12: 1112:    size = mem;
       12: 1113:  if (getrlimit (RLIMIT_DATA, &rlimit) == 0 && rlimit.rlim_cur < size)
    #####: 1114:    size = rlimit.rlim_cur;
        -: 1115:#ifdef RLIMIT_AS
       12: 1116:  if (getrlimit (RLIMIT_AS, &rlimit) == 0 && rlimit.rlim_cur < size)
    #####: 1117:    size = rlimit.rlim_cur;
        -: 1118:#endif
        -: 1119:
        -: 1120:  /* Leave a large safety margin for the above limits, as failure can
        -: 1121:     occur when they are exceeded.  */
       12: 1122:  size /= 2;
        -: 1123:
        -: 1124:#ifdef RLIMIT_RSS
        -: 1125:  /* Leave a 1/16 margin for RSS to leave room for code, stack, etc.
        -: 1126:     Exceeding RSS is not fatal, but can be quite slow.  */
       12: 1127:  if (getrlimit (RLIMIT_RSS, &rlimit) == 0 && rlimit.rlim_cur / 16 * 15 < size)
    #####: 1128:    size = rlimit.rlim_cur / 16 * 15;
        -: 1129:#endif
        -: 1130:
        -: 1131:  /* Use no less than the minimum.  */
       12: 1132:  return MAX (size, MIN_SORT_SIZE);
        -: 1133:}
        -: 1134:
        -: 1135:/* Return the sort buffer size to use with the input files identified
        -: 1136:   by FPS and FILES, which are alternate names of the same files.
        -: 1137:   NFILES gives the number of input files; NFPS may be less.  Assume
        -: 1138:   that each input line requires LINE_BYTES extra bytes' worth of line
        -: 1139:   information.  Do not exceed the size bound specified by the user
        -: 1140:   (or a default size bound, if the user does not specify one).  */
        -: 1141:
        -: 1142:static size_t
       12: 1143:sort_buffer_size (FILE *const *fps, size_t nfps,
        -: 1144:		  char *const *files, size_t nfiles,
        -: 1145:		  size_t line_bytes)
        -: 1146:{
        -: 1147:  /* A bound on the input size.  If zero, the bound hasn't been
        -: 1148:     determined yet.  */
        -: 1149:  static size_t size_bound;
        -: 1150:
        -: 1151:  /* In the worst case, each input byte is a newline.  */
       12: 1152:  size_t worst_case_per_input_byte = line_bytes + 1;
        -: 1153:
        -: 1154:  /* Keep enough room for one extra input line and an extra byte.
        -: 1155:     This extra room might be needed when preparing to read EOF.  */
       12: 1156:  size_t size = worst_case_per_input_byte + 1;
        -: 1157:
        -: 1158:  size_t i;
        -: 1159:
       48: 1160:  for (i = 0; i < nfiles; i++)
        -: 1161:    {
        -: 1162:      struct stat st;
        -: 1163:      off_t file_size;
        -: 1164:      size_t worst_case;
        -: 1165:
       24: 1166:      if ((i < nfps ? fstat (fileno (fps[i]), &st)
    #####: 1167:	   : STREQ (files[i], "-") ? fstat (STDIN_FILENO, &st)
    #####: 1168:	   : stat (files[i], &st))
       24: 1169:	  != 0)
    #####: 1170:	die (_("stat failed"), files[i]);
        -: 1171:
       12: 1172:      if (S_ISREG (st.st_mode))
    #####: 1173:	file_size = st.st_size;
        -: 1174:      else
        -: 1175:	{
        -: 1176:	  /* The file has unknown size.  If the user specified a sort
        -: 1177:	     buffer size, use that; otherwise, guess the size.  */
       12: 1178:	  if (sort_size)
    #####: 1179:	    return sort_size;
       12: 1180:	  file_size = INPUT_FILE_SIZE_GUESS;
        -: 1181:	}
        -: 1182:
       12: 1183:      if (! size_bound)
        -: 1184:	{
       12: 1185:	  size_bound = sort_size;
       12: 1186:	  if (! size_bound)
       12: 1187:	    size_bound = default_sort_size ();
        -: 1188:	}
        -: 1189:
        -: 1190:      /* Add the amount of memory needed to represent the worst case
        -: 1191:	 where the input consists entirely of newlines followed by a
        -: 1192:	 single non-newline.  Check for overflow.  */
       12: 1193:      worst_case = file_size * worst_case_per_input_byte + 1;
       12: 1194:      if (file_size != worst_case / worst_case_per_input_byte
       12: 1195:	  || size_bound - size <= worst_case)
    #####: 1196:	return size_bound;
       12: 1197:      size += worst_case;
        -: 1198:    }
        -: 1199:
       12: 1200:  return size;
        -: 1201:}
        -: 1202:
        -: 1203:/* Initialize BUF.  Reserve LINE_BYTES bytes for each line; LINE_BYTES
        -: 1204:   must be at least sizeof (struct line).  Allocate ALLOC bytes
        -: 1205:   initially.  */
        -: 1206:
        -: 1207:static void
       12: 1208:initbuf (struct buffer *buf, size_t line_bytes, size_t alloc)
        -: 1209:{
        -: 1210:  /* Ensure that the line array is properly aligned.  If the desired
        -: 1211:     size cannot be allocated, repeatedly halve it until allocation
        -: 1212:     succeeds.  The smaller allocation may hurt overall performance,
        -: 1213:     but that's better than failing.  */
        -: 1214:  for (;;)
        -: 1215:    {
       12: 1216:      alloc += sizeof (struct line) - alloc % sizeof (struct line);
       12: 1217:      buf->buf = malloc (alloc);
       12: 1218:      if (buf->buf)
       12: 1219:	break;
    #####: 1220:      alloc /= 2;
    #####: 1221:      if (alloc <= line_bytes + 1)
    #####: 1222:	xalloc_die ();
    #####: 1223:    }
        -: 1224:
       12: 1225:  buf->line_bytes = line_bytes;
       12: 1226:  buf->alloc = alloc;
       12: 1227:  buf->used = buf->left = buf->nlines = 0;
       12: 1228:  buf->eof = false;
       12: 1229:}
        -: 1230:
        -: 1231:/* Return one past the limit of the line array.  */
        -: 1232:
        -: 1233:static inline struct line *
       32: 1234:buffer_linelim (struct buffer const *buf)
        -: 1235:{
       32: 1236:  return (struct line *) (buf->buf + buf->alloc);
        -: 1237:}
        -: 1238:
        -: 1239:/* Return a pointer to the first character of the field specified
        -: 1240:   by KEY in LINE. */
        -: 1241:
        -: 1242:static char *
    #####: 1243:begfield (const struct line *line, const struct keyfield *key)
        -: 1244:{
    #####: 1245:  char *ptr = line->text, *lim = ptr + line->length - 1;
    #####: 1246:  size_t sword = key->sword;
    #####: 1247:  size_t schar = key->schar;
        -: 1248:  size_t remaining_bytes;
        -: 1249:
        -: 1250:  /* The leading field separator itself is included in a field when -t
        -: 1251:     is absent.  */
        -: 1252:
    #####: 1253:  if (tab != TAB_DEFAULT)
    #####: 1254:    while (ptr < lim && sword--)
        -: 1255:      {
    #####: 1256:	while (ptr < lim && *ptr != tab)
    #####: 1257:	  ++ptr;
    #####: 1258:	if (ptr < lim)
    #####: 1259:	  ++ptr;
        -: 1260:      }
        -: 1261:  else
    #####: 1262:    while (ptr < lim && sword--)
        -: 1263:      {
    #####: 1264:	while (ptr < lim && blanks[to_uchar (*ptr)])
    #####: 1265:	  ++ptr;
    #####: 1266:	while (ptr < lim && !blanks[to_uchar (*ptr)])
    #####: 1267:	  ++ptr;
        -: 1268:      }
        -: 1269:
    #####: 1270:  if (key->skipsblanks)
    #####: 1271:    while (ptr < lim && blanks[to_uchar (*ptr)])
    #####: 1272:      ++ptr;
        -: 1273:
        -: 1274:  /* Advance PTR by SCHAR (if possible), but no further than LIM.  */
    #####: 1275:  remaining_bytes = lim - ptr;
    #####: 1276:  if (schar < remaining_bytes)
    #####: 1277:    ptr += schar;
        -: 1278:  else
    #####: 1279:    ptr = lim;
        -: 1280:
    #####: 1281:  return ptr;
        -: 1282:}
        -: 1283:
        -: 1284:/* Return the limit of (a pointer to the first character after) the field
        -: 1285:   in LINE specified by KEY. */
        -: 1286:
        -: 1287:static char *
    #####: 1288:limfield (const struct line *line, const struct keyfield *key)
        -: 1289:{
    #####: 1290:  char *ptr = line->text, *lim = ptr + line->length - 1;
    #####: 1291:  size_t eword = key->eword, echar = key->echar;
        -: 1292:  size_t remaining_bytes;
        -: 1293:
        -: 1294:  /* Move PTR past EWORD fields or to one past the last byte on LINE,
        -: 1295:     whichever comes first.  If there are more than EWORD fields, leave
        -: 1296:     PTR pointing at the beginning of the field having zero-based index,
        -: 1297:     EWORD.  If a delimiter character was specified (via -t), then that
        -: 1298:     `beginning' is the first character following the delimiting TAB.
        -: 1299:     Otherwise, leave PTR pointing at the first `blank' character after
        -: 1300:     the preceding field.  */
    #####: 1301:  if (tab != TAB_DEFAULT)
    #####: 1302:    while (ptr < lim && eword--)
        -: 1303:      {
    #####: 1304:	while (ptr < lim && *ptr != tab)
    #####: 1305:	  ++ptr;
    #####: 1306:	if (ptr < lim && (eword | echar))
    #####: 1307:	  ++ptr;
        -: 1308:      }
        -: 1309:  else
    #####: 1310:    while (ptr < lim && eword--)
        -: 1311:      {
    #####: 1312:	while (ptr < lim && blanks[to_uchar (*ptr)])
    #####: 1313:	  ++ptr;
    #####: 1314:	while (ptr < lim && !blanks[to_uchar (*ptr)])
    #####: 1315:	  ++ptr;
        -: 1316:      }
        -: 1317:
        -: 1318:#ifdef POSIX_UNSPECIFIED
        -: 1319:  /* The following block of code makes GNU sort incompatible with
        -: 1320:     standard Unix sort, so it's ifdef'd out for now.
        -: 1321:     The POSIX spec isn't clear on how to interpret this.
        -: 1322:     FIXME: request clarification.
        -: 1323:
        -: 1324:     From: kwzh@gnu.ai.mit.edu (Karl Heuer)
        -: 1325:     Date: Thu, 30 May 96 12:20:41 -0400
        -: 1326:     [Translated to POSIX 1003.1-2001 terminology by Paul Eggert.]
        -: 1327:
        -: 1328:     [...]I believe I've found another bug in `sort'.
        -: 1329:
        -: 1330:     $ cat /tmp/sort.in
        -: 1331:     a b c 2 d
        -: 1332:     pq rs 1 t
        -: 1333:     $ textutils-1.15/src/sort -k1.7,1.7 </tmp/sort.in
        -: 1334:     a b c 2 d
        -: 1335:     pq rs 1 t
        -: 1336:     $ /bin/sort -k1.7,1.7 </tmp/sort.in
        -: 1337:     pq rs 1 t
        -: 1338:     a b c 2 d
        -: 1339:
        -: 1340:     Unix sort produced the answer I expected: sort on the single character
        -: 1341:     in column 7.  GNU sort produced different results, because it disagrees
        -: 1342:     on the interpretation of the key-end spec "M.N".  Unix sort reads this
        -: 1343:     as "skip M-1 fields, then N-1 characters"; but GNU sort wants it to mean
        -: 1344:     "skip M-1 fields, then either N-1 characters or the rest of the current
        -: 1345:     field, whichever comes first".  This extra clause applies only to
        -: 1346:     key-ends, not key-starts.
        -: 1347:     */
        -: 1348:
        -: 1349:  /* Make LIM point to the end of (one byte past) the current field.  */
        -: 1350:  if (tab != TAB_DEFAULT)
        -: 1351:    {
        -: 1352:      char *newlim;
        -: 1353:      newlim = memchr (ptr, tab, lim - ptr);
        -: 1354:      if (newlim)
        -: 1355:	lim = newlim;
        -: 1356:    }
        -: 1357:  else
        -: 1358:    {
        -: 1359:      char *newlim;
        -: 1360:      newlim = ptr;
        -: 1361:      while (newlim < lim && blanks[to_uchar (*newlim)])
        -: 1362:	++newlim;
        -: 1363:      while (newlim < lim && !blanks[to_uchar (*newlim)])
        -: 1364:	++newlim;
        -: 1365:      lim = newlim;
        -: 1366:    }
        -: 1367:#endif
        -: 1368:
        -: 1369:  /* If we're ignoring leading blanks when computing the End
        -: 1370:     of the field, don't start counting bytes until after skipping
        -: 1371:     past any leading blanks. */
    #####: 1372:  if (key->skipeblanks)
    #####: 1373:    while (ptr < lim && blanks[to_uchar (*ptr)])
    #####: 1374:      ++ptr;
        -: 1375:
        -: 1376:  /* Advance PTR by ECHAR (if possible), but no further than LIM.  */
    #####: 1377:  remaining_bytes = lim - ptr;
    #####: 1378:  if (echar < remaining_bytes)
    #####: 1379:    ptr += echar;
        -: 1380:  else
    #####: 1381:    ptr = lim;
        -: 1382:
    #####: 1383:  return ptr;
        -: 1384:}
        -: 1385:
        -: 1386:/* Fill BUF reading from FP, moving buf->left bytes from the end
        -: 1387:   of buf->buf to the beginning first.  If EOF is reached and the
        -: 1388:   file wasn't terminated by a newline, supply one.  Set up BUF's line
        -: 1389:   table too.  FILE is the name of the file corresponding to FP.
        -: 1390:   Return true if some input was read.  */
        -: 1391:
        -: 1392:static bool
       12: 1393:fillbuf (struct buffer *buf, FILE *fp, char const *file)
        -: 1394:{
       12: 1395:  struct keyfield const *key = keylist;
       12: 1396:  char eol = eolchar;
       12: 1397:  size_t line_bytes = buf->line_bytes;
       12: 1398:  size_t mergesize = merge_buffer_size - MIN_MERGE_BUFFER_SIZE;
        -: 1399:
       12: 1400:  if (buf->eof)
    #####: 1401:    return false;
        -: 1402:
       12: 1403:  if (buf->used != buf->left)
        -: 1404:    {
    #####: 1405:      memmove (buf->buf, buf->buf + buf->used - buf->left, buf->left);
    #####: 1406:      buf->used = buf->left;
    #####: 1407:      buf->nlines = 0;
        -: 1408:    }
        -: 1409:
        -: 1410:  for (;;)
        -: 1411:    {
       12: 1412:      char *ptr = buf->buf + buf->used;
       12: 1413:      struct line *linelim = buffer_linelim (buf);
       12: 1414:      struct line *line = linelim - buf->nlines;
       12: 1415:      size_t avail = (char *) linelim - buf->nlines * line_bytes - ptr;
       12: 1416:      char *line_start = buf->nlines ? line->text + line->length : buf->buf;
        -: 1417:
       24: 1418:      while (line_bytes + 1 < avail)
        -: 1419:	{
        -: 1420:	  /* Read as many bytes as possible, but do not read so many
        -: 1421:	     bytes that there might not be enough room for the
        -: 1422:	     corresponding line array.  The worst case is when the
        -: 1423:	     rest of the input file consists entirely of newlines,
        -: 1424:	     except that the last byte is not a newline.  */
       12: 1425:	  size_t readsize = (avail - 1) / (line_bytes + 1);
       12: 1426:	  size_t bytes_read = fread (ptr, 1, readsize, fp);
       12: 1427:	  char *ptrlim = ptr + bytes_read;
        -: 1428:	  char *p;
       12: 1429:	  avail -= bytes_read;
        -: 1430:
       12: 1431:	  if (bytes_read != readsize)
        -: 1432:	    {
       12: 1433:	      if (ferror (fp))
    #####: 1434:		die (_("read failed"), file);
       12: 1435:	      if (feof (fp))
        -: 1436:		{
       12: 1437:		  buf->eof = true;
       12: 1438:		  if (buf->buf == ptrlim)
        2: 1439:		    return false;
       10: 1440:		  if (ptrlim[-1] != eol)
    #####: 1441:		    *ptrlim++ = eol;
        -: 1442:		}
        -: 1443:	    }
        -: 1444:
        -: 1445:	  /* Find and record each line in the just-read input.  */
     1282: 1446:	  while ((p = memchr (ptr, eol, ptrlim - ptr)))
        -: 1447:	    {
     1262: 1448:	      ptr = p + 1;
     1262: 1449:	      line--;
     1262: 1450:	      line->text = line_start;
     1262: 1451:	      line->length = ptr - line_start;
     1262: 1452:	      mergesize = MAX (mergesize, line->length);
     1262: 1453:	      avail -= line_bytes;
        -: 1454:
     1262: 1455:	      if (key)
        -: 1456:		{
        -: 1457:		  /* Precompute the position of the first key for
        -: 1458:		     efficiency.  */
    #####: 1459:		  line->keylim = (key->eword == SIZE_MAX
        -: 1460:				  ? p
    #####: 1461:				  : limfield (line, key));
        -: 1462:
    #####: 1463:		  if (key->sword != SIZE_MAX)
    #####: 1464:		    line->keybeg = begfield (line, key);
        -: 1465:		  else
        -: 1466:		    {
    #####: 1467:		      if (key->skipsblanks)
    #####: 1468:			while (blanks[to_uchar (*line_start)])
    #####: 1469:			  line_start++;
    #####: 1470:		      line->keybeg = line_start;
        -: 1471:		    }
        -: 1472:		}
        -: 1473:
     1262: 1474:	      line_start = ptr;
        -: 1475:	    }
        -: 1476:
       10: 1477:	  ptr = ptrlim;
       10: 1478:	  if (buf->eof)
       10: 1479:	    break;
        -: 1480:	}
        -: 1481:
       10: 1482:      buf->used = ptr - buf->buf;
       10: 1483:      buf->nlines = buffer_linelim (buf) - line;
       10: 1484:      if (buf->nlines != 0)
        -: 1485:	{
       10: 1486:	  buf->left = ptr - line_start;
       10: 1487:	  merge_buffer_size = mergesize + MIN_MERGE_BUFFER_SIZE;
       10: 1488:	  return true;
        -: 1489:	}
        -: 1490:
        -: 1491:      {
        -: 1492:	/* The current input line is too long to fit in the buffer.
        -: 1493:	   Double the buffer size and try again, keeping it properly
        -: 1494:	   aligned.  */
    #####: 1495:	size_t line_alloc = buf->alloc / sizeof (struct line);
    #####: 1496:	buf->buf = x2nrealloc (buf->buf, &line_alloc, sizeof (struct line));
    #####: 1497:	buf->alloc = line_alloc * sizeof (struct line);
        -: 1498:      }
    #####: 1499:    }
        -: 1500:}
        -: 1501:
        -: 1502:/* Compare strings A and B as numbers without explicitly converting them to
        -: 1503:   machine numbers.  Comparatively slow for short strings, but asymptotically
        -: 1504:   hideously fast. */
        -: 1505:
        -: 1506:static int
    #####: 1507:numcompare (const char *a, const char *b)
        -: 1508:{
    #####: 1509:  while (blanks[to_uchar (*a)])
    #####: 1510:    a++;
    #####: 1511:  while (blanks[to_uchar (*b)])
    #####: 1512:    b++;
        -: 1513:
    #####: 1514:  return strnumcmp (a, b, decimal_point, thousands_sep);
        -: 1515:}
        -: 1516:
        -: 1517:static int
    #####: 1518:general_numcompare (const char *sa, const char *sb)
        -: 1519:{
        -: 1520:  /* FIXME: add option to warn about failed conversions.  */
        -: 1521:  /* FIXME: maybe add option to try expensive FP conversion
        -: 1522:     only if A and B can't be compared more cheaply/accurately.  */
        -: 1523:
        -: 1524:  char *ea;
        -: 1525:  char *eb;
    #####: 1526:  double a = strtod (sa, &ea);
    #####: 1527:  double b = strtod (sb, &eb);
        -: 1528:
        -: 1529:  /* Put conversion errors at the start of the collating sequence.  */
    #####: 1530:  if (sa == ea)
    #####: 1531:    return sb == eb ? 0 : -1;
    #####: 1532:  if (sb == eb)
    #####: 1533:    return 1;
        -: 1534:
        -: 1535:  /* Sort numbers in the usual way, where -0 == +0.  Put NaNs after
        -: 1536:     conversion errors but before numbers; sort them by internal
        -: 1537:     bit-pattern, for lack of a more portable alternative.  */
    #####: 1538:  return (a < b ? -1
    #####: 1539:	  : a > b ? 1
    #####: 1540:	  : a == b ? 0
    #####: 1541:	  : b == b ? -1
    #####: 1542:	  : a == a ? 1
    #####: 1543:	  : memcmp ((char *) &a, (char *) &b, sizeof a));
        -: 1544:}
        -: 1545:
        -: 1546:/* Return an integer in 1..12 of the month name MONTH with length LEN.
        -: 1547:   Return 0 if the name in S is not recognized.  */
        -: 1548:
        -: 1549:static int
    #####: 1550:getmonth (char const *month, size_t len)
        -: 1551:{
    #####: 1552:  size_t lo = 0;
    #####: 1553:  size_t hi = MONTHS_PER_YEAR;
    #####: 1554:  char const *monthlim = month + len;
        -: 1555:
        -: 1556:  for (;;)
        -: 1557:    {
    #####: 1558:      if (month == monthlim)
    #####: 1559:	return 0;
    #####: 1560:      if (!blanks[to_uchar (*month)])
    #####: 1561:	break;
    #####: 1562:      ++month;
    #####: 1563:    }
        -: 1564:
        -: 1565:  do
        -: 1566:    {
    #####: 1567:      size_t ix = (lo + hi) / 2;
    #####: 1568:      char const *m = month;
    #####: 1569:      char const *n = monthtab[ix].name;
        -: 1570:
    #####: 1571:      for (;; m++, n++)
        -: 1572:	{
    #####: 1573:	  if (!*n)
    #####: 1574:	    return monthtab[ix].val;
    #####: 1575:	  if (m == monthlim || fold_toupper[to_uchar (*m)] < to_uchar (*n))
        -: 1576:	    {
    #####: 1577:	      hi = ix;
    #####: 1578:	      break;
        -: 1579:	    }
    #####: 1580:	  else if (fold_toupper[to_uchar (*m)] > to_uchar (*n))
        -: 1581:	    {
    #####: 1582:	      lo = ix + 1;
    #####: 1583:	      break;
        -: 1584:	    }
    #####: 1585:	}
        -: 1586:    }
    #####: 1587:  while (lo < hi);
        -: 1588:
    #####: 1589:  return 0;
        -: 1590:}
        -: 1591:
        -: 1592:/* A source of random data.  */
        -: 1593:static struct randread_source *randread_source;
        -: 1594:
        -: 1595:/* Return the Ith randomly-generated state.  The caller must invoke
        -: 1596:   random_state (H) for all H less than I before invoking random_state
        -: 1597:   (I).  */
        -: 1598:
        -: 1599:static struct md5_ctx
    #####: 1600:random_state (size_t i)
        -: 1601:{
        -: 1602:  /* An array of states resulting from the random data, and counts of
        -: 1603:     its used and allocated members.  */
        -: 1604:  static struct md5_ctx *state;
        -: 1605:  static size_t used;
        -: 1606:  static size_t allocated;
        -: 1607:
    #####: 1608:  struct md5_ctx *s = &state[i];
        -: 1609:
    #####: 1610:  if (used <= i)
        -: 1611:    {
        -: 1612:      unsigned char buf[MD5_DIGEST_SIZE];
        -: 1613:
    #####: 1614:      used++;
        -: 1615:
    #####: 1616:      if (allocated <= i)
        -: 1617:	{
    #####: 1618:	  state = X2NREALLOC (state, &allocated);
    #####: 1619:	  s = &state[i];
        -: 1620:	}
        -: 1621:
    #####: 1622:      randread (randread_source, buf, sizeof buf);
    #####: 1623:      md5_init_ctx (s);
    #####: 1624:      md5_process_bytes (buf, sizeof buf, s);
        -: 1625:    }
        -: 1626:
    #####: 1627:  return *s;
        -: 1628:}
        -: 1629:
        -: 1630:/* Compare the hashes of TEXTA with length LENGTHA to those of TEXTB
        -: 1631:   with length LENGTHB.  Return negative if less, zero if equal,
        -: 1632:   positive if greater.  */
        -: 1633:
        -: 1634:static int
    #####: 1635:cmp_hashes (char const *texta, size_t lena,
        -: 1636:	    char const *textb, size_t lenb)
        -: 1637:{
        -: 1638:  /* Try random hashes until a pair of hashes disagree.  But if the
        -: 1639:     first pair of random hashes agree, check whether the keys are
        -: 1640:     identical and if so report no difference.  */
        -: 1641:  int diff;
        -: 1642:  size_t i;
    #####: 1643:  for (i = 0; ; i++)
        -: 1644:    {
        -: 1645:      uint32_t dig[2][MD5_DIGEST_SIZE / sizeof (uint32_t)];
        -: 1646:      struct md5_ctx s[2];
    #####: 1647:      s[0] = s[1] = random_state (i);
    #####: 1648:      md5_process_bytes (texta, lena, &s[0]);  md5_finish_ctx (&s[0], dig[0]);
    #####: 1649:      md5_process_bytes (textb, lenb, &s[1]);  md5_finish_ctx (&s[1], dig[1]);
    #####: 1650:      diff = memcmp (dig[0], dig[1], sizeof dig[0]);
    #####: 1651:      if (diff != 0)
    #####: 1652:	break;
    #####: 1653:      if (i == 0 && lena == lenb && memcmp (texta, textb, lena) == 0)
    #####: 1654:	break;
    #####: 1655:    }
        -: 1656:
    #####: 1657:  return diff;
        -: 1658:}
        -: 1659:
        -: 1660:/* Compare the keys TEXTA (of length LENA) and TEXTB (of length LENB)
        -: 1661:   using one or more random hash functions.  */
        -: 1662:
        -: 1663:static int
    #####: 1664:compare_random (char *restrict texta, size_t lena,
        -: 1665:		char *restrict textb, size_t lenb)
        -: 1666:{
        -: 1667:  int diff;
        -: 1668:
    #####: 1669:  if (! hard_LC_COLLATE)
    #####: 1670:    diff = cmp_hashes (texta, lena, textb, lenb);
        -: 1671:  else
        -: 1672:    {
        -: 1673:      /* Transform the text into the basis of comparison, so that byte
        -: 1674:	 strings that would otherwise considered to be equal are
        -: 1675:	 considered equal here even if their bytes differ.  */
        -: 1676:
    #####: 1677:      char *buf = NULL;
        -: 1678:      char stackbuf[4000];
    #####: 1679:      size_t tlena = xmemxfrm (stackbuf, sizeof stackbuf, texta, lena);
    #####: 1680:      bool a_fits = tlena <= sizeof stackbuf;
    #####: 1681:      size_t tlenb = xmemxfrm ((a_fits ? stackbuf + tlena : NULL),
        -: 1682:			       (a_fits ? sizeof stackbuf - tlena : 0),
        -: 1683:			       textb, lenb);
        -: 1684:
    #####: 1685:      if (a_fits && tlena + tlenb <= sizeof stackbuf)
    #####: 1686:	buf = stackbuf;
        -: 1687:      else
        -: 1688:	{
        -: 1689:	  /* Adding 1 to the buffer size lets xmemxfrm run a bit
        -: 1690:	     faster by avoiding the need for an extra buffer copy.  */
    #####: 1691:	  buf = xmalloc (tlena + tlenb + 1);
    #####: 1692:	  xmemxfrm (buf, tlena + 1, texta, lena);
    #####: 1693:	  xmemxfrm (buf + tlena, tlenb + 1, textb, lenb);
        -: 1694:	}
        -: 1695:
    #####: 1696:      diff = cmp_hashes (buf, tlena, buf + tlena, tlenb);
        -: 1697:
    #####: 1698:      if (buf != stackbuf)
    #####: 1699:	free (buf);
        -: 1700:    }
        -: 1701:
    #####: 1702:  return diff;
        -: 1703:}
        -: 1704:
        -: 1705:/* Compare two lines A and B trying every key in sequence until there
        -: 1706:   are no more keys or a difference is found. */
        -: 1707:
        -: 1708:static int
    #####: 1709:keycompare (const struct line *a, const struct line *b)
        -: 1710:{
    #####: 1711:  struct keyfield const *key = keylist;
        -: 1712:
        -: 1713:  /* For the first iteration only, the key positions have been
        -: 1714:     precomputed for us. */
    #####: 1715:  char *texta = a->keybeg;
    #####: 1716:  char *textb = b->keybeg;
    #####: 1717:  char *lima = a->keylim;
    #####: 1718:  char *limb = b->keylim;
        -: 1719:
        -: 1720:  int diff;
        -: 1721:
        -: 1722:  for (;;)
        -: 1723:    {
    #####: 1724:      char const *translate = key->translate;
    #####: 1725:      bool const *ignore = key->ignore;
        -: 1726:
        -: 1727:      /* Find the lengths. */
    #####: 1728:      size_t lena = lima <= texta ? 0 : lima - texta;
    #####: 1729:      size_t lenb = limb <= textb ? 0 : limb - textb;
        -: 1730:
        -: 1731:      /* Actually compare the fields. */
        -: 1732:
    #####: 1733:      if (key->random)
    #####: 1734:	diff = compare_random (texta, lena, textb, lenb);
    #####: 1735:      else if (key->numeric | key->general_numeric)
        -: 1736:	{
    #####: 1737:	  char savea = *lima, saveb = *limb;
        -: 1738:
    #####: 1739:	  *lima = *limb = '\0';
    #####: 1740:	  diff = ((key->numeric ? numcompare : general_numcompare)
        -: 1741:		  (texta, textb));
    #####: 1742:	  *lima = savea, *limb = saveb;
        -: 1743:	}
    #####: 1744:      else if (key->month)
    #####: 1745:	diff = getmonth (texta, lena) - getmonth (textb, lenb);
        -: 1746:      /* Sorting like this may become slow, so in a simple locale the user
        -: 1747:	 can select a faster sort that is similar to ascii sort.  */
    #####: 1748:      else if (hard_LC_COLLATE)
        -: 1749:	{
    #####: 1750:	  if (ignore || translate)
    #####: 1751:	    {
        -: 1752:	      char buf[4000];
    #####: 1753:	      size_t size = lena + 1 + lenb + 1;
    #####: 1754:	      char *copy_a = (size <= sizeof buf ? buf : xmalloc (size));
    #####: 1755:	      char *copy_b = copy_a + lena + 1;
        -: 1756:	      size_t new_len_a, new_len_b, i;
        -: 1757:
        -: 1758:	      /* Ignore and/or translate chars before comparing.  */
    #####: 1759:	      for (new_len_a = new_len_b = i = 0; i < MAX (lena, lenb); i++)
        -: 1760:		{
    #####: 1761:		  if (i < lena)
        -: 1762:		    {
    #####: 1763:		      copy_a[new_len_a] = (translate
    #####: 1764:					   ? translate[to_uchar (texta[i])]
    #####: 1765:					   : texta[i]);
    #####: 1766:		      if (!ignore || !ignore[to_uchar (texta[i])])
    #####: 1767:			++new_len_a;
        -: 1768:		    }
    #####: 1769:		  if (i < lenb)
        -: 1770:		    {
    #####: 1771:		      copy_b[new_len_b] = (translate
    #####: 1772:					   ? translate[to_uchar (textb[i])]
    #####: 1773:					   : textb [i]);
    #####: 1774:		      if (!ignore || !ignore[to_uchar (textb[i])])
    #####: 1775:			++new_len_b;
        -: 1776:		    }
        -: 1777:		}
        -: 1778:
    #####: 1779:	      diff = xmemcoll (copy_a, new_len_a, copy_b, new_len_b);
        -: 1780:
    #####: 1781:	      if (sizeof buf < size)
    #####: 1782:		free (copy_a);
        -: 1783:	    }
    #####: 1784:	  else if (lena == 0)
    #####: 1785:	    diff = - NONZERO (lenb);
    #####: 1786:	  else if (lenb == 0)
    #####: 1787:	    goto greater;
        -: 1788:	  else
    #####: 1789:	    diff = xmemcoll (texta, lena, textb, lenb);
        -: 1790:	}
    #####: 1791:      else if (ignore)
        -: 1792:	{
        -: 1793:#define CMP_WITH_IGNORE(A, B)						\
        -: 1794:  do									\
        -: 1795:    {									\
        -: 1796:	  for (;;)							\
        -: 1797:	    {								\
        -: 1798:	      while (texta < lima && ignore[to_uchar (*texta)])		\
        -: 1799:		++texta;						\
        -: 1800:	      while (textb < limb && ignore[to_uchar (*textb)])		\
        -: 1801:		++textb;						\
        -: 1802:	      if (! (texta < lima && textb < limb))			\
        -: 1803:		break;							\
        -: 1804:	      diff = to_uchar (A) - to_uchar (B);			\
        -: 1805:	      if (diff)							\
        -: 1806:		goto not_equal;						\
        -: 1807:	      ++texta;							\
        -: 1808:	      ++textb;							\
        -: 1809:	    }								\
        -: 1810:									\
        -: 1811:	  diff = (texta < lima) - (textb < limb);			\
        -: 1812:    }									\
        -: 1813:  while (0)
        -: 1814:
    #####: 1815:	  if (translate)
    #####: 1816:	    CMP_WITH_IGNORE (translate[to_uchar (*texta)],
        -: 1817:			     translate[to_uchar (*textb)]);
        -: 1818:	  else
    #####: 1819:	    CMP_WITH_IGNORE (*texta, *textb);
        -: 1820:	}
    #####: 1821:      else if (lena == 0)
    #####: 1822:	diff = - NONZERO (lenb);
    #####: 1823:      else if (lenb == 0)
    #####: 1824:	goto greater;
        -: 1825:      else
        -: 1826:	{
    #####: 1827:	  if (translate)
        -: 1828:	    {
    #####: 1829:	      while (texta < lima && textb < limb)
        -: 1830:		{
    #####: 1831:		  diff = (to_uchar (translate[to_uchar (*texta++)])
    #####: 1832:			  - to_uchar (translate[to_uchar (*textb++)]));
    #####: 1833:		  if (diff)
    #####: 1834:		    goto not_equal;
        -: 1835:		}
        -: 1836:	    }
        -: 1837:	  else
        -: 1838:	    {
    #####: 1839:	      diff = memcmp (texta, textb, MIN (lena, lenb));
    #####: 1840:	      if (diff)
    #####: 1841:		goto not_equal;
        -: 1842:	    }
    #####: 1843:	  diff = lena < lenb ? -1 : lena != lenb;
        -: 1844:	}
        -: 1845:
    #####: 1846:      if (diff)
    #####: 1847:	goto not_equal;
        -: 1848:
    #####: 1849:      key = key->next;
    #####: 1850:      if (! key)
    #####: 1851:	break;
        -: 1852:
        -: 1853:      /* Find the beginning and limit of the next field.  */
    #####: 1854:      if (key->eword != SIZE_MAX)
    #####: 1855:	lima = limfield (a, key), limb = limfield (b, key);
        -: 1856:      else
    #####: 1857:	lima = a->text + a->length - 1, limb = b->text + b->length - 1;
        -: 1858:
    #####: 1859:      if (key->sword != SIZE_MAX)
    #####: 1860:	texta = begfield (a, key), textb = begfield (b, key);
        -: 1861:      else
        -: 1862:	{
    #####: 1863:	  texta = a->text, textb = b->text;
    #####: 1864:	  if (key->skipsblanks)
        -: 1865:	    {
    #####: 1866:	      while (texta < lima && blanks[to_uchar (*texta)])
    #####: 1867:		++texta;
    #####: 1868:	      while (textb < limb && blanks[to_uchar (*textb)])
    #####: 1869:		++textb;
        -: 1870:	    }
        -: 1871:	}
    #####: 1872:    }
        -: 1873:
    #####: 1874:  return 0;
        -: 1875:
        -: 1876: greater:
    #####: 1877:  diff = 1;
        -: 1878: not_equal:
    #####: 1879:  return key->reverse ? -diff : diff;
        -: 1880:}
        -: 1881:
        -: 1882:/* Compare two lines A and B, returning negative, zero, or positive
        -: 1883:   depending on whether A compares less than, equal to, or greater than B. */
        -: 1884:
        -: 1885:static int
     7334: 1886:compare (const struct line *a, const struct line *b)
        -: 1887:{
        -: 1888:  int diff;
        -: 1889:  size_t alen, blen;
        -: 1890:
        -: 1891:  /* First try to compare on the specified keys (if any).
        -: 1892:     The only two cases with no key at all are unadorned sort,
        -: 1893:     and unadorned sort -r. */
     7334: 1894:  if (keylist)
        -: 1895:    {
    #####: 1896:      diff = keycompare (a, b);
    #####: 1897:      if (diff | unique | stable)
    #####: 1898:	return diff;
        -: 1899:    }
        -: 1900:
        -: 1901:  /* If the keys all compare equal (or no keys were specified)
        -: 1902:     fall through to the default comparison.  */
     7334: 1903:  alen = a->length - 1, blen = b->length - 1;
        -: 1904:
     7334: 1905:  if (alen == 0)
    #####: 1906:    diff = - NONZERO (blen);
     7334: 1907:  else if (blen == 0)
    #####: 1908:    diff = 1;
     7334: 1909:  else if (hard_LC_COLLATE)
    #####: 1910:    diff = xmemcoll (a->text, alen, b->text, blen);
     7334: 1911:  else if (! (diff = memcmp (a->text, b->text, MIN (alen, blen))))
      922: 1912:    diff = alen < blen ? -1 : alen != blen;
        -: 1913:
     7334: 1914:  return reverse ? -diff : diff;
        -: 1915:}
        -: 1916:
        -: 1917:/* Check that the lines read from FILE_NAME come in order.  Return
        -: 1918:   true if they are in order.  If CHECKONLY == 'c', also print a
        -: 1919:   diagnostic (FILE_NAME, line number, contents of line) to stderr if
        -: 1920:   they are not in order.  */
        -: 1921:
        -: 1922:static bool
    #####: 1923:check (char const *file_name, char checkonly)
        -: 1924:{
    #####: 1925:  FILE *fp = xfopen (file_name, "r");
        -: 1926:  struct buffer buf;		/* Input buffer. */
        -: 1927:  struct line temp;		/* Copy of previous line. */
    #####: 1928:  size_t alloc = 0;
    #####: 1929:  uintmax_t line_number = 0;
    #####: 1930:  struct keyfield const *key = keylist;
    #####: 1931:  bool nonunique = ! unique;
    #####: 1932:  bool ordered = true;
        -: 1933:
    #####: 1934:  initbuf (&buf, sizeof (struct line),
        -: 1935:	   MAX (merge_buffer_size, sort_size));
    #####: 1936:  temp.text = NULL;
        -: 1937:
    #####: 1938:  while (fillbuf (&buf, fp, file_name))
        -: 1939:    {
    #####: 1940:      struct line const *line = buffer_linelim (&buf);
    #####: 1941:      struct line const *linebase = line - buf.nlines;
        -: 1942:
        -: 1943:      /* Make sure the line saved from the old buffer contents is
        -: 1944:	 less than or equal to the first line of the new buffer. */
    #####: 1945:      if (alloc && nonunique <= compare (&temp, line - 1))
        -: 1946:	{
        -: 1947:	found_disorder:
        -: 1948:	  {
    #####: 1949:	    if (checkonly == 'c')
        -: 1950:	      {
    #####: 1951:		struct line const *disorder_line = line - 1;
    #####: 1952:		uintmax_t disorder_line_number =
    #####: 1953:		  buffer_linelim (&buf) - disorder_line + line_number;
        -: 1954:		char hr_buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 1955:		fprintf (stderr, _("%s: %s:%s: disorder: "),
        -: 1956:			 program_name, file_name,
        -: 1957:			 umaxtostr (disorder_line_number, hr_buf));
    #####: 1958:		write_bytes (disorder_line->text, disorder_line->length,
        -: 1959:			     stderr, _("standard error"));
        -: 1960:	      }
        -: 1961:
    #####: 1962:	    ordered = false;
    #####: 1963:	    break;
        -: 1964:	  }
        -: 1965:	}
        -: 1966:
        -: 1967:      /* Compare each line in the buffer with its successor.  */
    #####: 1968:      while (linebase < --line)
    #####: 1969:	if (nonunique <= compare (line, line - 1))
    #####: 1970:	  goto found_disorder;
        -: 1971:
    #####: 1972:      line_number += buf.nlines;
        -: 1973:
        -: 1974:      /* Save the last line of the buffer.  */
    #####: 1975:      if (alloc < line->length)
        -: 1976:	{
        -: 1977:	  do
        -: 1978:	    {
    #####: 1979:	      alloc *= 2;
    #####: 1980:	      if (! alloc)
        -: 1981:		{
    #####: 1982:		  alloc = line->length;
    #####: 1983:		  break;
        -: 1984:		}
        -: 1985:	    }
    #####: 1986:	  while (alloc < line->length);
        -: 1987:
    #####: 1988:	  temp.text = xrealloc (temp.text, alloc);
        -: 1989:	}
    #####: 1990:      memcpy (temp.text, line->text, line->length);
    #####: 1991:      temp.length = line->length;
    #####: 1992:      if (key)
        -: 1993:	{
    #####: 1994:	  temp.keybeg = temp.text + (line->keybeg - line->text);
    #####: 1995:	  temp.keylim = temp.text + (line->keylim - line->text);
        -: 1996:	}
        -: 1997:    }
        -: 1998:
    #####: 1999:  xfclose (fp, file_name);
    #####: 2000:  free (buf.buf);
    #####: 2001:  free (temp.text);
    #####: 2002:  return ordered;
        -: 2003:}
        -: 2004:
        -: 2005:/* Merge lines from FILES onto OFP.  NTEMPS is the number of temporary
        -: 2006:   files (all of which are at the start of the FILES array), and
        -: 2007:   NFILES is the number of files; 0 <= NTEMPS <= NFILES <= NMERGE.
        -: 2008:   Close input and output files before returning.
        -: 2009:   OUTPUT_FILE gives the name of the output file.  If it is NULL,
        -: 2010:   the output file is standard output.  If OFP is NULL, the output
        -: 2011:   file has not been opened yet (or written to, if standard output).  */
        -: 2012:
        -: 2013:static void
        2: 2014:mergefps (struct sortfile *files, size_t ntemps, size_t nfiles,
        -: 2015:	  FILE *ofp, char const *output_file)
        -: 2016:{
        -: 2017:  FILE *fps[NMERGE];		/* Input streams for each file.  */
        -: 2018:  struct buffer buffer[NMERGE];	/* Input buffers for each file. */
        -: 2019:  struct line saved;		/* Saved line storage for unique check. */
        2: 2020:  struct line const *savedline = NULL;
        -: 2021:				/* &saved if there is a saved line. */
        2: 2022:  size_t savealloc = 0;		/* Size allocated for the saved line. */
        -: 2023:  struct line const *cur[NMERGE]; /* Current line in each line table. */
        -: 2024:  struct line const *base[NMERGE]; /* Base of each line table.  */
        -: 2025:  size_t ord[NMERGE];		/* Table representing a permutation of fps,
        -: 2026:				   such that cur[ord[0]] is the smallest line
        -: 2027:				   and will be next output. */
        -: 2028:  size_t i;
        -: 2029:  size_t j;
        -: 2030:  size_t t;
        2: 2031:  struct keyfield const *key = keylist;
        2: 2032:  saved.text = NULL;
        -: 2033:
        -: 2034:  /* Read initial lines from each input file. */
        4: 2035:  for (i = 0; i < nfiles; )
        -: 2036:    {
    #####: 2037:      fps[i] = (files[i].pid
    #####: 2038:		? open_temp (files[i].name, files[i].pid)
    #####: 2039:		: xfopen (files[i].name, "r"));
    #####: 2040:      initbuf (&buffer[i], sizeof (struct line),
    #####: 2041:	       MAX (merge_buffer_size, sort_size / nfiles));
    #####: 2042:      if (fillbuf (&buffer[i], fps[i], files[i].name))
        -: 2043:	{
    #####: 2044:	  struct line const *linelim = buffer_linelim (&buffer[i]);
    #####: 2045:	  cur[i] = linelim - 1;
    #####: 2046:	  base[i] = linelim - buffer[i].nlines;
    #####: 2047:	  i++;
        -: 2048:	}
        -: 2049:      else
        -: 2050:	{
        -: 2051:	  /* fps[i] is empty; eliminate it from future consideration.  */
    #####: 2052:	  xfclose (fps[i], files[i].name);
    #####: 2053:	  if (i < ntemps)
        -: 2054:	    {
    #####: 2055:	      ntemps--;
    #####: 2056:	      zaptemp (files[i].name);
        -: 2057:	    }
    #####: 2058:	  free (buffer[i].buf);
    #####: 2059:	  --nfiles;
    #####: 2060:	  for (j = i; j < nfiles; ++j)
    #####: 2061:	    files[j] = files[j + 1];
        -: 2062:	}
        -: 2063:    }
        -: 2064:
        2: 2065:  if (! ofp)
        2: 2066:    ofp = xfopen (output_file, "w");
        -: 2067:
        -: 2068:  /* Set up the ord table according to comparisons among input lines.
        -: 2069:     Since this only reorders two items if one is strictly greater than
        -: 2070:     the other, it is stable. */
        2: 2071:  for (i = 0; i < nfiles; ++i)
    #####: 2072:    ord[i] = i;
        2: 2073:  for (i = 1; i < nfiles; ++i)
    #####: 2074:    if (0 < compare (cur[ord[i - 1]], cur[ord[i]]))
    #####: 2075:      t = ord[i - 1], ord[i - 1] = ord[i], ord[i] = t, i = 0;
        -: 2076:
        -: 2077:  /* Repeatedly output the smallest line until no input remains. */
        4: 2078:  while (nfiles)
        -: 2079:    {
    #####: 2080:      struct line const *smallest = cur[ord[0]];
        -: 2081:
        -: 2082:      /* If uniquified output is turned on, output only the first of
        -: 2083:	 an identical series of lines. */
    #####: 2084:      if (unique)
        -: 2085:	{
    #####: 2086:	  if (savedline && compare (savedline, smallest))
        -: 2087:	    {
    #####: 2088:	      savedline = NULL;
    #####: 2089:	      write_bytes (saved.text, saved.length, ofp, output_file);
        -: 2090:	    }
    #####: 2091:	  if (!savedline)
        -: 2092:	    {
    #####: 2093:	      savedline = &saved;
    #####: 2094:	      if (savealloc < smallest->length)
        -: 2095:		{
        -: 2096:		  do
    #####: 2097:		    if (! savealloc)
        -: 2098:		      {
    #####: 2099:			savealloc = smallest->length;
    #####: 2100:			break;
        -: 2101:		      }
    #####: 2102:		  while ((savealloc *= 2) < smallest->length);
        -: 2103:
    #####: 2104:		  saved.text = xrealloc (saved.text, savealloc);
        -: 2105:		}
    #####: 2106:	      saved.length = smallest->length;
    #####: 2107:	      memcpy (saved.text, smallest->text, saved.length);
    #####: 2108:	      if (key)
        -: 2109:		{
    #####: 2110:		  saved.keybeg =
    #####: 2111:		    saved.text + (smallest->keybeg - smallest->text);
    #####: 2112:		  saved.keylim =
    #####: 2113:		    saved.text + (smallest->keylim - smallest->text);
        -: 2114:		}
        -: 2115:	    }
        -: 2116:	}
        -: 2117:      else
    #####: 2118:	write_bytes (smallest->text, smallest->length, ofp, output_file);
        -: 2119:
        -: 2120:      /* Check if we need to read more lines into core. */
    #####: 2121:      if (base[ord[0]] < smallest)
    #####: 2122:	cur[ord[0]] = smallest - 1;
        -: 2123:      else
        -: 2124:	{
    #####: 2125:	  if (fillbuf (&buffer[ord[0]], fps[ord[0]], files[ord[0]].name))
        -: 2126:	    {
    #####: 2127:	      struct line const *linelim = buffer_linelim (&buffer[ord[0]]);
    #####: 2128:	      cur[ord[0]] = linelim - 1;
    #####: 2129:	      base[ord[0]] = linelim - buffer[ord[0]].nlines;
        -: 2130:	    }
        -: 2131:	  else
        -: 2132:	    {
        -: 2133:	      /* We reached EOF on fps[ord[0]].  */
    #####: 2134:	      for (i = 1; i < nfiles; ++i)
    #####: 2135:		if (ord[i] > ord[0])
    #####: 2136:		  --ord[i];
    #####: 2137:	      --nfiles;
    #####: 2138:	      xfclose (fps[ord[0]], files[ord[0]].name);
    #####: 2139:	      if (ord[0] < ntemps)
        -: 2140:		{
    #####: 2141:		  ntemps--;
    #####: 2142:		  zaptemp (files[ord[0]].name);
        -: 2143:		}
    #####: 2144:	      free (buffer[ord[0]].buf);
    #####: 2145:	      for (i = ord[0]; i < nfiles; ++i)
        -: 2146:		{
    #####: 2147:		  fps[i] = fps[i + 1];
    #####: 2148:		  files[i] = files[i + 1];
    #####: 2149:		  buffer[i] = buffer[i + 1];
    #####: 2150:		  cur[i] = cur[i + 1];
    #####: 2151:		  base[i] = base[i + 1];
        -: 2152:		}
    #####: 2153:	      for (i = 0; i < nfiles; ++i)
    #####: 2154:		ord[i] = ord[i + 1];
    #####: 2155:	      continue;
        -: 2156:	    }
        -: 2157:	}
        -: 2158:
        -: 2159:      /* The new line just read in may be larger than other lines
        -: 2160:	 already in main memory; push it back in the queue until we
        -: 2161:	 encounter a line larger than it.  Optimize for the common
        -: 2162:	 case where the new line is smallest.  */
        -: 2163:      {
    #####: 2164:	size_t lo = 1;
    #####: 2165:	size_t hi = nfiles;
    #####: 2166:	size_t probe = lo;
    #####: 2167:	size_t ord0 = ord[0];
        -: 2168:	size_t count_of_smaller_lines;
        -: 2169:
    #####: 2170:	while (lo < hi)
        -: 2171:	  {
    #####: 2172:	    int cmp = compare (cur[ord0], cur[ord[probe]]);
    #####: 2173:	    if (cmp < 0 || (cmp == 0 && ord0 < ord[probe]))
    #####: 2174:	      hi = probe;
        -: 2175:	    else
    #####: 2176:	      lo = probe + 1;
    #####: 2177:	    probe = (lo + hi) / 2;
        -: 2178:	  }
        -: 2179:
    #####: 2180:	count_of_smaller_lines = lo - 1;
    #####: 2181:	for (j = 0; j < count_of_smaller_lines; j++)
    #####: 2182:	  ord[j] = ord[j + 1];
    #####: 2183:	ord[count_of_smaller_lines] = ord0;
        -: 2184:      }
        -: 2185:
        -: 2186:      /* Free up some resources every once in a while.  */
    #####: 2187:      if (MAX_PROCS_BEFORE_REAP < nprocs)
    #####: 2188:	reap_some ();
        -: 2189:    }
        -: 2190:
        2: 2191:  if (unique && savedline)
        -: 2192:    {
    #####: 2193:      write_bytes (saved.text, saved.length, ofp, output_file);
    #####: 2194:      free (saved.text);
        -: 2195:    }
        -: 2196:
        2: 2197:  xfclose (ofp, output_file);
        2: 2198:}
        -: 2199:
        -: 2200:/* Merge into T the two sorted arrays of lines LO (with NLO members)
        -: 2201:   and HI (with NHI members).  T, LO, and HI point just past their
        -: 2202:   respective arrays, and the arrays are in reverse order.  NLO and
        -: 2203:   NHI must be positive, and HI - NHI must equal T - (NLO + NHI).  */
        -: 2204:
        -: 2205:static inline void
     5830: 2206:mergelines (struct line *t,
        -: 2207:	    struct line const *lo, size_t nlo,
        -: 2208:	    struct line const *hi, size_t nhi)
        -: 2209:{
        -: 2210:  for (;;)
     5830: 2211:    if (compare (lo - 1, hi - 1) <= 0)
        -: 2212:      {
     3672: 2213:	*--t = *--lo;
     3672: 2214:	if (! --nlo)
        -: 2215:	  {
        -: 2216:	    /* HI - NHI equalled T - (NLO + NHI) when this function
        -: 2217:	       began.  Therefore HI must equal T now, and there is no
        -: 2218:	       need to copy from HI to T.  */
      692: 2219:	    return;
        -: 2220:	  }
        -: 2221:      }
        -: 2222:    else
        -: 2223:      {
     2158: 2224:	*--t = *--hi;
     2158: 2225:	if (! --nhi)
        -: 2226:	  {
        -: 2227:	    do
      196: 2228:	      *--t = *--lo;
      196: 2229:	    while (--nlo);
        -: 2230:
      112: 2231:	    return;
        -: 2232:	  }
     5026: 2233:      }
        -: 2234:}
        -: 2235:
        -: 2236:/* Sort the array LINES with NLINES members, using TEMP for temporary space.
        -: 2237:   NLINES must be at least 2.
        -: 2238:   The input and output arrays are in reverse order, and LINES and
        -: 2239:   TEMP point just past the end of their respective arrays.
        -: 2240:
        -: 2241:   Use a recursive divide-and-conquer algorithm, in the style
        -: 2242:   suggested by Knuth volume 3 (2nd edition), exercise 5.2.4-23.  Use
        -: 2243:   the optimization suggested by exercise 5.2.4-10; this requires room
        -: 2244:   for only 1.5*N lines, rather than the usual 2*N lines.  Knuth
        -: 2245:   writes that this memory optimization was originally published by
        -: 2246:   D. A. Bell, Comp J. 1 (1958), 75.  */
        -: 2247:
        -: 2248:static void
      636: 2249:sortlines (struct line *lines, size_t nlines, struct line *temp)
        -: 2250:{
      636: 2251:  if (nlines == 2)
        -: 2252:    {
      228: 2253:      if (0 < compare (&lines[-1], &lines[-2]))
        -: 2254:	{
       14: 2255:	  struct line tmp = lines[-1];
       14: 2256:	  lines[-1] = lines[-2];
       14: 2257:	  lines[-2] = tmp;
        -: 2258:	}
        -: 2259:    }
        -: 2260:  else
        -: 2261:    {
      408: 2262:      size_t nlo = nlines / 2;
      408: 2263:      size_t nhi = nlines - nlo;
      408: 2264:      struct line *lo = lines;
      408: 2265:      struct line *hi = lines - nlo;
      408: 2266:      struct line *sorted_lo = temp;
        -: 2267:
      408: 2268:      sortlines (hi, nhi, temp);
      408: 2269:      if (1 < nlo)
      220: 2270:	sortlines_temp (lo, nlo, sorted_lo);
        -: 2271:      else
      188: 2272:	sorted_lo[-1] = lo[-1];
        -: 2273:
      408: 2274:      mergelines (lines, sorted_lo, nlo, hi, nhi);
        -: 2275:    }
      636: 2276:}
        -: 2277:
        -: 2278:/* Like sortlines (LINES, NLINES, TEMP), except output into TEMP
        -: 2279:   rather than sorting in place.  */
        -: 2280:
        -: 2281:static void
      616: 2282:sortlines_temp (struct line *lines, size_t nlines, struct line *temp)
        -: 2283:{
      616: 2284:  if (nlines == 2)
        -: 2285:    {
        -: 2286:      /* Declare `swap' as int, not bool, to work around a bug
        -: 2287:	 <http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html>
        -: 2288:	 in the IBM xlc 6.0.0.0 compiler in 64-bit mode.  */
      220: 2289:      int swap = (0 < compare (&lines[-1], &lines[-2]));
      220: 2290:      temp[-1] = lines[-1 - swap];
      220: 2291:      temp[-2] = lines[-2 + swap];
        -: 2292:    }
        -: 2293:  else
        -: 2294:    {
      396: 2295:      size_t nlo = nlines / 2;
      396: 2296:      size_t nhi = nlines - nlo;
      396: 2297:      struct line *lo = lines;
      396: 2298:      struct line *hi = lines - nlo;
      396: 2299:      struct line *sorted_hi = temp - nlo;
        -: 2300:
      396: 2301:      sortlines_temp (hi, nhi, sorted_hi);
      396: 2302:      if (1 < nlo)
      218: 2303:	sortlines (lo, nlo, temp);
        -: 2304:
      396: 2305:      mergelines (temp, lo, nlo, sorted_hi, nhi);
        -: 2306:    }
      616: 2307:}
        -: 2308:
        -: 2309:/* Scan through FILES[NTEMPS .. NFILES-1] looking for a file that is
        -: 2310:   the same as OUTFILE.  If found, merge the found instances (and perhaps
        -: 2311:   some other files) into a temporary file so that it can in turn be
        -: 2312:   merged into OUTFILE without destroying OUTFILE before it is completely
        -: 2313:   read.  Return the new value of NFILES, which differs from the old if
        -: 2314:   some merging occurred.
        -: 2315:
        -: 2316:   This test ensures that an otherwise-erroneous use like
        -: 2317:   "sort -m -o FILE ... FILE ..." copies FILE before writing to it.
        -: 2318:   It's not clear that POSIX requires this nicety.
        -: 2319:   Detect common error cases, but don't try to catch obscure cases like
        -: 2320:   "cat ... FILE ... | sort -m -o FILE"
        -: 2321:   where traditional "sort" doesn't copy the input and where
        -: 2322:   people should know that they're getting into trouble anyway.
        -: 2323:   Catching these obscure cases would slow down performance in
        -: 2324:   common cases.  */
        -: 2325:
        -: 2326:static size_t
        2: 2327:avoid_trashing_input (struct sortfile *files, size_t ntemps,
        -: 2328:		      size_t nfiles, char const *outfile)
        -: 2329:{
        -: 2330:  size_t i;
        2: 2331:  bool got_outstat = false;
        -: 2332:  struct stat outstat;
        -: 2333:
        2: 2334:  for (i = ntemps; i < nfiles; i++)
        -: 2335:    {
    #####: 2336:      bool is_stdin = STREQ (files[i].name, "-");
        -: 2337:      bool same;
        -: 2338:      struct stat instat;
        -: 2339:
    #####: 2340:      if (outfile && STREQ (outfile, files[i].name) && !is_stdin)
    #####: 2341:	same = true;
        -: 2342:      else
        -: 2343:	{
    #####: 2344:	  if (! got_outstat)
        -: 2345:	    {
    #####: 2346:	      if ((outfile
    #####: 2347:		   ? stat (outfile, &outstat)
    #####: 2348:		   : fstat (STDOUT_FILENO, &outstat))
    #####: 2349:		  != 0)
    #####: 2350:		break;
    #####: 2351:	      got_outstat = true;
        -: 2352:	    }
        -: 2353:
    #####: 2354:	  same = (((is_stdin
    #####: 2355:		    ? fstat (STDIN_FILENO, &instat)
    #####: 2356:		    : stat (files[i].name, &instat))
    #####: 2357:		   == 0)
    #####: 2358:		  && SAME_INODE (instat, outstat));
        -: 2359:	}
        -: 2360:
    #####: 2361:      if (same)
        -: 2362:	{
        -: 2363:	  FILE *tftp;
        -: 2364:	  pid_t pid;
    #####: 2365:	  char *temp = create_temp (&tftp, &pid);
    #####: 2366:	  mergefps (&files[i],0, nfiles - i, tftp, temp);
    #####: 2367:	  files[i].name = temp;
    #####: 2368:	  files[i].pid = pid;
    #####: 2369:	  return i + 1;
        -: 2370:	}
        -: 2371:    }
        -: 2372:
        2: 2373:  return nfiles;
        -: 2374:}
        -: 2375:
        -: 2376:/* Merge the input FILES.  NTEMPS is the number of files at the
        -: 2377:   start of FILES that are temporary; it is zero at the top level.
        -: 2378:   NFILES is the total number of files.  Put the output in
        -: 2379:   OUTPUT_FILE; a null OUTPUT_FILE stands for standard output.  */
        -: 2380:
        -: 2381:static void
        2: 2382:merge (struct sortfile *files, size_t ntemps, size_t nfiles,
        -: 2383:       char const *output_file)
        -: 2384:{
        4: 2385:  while (NMERGE < nfiles)
        -: 2386:    {
        -: 2387:      /* Number of input files processed so far.  */
        -: 2388:      size_t in;
        -: 2389:
        -: 2390:      /* Number of output files generated so far.  */
        -: 2391:      size_t out;
        -: 2392:
        -: 2393:      /* nfiles % NMERGE; this counts input files that are left over
        -: 2394:	 after all full-sized merges have been done.  */
        -: 2395:      size_t remainder;
        -: 2396:
        -: 2397:      /* Number of easily-available slots at the next loop iteration.  */
        -: 2398:      size_t cheap_slots;
        -: 2399:
        -: 2400:      /* Do as many NMERGE-size merges as possible.  */
    #####: 2401:      for (out = in = 0; out < nfiles / NMERGE; out++, in += NMERGE)
        -: 2402:	{
        -: 2403:	  FILE *tfp;
        -: 2404:	  pid_t pid;
    #####: 2405:	  char *temp = create_temp (&tfp, &pid);
    #####: 2406:	  size_t nt = MIN (ntemps, NMERGE);
    #####: 2407:	  ntemps -= nt;
    #####: 2408:	  mergefps (&files[in], nt, NMERGE, tfp, temp);
    #####: 2409:	  files[out].name = temp;
    #####: 2410:	  files[out].pid = pid;
        -: 2411:	}
        -: 2412:
    #####: 2413:      remainder = nfiles - in;
    #####: 2414:      cheap_slots = NMERGE - out % NMERGE;
        -: 2415:
    #####: 2416:      if (cheap_slots < remainder)
        -: 2417:	{
        -: 2418:	  /* So many files remain that they can't all be put into the last
        -: 2419:	     NMERGE-sized output window.  Do one more merge.  Merge as few
        -: 2420:	     files as possible, to avoid needless I/O.  */
    #####: 2421:	  size_t nshortmerge = remainder - cheap_slots + 1;
        -: 2422:	  FILE *tfp;
        -: 2423:	  pid_t pid;
    #####: 2424:	  char *temp = create_temp (&tfp, &pid);
    #####: 2425:	  size_t nt = MIN (ntemps, nshortmerge);
    #####: 2426:	  ntemps -= nt;
    #####: 2427:	  mergefps (&files[in], nt, nshortmerge, tfp, temp);
    #####: 2428:	  files[out].name = temp;
    #####: 2429:	  files[out++].pid = pid;
    #####: 2430:	  in += nshortmerge;
        -: 2431:	}
        -: 2432:
        -: 2433:      /* Put the remaining input files into the last NMERGE-sized output
        -: 2434:	 window, so they will be merged in the next pass.  */
    #####: 2435:      memmove(&files[out], &files[in], (nfiles - in) * sizeof *files);
    #####: 2436:      ntemps += out;
    #####: 2437:      nfiles -= in - out;
        -: 2438:    }
        -: 2439:
        2: 2440:  nfiles = avoid_trashing_input (files, ntemps, nfiles, output_file);
        2: 2441:  mergefps (files, ntemps, nfiles, NULL, output_file);
        2: 2442:}
        -: 2443:
        -: 2444:/* Sort NFILES FILES onto OUTPUT_FILE. */
        -: 2445:
        -: 2446:static void
       12: 2447:sort (char * const *files, size_t nfiles, char const *output_file)
        -: 2448:{
        -: 2449:  struct buffer buf;
       12: 2450:  size_t ntemps = 0;
       12: 2451:  bool output_file_created = false;
        -: 2452:
       12: 2453:  buf.alloc = 0;
        -: 2454:
       26: 2455:  while (nfiles)
        -: 2456:    {
        -: 2457:      char const *temp_output;
       12: 2458:      char const *file = *files;
       12: 2459:      FILE *fp = xfopen (file, "r");
        -: 2460:      FILE *tfp;
       12: 2461:      size_t bytes_per_line = (2 * sizeof (struct line)
        -: 2462:			       - sizeof (struct line) / 2);
        -: 2463:
       12: 2464:      if (! buf.alloc)
       12: 2465:	initbuf (&buf, bytes_per_line,
        -: 2466:		 sort_buffer_size (&fp, 1, files, nfiles, bytes_per_line));
       12: 2467:      buf.eof = false;
       12: 2468:      files++;
       12: 2469:      nfiles--;
        -: 2470:
       24: 2471:      while (fillbuf (&buf, fp, file))
        -: 2472:	{
        -: 2473:	  struct line *line;
        -: 2474:	  struct line *linebase;
        -: 2475:
       10: 2476:	  if (buf.eof && nfiles
    #####: 2477:	      && (bytes_per_line + 1
    #####: 2478:		  < (buf.alloc - buf.used - bytes_per_line * buf.nlines)))
        -: 2479:	    {
        -: 2480:	      /* End of file, but there is more input and buffer room.
        -: 2481:		 Concatenate the next input file; this is faster in
        -: 2482:		 the usual case.  */
    #####: 2483:	      buf.left = buf.used;
    #####: 2484:	      break;
        -: 2485:	    }
        -: 2486:
       10: 2487:	  line = buffer_linelim (&buf);
       10: 2488:	  linebase = line - buf.nlines;
       10: 2489:	  if (1 < buf.nlines)
       10: 2490:	    sortlines (line, buf.nlines, linebase);
       10: 2491:	  if (buf.eof && !nfiles && !ntemps && !buf.left)
        -: 2492:	    {
       10: 2493:	      xfclose (fp, file);
       10: 2494:	      tfp = xfopen (output_file, "w");
       10: 2495:	      temp_output = output_file;
       10: 2496:	      output_file_created = true;
        -: 2497:	    }
        -: 2498:	  else
        -: 2499:	    {
    #####: 2500:	      ++ntemps;
    #####: 2501:	      temp_output = create_temp (&tfp, NULL);
        -: 2502:	    }
        -: 2503:
        -: 2504:	  do
        -: 2505:	    {
      874: 2506:	      line--;
      874: 2507:	      write_bytes (line->text, line->length, tfp, temp_output);
      874: 2508:	      if (unique)
     1740: 2509:		while (linebase < line && compare (line, line - 1) == 0)
      388: 2510:		  line--;
        -: 2511:	    }
      874: 2512:	  while (linebase < line);
        -: 2513:
       10: 2514:	  xfclose (tfp, temp_output);
        -: 2515:
        -: 2516:	  /* Free up some resources every once in a while.  */
       10: 2517:	  if (MAX_PROCS_BEFORE_REAP < nprocs)
    #####: 2518:	    reap_some ();
        -: 2519:
       10: 2520:	  if (output_file_created)
       20: 2521:	    goto finish;
        -: 2522:	}
        2: 2523:      xfclose (fp, file);
        -: 2524:    }
        -: 2525:
        -: 2526: finish:
       12: 2527:  free (buf.buf);
        -: 2528:
       12: 2529:  if (! output_file_created)
        -: 2530:    {
        -: 2531:      size_t i;
        2: 2532:      struct tempnode *node = temphead;
        2: 2533:      struct sortfile *tempfiles = xnmalloc (ntemps, sizeof *tempfiles);
        2: 2534:      for (i = 0; node; i++)
        -: 2535:	{
    #####: 2536:	  tempfiles[i].name = node->name;
    #####: 2537:	  tempfiles[i].pid = node->pid;
    #####: 2538:	  node = node->next;
        -: 2539:	}
        2: 2540:      merge (tempfiles, ntemps, ntemps, output_file);
        2: 2541:      free (tempfiles);
        -: 2542:    }
       12: 2543:}
        -: 2544:
        -: 2545:/* Insert a malloc'd copy of key KEY_ARG at the end of the key list.  */
        -: 2546:
        -: 2547:static void
    #####: 2548:insertkey (struct keyfield *key_arg)
        -: 2549:{
        -: 2550:  struct keyfield **p;
    #####: 2551:  struct keyfield *key = xmemdup (key_arg, sizeof *key);
        -: 2552:
    #####: 2553:  for (p = &keylist; *p; p = &(*p)->next)
    #####: 2554:    continue;
    #####: 2555:  *p = key;
    #####: 2556:  key->next = NULL;
    #####: 2557:}
        -: 2558:
        -: 2559:/* Report a bad field specification SPEC, with extra info MSGID.  */
        -: 2560:
        -: 2561:static void badfieldspec (char const *, char const *)
        -: 2562:     ATTRIBUTE_NORETURN;
        -: 2563:static void
    #####: 2564:badfieldspec (char const *spec, char const *msgid)
        -: 2565:{
    #####: 2566:  error (SORT_FAILURE, 0, _("%s: invalid field specification %s"),
        -: 2567:	 _(msgid), quote (spec));
    #####: 2568:  abort ();
        -: 2569:}
        -: 2570:
        -: 2571:/* Report incompatible options.  */
        -: 2572:
        -: 2573:static void incompatible_options (char const *) ATTRIBUTE_NORETURN;
        -: 2574:static void
    #####: 2575:incompatible_options (char const *opts)
        -: 2576:{
    #####: 2577:  error (SORT_FAILURE, 0, _("options `-%s' are incompatible"), opts);
    #####: 2578:  abort ();
        -: 2579:}
        -: 2580:
        -: 2581:/* Check compatibility of ordering options.  */
        -: 2582:
        -: 2583:static void
       12: 2584:check_ordering_compatibility (void)
        -: 2585:{
        -: 2586:  struct keyfield const *key;
        -: 2587:
       12: 2588:  for (key = keylist; key; key = key->next)
    #####: 2589:    if ((1 < (key->random + key->numeric + key->general_numeric + key->month
    #####: 2590:	      + !!key->ignore))
    #####: 2591:	|| (key->random && key->translate))
        -: 2592:      {
        -: 2593:	char opts[7];
    #####: 2594:	char *p = opts;
    #####: 2595:	if (key->ignore == nondictionary)
    #####: 2596:	  *p++ = 'd';
    #####: 2597:	if (key->translate)
    #####: 2598:	  *p++ = 'f';
    #####: 2599:	if (key->general_numeric)
    #####: 2600:	  *p++ = 'g';
    #####: 2601:	if (key->ignore == nonprinting)
    #####: 2602:	  *p++ = 'i';
    #####: 2603:	if (key->month)
    #####: 2604:	  *p++ = 'M';
    #####: 2605:	if (key->numeric)
    #####: 2606:	  *p++ = 'n';
    #####: 2607:	if (key->random)
    #####: 2608:	  *p++ = 'R';
    #####: 2609:	*p = '\0';
    #####: 2610:	incompatible_options (opts);
        -: 2611:      }
       12: 2612:}
        -: 2613:
        -: 2614:/* Parse the leading integer in STRING and store the resulting value
        -: 2615:   (which must fit into size_t) into *VAL.  Return the address of the
        -: 2616:   suffix after the integer.  If the value is too large, silently
        -: 2617:   substitute SIZE_MAX.  If MSGID is NULL, return NULL after
        -: 2618:   failure; otherwise, report MSGID and exit on failure.  */
        -: 2619:
        -: 2620:static char const *
    #####: 2621:parse_field_count (char const *string, size_t *val, char const *msgid)
        -: 2622:{
        -: 2623:  char *suffix;
        -: 2624:  uintmax_t n;
        -: 2625:
    #####: 2626:  switch (xstrtoumax (string, &suffix, 10, &n, ""))
        -: 2627:    {
        -: 2628:    case LONGINT_OK:
        -: 2629:    case LONGINT_INVALID_SUFFIX_CHAR:
    #####: 2630:      *val = n;
    #####: 2631:      if (*val == n)
    #####: 2632:	break;
        -: 2633:      /* Fall through.  */
        -: 2634:    case LONGINT_OVERFLOW:
        -: 2635:    case LONGINT_OVERFLOW | LONGINT_INVALID_SUFFIX_CHAR:
    #####: 2636:      *val = SIZE_MAX;
    #####: 2637:      break;
        -: 2638:
        -: 2639:    case LONGINT_INVALID:
    #####: 2640:      if (msgid)
    #####: 2641:	error (SORT_FAILURE, 0, _("%s: invalid count at start of %s"),
        -: 2642:	       _(msgid), quote (string));
    #####: 2643:      return NULL;
        -: 2644:    }
        -: 2645:
    #####: 2646:  return suffix;
        -: 2647:}
        -: 2648:
        -: 2649:/* Handle interrupts and hangups. */
        -: 2650:
        -: 2651:static void
    #####: 2652:sighandler (int sig)
        -: 2653:{
        -: 2654:  if (! SA_NOCLDSTOP)
        -: 2655:    signal (sig, SIG_IGN);
        -: 2656:
    #####: 2657:  cleanup ();
        -: 2658:
    #####: 2659:  signal (sig, SIG_DFL);
    #####: 2660:  raise (sig);
    #####: 2661:}
        -: 2662:
        -: 2663:/* Set the ordering options for KEY specified in S.
        -: 2664:   Return the address of the first character in S that
        -: 2665:   is not a valid ordering option.
        -: 2666:   BLANKTYPE is the kind of blanks that 'b' should skip. */
        -: 2667:
        -: 2668:static char *
    #####: 2669:set_ordering (const char *s, struct keyfield *key, enum blanktype blanktype)
        -: 2670:{
    #####: 2671:  while (*s)
        -: 2672:    {
    #####: 2673:      switch (*s)
        -: 2674:	{
        -: 2675:	case 'b':
    #####: 2676:	  if (blanktype == bl_start || blanktype == bl_both)
    #####: 2677:	    key->skipsblanks = true;
    #####: 2678:	  if (blanktype == bl_end || blanktype == bl_both)
    #####: 2679:	    key->skipeblanks = true;
    #####: 2680:	  break;
        -: 2681:	case 'd':
    #####: 2682:	  key->ignore = nondictionary;
    #####: 2683:	  break;
        -: 2684:	case 'f':
    #####: 2685:	  key->translate = fold_toupper;
    #####: 2686:	  break;
        -: 2687:	case 'g':
    #####: 2688:	  key->general_numeric = true;
    #####: 2689:	  break;
        -: 2690:	case 'i':
        -: 2691:	  /* Option order should not matter, so don't let -i override
        -: 2692:	     -d.  -d implies -i, but -i does not imply -d.  */
    #####: 2693:	  if (! key->ignore)
    #####: 2694:	    key->ignore = nonprinting;
    #####: 2695:	  break;
        -: 2696:	case 'M':
    #####: 2697:	  key->month = true;
    #####: 2698:	  break;
        -: 2699:	case 'n':
    #####: 2700:	  key->numeric = true;
    #####: 2701:	  break;
        -: 2702:	case 'R':
    #####: 2703:	  key->random = true;
    #####: 2704:	  break;
        -: 2705:	case 'r':
    #####: 2706:	  key->reverse = true;
    #####: 2707:	  break;
        -: 2708:	default:
    #####: 2709:	  return (char *) s;
        -: 2710:	}
    #####: 2711:      ++s;
        -: 2712:    }
    #####: 2713:  return (char *) s;
        -: 2714:}
        -: 2715:
        -: 2716:static struct keyfield *
    #####: 2717:key_init (struct keyfield *key)
        -: 2718:{
    #####: 2719:  memset (key, 0, sizeof *key);
    #####: 2720:  key->eword = SIZE_MAX;
    #####: 2721:  return key;
        -: 2722:}
        -: 2723:
        -: 2724:int
       12: 2725:main (int argc, char **argv)
        -: 2726:{
        -: 2727:  struct keyfield *key;
        -: 2728:  struct keyfield key_buf;
        -: 2729:  struct keyfield gkey;
        -: 2730:  char const *s;
       12: 2731:  int c = 0;
       12: 2732:  char checkonly = 0;
       12: 2733:  bool mergeonly = false;
       12: 2734:  char *random_source = NULL;
       12: 2735:  bool need_random = false;
       12: 2736:  size_t nfiles = 0;
       12: 2737:  bool posixly_correct = (getenv ("POSIXLY_CORRECT") != NULL);
       12: 2738:  bool obsolete_usage = (posix2_version () < 200112);
        -: 2739:  char **files;
       12: 2740:  char const *outfile = NULL;
        -: 2741:
        -: 2742:  initialize_main (&argc, &argv);
       12: 2743:  program_name = argv[0];
       12: 2744:  setlocale (LC_ALL, "");
        -: 2745:  bindtextdomain (PACKAGE, LOCALEDIR);
        -: 2746:  textdomain (PACKAGE);
        -: 2747:
       12: 2748:  initialize_exit_failure (SORT_FAILURE);
        -: 2749:
       12: 2750:  hard_LC_COLLATE = hard_locale (LC_COLLATE);
        -: 2751:#if HAVE_NL_LANGINFO
        -: 2752:  hard_LC_TIME = hard_locale (LC_TIME);
        -: 2753:#endif
        -: 2754:
        -: 2755:  /* Get locale's representation of the decimal point.  */
        -: 2756:  {
       12: 2757:    struct lconv const *locale = localeconv ();
        -: 2758:
        -: 2759:    /* If the locale doesn't define a decimal point, or if the decimal
        -: 2760:       point is multibyte, use the C locale's decimal point.  FIXME:
        -: 2761:       add support for multibyte decimal points.  */
       12: 2762:    decimal_point = to_uchar (locale->decimal_point[0]);
       12: 2763:    if (! decimal_point || locale->decimal_point[1])
    #####: 2764:      decimal_point = '.';
        -: 2765:
        -: 2766:    /* FIXME: add support for multibyte thousands separators.  */
       12: 2767:    thousands_sep = to_uchar (*locale->thousands_sep);
       12: 2768:    if (! thousands_sep || locale->thousands_sep[1])
       12: 2769:      thousands_sep = -1;
        -: 2770:  }
        -: 2771:
       12: 2772:  have_read_stdin = false;
       12: 2773:  inittables ();
        -: 2774:
        -: 2775:  {
        -: 2776:    size_t i;
        -: 2777:    static int const sig[] =
        -: 2778:      {
        -: 2779:	/* The usual suspects.  */
        -: 2780:	SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
        -: 2781:#ifdef SIGPOLL
        -: 2782:	SIGPOLL,
        -: 2783:#endif
        -: 2784:#ifdef SIGPROF
        -: 2785:	SIGPROF,
        -: 2786:#endif
        -: 2787:#ifdef SIGVTALRM
        -: 2788:	SIGVTALRM,
        -: 2789:#endif
        -: 2790:#ifdef SIGXCPU
        -: 2791:	SIGXCPU,
        -: 2792:#endif
        -: 2793:#ifdef SIGXFSZ
        -: 2794:	SIGXFSZ,
        -: 2795:#endif
        -: 2796:      };
        -: 2797:    enum { nsigs = sizeof sig / sizeof sig[0] };
        -: 2798:
        -: 2799:#if SA_NOCLDSTOP
        -: 2800:    struct sigaction act;
        -: 2801:
       12: 2802:    sigemptyset (&caught_signals);
      144: 2803:    for (i = 0; i < nsigs; i++)
        -: 2804:      {
      132: 2805:	sigaction (sig[i], NULL, &act);
      132: 2806:	if (act.sa_handler != SIG_IGN)
      132: 2807:	  sigaddset (&caught_signals, sig[i]);
        -: 2808:      }
        -: 2809:
       12: 2810:    act.sa_handler = sighandler;
       12: 2811:    act.sa_mask = caught_signals;
       12: 2812:    act.sa_flags = 0;
        -: 2813:
      144: 2814:    for (i = 0; i < nsigs; i++)
      132: 2815:      if (sigismember (&caught_signals, sig[i]))
      132: 2816:	sigaction (sig[i], &act, NULL);
        -: 2817:#else
        -: 2818:    for (i = 0; i < nsigs; i++)
        -: 2819:      if (signal (sig[i], SIG_IGN) != SIG_IGN)
        -: 2820:	{
        -: 2821:	  signal (sig[i], sighandler);
        -: 2822:	  siginterrupt (sig[i], 1);
        -: 2823:	}
        -: 2824:#endif
        -: 2825:  }
        -: 2826:
        -: 2827:  /* The signal mask is known, so it is safe to invoke exit_cleanup.  */
       12: 2828:  atexit (exit_cleanup);
        -: 2829:
       12: 2830:  gkey.sword = gkey.eword = SIZE_MAX;
       12: 2831:  gkey.ignore = NULL;
       12: 2832:  gkey.translate = NULL;
       12: 2833:  gkey.numeric = gkey.general_numeric = gkey.random = false;
       12: 2834:  gkey.month = gkey.reverse = false;
       12: 2835:  gkey.skipsblanks = gkey.skipeblanks = false;
        -: 2836:
       12: 2837:  files = xnmalloc (argc, sizeof *files);
        -: 2838:
        -: 2839:  for (;;)
        -: 2840:    {
        -: 2841:      /* Parse an operand as a file after "--" was seen; or if
        -: 2842:	 pedantic and a file was seen, unless the POSIX version
        -: 2843:	 predates 1003.1-2001 and -c was not seen and the operand is
        -: 2844:	 "-o FILE" or "-oFILE".  */
       22: 2845:      int oi = -1;
        -: 2846:
       22: 2847:      if (c == -1
       22: 2848:	  || (posixly_correct && nfiles != 0
    #####: 2849:	      && ! (obsolete_usage
    #####: 2850:		    && ! checkonly
    #####: 2851:		    && optind != argc
    #####: 2852:		    && argv[optind][0] == '-' && argv[optind][1] == 'o'
    #####: 2853:		    && (argv[optind][2] || optind + 1 != argc)))
       22: 2854:	  || ((c = getopt_long (argc, argv, short_options,
        -: 2855:				long_options, &oi))
        -: 2856:	      == -1))
        -: 2857:	{
       12: 2858:	  if (argc <= optind)
       12: 2859:	    break;
    #####: 2860:	  files[nfiles++] = argv[optind++];
        -: 2861:	}
       10: 2862:      else switch (c)
        -: 2863:	{
        -: 2864:	case 1:
    #####: 2865:	  key = NULL;
    #####: 2866:	  if (optarg[0] == '+')
        -: 2867:	    {
    #####: 2868:	      bool minus_pos_usage = (optind != argc && argv[optind][0] == '-'
    #####: 2869:				      && ISDIGIT (argv[optind][1]));
    #####: 2870:	      obsolete_usage |= minus_pos_usage & ~posixly_correct;
    #####: 2871:	      if (obsolete_usage)
        -: 2872:		{
        -: 2873:		  /* Treat +POS1 [-POS2] as a key if possible; but silently
        -: 2874:		     treat an operand as a file if it is not a valid +POS1.  */
    #####: 2875:		  key = key_init (&key_buf);
    #####: 2876:		  s = parse_field_count (optarg + 1, &key->sword, NULL);
    #####: 2877:		  if (s && *s == '.')
    #####: 2878:		    s = parse_field_count (s + 1, &key->schar, NULL);
    #####: 2879:		  if (! (key->sword | key->schar))
    #####: 2880:		    key->sword = SIZE_MAX;
    #####: 2881:		  if (! s || *set_ordering (s, key, bl_start))
    #####: 2882:		    key = NULL;
        -: 2883:		  else
        -: 2884:		    {
    #####: 2885:		      if (minus_pos_usage)
        -: 2886:			{
    #####: 2887:			  char const *optarg1 = argv[optind++];
    #####: 2888:			  s = parse_field_count (optarg1 + 1, &key->eword,
        -: 2889:					     N_("invalid number after `-'"));
    #####: 2890:			  if (*s == '.')
    #####: 2891:			    s = parse_field_count (s + 1, &key->echar,
        -: 2892:					       N_("invalid number after `.'"));
    #####: 2893:			  if (*set_ordering (s, key, bl_end))
    #####: 2894:			    badfieldspec (optarg1,
        -: 2895:				      N_("stray character in field spec"));
        -: 2896:			}
    #####: 2897:		      insertkey (key);
        -: 2898:		    }
        -: 2899:		}
        -: 2900:	    }
    #####: 2901:	  if (! key)
    #####: 2902:	    files[nfiles++] = optarg;
    #####: 2903:	  break;
        -: 2904:
        -: 2905:	case 'b':
        -: 2906:	case 'd':
        -: 2907:	case 'f':
        -: 2908:	case 'g':
        -: 2909:	case 'i':
        -: 2910:	case 'M':
        -: 2911:	case 'n':
        -: 2912:	case 'r':
        -: 2913:	case 'R':
        -: 2914:	  {
        -: 2915:	    char str[2];
    #####: 2916:	    str[0] = c;
    #####: 2917:	    str[1] = '\0';
    #####: 2918:	    set_ordering (str, &gkey, bl_both);
        -: 2919:	  }
    #####: 2920:	  break;
        -: 2921:
        -: 2922:	case CHECK_OPTION:
    #####: 2923:	  c = (optarg
    #####: 2924:	       ? XARGMATCH ("--check", optarg, check_args, check_types)
    #####: 2925:	       : 'c');
        -: 2926:	  /* Fall through.  */
        -: 2927:	case 'c':
        -: 2928:	case 'C':
    #####: 2929:	  if (checkonly && checkonly != c)
    #####: 2930:	    incompatible_options ("cC");
    #####: 2931:	  checkonly = c;
    #####: 2932:	  break;
        -: 2933:
        -: 2934:	case COMPRESS_PROGRAM_OPTION:
    #####: 2935:	  if (compress_program && !STREQ (compress_program, optarg))
    #####: 2936:	    error (SORT_FAILURE, 0, _("multiple compress programs specified"));
    #####: 2937:	  compress_program = optarg;
    #####: 2938:	  break;
        -: 2939:
        -: 2940:	case 'k':
    #####: 2941:	  key = key_init (&key_buf);
        -: 2942:
        -: 2943:	  /* Get POS1. */
    #####: 2944:	  s = parse_field_count (optarg, &key->sword,
        -: 2945:				 N_("invalid number at field start"));
    #####: 2946:	  if (! key->sword--)
        -: 2947:	    {
        -: 2948:	      /* Provoke with `sort -k0' */
    #####: 2949:	      badfieldspec (optarg, N_("field number is zero"));
        -: 2950:	    }
    #####: 2951:	  if (*s == '.')
        -: 2952:	    {
    #####: 2953:	      s = parse_field_count (s + 1, &key->schar,
        -: 2954:				     N_("invalid number after `.'"));
    #####: 2955:	      if (! key->schar--)
        -: 2956:		{
        -: 2957:		  /* Provoke with `sort -k1.0' */
    #####: 2958:		  badfieldspec (optarg, N_("character offset is zero"));
        -: 2959:		}
        -: 2960:	    }
    #####: 2961:	  if (! (key->sword | key->schar))
    #####: 2962:	    key->sword = SIZE_MAX;
    #####: 2963:	  s = set_ordering (s, key, bl_start);
    #####: 2964:	  if (*s != ',')
        -: 2965:	    {
    #####: 2966:	      key->eword = SIZE_MAX;
    #####: 2967:	      key->echar = 0;
        -: 2968:	    }
        -: 2969:	  else
        -: 2970:	    {
        -: 2971:	      /* Get POS2. */
    #####: 2972:	      s = parse_field_count (s + 1, &key->eword,
        -: 2973:				     N_("invalid number after `,'"));
    #####: 2974:	      if (! key->eword--)
        -: 2975:		{
        -: 2976:		  /* Provoke with `sort -k1,0' */
    #####: 2977:		  badfieldspec (optarg, N_("field number is zero"));
        -: 2978:		}
    #####: 2979:	      if (*s == '.')
    #####: 2980:		s = parse_field_count (s + 1, &key->echar,
        -: 2981:				       N_("invalid number after `.'"));
        -: 2982:	      else
        -: 2983:		{
        -: 2984:		  /* `-k 2,3' is equivalent to `+1 -3'.  */
    #####: 2985:		  key->eword++;
        -: 2986:		}
    #####: 2987:	      s = set_ordering (s, key, bl_end);
        -: 2988:	    }
    #####: 2989:	  if (*s)
    #####: 2990:	    badfieldspec (optarg, N_("stray character in field spec"));
    #####: 2991:	  insertkey (key);
    #####: 2992:	  break;
        -: 2993:
        -: 2994:	case 'm':
    #####: 2995:	  mergeonly = true;
    #####: 2996:	  break;
        -: 2997:
        -: 2998:	case 'o':
    #####: 2999:	  if (outfile && !STREQ (outfile, optarg))
    #####: 3000:	    error (SORT_FAILURE, 0, _("multiple output files specified"));
    #####: 3001:	  outfile = optarg;
    #####: 3002:	  break;
        -: 3003:
        -: 3004:	case RANDOM_SOURCE_OPTION:
    #####: 3005:	  if (random_source && !STREQ (random_source, optarg))
    #####: 3006:	    error (SORT_FAILURE, 0, _("multiple random sources specified"));
    #####: 3007:	  random_source = optarg;
    #####: 3008:	  break;
        -: 3009:
        -: 3010:	case 's':
    #####: 3011:	  stable = true;
    #####: 3012:	  break;
        -: 3013:
        -: 3014:	case 'S':
    #####: 3015:	  specify_sort_size (oi, c, optarg);
    #####: 3016:	  break;
        -: 3017:
        -: 3018:	case 't':
        -: 3019:	  {
    #####: 3020:	    char newtab = optarg[0];
    #####: 3021:	    if (! newtab)
    #####: 3022:	      error (SORT_FAILURE, 0, _("empty tab"));
    #####: 3023:	    if (optarg[1])
        -: 3024:	      {
    #####: 3025:		if (STREQ (optarg, "\\0"))
    #####: 3026:		  newtab = '\0';
        -: 3027:		else
        -: 3028:		  {
        -: 3029:		    /* Provoke with `sort -txx'.  Complain about
        -: 3030:		       "multi-character tab" instead of "multibyte tab", so
        -: 3031:		       that the diagnostic's wording does not need to be
        -: 3032:		       changed once multibyte characters are supported.  */
    #####: 3033:		    error (SORT_FAILURE, 0, _("multi-character tab %s"),
        -: 3034:			   quote (optarg));
        -: 3035:		  }
        -: 3036:	      }
    #####: 3037:	    if (tab != TAB_DEFAULT && tab != newtab)
    #####: 3038:	      error (SORT_FAILURE, 0, _("incompatible tabs"));
    #####: 3039:	    tab = newtab;
        -: 3040:	  }
    #####: 3041:	  break;
        -: 3042:
        -: 3043:	case 'T':
    #####: 3044:	  add_temp_dir (optarg);
    #####: 3045:	  break;
        -: 3046:
        -: 3047:	case 'u':
       10: 3048:	  unique = true;
       10: 3049:	  break;
        -: 3050:
        -: 3051:	case 'y':
        -: 3052:	  /* Accept and ignore e.g. -y0 for compatibility with Solaris 2.x
        -: 3053:	     through Solaris 7.  It is also accepted by many non-Solaris
        -: 3054:	     "sort" implementations, e.g., AIX 5.2, HP-UX 11i v2, IRIX 6.5.
        -: 3055:	     -y is marked as obsolete starting with Solaris 8 (1999), but is
        -: 3056:	     still accepted as of Solaris 10 prerelease (2004).
        -: 3057:
        -: 3058:	     Solaris 2.5.1 "sort -y 100" reads the input file "100", but
        -: 3059:	     emulate Solaris 8 and 9 "sort -y 100" which ignores the "100",
        -: 3060:	     and which in general ignores the argument after "-y" if it
        -: 3061:	     consists entirely of digits (it can even be empty).  */
    #####: 3062:	  if (optarg == argv[optind - 1])
        -: 3063:	    {
        -: 3064:	      char const *p;
    #####: 3065:	      for (p = optarg; ISDIGIT (*p); p++)
    #####: 3066:		continue;
    #####: 3067:	      optind -= (*p != '\0');
        -: 3068:	    }
    #####: 3069:	  break;
        -: 3070:
        -: 3071:	case 'z':
    #####: 3072:	  eolchar = 0;
    #####: 3073:	  break;
        -: 3074:
    #####: 3075:	case_GETOPT_HELP_CHAR;
        -: 3076:
    #####: 3077:	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -: 3078:
        -: 3079:	default:
    #####: 3080:	  usage (SORT_FAILURE);
        -: 3081:	}
       10: 3082:    }
        -: 3083:
        -: 3084:  /* Inheritance of global options to individual keys. */
       12: 3085:  for (key = keylist; key; key = key->next)
        -: 3086:    {
    #####: 3087:      if (! (key->ignore || key->translate
    #####: 3088:             || (key->skipsblanks | key->reverse
    #####: 3089:                 | key->skipeblanks | key->month | key->numeric
    #####: 3090:                 | key->general_numeric
    #####: 3091:                 | key->random)))
        -: 3092:        {
    #####: 3093:          key->ignore = gkey.ignore;
    #####: 3094:          key->translate = gkey.translate;
    #####: 3095:          key->skipsblanks = gkey.skipsblanks;
    #####: 3096:          key->skipeblanks = gkey.skipeblanks;
    #####: 3097:          key->month = gkey.month;
    #####: 3098:          key->numeric = gkey.numeric;
    #####: 3099:          key->general_numeric = gkey.general_numeric;
    #####: 3100:          key->random = gkey.random;
    #####: 3101:          key->reverse = gkey.reverse;
        -: 3102:        }
        -: 3103:
    #####: 3104:      need_random |= key->random;
        -: 3105:    }
        -: 3106:
       12: 3107:  if (!keylist && (gkey.ignore || gkey.translate
       24: 3108:		   || (gkey.skipsblanks | gkey.skipeblanks | gkey.month
       12: 3109:		       | gkey.numeric | gkey.general_numeric
       12: 3110:                       | gkey.random)))
        -: 3111:    {
    #####: 3112:      insertkey (&gkey);
    #####: 3113:      need_random |= gkey.random;
        -: 3114:    }
        -: 3115:
       12: 3116:  check_ordering_compatibility ();
        -: 3117:
       12: 3118:  reverse = gkey.reverse;
        -: 3119:
       12: 3120:  if (need_random)
        -: 3121:    {
    #####: 3122:      randread_source = randread_new (random_source, MD5_DIGEST_SIZE);
    #####: 3123:      if (! randread_source)
    #####: 3124:	die (_("open failed"), random_source);
        -: 3125:    }
        -: 3126:
       12: 3127:  if (temp_dir_count == 0)
        -: 3128:    {
       12: 3129:      char const *tmp_dir = getenv ("TMPDIR");
       12: 3130:      add_temp_dir (tmp_dir ? tmp_dir : DEFAULT_TMPDIR);
        -: 3131:    }
        -: 3132:
       12: 3133:  if (nfiles == 0)
        -: 3134:    {
        -: 3135:      static char *minus = "-";
       12: 3136:      nfiles = 1;
       12: 3137:      free (files);
       12: 3138:      files = &minus;
        -: 3139:    }
        -: 3140:
       12: 3141:  if (checkonly)
        -: 3142:    {
    #####: 3143:      if (nfiles > 1)
    #####: 3144:	error (SORT_FAILURE, 0, _("extra operand %s not allowed with -%c"),
    #####: 3145:	       quote (files[1]), checkonly);
        -: 3146:
    #####: 3147:      if (outfile)
        -: 3148:	{
        -: 3149:	  static char opts[] = {0, 'o', 0};
    #####: 3150:	  opts[0] = checkonly;
    #####: 3151:	  incompatible_options (opts);
        -: 3152:	}
        -: 3153:
        -: 3154:      /* POSIX requires that sort return 1 IFF invoked with -c or -C and the
        -: 3155:	 input is not properly sorted.  */
    #####: 3156:      exit (check (files[0], checkonly) ? EXIT_SUCCESS : SORT_OUT_OF_ORDER);
        -: 3157:    }
        -: 3158:
       12: 3159:  if (mergeonly)
        -: 3160:    {
    #####: 3161:      struct sortfile *sortfiles = xcalloc (nfiles, sizeof *sortfiles);
        -: 3162:      size_t i;
        -: 3163:
    #####: 3164:      for (i = 0; i < nfiles; ++i)
    #####: 3165:	sortfiles[i].name = files[i];
        -: 3166:
    #####: 3167:      merge (sortfiles, 0, nfiles, outfile);
        -: 3168:      IF_LINT (free (sortfiles));
        -: 3169:    }
        -: 3170:  else
       12: 3171:    sort (files, nfiles, outfile);
        -: 3172:
       12: 3173:  if (have_read_stdin && fclose (stdin) == EOF)
    #####: 3174:    die (_("close failed"), "-");
        -: 3175:
       12: 3176:  exit (EXIT_SUCCESS);
        -: 3177:}
