        -:    0:Source:ls.c
        -:    0:Graph:ls.gcno
        -:    0:Data:ls.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:/* `dir', `vdir' and `ls' directory listing programs for GNU.
        -:    2:   Copyright (C) 85, 88, 90, 91, 1995-2007 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* If ls_mode is LS_MULTI_COL,
        -:   18:   the multi-column format is the default regardless
        -:   19:   of the type of output device.
        -:   20:   This is for the `dir' program.
        -:   21:
        -:   22:   If ls_mode is LS_LONG_FORMAT,
        -:   23:   the long format is the default regardless of the
        -:   24:   type of output device.
        -:   25:   This is for the `vdir' program.
        -:   26:
        -:   27:   If ls_mode is LS_LS,
        -:   28:   the output format depends on whether the output
        -:   29:   device is a terminal.
        -:   30:   This is for the `ls' program.  */
        -:   31:
        -:   32:/* Written by Richard Stallman and David MacKenzie.  */
        -:   33:
        -:   34:/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis
        -:   35:   Flaherty <dennisf@denix.elk.miles.com> based on original patches by
        -:   36:   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */
        -:   37:
        -:   38:#include <config.h>
        -:   39:#include <sys/types.h>
        -:   40:
        -:   41:#if HAVE_TERMIOS_H
        -:   42:# include <termios.h>
        -:   43:#endif
        -:   44:#if HAVE_STROPTS_H
        -:   45:# include <stropts.h>
        -:   46:#endif
        -:   47:#if HAVE_SYS_IOCTL_H
        -:   48:# include <sys/ioctl.h>
        -:   49:#endif
        -:   50:
        -:   51:#ifdef WINSIZE_IN_PTEM
        -:   52:# include <sys/stream.h>
        -:   53:# include <sys/ptem.h>
        -:   54:#endif
        -:   55:
        -:   56:#include <stdio.h>
        -:   57:#include <assert.h>
        -:   58:#include <setjmp.h>
        -:   59:#include <grp.h>
        -:   60:#include <pwd.h>
        -:   61:#include <getopt.h>
        -:   62:#include <signal.h>
        -:   63:#include <selinux/selinux.h>
        -:   64:#include <wchar.h>
        -:   65:
        -:   66:/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
        -:   67:   present.  */
        -:   68:#ifndef SA_NOCLDSTOP
        -:   69:# define SA_NOCLDSTOP 0
        -:   70:# define sigprocmask(How, Set, Oset) /* empty */
        -:   71:# define sigset_t int
        -:   72:# if ! HAVE_SIGINTERRUPT
        -:   73:#  define siginterrupt(sig, flag) /* empty */
        -:   74:# endif
        -:   75:#endif
        -:   76:#ifndef SA_RESTART
        -:   77:# define SA_RESTART 0
        -:   78:#endif
        -:   79:
        -:   80:#include "system.h"
        -:   81:#include <fnmatch.h>
        -:   82:
        -:   83:#include "acl.h"
        -:   84:#include "argmatch.h"
        -:   85:#include "dev-ino.h"
        -:   86:#include "dirfd.h"
        -:   87:#include "error.h"
        -:   88:#include "filenamecat.h"
        -:   89:#include "hard-locale.h"
        -:   90:#include "hash.h"
        -:   91:#include "human.h"
        -:   92:#include "filemode.h"
        -:   93:#include "idcache.h"
        -:   94:#include "inttostr.h"
        -:   95:#include "ls.h"
        -:   96:#include "lstat.h"
        -:   97:#include "mbswidth.h"
        -:   98:#include "mpsort.h"
        -:   99:#include "obstack.h"
        -:  100:#include "quote.h"
        -:  101:#include "quotearg.h"
        -:  102:#include "same.h"
        -:  103:#include "stat-time.h"
        -:  104:#include "strftime.h"
        -:  105:#include "strverscmp.h"
        -:  106:#include "xstrtol.h"
        -:  107:#include "areadlink.h"
        -:  108:
        -:  109:#define PROGRAM_NAME (ls_mode == LS_LS ? "ls" \
        -:  110:		      : (ls_mode == LS_MULTI_COL \
        -:  111:			 ? "dir" : "vdir"))
        -:  112:
        -:  113:#define AUTHORS "Richard Stallman", "David MacKenzie"
        -:  114:
        -:  115:#define obstack_chunk_alloc malloc
        -:  116:#define obstack_chunk_free free
        -:  117:
        -:  118:/* Return an int indicating the result of comparing two integers.
        -:  119:   Subtracting doesn't always work, due to overflow.  */
        -:  120:#define longdiff(a, b) ((a) < (b) ? -1 : (a) > (b))
        -:  121:
        -:  122:#if ! HAVE_STRUCT_STAT_ST_AUTHOR
        -:  123:# define st_author st_uid
        -:  124:#endif
        -:  125:
        -:  126:enum filetype
        -:  127:  {
        -:  128:    unknown,
        -:  129:    fifo,
        -:  130:    chardev,
        -:  131:    directory,
        -:  132:    blockdev,
        -:  133:    normal,
        -:  134:    symbolic_link,
        -:  135:    sock,
        -:  136:    whiteout,
        -:  137:    arg_directory
        -:  138:  };
        -:  139:
        -:  140:/* Display letters and indicators for each filetype.
        -:  141:   Keep these in sync with enum filetype.  */
        -:  142:static char const filetype_letter[] = "?pcdb-lswd";
        -:  143:
        -:  144:/* Ensure that filetype and filetype_letter have the same
        -:  145:   number of elements.  */
        -:  146:verify (sizeof filetype_letter - 1 == arg_directory + 1);
        -:  147:
        -:  148:#define FILETYPE_INDICATORS				\
        -:  149:  {							\
        -:  150:    C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE,	\
        -:  151:    C_LINK, C_SOCK, C_FILE, C_DIR			\
        -:  152:  }
        -:  153:
        -:  154:
        -:  155:struct fileinfo
        -:  156:  {
        -:  157:    /* The file name.  */
        -:  158:    char *name;
        -:  159:
        -:  160:    /* For symbolic link, name of the file linked to, otherwise zero.  */
        -:  161:    char *linkname;
        -:  162:
        -:  163:    struct stat stat;
        -:  164:
        -:  165:    enum filetype filetype;
        -:  166:
        -:  167:    /* For symbolic link and long listing, st_mode of file linked to, otherwise
        -:  168:       zero.  */
        -:  169:    mode_t linkmode;
        -:  170:
        -:  171:    /* SELinux security context.  */
        -:  172:    security_context_t scontext;
        -:  173:
        -:  174:    bool stat_ok;
        -:  175:
        -:  176:    /* For symbolic link and color printing, true if linked-to file
        -:  177:       exists, otherwise false.  */
        -:  178:    bool linkok;
        -:  179:
        -:  180:    /* For long listings, true if the file has an access control list,
        -:  181:       or an SELinux security context.  */
        -:  182:    bool have_acl;
        -:  183:  };
        -:  184:
        -:  185:#define LEN_STR_PAIR(s) sizeof (s) - 1, s
        -:  186:
        -:  187:/* Null is a valid character in a color indicator (think about Epson
        -:  188:   printers, for example) so we have to use a length/buffer string
        -:  189:   type.  */
        -:  190:
        -:  191:struct bin_str
        -:  192:  {
        -:  193:    size_t len;			/* Number of bytes */
        -:  194:    const char *string;		/* Pointer to the same */
        -:  195:  };
        -:  196:
        -:  197:#if ! HAVE_TCGETPGRP
        -:  198:# define tcgetpgrp(Fd) 0
        -:  199:#endif
        -:  200:
        -:  201:static size_t quote_name (FILE *out, const char *name,
        -:  202:			  struct quoting_options const *options,
        -:  203:			  size_t *width);
        -:  204:static char *make_link_name (char const *name, char const *linkname);
        -:  205:static int decode_switches (int argc, char **argv);
        -:  206:static bool file_ignored (char const *name);
        -:  207:static uintmax_t gobble_file (char const *name, enum filetype type,
        -:  208:			      ino_t inode, bool command_line_arg,
        -:  209:			      char const *dirname);
        -:  210:static void print_color_indicator (const char *name, mode_t mode, int linkok,
        -:  211:				   bool stat_ok, enum filetype type);
        -:  212:static void put_indicator (const struct bin_str *ind);
        -:  213:static void add_ignore_pattern (const char *pattern);
        -:  214:static void attach (char *dest, const char *dirname, const char *name);
        -:  215:static void clear_files (void);
        -:  216:static void extract_dirs_from_files (char const *dirname,
        -:  217:				     bool command_line_arg);
        -:  218:static void get_link_name (char const *filename, struct fileinfo *f,
        -:  219:			   bool command_line_arg);
        -:  220:static void indent (size_t from, size_t to);
        -:  221:static size_t calculate_columns (bool by_columns);
        -:  222:static void print_current_files (void);
        -:  223:static void print_dir (char const *name, char const *realname,
        -:  224:		       bool command_line_arg);
        -:  225:static void print_file_name_and_frills (const struct fileinfo *f);
        -:  226:static void print_horizontal (void);
        -:  227:static int format_user_width (uid_t u);
        -:  228:static int format_group_width (gid_t g);
        -:  229:static void print_long_format (const struct fileinfo *f);
        -:  230:static void print_many_per_line (void);
        -:  231:static void print_name_with_quoting (const char *p, mode_t mode,
        -:  232:				     int linkok, bool stat_ok,
        -:  233:				     enum filetype type,
        -:  234:				     struct obstack *stack);
        -:  235:static void prep_non_filename_text (void);
        -:  236:static void print_type_indicator (bool stat_ok, mode_t mode,
        -:  237:				  enum filetype type);
        -:  238:static void print_with_commas (void);
        -:  239:static void queue_directory (char const *name, char const *realname,
        -:  240:			     bool command_line_arg);
        -:  241:static void sort_files (void);
        -:  242:static void parse_ls_color (void);
        -:  243:void usage (int status);
        -:  244:
        -:  245:/* The name this program was run with.  */
        -:  246:char *program_name;
        -:  247:
        -:  248:/* Initial size of hash table.
        -:  249:   Most hierarchies are likely to be shallower than this.  */
        -:  250:#define INITIAL_TABLE_SIZE 30
        -:  251:
        -:  252:/* The set of `active' directories, from the current command-line argument
        -:  253:   to the level in the hierarchy at which files are being listed.
        -:  254:   A directory is represented by its device and inode numbers (struct dev_ino).
        -:  255:   A directory is added to this set when ls begins listing it or its
        -:  256:   entries, and it is removed from the set just after ls has finished
        -:  257:   processing it.  This set is used solely to detect loops, e.g., with
        -:  258:   mkdir loop; cd loop; ln -s ../loop sub; ls -RL  */
        -:  259:static Hash_table *active_dir_set;
        -:  260:
        -:  261:#define LOOP_DETECT (!!active_dir_set)
        -:  262:
        -:  263:/* The table of files in the current directory:
        -:  264:
        -:  265:   `cwd_file' points to a vector of `struct fileinfo', one per file.
        -:  266:   `cwd_n_alloc' is the number of elements space has been allocated for.
        -:  267:   `cwd_n_used' is the number actually in use.  */
        -:  268:
        -:  269:/* Address of block containing the files that are described.  */
        -:  270:static struct fileinfo *cwd_file;
        -:  271:
        -:  272:/* Length of block that `cwd_file' points to, measured in files.  */
        -:  273:static size_t cwd_n_alloc;
        -:  274:
        -:  275:/* Index of first unused slot in `cwd_file'.  */
        -:  276:static size_t cwd_n_used;
        -:  277:
        -:  278:/* Vector of pointers to files, in proper sorted order, and the number
        -:  279:   of entries allocated for it.  */
        -:  280:static void **sorted_file;
        -:  281:static size_t sorted_file_alloc;
        -:  282:
        -:  283:/* When true, in a color listing, color each symlink name according to the
        -:  284:   type of file it points to.  Otherwise, color them according to the `ln'
        -:  285:   directive in LS_COLORS.  Dangling (orphan) symlinks are treated specially,
        -:  286:   regardless.  This is set when `ln=target' appears in LS_COLORS.  */
        -:  287:
        -:  288:static bool color_symlink_as_referent;
        -:  289:
        -:  290:/* mode of appropriate file for colorization */
        -:  291:#define FILE_OR_LINK_MODE(File) \
        -:  292:    ((color_symlink_as_referent & (File)->linkok) \
        -:  293:     ? (File)->linkmode : (File)->stat.st_mode)
        -:  294:
        -:  295:
        -:  296:/* Record of one pending directory waiting to be listed.  */
        -:  297:
        -:  298:struct pending
        -:  299:  {
        -:  300:    char *name;
        -:  301:    /* If the directory is actually the file pointed to by a symbolic link we
        -:  302:       were told to list, `realname' will contain the name of the symbolic
        -:  303:       link, otherwise zero.  */
        -:  304:    char *realname;
        -:  305:    bool command_line_arg;
        -:  306:    struct pending *next;
        -:  307:  };
        -:  308:
        -:  309:static struct pending *pending_dirs;
        -:  310:
        -:  311:/* Current time in seconds and nanoseconds since 1970, updated as
        -:  312:   needed when deciding whether a file is recent.  */
        -:  313:
        -:  314:static time_t current_time = TYPE_MINIMUM (time_t);
        -:  315:static int current_time_ns = -1;
        -:  316:
        -:  317:static bool print_scontext;
        -:  318:
        -:  319:/* Whether any of the files has an ACL.  This affects the width of the
        -:  320:   mode column.  */
        -:  321:
        -:  322:static bool any_has_acl;
        -:  323:
        -:  324:/* The number of columns to use for columns containing inode numbers,
        -:  325:   block sizes, link counts, owners, groups, authors, major device
        -:  326:   numbers, minor device numbers, and file sizes, respectively.  */
        -:  327:
        -:  328:static int inode_number_width;
        -:  329:static int block_size_width;
        -:  330:static int nlink_width;
        -:  331:static int scontext_width;
        -:  332:static int owner_width;
        -:  333:static int group_width;
        -:  334:static int author_width;
        -:  335:static int major_device_number_width;
        -:  336:static int minor_device_number_width;
        -:  337:static int file_size_width;
        -:  338:
        -:  339:/* Option flags */
        -:  340:
        -:  341:/* long_format for lots of info, one per line.
        -:  342:   one_per_line for just names, one per line.
        -:  343:   many_per_line for just names, many per line, sorted vertically.
        -:  344:   horizontal for just names, many per line, sorted horizontally.
        -:  345:   with_commas for just names, many per line, separated by commas.
        -:  346:
        -:  347:   -l (and other options that imply -l), -1, -C, -x and -m control
        -:  348:   this parameter.  */
        -:  349:
        -:  350:enum format
        -:  351:  {
        -:  352:    long_format,		/* -l and other options that imply -l */
        -:  353:    one_per_line,		/* -1 */
        -:  354:    many_per_line,		/* -C */
        -:  355:    horizontal,			/* -x */
        -:  356:    with_commas			/* -m */
        -:  357:  };
        -:  358:
        -:  359:static enum format format;
        -:  360:
        -:  361:/* `full-iso' uses full ISO-style dates and times.  `long-iso' uses longer
        -:  362:   ISO-style time stamps, though shorter than `full-iso'.  `iso' uses shorter
        -:  363:   ISO-style time stamps.  `locale' uses locale-dependent time stamps.  */
        -:  364:enum time_style
        -:  365:  {
        -:  366:    full_iso_time_style,	/* --time-style=full-iso */
        -:  367:    long_iso_time_style,	/* --time-style=long-iso */
        -:  368:    iso_time_style,		/* --time-style=iso */
        -:  369:    locale_time_style		/* --time-style=locale */
        -:  370:  };
        -:  371:
        -:  372:static char const *const time_style_args[] =
        -:  373:{
        -:  374:  "full-iso", "long-iso", "iso", "locale", NULL
        -:  375:};
        -:  376:static enum time_style const time_style_types[] =
        -:  377:{
        -:  378:  full_iso_time_style, long_iso_time_style, iso_time_style,
        -:  379:  locale_time_style
        -:  380:};
        -:  381:ARGMATCH_VERIFY (time_style_args, time_style_types);
        -:  382:
        -:  383:/* Type of time to print or sort by.  Controlled by -c and -u.
        -:  384:   The values of each item of this enum are important since they are
        -:  385:   used as indices in the sort functions array (see sort_files()).  */
        -:  386:
        -:  387:enum time_type
        -:  388:  {
        -:  389:    time_mtime,			/* default */
        -:  390:    time_ctime,			/* -c */
        -:  391:    time_atime,			/* -u */
        -:  392:    time_numtypes		/* the number of elements of this enum */
        -:  393:  };
        -:  394:
        -:  395:static enum time_type time_type;
        -:  396:
        -:  397:/* The file characteristic to sort by.  Controlled by -t, -S, -U, -X, -v.
        -:  398:   The values of each item of this enum are important since they are
        -:  399:   used as indices in the sort functions array (see sort_files()).  */
        -:  400:
        -:  401:enum sort_type
        -:  402:  {
        -:  403:    sort_none = -1,		/* -U */
        -:  404:    sort_name,			/* default */
        -:  405:    sort_extension,		/* -X */
        -:  406:    sort_size,			/* -S */
        -:  407:    sort_version,		/* -v */
        -:  408:    sort_time,			/* -t */
        -:  409:    sort_numtypes		/* the number of elements of this enum */
        -:  410:  };
        -:  411:
        -:  412:static enum sort_type sort_type;
        -:  413:
        -:  414:/* Direction of sort.
        -:  415:   false means highest first if numeric,
        -:  416:   lowest first if alphabetic;
        -:  417:   these are the defaults.
        -:  418:   true means the opposite order in each case.  -r  */
        -:  419:
        -:  420:static bool sort_reverse;
        -:  421:
        -:  422:/* True means to display owner information.  -g turns this off.  */
        -:  423:
        -:  424:static bool print_owner = true;
        -:  425:
        -:  426:/* True means to display author information.  */
        -:  427:
        -:  428:static bool print_author;
        -:  429:
        -:  430:/* True means to display group information.  -G and -o turn this off.  */
        -:  431:
        -:  432:static bool print_group = true;
        -:  433:
        -:  434:/* True means print the user and group id's as numbers rather
        -:  435:   than as names.  -n  */
        -:  436:
        -:  437:static bool numeric_ids;
        -:  438:
        -:  439:/* True means mention the size in blocks of each file.  -s  */
        -:  440:
        -:  441:static bool print_block_size;
        -:  442:
        -:  443:/* Human-readable options for output.  */
        -:  444:static int human_output_opts;
        -:  445:
        -:  446:/* The units to use when printing sizes other than file sizes.  */
        -:  447:static uintmax_t output_block_size;
        -:  448:
        -:  449:/* Likewise, but for file sizes.  */
        -:  450:static uintmax_t file_output_block_size = 1;
        -:  451:
        -:  452:/* Follow the output with a special string.  Using this format,
        -:  453:   Emacs' dired mode starts up twice as fast, and can handle all
        -:  454:   strange characters in file names.  */
        -:  455:static bool dired;
        -:  456:
        -:  457:/* `none' means don't mention the type of files.
        -:  458:   `slash' means mention directories only, with a '/'.
        -:  459:   `file_type' means mention file types.
        -:  460:   `classify' means mention file types and mark executables.
        -:  461:
        -:  462:   Controlled by -F, -p, and --indicator-style.  */
        -:  463:
        -:  464:enum indicator_style
        -:  465:  {
        -:  466:    none,	/*     --indicator-style=none */
        -:  467:    slash,	/* -p, --indicator-style=slash */
        -:  468:    file_type,	/*     --indicator-style=file-type */
        -:  469:    classify	/* -F, --indicator-style=classify */
        -:  470:  };
        -:  471:
        -:  472:static enum indicator_style indicator_style;
        -:  473:
        -:  474:/* Names of indicator styles.  */
        -:  475:static char const *const indicator_style_args[] =
        -:  476:{
        -:  477:  "none", "slash", "file-type", "classify", NULL
        -:  478:};
        -:  479:static enum indicator_style const indicator_style_types[] =
        -:  480:{
        -:  481:  none, slash, file_type, classify
        -:  482:};
        -:  483:ARGMATCH_VERIFY (indicator_style_args, indicator_style_types);
        -:  484:
        -:  485:/* True means use colors to mark types.  Also define the different
        -:  486:   colors as well as the stuff for the LS_COLORS environment variable.
        -:  487:   The LS_COLORS variable is now in a termcap-like format.  */
        -:  488:
        -:  489:static bool print_with_color;
        -:  490:
        -:  491:enum color_type
        -:  492:  {
        -:  493:    color_never,		/* 0: default or --color=never */
        -:  494:    color_always,		/* 1: --color=always */
        -:  495:    color_if_tty		/* 2: --color=tty */
        -:  496:  };
        -:  497:
        -:  498:enum Dereference_symlink
        -:  499:  {
        -:  500:    DEREF_UNDEFINED = 1,
        -:  501:    DEREF_NEVER,
        -:  502:    DEREF_COMMAND_LINE_ARGUMENTS,	/* -H */
        -:  503:    DEREF_COMMAND_LINE_SYMLINK_TO_DIR,	/* the default, in certain cases */
        -:  504:    DEREF_ALWAYS			/* -L */
        -:  505:  };
        -:  506:
        -:  507:enum indicator_no
        -:  508:  {
        -:  509:    C_LEFT, C_RIGHT, C_END, C_NORM, C_FILE, C_DIR, C_LINK, C_FIFO, C_SOCK,
        -:  510:    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,
        -:  511:    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE
        -:  512:  };
        -:  513:
        -:  514:static const char *const indicator_name[]=
        -:  515:  {
        -:  516:    "lc", "rc", "ec", "no", "fi", "di", "ln", "pi", "so",
        -:  517:    "bd", "cd", "mi", "or", "ex", "do", "su", "sg", "st",
        -:  518:    "ow", "tw", NULL
        -:  519:  };
        -:  520:
        -:  521:struct color_ext_type
        -:  522:  {
        -:  523:    struct bin_str ext;		/* The extension we're looking for */
        -:  524:    struct bin_str seq;		/* The sequence to output when we do */
        -:  525:    struct color_ext_type *next;	/* Next in list */
        -:  526:  };
        -:  527:
        -:  528:static struct bin_str color_indicator[] =
        -:  529:  {
        -:  530:    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
        -:  531:    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
        -:  532:    { 0, NULL },			/* ec: End color (replaces lc+no+rc) */
        -:  533:    { LEN_STR_PAIR ("0") },		/* no: Normal */
        -:  534:    { LEN_STR_PAIR ("0") },		/* fi: File: default */
        -:  535:    { LEN_STR_PAIR ("01;34") },		/* di: Directory: bright blue */
        -:  536:    { LEN_STR_PAIR ("01;36") },		/* ln: Symlink: bright cyan */
        -:  537:    { LEN_STR_PAIR ("33") },		/* pi: Pipe: yellow/brown */
        -:  538:    { LEN_STR_PAIR ("01;35") },		/* so: Socket: bright magenta */
        -:  539:    { LEN_STR_PAIR ("01;33") },		/* bd: Block device: bright yellow */
        -:  540:    { LEN_STR_PAIR ("01;33") },		/* cd: Char device: bright yellow */
        -:  541:    { 0, NULL },			/* mi: Missing file: undefined */
        -:  542:    { 0, NULL },			/* or: Orphaned symlink: undefined */
        -:  543:    { LEN_STR_PAIR ("01;32") },		/* ex: Executable: bright green */
        -:  544:    { LEN_STR_PAIR ("01;35") },		/* do: Door: bright magenta */
        -:  545:    { LEN_STR_PAIR ("37;41") },		/* su: setuid: white on red */
        -:  546:    { LEN_STR_PAIR ("30;43") },		/* sg: setgid: black on yellow */
        -:  547:    { LEN_STR_PAIR ("37;44") },		/* st: sticky: black on blue */
        -:  548:    { LEN_STR_PAIR ("34;42") },		/* ow: other-writable: blue on green */
        -:  549:    { LEN_STR_PAIR ("30;42") },		/* tw: ow w/ sticky: black on green */
        -:  550:  };
        -:  551:
        -:  552:/* FIXME: comment  */
        -:  553:static struct color_ext_type *color_ext_list = NULL;
        -:  554:
        -:  555:/* Buffer for color sequences */
        -:  556:static char *color_buf;
        -:  557:
        -:  558:/* True means to check for orphaned symbolic link, for displaying
        -:  559:   colors.  */
        -:  560:
        -:  561:static bool check_symlink_color;
        -:  562:
        -:  563:/* True means mention the inode number of each file.  -i  */
        -:  564:
        -:  565:static bool print_inode;
        -:  566:
        -:  567:/* What to do with symbolic links.  Affected by -d, -F, -H, -l (and
        -:  568:   other options that imply -l), and -L.  */
        -:  569:
        -:  570:static enum Dereference_symlink dereference;
        -:  571:
        -:  572:/* True means when a directory is found, display info on its
        -:  573:   contents.  -R  */
        -:  574:
        -:  575:static bool recursive;
        -:  576:
        -:  577:/* True means when an argument is a directory name, display info
        -:  578:   on it itself.  -d  */
        -:  579:
        -:  580:static bool immediate_dirs;
        -:  581:
        -:  582:/* True means that directories are grouped before files. */
        -:  583:
        -:  584:static bool directories_first;
        -:  585:
        -:  586:/* Which files to ignore.  */
        -:  587:
        -:  588:static enum
        -:  589:{
        -:  590:  /* Ignore files whose names start with `.', and files specified by
        -:  591:     --hide and --ignore.  */
        -:  592:  IGNORE_DEFAULT,
        -:  593:
        -:  594:  /* Ignore `.', `..', and files specified by --ignore.  */
        -:  595:  IGNORE_DOT_AND_DOTDOT,
        -:  596:
        -:  597:  /* Ignore only files specified by --ignore.  */
        -:  598:  IGNORE_MINIMAL
        -:  599:} ignore_mode;
        -:  600:
        -:  601:/* A linked list of shell-style globbing patterns.  If a non-argument
        -:  602:   file name matches any of these patterns, it is ignored.
        -:  603:   Controlled by -I.  Multiple -I options accumulate.
        -:  604:   The -B option adds `*~' and `.*~' to this list.  */
        -:  605:
        -:  606:struct ignore_pattern
        -:  607:  {
        -:  608:    const char *pattern;
        -:  609:    struct ignore_pattern *next;
        -:  610:  };
        -:  611:
        -:  612:static struct ignore_pattern *ignore_patterns;
        -:  613:
        -:  614:/* Similar to IGNORE_PATTERNS, except that -a or -A causes this
        -:  615:   variable itself to be ignored.  */
        -:  616:static struct ignore_pattern *hide_patterns;
        -:  617:
        -:  618:/* True means output nongraphic chars in file names as `?'.
        -:  619:   (-q, --hide-control-chars)
        -:  620:   qmark_funny_chars and the quoting style (-Q, --quoting-style=WORD) are
        -:  621:   independent.  The algorithm is: first, obey the quoting style to get a
        -:  622:   string representing the file name;  then, if qmark_funny_chars is set,
        -:  623:   replace all nonprintable chars in that string with `?'.  It's necessary
        -:  624:   to replace nonprintable chars even in quoted strings, because we don't
        -:  625:   want to mess up the terminal if control chars get sent to it, and some
        -:  626:   quoting methods pass through control chars as-is.  */
        -:  627:static bool qmark_funny_chars;
        -:  628:
        -:  629:/* Quoting options for file and dir name output.  */
        -:  630:
        -:  631:static struct quoting_options *filename_quoting_options;
        -:  632:static struct quoting_options *dirname_quoting_options;
        -:  633:
        -:  634:/* The number of chars per hardware tab stop.  Setting this to zero
        -:  635:   inhibits the use of TAB characters for separating columns.  -T */
        -:  636:static size_t tabsize;
        -:  637:
        -:  638:/* True means print each directory name before listing it.  */
        -:  639:
        -:  640:static bool print_dir_name;
        -:  641:
        -:  642:/* The line length to use for breaking lines in many-per-line format.
        -:  643:   Can be set with -w.  */
        -:  644:
        -:  645:static size_t line_length;
        -:  646:
        -:  647:/* If true, the file listing format requires that stat be called on
        -:  648:   each file.  */
        -:  649:
        -:  650:static bool format_needs_stat;
        -:  651:
        -:  652:/* Similar to `format_needs_stat', but set if only the file type is
        -:  653:   needed.  */
        -:  654:
        -:  655:static bool format_needs_type;
        -:  656:
        -:  657:/* An arbitrary limit on the number of bytes in a printed time stamp.
        -:  658:   This is set to a relatively small value to avoid the need to worry
        -:  659:   about denial-of-service attacks on servers that run "ls" on behalf
        -:  660:   of remote clients.  1000 bytes should be enough for any practical
        -:  661:   time stamp format.  */
        -:  662:
        -:  663:enum { TIME_STAMP_LEN_MAXIMUM = MAX (1000, INT_STRLEN_BOUND (time_t)) };
        -:  664:
        -:  665:/* strftime formats for non-recent and recent files, respectively, in
        -:  666:   -l output.  */
        -:  667:
        -:  668:static char const *long_time_format[2] =
        -:  669:  {
        -:  670:    /* strftime format for non-recent files (older than 6 months), in
        -:  671:       -l output.  This should contain the year, month and day (at
        -:  672:       least), in an order that is understood by people in your
        -:  673:       locale's territory.  Please try to keep the number of used
        -:  674:       screen columns small, because many people work in windows with
        -:  675:       only 80 columns.  But make this as wide as the other string
        -:  676:       below, for recent files.  */
        -:  677:    N_("%b %e  %Y"),
        -:  678:    /* strftime format for recent files (younger than 6 months), in -l
        -:  679:       output.  This should contain the month, day and time (at
        -:  680:       least), in an order that is understood by people in your
        -:  681:       locale's territory.  Please try to keep the number of used
        -:  682:       screen columns small, because many people work in windows with
        -:  683:       only 80 columns.  But make this as wide as the other string
        -:  684:       above, for non-recent files.  */
        -:  685:    N_("%b %e %H:%M")
        -:  686:  };
        -:  687:
        -:  688:/* The set of signals that are caught.  */
        -:  689:
        -:  690:static sigset_t caught_signals;
        -:  691:
        -:  692:/* If nonzero, the value of the pending fatal signal.  */
        -:  693:
        -:  694:static sig_atomic_t volatile interrupt_signal;
        -:  695:
        -:  696:/* A count of the number of pending stop signals that have been received.  */
        -:  697:
        -:  698:static sig_atomic_t volatile stop_signal_count;
        -:  699:
        -:  700:/* Desired exit status.  */
        -:  701:
        -:  702:static int exit_status;
        -:  703:
        -:  704:/* Exit statuses.  */
        -:  705:enum
        -:  706:  {
        -:  707:    /* "ls" had a minor problem (e.g., it could not stat a directory
        -:  708:       entry).  */
        -:  709:    LS_MINOR_PROBLEM = 1,
        -:  710:
        -:  711:    /* "ls" had more serious trouble.  */
        -:  712:    LS_FAILURE = 2
        -:  713:  };
        -:  714:
        -:  715:/* For long options that have no equivalent short option, use a
        -:  716:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  717:enum
        -:  718:{
        -:  719:  AUTHOR_OPTION = CHAR_MAX + 1,
        -:  720:  BLOCK_SIZE_OPTION,
        -:  721:  COLOR_OPTION,
        -:  722:  DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION,
        -:  723:  FILE_TYPE_INDICATOR_OPTION,
        -:  724:  FORMAT_OPTION,
        -:  725:  FULL_TIME_OPTION,
        -:  726:  GROUP_DIRECTORIES_FIRST_OPTION,
        -:  727:  HIDE_OPTION,
        -:  728:  INDICATOR_STYLE_OPTION,
        -:  729:  QUOTING_STYLE_OPTION,
        -:  730:  SHOW_CONTROL_CHARS_OPTION,
        -:  731:  SI_OPTION,
        -:  732:  SORT_OPTION,
        -:  733:  TIME_OPTION,
        -:  734:  TIME_STYLE_OPTION
        -:  735:};
        -:  736:
        -:  737:static struct option const long_options[] =
        -:  738:{
        -:  739:  {"all", no_argument, NULL, 'a'},
        -:  740:  {"escape", no_argument, NULL, 'b'},
        -:  741:  {"directory", no_argument, NULL, 'd'},
        -:  742:  {"dired", no_argument, NULL, 'D'},
        -:  743:  {"full-time", no_argument, NULL, FULL_TIME_OPTION},
        -:  744:  {"group-directories-first", no_argument, NULL,
        -:  745:   GROUP_DIRECTORIES_FIRST_OPTION},
        -:  746:  {"human-readable", no_argument, NULL, 'h'},
        -:  747:  {"inode", no_argument, NULL, 'i'},
        -:  748:  {"numeric-uid-gid", no_argument, NULL, 'n'},
        -:  749:  {"no-group", no_argument, NULL, 'G'},
        -:  750:  {"hide-control-chars", no_argument, NULL, 'q'},
        -:  751:  {"reverse", no_argument, NULL, 'r'},
        -:  752:  {"size", no_argument, NULL, 's'},
        -:  753:  {"width", required_argument, NULL, 'w'},
        -:  754:  {"almost-all", no_argument, NULL, 'A'},
        -:  755:  {"ignore-backups", no_argument, NULL, 'B'},
        -:  756:  {"classify", no_argument, NULL, 'F'},
        -:  757:  {"file-type", no_argument, NULL, FILE_TYPE_INDICATOR_OPTION},
        -:  758:  {"si", no_argument, NULL, SI_OPTION},
        -:  759:  {"dereference-command-line", no_argument, NULL, 'H'},
        -:  760:  {"dereference-command-line-symlink-to-dir", no_argument, NULL,
        -:  761:   DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION},
        -:  762:  {"hide", required_argument, NULL, HIDE_OPTION},
        -:  763:  {"ignore", required_argument, NULL, 'I'},
        -:  764:  {"indicator-style", required_argument, NULL, INDICATOR_STYLE_OPTION},
        -:  765:  {"dereference", no_argument, NULL, 'L'},
        -:  766:  {"literal", no_argument, NULL, 'N'},
        -:  767:  {"quote-name", no_argument, NULL, 'Q'},
        -:  768:  {"quoting-style", required_argument, NULL, QUOTING_STYLE_OPTION},
        -:  769:  {"recursive", no_argument, NULL, 'R'},
        -:  770:  {"format", required_argument, NULL, FORMAT_OPTION},
        -:  771:  {"show-control-chars", no_argument, NULL, SHOW_CONTROL_CHARS_OPTION},
        -:  772:  {"sort", required_argument, NULL, SORT_OPTION},
        -:  773:  {"tabsize", required_argument, NULL, 'T'},
        -:  774:  {"time", required_argument, NULL, TIME_OPTION},
        -:  775:  {"time-style", required_argument, NULL, TIME_STYLE_OPTION},
        -:  776:  {"color", optional_argument, NULL, COLOR_OPTION},
        -:  777:  {"block-size", required_argument, NULL, BLOCK_SIZE_OPTION},
        -:  778:  {"context", no_argument, 0, 'Z'},
        -:  779:  {"author", no_argument, NULL, AUTHOR_OPTION},
        -:  780:  {GETOPT_HELP_OPTION_DECL},
        -:  781:  {GETOPT_VERSION_OPTION_DECL},
        -:  782:  {NULL, 0, NULL, 0}
        -:  783:};
        -:  784:
        -:  785:static char const *const format_args[] =
        -:  786:{
        -:  787:  "verbose", "long", "commas", "horizontal", "across",
        -:  788:  "vertical", "single-column", NULL
        -:  789:};
        -:  790:static enum format const format_types[] =
        -:  791:{
        -:  792:  long_format, long_format, with_commas, horizontal, horizontal,
        -:  793:  many_per_line, one_per_line
        -:  794:};
        -:  795:ARGMATCH_VERIFY (format_args, format_types);
        -:  796:
        -:  797:static char const *const sort_args[] =
        -:  798:{
        -:  799:  "none", "time", "size", "extension", "version", NULL
        -:  800:};
        -:  801:static enum sort_type const sort_types[] =
        -:  802:{
        -:  803:  sort_none, sort_time, sort_size, sort_extension, sort_version
        -:  804:};
        -:  805:ARGMATCH_VERIFY (sort_args, sort_types);
        -:  806:
        -:  807:static char const *const time_args[] =
        -:  808:{
        -:  809:  "atime", "access", "use", "ctime", "status", NULL
        -:  810:};
        -:  811:static enum time_type const time_types[] =
        -:  812:{
        -:  813:  time_atime, time_atime, time_atime, time_ctime, time_ctime
        -:  814:};
        -:  815:ARGMATCH_VERIFY (time_args, time_types);
        -:  816:
        -:  817:static char const *const color_args[] =
        -:  818:{
        -:  819:  /* force and none are for compatibility with another color-ls version */
        -:  820:  "always", "yes", "force",
        -:  821:  "never", "no", "none",
        -:  822:  "auto", "tty", "if-tty", NULL
        -:  823:};
        -:  824:static enum color_type const color_types[] =
        -:  825:{
        -:  826:  color_always, color_always, color_always,
        -:  827:  color_never, color_never, color_never,
        -:  828:  color_if_tty, color_if_tty, color_if_tty
        -:  829:};
        -:  830:ARGMATCH_VERIFY (color_args, color_types);
        -:  831:
        -:  832:/* Information about filling a column.  */
        -:  833:struct column_info
        -:  834:{
        -:  835:  bool valid_len;
        -:  836:  size_t line_len;
        -:  837:  size_t *col_arr;
        -:  838:};
        -:  839:
        -:  840:/* Array with information about column filledness.  */
        -:  841:static struct column_info *column_info;
        -:  842:
        -:  843:/* Maximum number of columns ever possible for this display.  */
        -:  844:static size_t max_idx;
        -:  845:
        -:  846:/* The minimum width of a column is 3: 1 character for the name and 2
        -:  847:   for the separating white space.  */
        -:  848:#define MIN_COLUMN_WIDTH	3
        -:  849:
        -:  850:
        -:  851:/* This zero-based index is used solely with the --dired option.
        -:  852:   When that option is in effect, this counter is incremented for each
        -:  853:   byte of output generated by this program so that the beginning
        -:  854:   and ending indices (in that output) of every file name can be recorded
        -:  855:   and later output themselves.  */
        -:  856:static size_t dired_pos;
        -:  857:
        -:  858:#define DIRED_PUTCHAR(c) do {putchar ((c)); ++dired_pos;} while (0)
        -:  859:
        -:  860:/* Write S to STREAM and increment DIRED_POS by S_LEN.  */
        -:  861:#define DIRED_FPUTS(s, stream, s_len) \
        -:  862:    do {fputs (s, stream); dired_pos += s_len;} while (0)
        -:  863:
        -:  864:/* Like DIRED_FPUTS, but for use when S is a literal string.  */
        -:  865:#define DIRED_FPUTS_LITERAL(s, stream) \
        -:  866:    do {fputs (s, stream); dired_pos += sizeof (s) - 1;} while (0)
        -:  867:
        -:  868:#define DIRED_INDENT()							\
        -:  869:    do									\
        -:  870:      {									\
        -:  871:	if (dired)							\
        -:  872:	  DIRED_FPUTS_LITERAL ("  ", stdout);				\
        -:  873:      }									\
        -:  874:    while (0)
        -:  875:
        -:  876:/* With --dired, store pairs of beginning and ending indices of filenames.  */
        -:  877:static struct obstack dired_obstack;
        -:  878:
        -:  879:/* With --dired, store pairs of beginning and ending indices of any
        -:  880:   directory names that appear as headers (just before `total' line)
        -:  881:   for lists of directory entries.  Such directory names are seen when
        -:  882:   listing hierarchies using -R and when a directory is listed with at
        -:  883:   least one other command line argument.  */
        -:  884:static struct obstack subdired_obstack;
        -:  885:
        -:  886:/* Save the current index on the specified obstack, OBS.  */
        -:  887:#define PUSH_CURRENT_DIRED_POS(obs)					\
        -:  888:  do									\
        -:  889:    {									\
        -:  890:      if (dired)							\
        -:  891:	obstack_grow (obs, &dired_pos, sizeof (dired_pos));		\
        -:  892:    }									\
        -:  893:  while (0)
        -:  894:
        -:  895:/* With -R, this stack is used to help detect directory cycles.
        -:  896:   The device/inode pairs on this stack mirror the pairs in the
        -:  897:   active_dir_set hash table.  */
        -:  898:static struct obstack dev_ino_obstack;
        -:  899:
        -:  900:/* Push a pair onto the device/inode stack.  */
        -:  901:#define DEV_INO_PUSH(Dev, Ino)						\
        -:  902:  do									\
        -:  903:    {									\
        -:  904:      struct dev_ino *di;						\
        -:  905:      obstack_blank (&dev_ino_obstack, sizeof (struct dev_ino));	\
        -:  906:      di = -1 + (struct dev_ino *) obstack_next_free (&dev_ino_obstack); \
        -:  907:      di->st_dev = (Dev);						\
        -:  908:      di->st_ino = (Ino);						\
        -:  909:    }									\
        -:  910:  while (0)
        -:  911:
        -:  912:/* Pop a dev/ino struct off the global dev_ino_obstack
        -:  913:   and return that struct.  */
        -:  914:static struct dev_ino
    #####:  915:dev_ino_pop (void)
        -:  916:{
    #####:  917:  assert (sizeof (struct dev_ino) <= obstack_object_size (&dev_ino_obstack));
    #####:  918:  obstack_blank (&dev_ino_obstack, -(int) (sizeof (struct dev_ino)));
    #####:  919:  return *(struct dev_ino *) obstack_next_free (&dev_ino_obstack);
        -:  920:}
        -:  921:
        -:  922:#define ASSERT_MATCHING_DEV_INO(Name, Di)	\
        -:  923:  do						\
        -:  924:    {						\
        -:  925:      struct stat sb;				\
        -:  926:      assert (Name);				\
        -:  927:      assert (0 <= stat (Name, &sb));		\
        -:  928:      assert (sb.st_dev == Di.st_dev);		\
        -:  929:      assert (sb.st_ino == Di.st_ino);		\
        -:  930:    }						\
        -:  931:  while (0)
        -:  932:
        -:  933:
        -:  934:/* Write to standard output PREFIX, followed by the quoting style and
        -:  935:   a space-separated list of the integers stored in OS all on one line.  */
        -:  936:
        -:  937:static void
    #####:  938:dired_dump_obstack (const char *prefix, struct obstack *os)
        -:  939:{
        -:  940:  size_t n_pos;
        -:  941:
    #####:  942:  n_pos = obstack_object_size (os) / sizeof (dired_pos);
    #####:  943:  if (n_pos > 0)
        -:  944:    {
        -:  945:      size_t i;
        -:  946:      size_t *pos;
        -:  947:
    #####:  948:      pos = (size_t *) obstack_finish (os);
    #####:  949:      fputs (prefix, stdout);
    #####:  950:      for (i = 0; i < n_pos; i++)
    #####:  951:	printf (" %lu", (unsigned long int) pos[i]);
    #####:  952:      putchar ('\n');
        -:  953:    }
    #####:  954:}
        -:  955:
        -:  956:static size_t
    #####:  957:dev_ino_hash (void const *x, size_t table_size)
        -:  958:{
    #####:  959:  struct dev_ino const *p = x;
    #####:  960:  return (uintmax_t) p->st_ino % table_size;
        -:  961:}
        -:  962:
        -:  963:static bool
    #####:  964:dev_ino_compare (void const *x, void const *y)
        -:  965:{
    #####:  966:  struct dev_ino const *a = x;
    #####:  967:  struct dev_ino const *b = y;
    #####:  968:  return SAME_INODE (*a, *b) ? true : false;
        -:  969:}
        -:  970:
        -:  971:static void
    #####:  972:dev_ino_free (void *x)
        -:  973:{
    #####:  974:  free (x);
    #####:  975:}
        -:  976:
        -:  977:/* Add the device/inode pair (P->st_dev/P->st_ino) to the set of
        -:  978:   active directories.  Return true if there is already a matching
        -:  979:   entry in the table.  */
        -:  980:
        -:  981:static bool
    #####:  982:visit_dir (dev_t dev, ino_t ino)
        -:  983:{
        -:  984:  struct dev_ino *ent;
        -:  985:  struct dev_ino *ent_from_table;
        -:  986:  bool found_match;
        -:  987:
    #####:  988:  ent = xmalloc (sizeof *ent);
    #####:  989:  ent->st_ino = ino;
    #####:  990:  ent->st_dev = dev;
        -:  991:
        -:  992:  /* Attempt to insert this entry into the table.  */
    #####:  993:  ent_from_table = hash_insert (active_dir_set, ent);
        -:  994:
    #####:  995:  if (ent_from_table == NULL)
        -:  996:    {
        -:  997:      /* Insertion failed due to lack of memory.  */
    #####:  998:      xalloc_die ();
        -:  999:    }
        -: 1000:
    #####: 1001:  found_match = (ent_from_table != ent);
        -: 1002:
    #####: 1003:  if (found_match)
        -: 1004:    {
        -: 1005:      /* ent was not inserted, so free it.  */
    #####: 1006:      free (ent);
        -: 1007:    }
        -: 1008:
    #####: 1009:  return found_match;
        -: 1010:}
        -: 1011:
        -: 1012:static void
    #####: 1013:free_pending_ent (struct pending *p)
        -: 1014:{
    #####: 1015:  free (p->name);
    #####: 1016:  free (p->realname);
    #####: 1017:  free (p);
    #####: 1018:}
        -: 1019:
        -: 1020:static bool
    #####: 1021:is_colored (enum indicator_no type)
        -: 1022:{
    #####: 1023:  size_t len = color_indicator[type].len;
    #####: 1024:  char const *s = color_indicator[type].string;
    #####: 1025:  return ! (len == 0
    #####: 1026:	    || (len == 1 && strncmp (s, "0", 1) == 0)
    #####: 1027:	    || (len == 2 && strncmp (s, "00", 2) == 0));
        -: 1028:}
        -: 1029:
        -: 1030:static void
    #####: 1031:restore_default_color (void)
        -: 1032:{
    #####: 1033:  put_indicator (&color_indicator[C_LEFT]);
    #####: 1034:  put_indicator (&color_indicator[C_RIGHT]);
    #####: 1035:}
        -: 1036:
        -: 1037:/* An ordinary signal was received; arrange for the program to exit.  */
        -: 1038:
        -: 1039:static void
    #####: 1040:sighandler (int sig)
        -: 1041:{
        -: 1042:  if (! SA_NOCLDSTOP)
        -: 1043:    signal (sig, SIG_IGN);
    #####: 1044:  if (! interrupt_signal)
    #####: 1045:    interrupt_signal = sig;
    #####: 1046:}
        -: 1047:
        -: 1048:/* A SIGTSTP was received; arrange for the program to suspend itself.  */
        -: 1049:
        -: 1050:static void
    #####: 1051:stophandler (int sig)
        -: 1052:{
        -: 1053:  if (! SA_NOCLDSTOP)
        -: 1054:    signal (sig, stophandler);
    #####: 1055:  if (! interrupt_signal)
    #####: 1056:    stop_signal_count++;
    #####: 1057:}
        -: 1058:
        -: 1059:/* Process any pending signals.  If signals are caught, this function
        -: 1060:   should be called periodically.  Ideally there should never be an
        -: 1061:   unbounded amount of time when signals are not being processed.
        -: 1062:   Signal handling can restore the default colors, so callers must
        -: 1063:   immediately change colors after invoking this function.  */
        -: 1064:
        -: 1065:static void
    #####: 1066:process_signals (void)
        -: 1067:{
    #####: 1068:  while (interrupt_signal | stop_signal_count)
        -: 1069:    {
        -: 1070:      int sig;
        -: 1071:      int stops;
        -: 1072:      sigset_t oldset;
        -: 1073:
    #####: 1074:      restore_default_color ();
    #####: 1075:      fflush (stdout);
        -: 1076:
    #####: 1077:      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
        -: 1078:
        -: 1079:      /* Reload interrupt_signal and stop_signal_count, in case a new
        -: 1080:	 signal was handled before sigprocmask took effect.  */
    #####: 1081:      sig = interrupt_signal;
    #####: 1082:      stops = stop_signal_count;
        -: 1083:
        -: 1084:      /* SIGTSTP is special, since the application can receive that signal
        -: 1085:	 more than once.  In this case, don't set the signal handler to the
        -: 1086:	 default.  Instead, just raise the uncatchable SIGSTOP.  */
    #####: 1087:      if (stops)
        -: 1088:	{
    #####: 1089:	  stop_signal_count = stops - 1;
    #####: 1090:	  sig = SIGSTOP;
        -: 1091:	}
        -: 1092:      else
    #####: 1093:	signal (sig, SIG_DFL);
        -: 1094:
        -: 1095:      /* Exit or suspend the program.  */
    #####: 1096:      raise (sig);
    #####: 1097:      sigprocmask (SIG_SETMASK, &oldset, NULL);
        -: 1098:
        -: 1099:      /* If execution reaches here, then the program has been
        -: 1100:	 continued (after being suspended).  */
        -: 1101:    }
    #####: 1102:}
        -: 1103:
        -: 1104:int
        3: 1105:main (int argc, char **argv)
        -: 1106:{
        -: 1107:  int i;
        -: 1108:  struct pending *thispend;
        -: 1109:  int n_files;
        -: 1110:
        -: 1111:  /* The signals that are trapped, and the number of such signals.  */
        -: 1112:  static int const sig[] =
        -: 1113:    {
        -: 1114:      /* This one is handled specially.  */
        -: 1115:      SIGTSTP,
        -: 1116:
        -: 1117:      /* The usual suspects.  */
        -: 1118:      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
        -: 1119:#ifdef SIGPOLL
        -: 1120:      SIGPOLL,
        -: 1121:#endif
        -: 1122:#ifdef SIGPROF
        -: 1123:      SIGPROF,
        -: 1124:#endif
        -: 1125:#ifdef SIGVTALRM
        -: 1126:      SIGVTALRM,
        -: 1127:#endif
        -: 1128:#ifdef SIGXCPU
        -: 1129:      SIGXCPU,
        -: 1130:#endif
        -: 1131:#ifdef SIGXFSZ
        -: 1132:      SIGXFSZ,
        -: 1133:#endif
        -: 1134:    };
        -: 1135:  enum { nsigs = sizeof sig / sizeof sig[0] };
        -: 1136:
        -: 1137:#if ! SA_NOCLDSTOP
        -: 1138:  bool caught_sig[nsigs];
        -: 1139:#endif
        -: 1140:
        -: 1141:  initialize_main (&argc, &argv);
        3: 1142:  program_name = argv[0];
        3: 1143:  setlocale (LC_ALL, "");
        -: 1144:  bindtextdomain (PACKAGE, LOCALEDIR);
        -: 1145:  textdomain (PACKAGE);
        -: 1146:
        3: 1147:  initialize_exit_failure (LS_FAILURE);
        3: 1148:  atexit (close_stdout);
        -: 1149:
        -: 1150:#define N_ENTRIES(Array) (sizeof Array / sizeof *(Array))
        -: 1151:  assert (N_ENTRIES (color_indicator) + 1 == N_ENTRIES (indicator_name));
        -: 1152:
        3: 1153:  exit_status = EXIT_SUCCESS;
        3: 1154:  print_dir_name = true;
        3: 1155:  pending_dirs = NULL;
        -: 1156:
        3: 1157:  i = decode_switches (argc, argv);
        -: 1158:
        3: 1159:  if (print_with_color)
    #####: 1160:    parse_ls_color ();
        -: 1161:
        -: 1162:  /* Test print_with_color again, because the call to parse_ls_color
        -: 1163:     may have just reset it -- e.g., if LS_COLORS is invalid.  */
        3: 1164:  if (print_with_color)
        -: 1165:    {
        -: 1166:      /* Avoid following symbolic links when possible.  */
    #####: 1167:      if (is_colored (C_ORPHAN)
    #####: 1168:	  || (is_colored (C_EXEC) && color_symlink_as_referent)
    #####: 1169:	  || (is_colored (C_MISSING) && format == long_format))
    #####: 1170:	check_symlink_color = true;
        -: 1171:
        -: 1172:      /* If the standard output is a controlling terminal, watch out
        -: 1173:         for signals, so that the colors can be restored to the
        -: 1174:         default state if "ls" is suspended or interrupted.  */
        -: 1175:
    #####: 1176:      if (0 <= tcgetpgrp (STDOUT_FILENO))
        -: 1177:	{
        -: 1178:	  int j;
        -: 1179:#if SA_NOCLDSTOP
        -: 1180:	  struct sigaction act;
        -: 1181:
    #####: 1182:	  sigemptyset (&caught_signals);
    #####: 1183:	  for (j = 0; j < nsigs; j++)
        -: 1184:	    {
    #####: 1185:	      sigaction (sig[j], NULL, &act);
    #####: 1186:	      if (act.sa_handler != SIG_IGN)
    #####: 1187:		sigaddset (&caught_signals, sig[j]);
        -: 1188:	    }
        -: 1189:
    #####: 1190:	  act.sa_mask = caught_signals;
    #####: 1191:	  act.sa_flags = SA_RESTART;
        -: 1192:
    #####: 1193:	  for (j = 0; j < nsigs; j++)
    #####: 1194:	    if (sigismember (&caught_signals, sig[j]))
        -: 1195:	      {
    #####: 1196:		act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
    #####: 1197:		sigaction (sig[j], &act, NULL);
        -: 1198:	      }
        -: 1199:#else
        -: 1200:	  for (j = 0; j < nsigs; j++)
        -: 1201:	    {
        -: 1202:	      caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
        -: 1203:	      if (caught_sig[j])
        -: 1204:		{
        -: 1205:		  signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
        -: 1206:		  siginterrupt (sig[j], 0);
        -: 1207:		}
        -: 1208:	    }
        -: 1209:#endif
        -: 1210:	}
        -: 1211:
    #####: 1212:      prep_non_filename_text ();
        -: 1213:    }
        -: 1214:
        3: 1215:  if (dereference == DEREF_UNDEFINED)
        3: 1216:    dereference = ((immediate_dirs
        3: 1217:		    || indicator_style == classify
        3: 1218:		    || format == long_format)
        -: 1219:		   ? DEREF_NEVER
        -: 1220:		   : DEREF_COMMAND_LINE_SYMLINK_TO_DIR);
        -: 1221:
        -: 1222:  /* When using -R, initialize a data structure we'll use to
        -: 1223:     detect any directory cycles.  */
        3: 1224:  if (recursive)
        -: 1225:    {
    #####: 1226:      active_dir_set = hash_initialize (INITIAL_TABLE_SIZE, NULL,
        -: 1227:					dev_ino_hash,
        -: 1228:					dev_ino_compare,
        -: 1229:					dev_ino_free);
    #####: 1230:      if (active_dir_set == NULL)
    #####: 1231:	xalloc_die ();
        -: 1232:
    #####: 1233:      obstack_init (&dev_ino_obstack);
        -: 1234:    }
        -: 1235:
        9: 1236:  format_needs_stat = sort_type == sort_time || sort_type == sort_size
        3: 1237:    || format == long_format
        3: 1238:    || print_scontext
        6: 1239:    || print_block_size;
        6: 1240:  format_needs_type = (! format_needs_stat
        3: 1241:		       && (recursive
        3: 1242:			   || print_with_color
        3: 1243:			   || indicator_style != none
        3: 1244:			   || directories_first));
        -: 1245:
        3: 1246:  if (dired)
        -: 1247:    {
    #####: 1248:      obstack_init (&dired_obstack);
    #####: 1249:      obstack_init (&subdired_obstack);
        -: 1250:    }
        -: 1251:
        3: 1252:  cwd_n_alloc = 100;
        3: 1253:  cwd_file = xnmalloc (cwd_n_alloc, sizeof *cwd_file);
        3: 1254:  cwd_n_used = 0;
        -: 1255:
        3: 1256:  clear_files ();
        -: 1257:
        3: 1258:  n_files = argc - i;
        -: 1259:
        3: 1260:  if (n_files <= 0)
        -: 1261:    {
    #####: 1262:      if (immediate_dirs)
    #####: 1263:	gobble_file (".", directory, NOT_AN_INODE_NUMBER, true, "");
        -: 1264:      else
    #####: 1265:	queue_directory (".", NULL, true);
        -: 1266:    }
        -: 1267:  else
        -: 1268:    do
      209: 1269:      gobble_file (argv[i++], unknown, NOT_AN_INODE_NUMBER, true, "");
      209: 1270:    while (i < argc);
        -: 1271:
        3: 1272:  if (cwd_n_used)
        -: 1273:    {
        3: 1274:      sort_files ();
        3: 1275:      if (!immediate_dirs)
        3: 1276:	extract_dirs_from_files (NULL, true);
        -: 1277:      /* `cwd_n_used' might be zero now.  */
        -: 1278:    }
        -: 1279:
        -: 1280:  /* In the following if/else blocks, it is sufficient to test `pending_dirs'
        -: 1281:     (and not pending_dirs->name) because there may be no markers in the queue
        -: 1282:     at this point.  A marker may be enqueued when extract_dirs_from_files is
        -: 1283:     called with a non-empty string or via print_dir.  */
        3: 1284:  if (cwd_n_used)
        -: 1285:    {
        3: 1286:      print_current_files ();
        3: 1287:      if (pending_dirs)
    #####: 1288:	DIRED_PUTCHAR ('\n');
        -: 1289:    }
    #####: 1290:  else if (n_files <= 1 && pending_dirs && pending_dirs->next == 0)
    #####: 1291:    print_dir_name = false;
        -: 1292:
        6: 1293:  while (pending_dirs)
        -: 1294:    {
    #####: 1295:      thispend = pending_dirs;
    #####: 1296:      pending_dirs = pending_dirs->next;
        -: 1297:
    #####: 1298:      if (LOOP_DETECT)
        -: 1299:	{
    #####: 1300:	  if (thispend->name == NULL)
        -: 1301:	    {
        -: 1302:	      /* thispend->name == NULL means this is a marker entry
        -: 1303:		 indicating we've finished processing the directory.
        -: 1304:		 Use its dev/ino numbers to remove the corresponding
        -: 1305:		 entry from the active_dir_set hash table.  */
    #####: 1306:	      struct dev_ino di = dev_ino_pop ();
    #####: 1307:	      struct dev_ino *found = hash_delete (active_dir_set, &di);
        -: 1308:	      /* ASSERT_MATCHING_DEV_INO (thispend->realname, di); */
    #####: 1309:	      assert (found);
    #####: 1310:	      dev_ino_free (found);
    #####: 1311:	      free_pending_ent (thispend);
    #####: 1312:	      continue;
        -: 1313:	    }
        -: 1314:	}
        -: 1315:
    #####: 1316:      print_dir (thispend->name, thispend->realname,
    #####: 1317:		 thispend->command_line_arg);
        -: 1318:
    #####: 1319:      free_pending_ent (thispend);
    #####: 1320:      print_dir_name = true;
        -: 1321:    }
        -: 1322:
        3: 1323:  if (print_with_color)
        -: 1324:    {
        -: 1325:      int j;
        -: 1326:
    #####: 1327:      restore_default_color ();
    #####: 1328:      fflush (stdout);
        -: 1329:
        -: 1330:      /* Restore the default signal handling.  */
        -: 1331:#if SA_NOCLDSTOP
    #####: 1332:      for (j = 0; j < nsigs; j++)
    #####: 1333:	if (sigismember (&caught_signals, sig[j]))
    #####: 1334:	  signal (sig[j], SIG_DFL);
        -: 1335:#else
        -: 1336:      for (j = 0; j < nsigs; j++)
        -: 1337:	if (caught_sig[j])
        -: 1338:	  signal (sig[j], SIG_DFL);
        -: 1339:#endif
        -: 1340:
        -: 1341:      /* Act on any signals that arrived before the default was restored.
        -: 1342:	 This can process signals out of order, but there doesn't seem to
        -: 1343:	 be an easy way to do them in order, and the order isn't that
        -: 1344:	 important anyway.  */
    #####: 1345:      for (j = stop_signal_count; j; j--)
    #####: 1346:	raise (SIGSTOP);
    #####: 1347:      j = interrupt_signal;
    #####: 1348:      if (j)
    #####: 1349:	raise (j);
        -: 1350:    }
        -: 1351:
        3: 1352:  if (dired)
        -: 1353:    {
        -: 1354:      /* No need to free these since we're about to exit.  */
    #####: 1355:      dired_dump_obstack ("//DIRED//", &dired_obstack);
    #####: 1356:      dired_dump_obstack ("//SUBDIRED//", &subdired_obstack);
    #####: 1357:      printf ("//DIRED-OPTIONS// --quoting-style=%s\n",
    #####: 1358:	      quoting_style_args[get_quoting_style (filename_quoting_options)]);
        -: 1359:    }
        -: 1360:
        3: 1361:  if (LOOP_DETECT)
        -: 1362:    {
    #####: 1363:      assert (hash_get_n_entries (active_dir_set) == 0);
    #####: 1364:      hash_free (active_dir_set);
        -: 1365:    }
        -: 1366:
        3: 1367:  exit (exit_status);
        -: 1368:}
        -: 1369:
        -: 1370:/* Set all the option flags according to the switches specified.
        -: 1371:   Return the index of the first non-option argument.  */
        -: 1372:
        -: 1373:static int
        3: 1374:decode_switches (int argc, char **argv)
        -: 1375:{
        3: 1376:  char *time_style_option = NULL;
        -: 1377:
        -: 1378:  /* Record whether there is an option specifying sort type.  */
        3: 1379:  bool sort_type_specified = false;
        -: 1380:
        3: 1381:  qmark_funny_chars = false;
        -: 1382:
        -: 1383:  /* initialize all switches to default settings */
        -: 1384:
        3: 1385:  switch (ls_mode)
        -: 1386:    {
        -: 1387:    case LS_MULTI_COL:
        -: 1388:      /* This is for the `dir' program.  */
    #####: 1389:      format = many_per_line;
    #####: 1390:      set_quoting_style (NULL, escape_quoting_style);
    #####: 1391:      break;
        -: 1392:
        -: 1393:    case LS_LONG_FORMAT:
        -: 1394:      /* This is for the `vdir' program.  */
    #####: 1395:      format = long_format;
    #####: 1396:      set_quoting_style (NULL, escape_quoting_style);
    #####: 1397:      break;
        -: 1398:
        -: 1399:    case LS_LS:
        -: 1400:      /* This is for the `ls' program.  */
        3: 1401:      if (isatty (STDOUT_FILENO))
        -: 1402:	{
    #####: 1403:	  format = many_per_line;
        -: 1404:	  /* See description of qmark_funny_chars, above.  */
    #####: 1405:	  qmark_funny_chars = true;
        -: 1406:	}
        -: 1407:      else
        -: 1408:	{
        3: 1409:	  format = one_per_line;
        3: 1410:	  qmark_funny_chars = false;
        -: 1411:	}
        3: 1412:      break;
        -: 1413:
        -: 1414:    default:
    #####: 1415:      abort ();
        -: 1416:    }
        -: 1417:
        3: 1418:  time_type = time_mtime;
        3: 1419:  sort_type = sort_name;
        3: 1420:  sort_reverse = false;
        3: 1421:  numeric_ids = false;
        3: 1422:  print_block_size = false;
        3: 1423:  indicator_style = none;
        3: 1424:  print_inode = false;
        3: 1425:  dereference = DEREF_UNDEFINED;
        3: 1426:  recursive = false;
        3: 1427:  immediate_dirs = false;
        3: 1428:  ignore_mode = IGNORE_DEFAULT;
        3: 1429:  ignore_patterns = NULL;
        3: 1430:  hide_patterns = NULL;
        3: 1431:  print_scontext = false;
        -: 1432:
        -: 1433:  /* FIXME: put this in a function.  */
        -: 1434:  {
        3: 1435:    char const *q_style = getenv ("QUOTING_STYLE");
        3: 1436:    if (q_style)
        -: 1437:      {
    #####: 1438:	int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);
    #####: 1439:	if (0 <= i)
    #####: 1440:	  set_quoting_style (NULL, quoting_style_vals[i]);
        -: 1441:	else
    #####: 1442:	  error (0, 0,
        -: 1443:	 _("ignoring invalid value of environment variable QUOTING_STYLE: %s"),
        -: 1444:		 quotearg (q_style));
        -: 1445:      }
        -: 1446:  }
        -: 1447:
        -: 1448:  {
        3: 1449:    char const *ls_block_size = getenv ("LS_BLOCK_SIZE");
        3: 1450:    human_options (ls_block_size,
        -: 1451:		   &human_output_opts, &output_block_size);
        3: 1452:    if (ls_block_size || getenv ("BLOCK_SIZE"))
    #####: 1453:      file_output_block_size = output_block_size;
        -: 1454:  }
        -: 1455:
        3: 1456:  line_length = 80;
        -: 1457:  {
        3: 1458:    char const *p = getenv ("COLUMNS");
        3: 1459:    if (p && *p)
        -: 1460:      {
        -: 1461:	unsigned long int tmp_ulong;
    #####: 1462:	if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
    #####: 1463:	    && 0 < tmp_ulong && tmp_ulong <= SIZE_MAX)
        -: 1464:	  {
    #####: 1465:	    line_length = tmp_ulong;
        -: 1466:	  }
        -: 1467:	else
        -: 1468:	  {
    #####: 1469:	    error (0, 0,
        -: 1470:	       _("ignoring invalid width in environment variable COLUMNS: %s"),
        -: 1471:		   quotearg (p));
        -: 1472:	  }
        -: 1473:      }
        -: 1474:  }
        -: 1475:
        -: 1476:#ifdef TIOCGWINSZ
        -: 1477:  {
        -: 1478:    struct winsize ws;
        -: 1479:
        3: 1480:    if (ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws) != -1
    #####: 1481:	&& 0 < ws.ws_col && ws.ws_col == (size_t) ws.ws_col)
    #####: 1482:      line_length = ws.ws_col;
        -: 1483:  }
        -: 1484:#endif
        -: 1485:
        -: 1486:  {
        3: 1487:    char const *p = getenv ("TABSIZE");
        3: 1488:    tabsize = 8;
        3: 1489:    if (p)
        -: 1490:      {
        -: 1491:	unsigned long int tmp_ulong;
    #####: 1492:	if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
        -: 1493:	    && tmp_ulong <= SIZE_MAX)
        -: 1494:	  {
    #####: 1495:	    tabsize = tmp_ulong;
        -: 1496:	  }
        -: 1497:	else
        -: 1498:	  {
    #####: 1499:	    error (0, 0,
        -: 1500:	     _("ignoring invalid tab size in environment variable TABSIZE: %s"),
        -: 1501:		   quotearg (p));
        -: 1502:	  }
        -: 1503:      }
        -: 1504:  }
        -: 1505:
        -: 1506:  for (;;)
        -: 1507:    {
        6: 1508:      int oi = -1;
        6: 1509:      int c = getopt_long (argc, argv,
        -: 1510:			   "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",
        -: 1511:			   long_options, &oi);
        6: 1512:      if (c == -1)
        3: 1513:	break;
        -: 1514:
        3: 1515:      switch (c)
        -: 1516:	{
        -: 1517:	case 'a':
    #####: 1518:	  ignore_mode = IGNORE_MINIMAL;
    #####: 1519:	  break;
        -: 1520:
        -: 1521:	case 'b':
    #####: 1522:	  set_quoting_style (NULL, escape_quoting_style);
    #####: 1523:	  break;
        -: 1524:
        -: 1525:	case 'c':
    #####: 1526:	  time_type = time_ctime;
    #####: 1527:	  break;
        -: 1528:
        -: 1529:	case 'd':
    #####: 1530:	  immediate_dirs = true;
    #####: 1531:	  break;
        -: 1532:
        -: 1533:	case 'f':
        -: 1534:	  /* Same as enabling -a -U and disabling -l -s.  */
    #####: 1535:	  ignore_mode = IGNORE_MINIMAL;
    #####: 1536:	  sort_type = sort_none;
    #####: 1537:	  sort_type_specified = true;
        -: 1538:	  /* disable -l */
    #####: 1539:	  if (format == long_format)
    #####: 1540:	    format = (isatty (STDOUT_FILENO) ? many_per_line : one_per_line);
    #####: 1541:	  print_block_size = false;	/* disable -s */
    #####: 1542:	  print_with_color = false;	/* disable --color */
    #####: 1543:	  break;
        -: 1544:
        -: 1545:	case FILE_TYPE_INDICATOR_OPTION: /* --file-type */
    #####: 1546:	  indicator_style = file_type;
    #####: 1547:	  break;
        -: 1548:
        -: 1549:	case 'g':
    #####: 1550:	  format = long_format;
    #####: 1551:	  print_owner = false;
    #####: 1552:	  break;
        -: 1553:
        -: 1554:	case 'h':
    #####: 1555:	  human_output_opts = human_autoscale | human_SI | human_base_1024;
    #####: 1556:	  file_output_block_size = output_block_size = 1;
    #####: 1557:	  break;
        -: 1558:
        -: 1559:	case 'i':
    #####: 1560:	  print_inode = true;
    #####: 1561:	  break;
        -: 1562:
        -: 1563:	case 'k':
    #####: 1564:	  human_output_opts = 0;
    #####: 1565:	  file_output_block_size = output_block_size = 1024;
    #####: 1566:	  break;
        -: 1567:
        -: 1568:	case 'l':
    #####: 1569:	  format = long_format;
    #####: 1570:	  break;
        -: 1571:
        -: 1572:	case 'm':
    #####: 1573:	  format = with_commas;
    #####: 1574:	  break;
        -: 1575:
        -: 1576:	case 'n':
    #####: 1577:	  numeric_ids = true;
    #####: 1578:	  format = long_format;
    #####: 1579:	  break;
        -: 1580:
        -: 1581:	case 'o':  /* Just like -l, but don't display group info.  */
    #####: 1582:	  format = long_format;
    #####: 1583:	  print_group = false;
    #####: 1584:	  break;
        -: 1585:
        -: 1586:	case 'p':
    #####: 1587:	  indicator_style = slash;
    #####: 1588:	  break;
        -: 1589:
        -: 1590:	case 'q':
    #####: 1591:	  qmark_funny_chars = true;
    #####: 1592:	  break;
        -: 1593:
        -: 1594:	case 'r':
    #####: 1595:	  sort_reverse = true;
    #####: 1596:	  break;
        -: 1597:
        -: 1598:	case 's':
    #####: 1599:	  print_block_size = true;
    #####: 1600:	  break;
        -: 1601:
        -: 1602:	case 't':
    #####: 1603:	  sort_type = sort_time;
    #####: 1604:	  sort_type_specified = true;
    #####: 1605:	  break;
        -: 1606:
        -: 1607:	case 'u':
    #####: 1608:	  time_type = time_atime;
    #####: 1609:	  break;
        -: 1610:
        -: 1611:	case 'v':
    #####: 1612:	  sort_type = sort_version;
    #####: 1613:	  sort_type_specified = true;
    #####: 1614:	  break;
        -: 1615:
        -: 1616:	case 'w':
        -: 1617:	  {
        -: 1618:	    unsigned long int tmp_ulong;
    #####: 1619:	    if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK
    #####: 1620:		|| ! (0 < tmp_ulong && tmp_ulong <= SIZE_MAX))
    #####: 1621:	      error (LS_FAILURE, 0, _("invalid line width: %s"),
        -: 1622:		     quotearg (optarg));
    #####: 1623:	    line_length = tmp_ulong;
    #####: 1624:	    break;
        -: 1625:	  }
        -: 1626:
        -: 1627:	case 'x':
    #####: 1628:	  format = horizontal;
    #####: 1629:	  break;
        -: 1630:
        -: 1631:	case 'A':
    #####: 1632:	  if (ignore_mode == IGNORE_DEFAULT)
    #####: 1633:	    ignore_mode = IGNORE_DOT_AND_DOTDOT;
    #####: 1634:	  break;
        -: 1635:
        -: 1636:	case 'B':
    #####: 1637:	  add_ignore_pattern ("*~");
    #####: 1638:	  add_ignore_pattern (".*~");
    #####: 1639:	  break;
        -: 1640:
        -: 1641:	case 'C':
    #####: 1642:	  format = many_per_line;
    #####: 1643:	  break;
        -: 1644:
        -: 1645:	case 'D':
    #####: 1646:	  dired = true;
    #####: 1647:	  break;
        -: 1648:
        -: 1649:	case 'F':
    #####: 1650:	  indicator_style = classify;
    #####: 1651:	  break;
        -: 1652:
        -: 1653:	case 'G':		/* inhibit display of group info */
    #####: 1654:	  print_group = false;
    #####: 1655:	  break;
        -: 1656:
        -: 1657:	case 'H':
    #####: 1658:	  dereference = DEREF_COMMAND_LINE_ARGUMENTS;
    #####: 1659:	  break;
        -: 1660:
        -: 1661:	case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:
    #####: 1662:	  dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;
    #####: 1663:	  break;
        -: 1664:
        -: 1665:	case 'I':
    #####: 1666:	  add_ignore_pattern (optarg);
    #####: 1667:	  break;
        -: 1668:
        -: 1669:	case 'L':
    #####: 1670:	  dereference = DEREF_ALWAYS;
    #####: 1671:	  break;
        -: 1672:
        -: 1673:	case 'N':
    #####: 1674:	  set_quoting_style (NULL, literal_quoting_style);
    #####: 1675:	  break;
        -: 1676:
        -: 1677:	case 'Q':
    #####: 1678:	  set_quoting_style (NULL, c_quoting_style);
    #####: 1679:	  break;
        -: 1680:
        -: 1681:	case 'R':
    #####: 1682:	  recursive = true;
    #####: 1683:	  break;
        -: 1684:
        -: 1685:	case 'S':
    #####: 1686:	  sort_type = sort_size;
    #####: 1687:	  sort_type_specified = true;
    #####: 1688:	  break;
        -: 1689:
        -: 1690:	case 'T':
        -: 1691:	  {
        -: 1692:	    unsigned long int tmp_ulong;
    #####: 1693:	    if (xstrtoul (optarg, NULL, 0, &tmp_ulong, NULL) != LONGINT_OK
        -: 1694:		|| SIZE_MAX < tmp_ulong)
    #####: 1695:	      error (LS_FAILURE, 0, _("invalid tab size: %s"),
        -: 1696:		     quotearg (optarg));
    #####: 1697:	    tabsize = tmp_ulong;
    #####: 1698:	    break;
        -: 1699:	  }
        -: 1700:
        -: 1701:	case 'U':
    #####: 1702:	  sort_type = sort_none;
    #####: 1703:	  sort_type_specified = true;
    #####: 1704:	  break;
        -: 1705:
        -: 1706:	case 'X':
    #####: 1707:	  sort_type = sort_extension;
    #####: 1708:	  sort_type_specified = true;
    #####: 1709:	  break;
        -: 1710:
        -: 1711:	case '1':
        -: 1712:	  /* -1 has no effect after -l.  */
        3: 1713:	  if (format != long_format)
        3: 1714:	    format = one_per_line;
        3: 1715:	  break;
        -: 1716:
        -: 1717:        case AUTHOR_OPTION:
    #####: 1718:          print_author = true;
    #####: 1719:          break;
        -: 1720:
        -: 1721:	case HIDE_OPTION:
        -: 1722:	  {
    #####: 1723:	    struct ignore_pattern *hide = xmalloc (sizeof *hide);
    #####: 1724:	    hide->pattern = optarg;
    #####: 1725:	    hide->next = hide_patterns;
    #####: 1726:	    hide_patterns = hide;
        -: 1727:	  }
    #####: 1728:	  break;
        -: 1729:
        -: 1730:	case SORT_OPTION:
    #####: 1731:	  sort_type = XARGMATCH ("--sort", optarg, sort_args, sort_types);
    #####: 1732:	  sort_type_specified = true;
    #####: 1733:	  break;
        -: 1734:
        -: 1735:	case GROUP_DIRECTORIES_FIRST_OPTION:
    #####: 1736:	  directories_first = true;
    #####: 1737:	  break;
        -: 1738:
        -: 1739:	case TIME_OPTION:
    #####: 1740:	  time_type = XARGMATCH ("--time", optarg, time_args, time_types);
    #####: 1741:	  break;
        -: 1742:
        -: 1743:	case FORMAT_OPTION:
    #####: 1744:	  format = XARGMATCH ("--format", optarg, format_args, format_types);
    #####: 1745:	  break;
        -: 1746:
        -: 1747:	case FULL_TIME_OPTION:
    #####: 1748:	  format = long_format;
    #####: 1749:	  time_style_option = "full-iso";
    #####: 1750:	  break;
        -: 1751:
        -: 1752:	case COLOR_OPTION:
        -: 1753:	  {
        -: 1754:	    int i;
    #####: 1755:	    if (optarg)
    #####: 1756:	      i = XARGMATCH ("--color", optarg, color_args, color_types);
        -: 1757:	    else
        -: 1758:	      /* Using --color with no argument is equivalent to using
        -: 1759:		 --color=always.  */
    #####: 1760:	      i = color_always;
        -: 1761:
    #####: 1762:	    print_with_color = (i == color_always
    #####: 1763:				|| (i == color_if_tty
    #####: 1764:				    && isatty (STDOUT_FILENO)));
        -: 1765:
    #####: 1766:	    if (print_with_color)
        -: 1767:	      {
        -: 1768:		/* Don't use TAB characters in output.  Some terminal
        -: 1769:		   emulators can't handle the combination of tabs and
        -: 1770:		   color codes on the same line.  */
    #####: 1771:		tabsize = 0;
        -: 1772:	      }
    #####: 1773:	    break;
        -: 1774:	  }
        -: 1775:
        -: 1776:	case INDICATOR_STYLE_OPTION:
    #####: 1777:	  indicator_style = XARGMATCH ("--indicator-style", optarg,
        -: 1778:				       indicator_style_args,
        -: 1779:				       indicator_style_types);
    #####: 1780:	  break;
        -: 1781:
        -: 1782:	case QUOTING_STYLE_OPTION:
    #####: 1783:	  set_quoting_style (NULL,
    #####: 1784:			     XARGMATCH ("--quoting-style", optarg,
        -: 1785:					quoting_style_args,
        -: 1786:					quoting_style_vals));
    #####: 1787:	  break;
        -: 1788:
        -: 1789:	case TIME_STYLE_OPTION:
    #####: 1790:	  time_style_option = optarg;
    #####: 1791:	  break;
        -: 1792:
        -: 1793:	case SHOW_CONTROL_CHARS_OPTION:
    #####: 1794:	  qmark_funny_chars = false;
    #####: 1795:	  break;
        -: 1796:
        -: 1797:	case BLOCK_SIZE_OPTION:
        -: 1798:	  {
    #####: 1799:	    enum strtol_error e = human_options (optarg, &human_output_opts,
        -: 1800:						 &output_block_size);
    #####: 1801:	    if (e != LONGINT_OK)
    #####: 1802:	      xstrtol_fatal (e, oi, 0, long_options, optarg);
    #####: 1803:	    file_output_block_size = output_block_size;
        -: 1804:	  }
    #####: 1805:	  break;
        -: 1806:
        -: 1807:	case SI_OPTION:
    #####: 1808:	  human_output_opts = human_autoscale | human_SI;
    #####: 1809:	  file_output_block_size = output_block_size = 1;
    #####: 1810:	  break;
        -: 1811:
        -: 1812:	case 'Z':
    #####: 1813:	  print_scontext = true;
    #####: 1814:	  break;
        -: 1815:
    #####: 1816:	case_GETOPT_HELP_CHAR;
        -: 1817:
    #####: 1818:	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -: 1819:
        -: 1820:	default:
    #####: 1821:	  usage (LS_FAILURE);
        -: 1822:	}
        3: 1823:    }
        -: 1824:
        6: 1825:  max_idx = MAX (1, line_length / MIN_COLUMN_WIDTH);
        -: 1826:
        3: 1827:  filename_quoting_options = clone_quoting_options (NULL);
        3: 1828:  if (get_quoting_style (filename_quoting_options) == escape_quoting_style)
    #####: 1829:    set_char_quoting (filename_quoting_options, ' ', 1);
        3: 1830:  if (file_type <= indicator_style)
        -: 1831:    {
        -: 1832:      char const *p;
    #####: 1833:      for (p = "*=>@|" + indicator_style - file_type; *p; p++)
    #####: 1834:	set_char_quoting (filename_quoting_options, *p, 1);
        -: 1835:    }
        -: 1836:
        3: 1837:  dirname_quoting_options = clone_quoting_options (NULL);
        3: 1838:  set_char_quoting (dirname_quoting_options, ':', 1);
        -: 1839:
        -: 1840:  /* --dired is meaningful only with --format=long (-l).
        -: 1841:     Otherwise, ignore it.  FIXME: warn about this?
        -: 1842:     Alternatively, make --dired imply --format=long?  */
        3: 1843:  if (dired && format != long_format)
    #####: 1844:    dired = false;
        -: 1845:
        -: 1846:  /* If -c or -u is specified and not -l (or any other option that implies -l),
        -: 1847:     and no sort-type was specified, then sort by the ctime (-c) or atime (-u).
        -: 1848:     The behavior of ls when using either -c or -u but with neither -l nor -t
        -: 1849:     appears to be unspecified by POSIX.  So, with GNU ls, `-u' alone means
        -: 1850:     sort by atime (this is the one that's not specified by the POSIX spec),
        -: 1851:     -lu means show atime and sort by name, -lut means show atime and sort
        -: 1852:     by atime.  */
        -: 1853:
        3: 1854:  if ((time_type == time_ctime || time_type == time_atime)
    #####: 1855:      && !sort_type_specified && format != long_format)
        -: 1856:    {
    #####: 1857:      sort_type = sort_time;
        -: 1858:    }
        -: 1859:
        3: 1860:  if (format == long_format)
        -: 1861:    {
    #####: 1862:      char *style = time_style_option;
        -: 1863:      static char const posix_prefix[] = "posix-";
        -: 1864:
    #####: 1865:      if (! style)
    #####: 1866:	if (! (style = getenv ("TIME_STYLE")))
    #####: 1867:	  style = "locale";
        -: 1868:
    #####: 1869:      while (strncmp (style, posix_prefix, sizeof posix_prefix - 1) == 0)
        -: 1870:	{
    #####: 1871:	  if (! hard_locale (LC_TIME))
    #####: 1872:	    return optind;
    #####: 1873:	  style += sizeof posix_prefix - 1;
        -: 1874:	}
        -: 1875:
    #####: 1876:      if (*style == '+')
        -: 1877:	{
    #####: 1878:	  char *p0 = style + 1;
    #####: 1879:	  char *p1 = strchr (p0, '\n');
    #####: 1880:	  if (! p1)
    #####: 1881:	    p1 = p0;
        -: 1882:	  else
        -: 1883:	    {
    #####: 1884:	      if (strchr (p1 + 1, '\n'))
    #####: 1885:		error (LS_FAILURE, 0, _("invalid time style format %s"),
        -: 1886:		       quote (p0));
    #####: 1887:	      *p1++ = '\0';
        -: 1888:	    }
    #####: 1889:	  long_time_format[0] = p0;
    #####: 1890:	  long_time_format[1] = p1;
        -: 1891:	}
        -: 1892:      else
    #####: 1893:	switch (XARGMATCH ("time style", style,
        -: 1894:			   time_style_args,
        -: 1895:			   time_style_types))
        -: 1896:	  {
        -: 1897:	  case full_iso_time_style:
    #####: 1898:	    long_time_format[0] = long_time_format[1] =
        -: 1899:	      "%Y-%m-%d %H:%M:%S.%N %z";
    #####: 1900:	    break;
        -: 1901:
        -: 1902:	  case long_iso_time_style:
        -: 1903:	  case_long_iso_time_style:
    #####: 1904:	    long_time_format[0] = long_time_format[1] = "%Y-%m-%d %H:%M";
    #####: 1905:	    break;
        -: 1906:
        -: 1907:	  case iso_time_style:
    #####: 1908:	    long_time_format[0] = "%Y-%m-%d ";
    #####: 1909:	    long_time_format[1] = "%m-%d %H:%M";
    #####: 1910:	    break;
        -: 1911:
        -: 1912:	  case locale_time_style:
    #####: 1913:	    if (hard_locale (LC_TIME))
        -: 1914:	      {
        -: 1915:		/* Ensure that the locale has translations for both
        -: 1916:		   formats.  If not, fall back on long-iso format.  */
        -: 1917:		int i;
    #####: 1918:		for (i = 0; i < 2; i++)
        -: 1919:		  {
    #####: 1920:		    char const *locale_format =
        -: 1921:		      dcgettext (NULL, long_time_format[i], LC_TIME);
    #####: 1922:		    if (locale_format == long_time_format[i])
    #####: 1923:		      goto case_long_iso_time_style;
    #####: 1924:		    long_time_format[i] = locale_format;
        -: 1925:		  }
        -: 1926:	      }
        -: 1927:	  }
        -: 1928:    }
        -: 1929:
        3: 1930:  return optind;
        -: 1931:}
        -: 1932:
        -: 1933:/* Parse a string as part of the LS_COLORS variable; this may involve
        -: 1934:   decoding all kinds of escape characters.  If equals_end is set an
        -: 1935:   unescaped equal sign ends the string, otherwise only a : or \0
        -: 1936:   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
        -: 1937:   true if successful.
        -: 1938:
        -: 1939:   The resulting string is *not* null-terminated, but may contain
        -: 1940:   embedded nulls.
        -: 1941:
        -: 1942:   Note that both dest and src are char **; on return they point to
        -: 1943:   the first free byte after the array and the character that ended
        -: 1944:   the input string, respectively.  */
        -: 1945:
        -: 1946:static bool
    #####: 1947:get_funky_string (char **dest, const char **src, bool equals_end,
        -: 1948:		  size_t *output_count)
        -: 1949:{
        -: 1950:  char num;			/* For numerical codes */
        -: 1951:  size_t count;			/* Something to count with */
        -: 1952:  enum {
        -: 1953:    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
        -: 1954:  } state;
        -: 1955:  const char *p;
        -: 1956:  char *q;
        -: 1957:
    #####: 1958:  p = *src;			/* We don't want to double-indirect */
    #####: 1959:  q = *dest;			/* the whole darn time.  */
        -: 1960:
    #####: 1961:  count = 0;			/* No characters counted in yet.  */
    #####: 1962:  num = 0;
        -: 1963:
    #####: 1964:  state = ST_GND;		/* Start in ground state.  */
    #####: 1965:  while (state < ST_END)
        -: 1966:    {
    #####: 1967:      switch (state)
        -: 1968:	{
        -: 1969:	case ST_GND:		/* Ground state (no escapes) */
    #####: 1970:	  switch (*p)
        -: 1971:	    {
        -: 1972:	    case ':':
        -: 1973:	    case '\0':
    #####: 1974:	      state = ST_END;	/* End of string */
    #####: 1975:	      break;
        -: 1976:	    case '\\':
    #####: 1977:	      state = ST_BACKSLASH; /* Backslash scape sequence */
    #####: 1978:	      ++p;
    #####: 1979:	      break;
        -: 1980:	    case '^':
    #####: 1981:	      state = ST_CARET; /* Caret escape */
    #####: 1982:	      ++p;
    #####: 1983:	      break;
        -: 1984:	    case '=':
    #####: 1985:	      if (equals_end)
        -: 1986:		{
    #####: 1987:		  state = ST_END; /* End */
    #####: 1988:		  break;
        -: 1989:		}
        -: 1990:	      /* else fall through */
        -: 1991:	    default:
    #####: 1992:	      *(q++) = *(p++);
    #####: 1993:	      ++count;
    #####: 1994:	      break;
        -: 1995:	    }
    #####: 1996:	  break;
        -: 1997:
        -: 1998:	case ST_BACKSLASH:	/* Backslash escaped character */
    #####: 1999:	  switch (*p)
        -: 2000:	    {
        -: 2001:	    case '0':
        -: 2002:	    case '1':
        -: 2003:	    case '2':
        -: 2004:	    case '3':
        -: 2005:	    case '4':
        -: 2006:	    case '5':
        -: 2007:	    case '6':
        -: 2008:	    case '7':
    #####: 2009:	      state = ST_OCTAL;	/* Octal sequence */
    #####: 2010:	      num = *p - '0';
    #####: 2011:	      break;
        -: 2012:	    case 'x':
        -: 2013:	    case 'X':
    #####: 2014:	      state = ST_HEX;	/* Hex sequence */
    #####: 2015:	      num = 0;
    #####: 2016:	      break;
        -: 2017:	    case 'a':		/* Bell */
    #####: 2018:	      num = '\a';
    #####: 2019:	      break;
        -: 2020:	    case 'b':		/* Backspace */
    #####: 2021:	      num = '\b';
    #####: 2022:	      break;
        -: 2023:	    case 'e':		/* Escape */
    #####: 2024:	      num = 27;
    #####: 2025:	      break;
        -: 2026:	    case 'f':		/* Form feed */
    #####: 2027:	      num = '\f';
    #####: 2028:	      break;
        -: 2029:	    case 'n':		/* Newline */
    #####: 2030:	      num = '\n';
    #####: 2031:	      break;
        -: 2032:	    case 'r':		/* Carriage return */
    #####: 2033:	      num = '\r';
    #####: 2034:	      break;
        -: 2035:	    case 't':		/* Tab */
    #####: 2036:	      num = '\t';
    #####: 2037:	      break;
        -: 2038:	    case 'v':		/* Vtab */
    #####: 2039:	      num = '\v';
    #####: 2040:	      break;
        -: 2041:	    case '?':		/* Delete */
    #####: 2042:              num = 127;
    #####: 2043:	      break;
        -: 2044:	    case '_':		/* Space */
    #####: 2045:	      num = ' ';
    #####: 2046:	      break;
        -: 2047:	    case '\0':		/* End of string */
    #####: 2048:	      state = ST_ERROR;	/* Error! */
    #####: 2049:	      break;
        -: 2050:	    default:		/* Escaped character like \ ^ : = */
    #####: 2051:	      num = *p;
    #####: 2052:	      break;
        -: 2053:	    }
    #####: 2054:	  if (state == ST_BACKSLASH)
        -: 2055:	    {
    #####: 2056:	      *(q++) = num;
    #####: 2057:	      ++count;
    #####: 2058:	      state = ST_GND;
        -: 2059:	    }
    #####: 2060:	  ++p;
    #####: 2061:	  break;
        -: 2062:
        -: 2063:	case ST_OCTAL:		/* Octal sequence */
    #####: 2064:	  if (*p < '0' || *p > '7')
        -: 2065:	    {
    #####: 2066:	      *(q++) = num;
    #####: 2067:	      ++count;
    #####: 2068:	      state = ST_GND;
        -: 2069:	    }
        -: 2070:	  else
    #####: 2071:	    num = (num << 3) + (*(p++) - '0');
    #####: 2072:	  break;
        -: 2073:
        -: 2074:	case ST_HEX:		/* Hex sequence */
    #####: 2075:	  switch (*p)
        -: 2076:	    {
        -: 2077:	    case '0':
        -: 2078:	    case '1':
        -: 2079:	    case '2':
        -: 2080:	    case '3':
        -: 2081:	    case '4':
        -: 2082:	    case '5':
        -: 2083:	    case '6':
        -: 2084:	    case '7':
        -: 2085:	    case '8':
        -: 2086:	    case '9':
    #####: 2087:	      num = (num << 4) + (*(p++) - '0');
    #####: 2088:	      break;
        -: 2089:	    case 'a':
        -: 2090:	    case 'b':
        -: 2091:	    case 'c':
        -: 2092:	    case 'd':
        -: 2093:	    case 'e':
        -: 2094:	    case 'f':
    #####: 2095:	      num = (num << 4) + (*(p++) - 'a') + 10;
    #####: 2096:	      break;
        -: 2097:	    case 'A':
        -: 2098:	    case 'B':
        -: 2099:	    case 'C':
        -: 2100:	    case 'D':
        -: 2101:	    case 'E':
        -: 2102:	    case 'F':
    #####: 2103:	      num = (num << 4) + (*(p++) - 'A') + 10;
    #####: 2104:	      break;
        -: 2105:	    default:
    #####: 2106:	      *(q++) = num;
    #####: 2107:	      ++count;
    #####: 2108:	      state = ST_GND;
    #####: 2109:	      break;
        -: 2110:	    }
    #####: 2111:	  break;
        -: 2112:
        -: 2113:	case ST_CARET:		/* Caret escape */
    #####: 2114:	  state = ST_GND;	/* Should be the next state... */
    #####: 2115:	  if (*p >= '@' && *p <= '~')
        -: 2116:	    {
    #####: 2117:	      *(q++) = *(p++) & 037;
    #####: 2118:	      ++count;
        -: 2119:	    }
    #####: 2120:	  else if (*p == '?')
        -: 2121:	    {
    #####: 2122:	      *(q++) = 127;
    #####: 2123:	      ++count;
        -: 2124:	    }
        -: 2125:	  else
    #####: 2126:	    state = ST_ERROR;
    #####: 2127:	  break;
        -: 2128:
        -: 2129:	default:
    #####: 2130:	  abort ();
        -: 2131:	}
        -: 2132:    }
        -: 2133:
    #####: 2134:  *dest = q;
    #####: 2135:  *src = p;
    #####: 2136:  *output_count = count;
        -: 2137:
    #####: 2138:  return state != ST_ERROR;
        -: 2139:}
        -: 2140:
        -: 2141:static void
    #####: 2142:parse_ls_color (void)
        -: 2143:{
        -: 2144:  const char *p;		/* Pointer to character being parsed */
        -: 2145:  char *buf;			/* color_buf buffer pointer */
        -: 2146:  int state;			/* State of parser */
        -: 2147:  int ind_no;			/* Indicator number */
        -: 2148:  char label[3];		/* Indicator label */
        -: 2149:  struct color_ext_type *ext;	/* Extension we are working on */
        -: 2150:
    #####: 2151:  if ((p = getenv ("LS_COLORS")) == NULL || *p == '\0')
    #####: 2152:    return;
        -: 2153:
    #####: 2154:  ext = NULL;
    #####: 2155:  strcpy (label, "??");
        -: 2156:
        -: 2157:  /* This is an overly conservative estimate, but any possible
        -: 2158:     LS_COLORS string will *not* generate a color_buf longer than
        -: 2159:     itself, so it is a safe way of allocating a buffer in
        -: 2160:     advance.  */
    #####: 2161:  buf = color_buf = xstrdup (p);
        -: 2162:
    #####: 2163:  state = 1;
    #####: 2164:  while (state > 0)
        -: 2165:    {
    #####: 2166:      switch (state)
        -: 2167:	{
        -: 2168:	case 1:		/* First label character */
    #####: 2169:	  switch (*p)
        -: 2170:	    {
        -: 2171:	    case ':':
    #####: 2172:	      ++p;
    #####: 2173:	      break;
        -: 2174:
        -: 2175:	    case '*':
        -: 2176:	      /* Allocate new extension block and add to head of
        -: 2177:		 linked list (this way a later definition will
        -: 2178:		 override an earlier one, which can be useful for
        -: 2179:		 having terminal-specific defs override global).  */
        -: 2180:
    #####: 2181:	      ext = xmalloc (sizeof *ext);
    #####: 2182:	      ext->next = color_ext_list;
    #####: 2183:	      color_ext_list = ext;
        -: 2184:
    #####: 2185:	      ++p;
    #####: 2186:	      ext->ext.string = buf;
        -: 2187:
    #####: 2188:	      state = (get_funky_string (&buf, &p, true, &ext->ext.len)
    #####: 2189:		       ? 4 : -1);
    #####: 2190:	      break;
        -: 2191:
        -: 2192:	    case '\0':
    #####: 2193:	      state = 0;	/* Done! */
    #####: 2194:	      break;
        -: 2195:
        -: 2196:	    default:	/* Assume it is file type label */
    #####: 2197:	      label[0] = *(p++);
    #####: 2198:	      state = 2;
    #####: 2199:	      break;
        -: 2200:	    }
    #####: 2201:	  break;
        -: 2202:
        -: 2203:	case 2:		/* Second label character */
    #####: 2204:	  if (*p)
        -: 2205:	    {
    #####: 2206:	      label[1] = *(p++);
    #####: 2207:	      state = 3;
        -: 2208:	    }
        -: 2209:	  else
    #####: 2210:	    state = -1;	/* Error */
    #####: 2211:	  break;
        -: 2212:
        -: 2213:	case 3:		/* Equal sign after indicator label */
    #####: 2214:	  state = -1;	/* Assume failure...  */
    #####: 2215:	  if (*(p++) == '=')/* It *should* be...  */
        -: 2216:	    {
    #####: 2217:	      for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
        -: 2218:		{
    #####: 2219:		  if (STREQ (label, indicator_name[ind_no]))
        -: 2220:		    {
    #####: 2221:		      color_indicator[ind_no].string = buf;
    #####: 2222:		      state = (get_funky_string (&buf, &p, false,
        -: 2223:						 &color_indicator[ind_no].len)
    #####: 2224:			       ? 1 : -1);
    #####: 2225:		      break;
        -: 2226:		    }
        -: 2227:		}
    #####: 2228:	      if (state == -1)
    #####: 2229:		error (0, 0, _("unrecognized prefix: %s"), quotearg (label));
        -: 2230:	    }
    #####: 2231:	  break;
        -: 2232:
        -: 2233:	case 4:		/* Equal sign after *.ext */
    #####: 2234:	  if (*(p++) == '=')
        -: 2235:	    {
    #####: 2236:	      ext->seq.string = buf;
    #####: 2237:	      state = (get_funky_string (&buf, &p, false, &ext->seq.len)
    #####: 2238:		       ? 1 : -1);
        -: 2239:	    }
        -: 2240:	  else
    #####: 2241:	    state = -1;
    #####: 2242:	  break;
        -: 2243:	}
        -: 2244:    }
        -: 2245:
    #####: 2246:  if (state < 0)
        -: 2247:    {
        -: 2248:      struct color_ext_type *e;
        -: 2249:      struct color_ext_type *e2;
        -: 2250:
    #####: 2251:      error (0, 0,
        -: 2252:	     _("unparsable value for LS_COLORS environment variable"));
    #####: 2253:      free (color_buf);
    #####: 2254:      for (e = color_ext_list; e != NULL; /* empty */)
        -: 2255:	{
    #####: 2256:	  e2 = e;
    #####: 2257:	  e = e->next;
    #####: 2258:	  free (e2);
        -: 2259:	}
    #####: 2260:      print_with_color = false;
        -: 2261:    }
        -: 2262:
    #####: 2263:  if (color_indicator[C_LINK].len == 6
    #####: 2264:      && !strncmp (color_indicator[C_LINK].string, "target", 6))
    #####: 2265:    color_symlink_as_referent = true;
        -: 2266:}
        -: 2267:
        -: 2268:/* Set the exit status to report a failure.  If SERIOUS, it is a
        -: 2269:   serious failure; otherwise, it is merely a minor problem.  */
        -: 2270:
        -: 2271:static void
    #####: 2272:set_exit_status (bool serious)
        -: 2273:{
    #####: 2274:  if (serious)
    #####: 2275:    exit_status = LS_FAILURE;
    #####: 2276:  else if (exit_status == EXIT_SUCCESS)
    #####: 2277:    exit_status = LS_MINOR_PROBLEM;
    #####: 2278:}
        -: 2279:
        -: 2280:/* Assuming a failure is serious if SERIOUS, use the printf-style
        -: 2281:   MESSAGE to report the failure to access a file named FILE.  Assume
        -: 2282:   errno is set appropriately for the failure.  */
        -: 2283:
        -: 2284:static void
    #####: 2285:file_failure (bool serious, char const *message, char const *file)
        -: 2286:{
    #####: 2287:  error (0, errno, message, quotearg_colon (file));
    #####: 2288:  set_exit_status (serious);
    #####: 2289:}
        -: 2290:
        -: 2291:/* Request that the directory named NAME have its contents listed later.
        -: 2292:   If REALNAME is nonzero, it will be used instead of NAME when the
        -: 2293:   directory name is printed.  This allows symbolic links to directories
        -: 2294:   to be treated as regular directories but still be listed under their
        -: 2295:   real names.  NAME == NULL is used to insert a marker entry for the
        -: 2296:   directory named in REALNAME.
        -: 2297:   If NAME is non-NULL, we use its dev/ino information to save
        -: 2298:   a call to stat -- when doing a recursive (-R) traversal.
        -: 2299:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2300:
        -: 2301:static void
    #####: 2302:queue_directory (char const *name, char const *realname, bool command_line_arg)
        -: 2303:{
    #####: 2304:  struct pending *new = xmalloc (sizeof *new);
    #####: 2305:  new->realname = realname ? xstrdup (realname) : NULL;
    #####: 2306:  new->name = name ? xstrdup (name) : NULL;
    #####: 2307:  new->command_line_arg = command_line_arg;
    #####: 2308:  new->next = pending_dirs;
    #####: 2309:  pending_dirs = new;
    #####: 2310:}
        -: 2311:
        -: 2312:/* Read directory NAME, and list the files in it.
        -: 2313:   If REALNAME is nonzero, print its name instead of NAME;
        -: 2314:   this is used for symbolic links to directories.
        -: 2315:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
        -: 2316:
        -: 2317:static void
    #####: 2318:print_dir (char const *name, char const *realname, bool command_line_arg)
        -: 2319:{
        -: 2320:  DIR *dirp;
        -: 2321:  struct dirent *next;
    #####: 2322:  uintmax_t total_blocks = 0;
        -: 2323:  static bool first = true;
        -: 2324:
    #####: 2325:  errno = 0;
    #####: 2326:  dirp = opendir (name);
    #####: 2327:  if (!dirp)
        -: 2328:    {
    #####: 2329:      file_failure (command_line_arg, _("cannot open directory %s"), name);
    #####: 2330:      return;
        -: 2331:    }
        -: 2332:
    #####: 2333:  if (LOOP_DETECT)
        -: 2334:    {
        -: 2335:      struct stat dir_stat;
    #####: 2336:      int fd = dirfd (dirp);
        -: 2337:
        -: 2338:      /* If dirfd failed, endure the overhead of using stat.  */
    #####: 2339:      if ((0 <= fd
    #####: 2340:	   ? fstat (fd, &dir_stat)
    #####: 2341:	   : stat (name, &dir_stat)) < 0)
        -: 2342:	{
    #####: 2343:	  file_failure (command_line_arg,
        -: 2344:			_("cannot determine device and inode of %s"), name);
    #####: 2345:	  closedir (dirp);
    #####: 2346:	  return;
        -: 2347:	}
        -: 2348:
        -: 2349:      /* If we've already visited this dev/inode pair, warn that
        -: 2350:	 we've found a loop, and do not process this directory.  */
    #####: 2351:      if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))
        -: 2352:	{
    #####: 2353:	  error (0, 0, _("%s: not listing already-listed directory"),
        -: 2354:		 quotearg_colon (name));
    #####: 2355:	  closedir (dirp);
    #####: 2356:	  return;
        -: 2357:	}
        -: 2358:
    #####: 2359:      DEV_INO_PUSH (dir_stat.st_dev, dir_stat.st_ino);
        -: 2360:    }
        -: 2361:
        -: 2362:  /* Read the directory entries, and insert the subfiles into the `cwd_file'
        -: 2363:     table.  */
        -: 2364:
    #####: 2365:  clear_files ();
        -: 2366:
        -: 2367:  while (1)
        -: 2368:    {
        -: 2369:      /* Set errno to zero so we can distinguish between a readdir failure
        -: 2370:	 and when readdir simply finds that there are no more entries.  */
    #####: 2371:      errno = 0;
    #####: 2372:      next = readdir (dirp);
    #####: 2373:      if (next)
        -: 2374:	{
    #####: 2375:	  if (! file_ignored (next->d_name))
        -: 2376:	    {
    #####: 2377:	      enum filetype type = unknown;
        -: 2378:
        -: 2379:#if HAVE_STRUCT_DIRENT_D_TYPE
    #####: 2380:	      switch (next->d_type)
        -: 2381:		{
    #####: 2382:		case DT_BLK:  type = blockdev;		break;
    #####: 2383:		case DT_CHR:  type = chardev;		break;
    #####: 2384:		case DT_DIR:  type = directory;		break;
    #####: 2385:		case DT_FIFO: type = fifo;		break;
    #####: 2386:		case DT_LNK:  type = symbolic_link;	break;
    #####: 2387:		case DT_REG:  type = normal;		break;
    #####: 2388:		case DT_SOCK: type = sock;		break;
        -: 2389:# ifdef DT_WHT
    #####: 2390:		case DT_WHT:  type = whiteout;		break;
        -: 2391:# endif
        -: 2392:		}
        -: 2393:#endif
    #####: 2394:	      total_blocks += gobble_file (next->d_name, type, D_INO (next),
        -: 2395:					   false, name);
        -: 2396:	    }
        -: 2397:	}
    #####: 2398:      else if (errno != 0)
        -: 2399:	{
    #####: 2400:	  file_failure (command_line_arg, _("reading directory %s"), name);
    #####: 2401:	  if (errno != EOVERFLOW)
    #####: 2402:	    break;
        -: 2403:	}
        -: 2404:      else
    #####: 2405:	break;
    #####: 2406:    }
        -: 2407:
    #####: 2408:  if (closedir (dirp) != 0)
        -: 2409:    {
    #####: 2410:      file_failure (command_line_arg, _("closing directory %s"), name);
        -: 2411:      /* Don't return; print whatever we got.  */
        -: 2412:    }
        -: 2413:
        -: 2414:  /* Sort the directory contents.  */
    #####: 2415:  sort_files ();
        -: 2416:
        -: 2417:  /* If any member files are subdirectories, perhaps they should have their
        -: 2418:     contents listed rather than being mentioned here as files.  */
        -: 2419:
    #####: 2420:  if (recursive)
    #####: 2421:    extract_dirs_from_files (name, command_line_arg);
        -: 2422:
    #####: 2423:  if (recursive | print_dir_name)
        -: 2424:    {
    #####: 2425:      if (!first)
    #####: 2426:	DIRED_PUTCHAR ('\n');
    #####: 2427:      first = false;
    #####: 2428:      DIRED_INDENT ();
    #####: 2429:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
    #####: 2430:      dired_pos += quote_name (stdout, realname ? realname : name,
        -: 2431:			       dirname_quoting_options, NULL);
    #####: 2432:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
    #####: 2433:      DIRED_FPUTS_LITERAL (":\n", stdout);
        -: 2434:    }
        -: 2435:
    #####: 2436:  if (format == long_format || print_block_size)
        -: 2437:    {
        -: 2438:      const char *p;
        -: 2439:      char buf[LONGEST_HUMAN_READABLE + 1];
        -: 2440:
    #####: 2441:      DIRED_INDENT ();
    #####: 2442:      p = _("total");
    #####: 2443:      DIRED_FPUTS (p, stdout, strlen (p));
    #####: 2444:      DIRED_PUTCHAR (' ');
    #####: 2445:      p = human_readable (total_blocks, buf, human_output_opts,
        -: 2446:			  ST_NBLOCKSIZE, output_block_size);
    #####: 2447:      DIRED_FPUTS (p, stdout, strlen (p));
    #####: 2448:      DIRED_PUTCHAR ('\n');
        -: 2449:    }
        -: 2450:
    #####: 2451:  if (cwd_n_used)
    #####: 2452:    print_current_files ();
        -: 2453:}
        -: 2454:
        -: 2455:/* Add `pattern' to the list of patterns for which files that match are
        -: 2456:   not listed.  */
        -: 2457:
        -: 2458:static void
    #####: 2459:add_ignore_pattern (const char *pattern)
        -: 2460:{
        -: 2461:  struct ignore_pattern *ignore;
        -: 2462:
    #####: 2463:  ignore = xmalloc (sizeof *ignore);
    #####: 2464:  ignore->pattern = pattern;
        -: 2465:  /* Add it to the head of the linked list.  */
    #####: 2466:  ignore->next = ignore_patterns;
    #####: 2467:  ignore_patterns = ignore;
    #####: 2468:}
        -: 2469:
        -: 2470:/* Return true if one of the PATTERNS matches FILE.  */
        -: 2471:
        -: 2472:static bool
    #####: 2473:patterns_match (struct ignore_pattern const *patterns, char const *file)
        -: 2474:{
        -: 2475:  struct ignore_pattern const *p;
    #####: 2476:  for (p = patterns; p; p = p->next)
    #####: 2477:    if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)
    #####: 2478:      return true;
    #####: 2479:  return false;
        -: 2480:}
        -: 2481:
        -: 2482:/* Return true if FILE should be ignored.  */
        -: 2483:
        -: 2484:static bool
    #####: 2485:file_ignored (char const *name)
        -: 2486:{
    #####: 2487:  return ((ignore_mode != IGNORE_MINIMAL
    #####: 2488:	   && name[0] == '.'
    #####: 2489:	   && (ignore_mode == IGNORE_DEFAULT || ! name[1 + (name[1] == '.')]))
    #####: 2490:	  || (ignore_mode == IGNORE_DEFAULT
    #####: 2491:	      && patterns_match (hide_patterns, name))
    #####: 2492:	  || patterns_match (ignore_patterns, name));
        -: 2493:}
        -: 2494:
        -: 2495:/* POSIX requires that a file size be printed without a sign, even
        -: 2496:   when negative.  Assume the typical case where negative sizes are
        -: 2497:   actually positive values that have wrapped around.  */
        -: 2498:
        -: 2499:static uintmax_t
    #####: 2500:unsigned_file_size (off_t size)
        -: 2501:{
    #####: 2502:  return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);
        -: 2503:}
        -: 2504:
        -: 2505:/* Enter and remove entries in the table `cwd_file'.  */
        -: 2506:
        -: 2507:/* Empty the table of files.  */
        -: 2508:
        -: 2509:static void
        3: 2510:clear_files (void)
        -: 2511:{
        -: 2512:  size_t i;
        -: 2513:
        3: 2514:  for (i = 0; i < cwd_n_used; i++)
        -: 2515:    {
    #####: 2516:      struct fileinfo *f = sorted_file[i];
    #####: 2517:      free (f->name);
    #####: 2518:      free (f->linkname);
    #####: 2519:      if (f->scontext)
        -: 2520:	{
    #####: 2521:	  freecon (f->scontext);
    #####: 2522:	  f->scontext = NULL;
        -: 2523:	}
        -: 2524:    }
        -: 2525:
        3: 2526:  cwd_n_used = 0;
        3: 2527:  any_has_acl = false;
        3: 2528:  inode_number_width = 0;
        3: 2529:  block_size_width = 0;
        3: 2530:  nlink_width = 0;
        3: 2531:  owner_width = 0;
        3: 2532:  group_width = 0;
        3: 2533:  author_width = 0;
        3: 2534:  scontext_width = 0;
        3: 2535:  major_device_number_width = 0;
        3: 2536:  minor_device_number_width = 0;
        3: 2537:  file_size_width = 0;
        3: 2538:}
        -: 2539:
        -: 2540:/* Add a file to the current table of files.
        -: 2541:   Verify that the file exists, and print an error message if it does not.
        -: 2542:   Return the number of blocks that the file occupies.  */
        -: 2543:
        -: 2544:static uintmax_t
      209: 2545:gobble_file (char const *name, enum filetype type, ino_t inode,
        -: 2546:	     bool command_line_arg, char const *dirname)
        -: 2547:{
      209: 2548:  uintmax_t blocks = 0;
        -: 2549:  struct fileinfo *f;
        -: 2550:
        -: 2551:  /* An inode value prior to gobble_file necessarily came from readdir,
        -: 2552:     which is not used for command line arguments.  */
      209: 2553:  assert (! command_line_arg || inode == NOT_AN_INODE_NUMBER);
        -: 2554:
      209: 2555:  if (cwd_n_used == cwd_n_alloc)
        -: 2556:    {
    #####: 2557:      cwd_file = xnrealloc (cwd_file, cwd_n_alloc, 2 * sizeof *cwd_file);
    #####: 2558:      cwd_n_alloc *= 2;
        -: 2559:    }
        -: 2560:
      209: 2561:  f = &cwd_file[cwd_n_used];
      209: 2562:  memset (f, '\0', sizeof *f);
      209: 2563:  f->stat.st_ino = inode;
      209: 2564:  f->filetype = type;
        -: 2565:
      209: 2566:  if (command_line_arg
    #####: 2567:      || format_needs_stat
        -: 2568:      /* When coloring a directory (we may know the type from
        -: 2569:	 direct.d_type), we have to stat it in order to indicate
        -: 2570:	 sticky and/or other-writable attributes.  */
    #####: 2571:      || (type == directory && print_with_color)
        -: 2572:      /* When dereferencing symlinks, the inode and type must come from
        -: 2573:	 stat, but readdir provides the inode and type of lstat.  */
    #####: 2574:      || ((print_inode || format_needs_type)
    #####: 2575:	  && (type == symbolic_link || type == unknown)
    #####: 2576:	  && (dereference == DEREF_ALWAYS
    #####: 2577:	      || (command_line_arg && dereference != DEREF_NEVER)
    #####: 2578:	      || color_symlink_as_referent || check_symlink_color))
        -: 2579:      /* Command line dereferences are already taken care of by the above
        -: 2580:	 assertion that the inode number is not yet known.  */
    #####: 2581:      || (print_inode && inode == NOT_AN_INODE_NUMBER)
    #####: 2582:      || (format_needs_type
    #####: 2583:	  && (type == unknown || command_line_arg
        -: 2584:	      /* --indicator-style=classify (aka -F)
        -: 2585:		 requires that we stat each regular file
        -: 2586:		 to see if it's executable.  */
    #####: 2587:	      || (type == normal && (indicator_style == classify
        -: 2588:				     /* This is so that --color ends up
        -: 2589:					highlighting files with the executable
        -: 2590:					bit set even when options like -F are
        -: 2591:					not specified.  */
    #####: 2592:				     || (print_with_color
    #####: 2593:					 && is_colored (C_EXEC))
        -: 2594:				     )))))
        -: 2595:
        -: 2596:    {
        -: 2597:      /* FIXME-c99: move this decl "down", once ls.c stabilizes.  */
      209: 2598:      bool file_has_security_context = false;
        -: 2599:      /* Absolute name of this file.  */
        -: 2600:      char *absolute_name;
        -: 2601:      bool do_deref;
        -: 2602:      int err;
        -: 2603:
      209: 2604:      if (name[0] == '/' || dirname[0] == 0)
      209: 2605:	absolute_name = (char *) name;
        -: 2606:      else
        -: 2607:	{
    #####: 2608:	  absolute_name = alloca (strlen (name) + strlen (dirname) + 2);
    #####: 2609:	  attach (absolute_name, dirname, name);
        -: 2610:	}
        -: 2611:
      209: 2612:      switch (dereference)
        -: 2613:	{
        -: 2614:	case DEREF_ALWAYS:
    #####: 2615:	  err = stat (absolute_name, &f->stat);
    #####: 2616:	  do_deref = true;
    #####: 2617:	  break;
        -: 2618:
        -: 2619:	case DEREF_COMMAND_LINE_ARGUMENTS:
        -: 2620:	case DEREF_COMMAND_LINE_SYMLINK_TO_DIR:
      209: 2621:	  if (command_line_arg)
        -: 2622:	    {
        -: 2623:	      bool need_lstat;
      209: 2624:	      err = stat (absolute_name, &f->stat);
      209: 2625:	      do_deref = true;
        -: 2626:
      209: 2627:	      if (dereference == DEREF_COMMAND_LINE_ARGUMENTS)
    #####: 2628:		break;
        -: 2629:
      209: 2630:	      need_lstat = (err < 0
    #####: 2631:			    ? errno == ENOENT
      209: 2632:			    : ! S_ISDIR (f->stat.st_mode));
      209: 2633:	      if (!need_lstat)
    #####: 2634:		break;
        -: 2635:
        -: 2636:	      /* stat failed because of ENOENT, maybe indicating a dangling
        -: 2637:		 symlink.  Or stat succeeded, ABSOLUTE_NAME does not refer to a
        -: 2638:		 directory, and --dereference-command-line-symlink-to-dir is
        -: 2639:		 in effect.  Fall through so that we call lstat instead.  */
        -: 2640:	    }
        -: 2641:
        -: 2642:	default: /* DEREF_NEVER */
      209: 2643:	  err = lstat (absolute_name, &f->stat);
      209: 2644:	  do_deref = false;
      209: 2645:	  break;
        -: 2646:	}
        -: 2647:
      209: 2648:      if (err == 0 && print_scontext)
        -: 2649:	{
    #####: 2650:	  int attr_len = (do_deref
    #####: 2651:			  ?  getfilecon (absolute_name, &f->scontext)
    #####: 2652:			  : lgetfilecon (absolute_name, &f->scontext));
    #####: 2653:	  err = (attr_len < 0);
    #####: 2654:	  file_has_security_context =
    #####: 2655:	    (err == 0 && ! STREQ ("unlabeled", f->scontext));
        -: 2656:
        -: 2657:	  /* When requesting security context information, don't make
        -: 2658:	     ls fail just because the file (even a command line argument)
        -: 2659:	     isn't on the right type of file system.  I.e., a getfilecon
        -: 2660:	     failure isn't in the same class as a stat failure.  */
    #####: 2661:	  if (err && (errno == ENOTSUP || errno == ENODATA))
    #####: 2662:	    err = 0;
        -: 2663:	}
        -: 2664:
      209: 2665:      if (err != 0)
        -: 2666:	{
        -: 2667:	  /* Failure to stat a command line argument leads to
        -: 2668:	     an exit status of 2.  For other files, stat failure
        -: 2669:	     provokes an exit status of 1.  */
    #####: 2670:	  file_failure (command_line_arg,
        -: 2671:			_("cannot access %s"), absolute_name);
    #####: 2672:	  if (command_line_arg)
    #####: 2673:	    return 0;
        -: 2674:
    #####: 2675:	  f->name = xstrdup (name);
    #####: 2676:	  cwd_n_used++;
        -: 2677:
    #####: 2678:	  return 0;
        -: 2679:	}
        -: 2680:
      209: 2681:      f->stat_ok = true;
        -: 2682:
      209: 2683:      if (format == long_format)
        -: 2684:	{
    #####: 2685:	  int n = file_has_acl (absolute_name, &f->stat);
    #####: 2686:	  f->have_acl = (0 < n || file_has_security_context);
    #####: 2687:	  any_has_acl |= f->have_acl;
    #####: 2688:	  if (n < 0)
    #####: 2689:	    error (0, errno, "%s", quotearg_colon (absolute_name));
        -: 2690:	}
        -: 2691:
      209: 2692:      if (S_ISLNK (f->stat.st_mode)
    #####: 2693:	  && (format == long_format || check_symlink_color))
        -: 2694:	{
        -: 2695:	  char *linkname;
        -: 2696:	  struct stat linkstats;
        -: 2697:
    #####: 2698:	  get_link_name (absolute_name, f, command_line_arg);
    #####: 2699:	  linkname = make_link_name (absolute_name, f->linkname);
        -: 2700:
        -: 2701:	  /* Avoid following symbolic links when possible, ie, when
        -: 2702:	     they won't be traced and when no indicator is needed.  */
    #####: 2703:	  if (linkname
    #####: 2704:	      && (file_type <= indicator_style || check_symlink_color)
    #####: 2705:	      && stat (linkname, &linkstats) == 0)
        -: 2706:	    {
    #####: 2707:	      f->linkok = true;
        -: 2708:
        -: 2709:	      /* Symbolic links to directories that are mentioned on the
        -: 2710:		 command line are automatically traced if not being
        -: 2711:		 listed as files.  */
    #####: 2712:	      if (!command_line_arg || format == long_format
    #####: 2713:		  || !S_ISDIR (linkstats.st_mode))
        -: 2714:		{
        -: 2715:		  /* Get the linked-to file's mode for the filetype indicator
        -: 2716:		     in long listings.  */
    #####: 2717:		  f->linkmode = linkstats.st_mode;
        -: 2718:		}
        -: 2719:	    }
    #####: 2720:	  free (linkname);
        -: 2721:	}
        -: 2722:
        -: 2723:      /* When not distinguishing types of symlinks, pretend we know that
        -: 2724:	 it is stat'able, so that it will be colored as a regular symlink,
        -: 2725:	 and not as an orphan.  */
      209: 2726:      if (S_ISLNK (f->stat.st_mode) && !check_symlink_color)
    #####: 2727:	f->linkok = true;
        -: 2728:
      209: 2729:      if (S_ISLNK (f->stat.st_mode))
    #####: 2730:	f->filetype = symbolic_link;
      209: 2731:      else if (S_ISDIR (f->stat.st_mode))
        -: 2732:	{
    #####: 2733:	  if (command_line_arg & !immediate_dirs)
    #####: 2734:	    f->filetype = arg_directory;
        -: 2735:	  else
    #####: 2736:	    f->filetype = directory;
        -: 2737:	}
        -: 2738:      else
      209: 2739:	f->filetype = normal;
        -: 2740:
      209: 2741:      blocks = ST_NBLOCKS (f->stat);
      209: 2742:      if (format == long_format || print_block_size)
        -: 2743:	{
        -: 2744:	  char buf[LONGEST_HUMAN_READABLE + 1];
    #####: 2745:	  int len = mbswidth (human_readable (blocks, buf, human_output_opts,
        -: 2746:					      ST_NBLOCKSIZE, output_block_size),
        -: 2747:			      0);
    #####: 2748:	  if (block_size_width < len)
    #####: 2749:	    block_size_width = len;
        -: 2750:	}
        -: 2751:
      209: 2752:      if (format == long_format)
        -: 2753:	{
    #####: 2754:	  if (print_owner)
        -: 2755:	    {
    #####: 2756:	      int len = format_user_width (f->stat.st_uid);
    #####: 2757:	      if (owner_width < len)
    #####: 2758:		owner_width = len;
        -: 2759:	    }
        -: 2760:
    #####: 2761:	  if (print_group)
        -: 2762:	    {
    #####: 2763:	      int len = format_group_width (f->stat.st_gid);
    #####: 2764:	      if (group_width < len)
    #####: 2765:		group_width = len;
        -: 2766:	    }
        -: 2767:
    #####: 2768:	  if (print_author)
        -: 2769:	    {
    #####: 2770:	      int len = format_user_width (f->stat.st_author);
    #####: 2771:	      if (author_width < len)
    #####: 2772:		author_width = len;
        -: 2773:	    }
        -: 2774:	}
        -: 2775:
      209: 2776:      if (print_scontext)
        -: 2777:	{
    #####: 2778:	  int len = f->scontext ? strlen (f->scontext) : 0;
    #####: 2779:	  if (scontext_width < len)
    #####: 2780:	    scontext_width = len;
        -: 2781:	}
        -: 2782:
      209: 2783:      if (format == long_format)
        -: 2784:	{
        -: 2785:	  char b[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 2786:	  int b_len = strlen (umaxtostr (f->stat.st_nlink, b));
    #####: 2787:	  if (nlink_width < b_len)
    #####: 2788:	    nlink_width = b_len;
        -: 2789:
    #####: 2790:	  if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))
    #####: 2791:	    {
        -: 2792:	      char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 2793:	      int len = strlen (umaxtostr (major (f->stat.st_rdev), buf));
    #####: 2794:	      if (major_device_number_width < len)
    #####: 2795:		major_device_number_width = len;
    #####: 2796:	      len = strlen (umaxtostr (minor (f->stat.st_rdev), buf));
    #####: 2797:	      if (minor_device_number_width < len)
    #####: 2798:		minor_device_number_width = len;
    #####: 2799:	      len = major_device_number_width + 2 + minor_device_number_width;
    #####: 2800:	      if (file_size_width < len)
    #####: 2801:		file_size_width = len;
        -: 2802:	    }
        -: 2803:	  else
        -: 2804:	    {
        -: 2805:	      char buf[LONGEST_HUMAN_READABLE + 1];
    #####: 2806:	      uintmax_t size = unsigned_file_size (f->stat.st_size);
    #####: 2807:	      int len = mbswidth (human_readable (size, buf, human_output_opts,
        -: 2808:						  1, file_output_block_size),
        -: 2809:				  0);
    #####: 2810:	      if (file_size_width < len)
    #####: 2811:		file_size_width = len;
        -: 2812:	    }
        -: 2813:	}
        -: 2814:    }
        -: 2815:
      209: 2816:  if (print_inode)
        -: 2817:    {
        -: 2818:      char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 2819:      int len = strlen (umaxtostr (f->stat.st_ino, buf));
    #####: 2820:      if (inode_number_width < len)
    #####: 2821:	inode_number_width = len;
        -: 2822:    }
        -: 2823:
      209: 2824:  f->name = xstrdup (name);
      209: 2825:  cwd_n_used++;
        -: 2826:
      209: 2827:  return blocks;
        -: 2828:}
        -: 2829:
        -: 2830:/* Return true if F refers to a directory.  */
        -: 2831:static bool
      209: 2832:is_directory (const struct fileinfo *f)
        -: 2833:{
      209: 2834:  return f->filetype == directory || f->filetype == arg_directory;
        -: 2835:}
        -: 2836:
        -: 2837:/* Put the name of the file that FILENAME is a symbolic link to
        -: 2838:   into the LINKNAME field of `f'.  COMMAND_LINE_ARG indicates whether
        -: 2839:   FILENAME is a command-line argument.  */
        -: 2840:
        -: 2841:static void
    #####: 2842:get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
        -: 2843:{
    #####: 2844:  f->linkname = areadlink_with_size (filename, f->stat.st_size);
    #####: 2845:  if (f->linkname == NULL)
    #####: 2846:    file_failure (command_line_arg, _("cannot read symbolic link %s"),
        -: 2847:		  filename);
    #####: 2848:}
        -: 2849:
        -: 2850:/* If `linkname' is a relative name and `name' contains one or more
        -: 2851:   leading directories, return `linkname' with those directories
        -: 2852:   prepended; otherwise, return a copy of `linkname'.
        -: 2853:   If `linkname' is zero, return zero.  */
        -: 2854:
        -: 2855:static char *
    #####: 2856:make_link_name (char const *name, char const *linkname)
        -: 2857:{
        -: 2858:  char *linkbuf;
        -: 2859:  size_t bufsiz;
        -: 2860:
    #####: 2861:  if (!linkname)
    #####: 2862:    return NULL;
        -: 2863:
    #####: 2864:  if (*linkname == '/')
    #####: 2865:    return xstrdup (linkname);
        -: 2866:
        -: 2867:  /* The link is to a relative name.  Prepend any leading directory
        -: 2868:     in `name' to the link name.  */
    #####: 2869:  linkbuf = strrchr (name, '/');
    #####: 2870:  if (linkbuf == 0)
    #####: 2871:    return xstrdup (linkname);
        -: 2872:
    #####: 2873:  bufsiz = linkbuf - name + 1;
    #####: 2874:  linkbuf = xmalloc (bufsiz + strlen (linkname) + 1);
    #####: 2875:  strncpy (linkbuf, name, bufsiz);
    #####: 2876:  strcpy (linkbuf + bufsiz, linkname);
    #####: 2877:  return linkbuf;
        -: 2878:}
        -: 2879:
        -: 2880:/* Return true if the last component of NAME is `.' or `..'
        -: 2881:   This is so we don't try to recurse on `././././. ...' */
        -: 2882:
        -: 2883:static bool
    #####: 2884:basename_is_dot_or_dotdot (const char *name)
        -: 2885:{
    #####: 2886:  char const *base = last_component (name);
    #####: 2887:  return dot_or_dotdot (base);
        -: 2888:}
        -: 2889:
        -: 2890:/* Remove any entries from CWD_FILE that are for directories,
        -: 2891:   and queue them to be listed as directories instead.
        -: 2892:   DIRNAME is the prefix to prepend to each dirname
        -: 2893:   to make it correct relative to ls's working dir;
        -: 2894:   if it is null, no prefix is needed and "." and ".." should not be ignored.
        -: 2895:   If COMMAND_LINE_ARG is true, this directory was mentioned at the top level,
        -: 2896:   This is desirable when processing directories recursively.  */
        -: 2897:
        -: 2898:static void
        3: 2899:extract_dirs_from_files (char const *dirname, bool command_line_arg)
        -: 2900:{
        -: 2901:  size_t i;
        -: 2902:  size_t j;
        3: 2903:  bool ignore_dot_and_dot_dot = (dirname != NULL);
        -: 2904:
        3: 2905:  if (dirname && LOOP_DETECT)
        -: 2906:    {
        -: 2907:      /* Insert a marker entry first.  When we dequeue this marker entry,
        -: 2908:	 we'll know that DIRNAME has been processed and may be removed
        -: 2909:	 from the set of active directories.  */
    #####: 2910:      queue_directory (NULL, dirname, false);
        -: 2911:    }
        -: 2912:
        -: 2913:  /* Queue the directories last one first, because queueing reverses the
        -: 2914:     order.  */
      215: 2915:  for (i = cwd_n_used; i-- != 0; )
        -: 2916:    {
      209: 2917:      struct fileinfo *f = sorted_file[i];
        -: 2918:
      209: 2919:      if (is_directory (f)
    #####: 2920:	  && (! ignore_dot_and_dot_dot
    #####: 2921:	      || ! basename_is_dot_or_dotdot (f->name)))
        -: 2922:	{
    #####: 2923:	  if (!dirname || f->name[0] == '/')
    #####: 2924:	    queue_directory (f->name, f->linkname, command_line_arg);
        -: 2925:	  else
        -: 2926:	    {
    #####: 2927:	      char *name = file_name_concat (dirname, f->name, NULL);
    #####: 2928:	      queue_directory (name, f->linkname, command_line_arg);
    #####: 2929:	      free (name);
        -: 2930:	    }
    #####: 2931:	  if (f->filetype == arg_directory)
    #####: 2932:	    free (f->name);
        -: 2933:	}
        -: 2934:    }
        -: 2935:
        -: 2936:  /* Now delete the directories from the table, compacting all the remaining
        -: 2937:     entries.  */
        -: 2938:
      212: 2939:  for (i = 0, j = 0; i < cwd_n_used; i++)
        -: 2940:    {
      209: 2941:      struct fileinfo *f = sorted_file[i];
      209: 2942:      sorted_file[j] = f;
      209: 2943:      j += (f->filetype != arg_directory);
        -: 2944:    }
        3: 2945:  cwd_n_used = j;
        3: 2946:}
        -: 2947:
        -: 2948:/* Use strcoll to compare strings in this locale.  If an error occurs,
        -: 2949:   report an error and longjmp to failed_strcoll.  */
        -: 2950:
        -: 2951:static jmp_buf failed_strcoll;
        -: 2952:
        -: 2953:static int
      641: 2954:xstrcoll (char const *a, char const *b)
        -: 2955:{
        -: 2956:  int diff;
      641: 2957:  errno = 0;
      641: 2958:  diff = strcoll (a, b);
      641: 2959:  if (errno)
        -: 2960:    {
    #####: 2961:      error (0, errno, _("cannot compare file names %s and %s"),
        -: 2962:	     quote_n (0, a), quote_n (1, b));
    #####: 2963:      set_exit_status (false);
    #####: 2964:      longjmp (failed_strcoll, 1);
        -: 2965:    }
      641: 2966:  return diff;
        -: 2967:}
        -: 2968:
        -: 2969:/* Comparison routines for sorting the files.  */
        -: 2970:
        -: 2971:typedef void const *V;
        -: 2972:typedef int (*qsortFunc)(V a, V b);
        -: 2973:
        -: 2974:/* Used below in DEFINE_SORT_FUNCTIONS for _df_ sort function variants.
        -: 2975:   The do { ... } while(0) makes it possible to use the macro more like
        -: 2976:   a statement, without violating C89 rules: */
        -: 2977:#define DIRFIRST_CHECK(a, b)						\
        -: 2978:  do									\
        -: 2979:    {									\
        -: 2980:      bool a_is_dir = is_directory ((struct fileinfo const *) a);	\
        -: 2981:      bool b_is_dir = is_directory ((struct fileinfo const *) b);	\
        -: 2982:      if (a_is_dir && !b_is_dir)					\
        -: 2983:	return -1;         /* a goes before b */			\
        -: 2984:      if (!a_is_dir && b_is_dir)					\
        -: 2985:	return 1;          /* b goes before a */			\
        -: 2986:    }									\
        -: 2987:  while (0)
        -: 2988:
        -: 2989:/* Define the 8 different sort function variants required for each sortkey.
        -: 2990:   KEY_NAME is a token describing the sort key, e.g., ctime, atime, size.
        -: 2991:   KEY_CMP_FUNC is a function to compare records based on that key, e.g.,
        -: 2992:   ctime_cmp, atime_cmp, size_cmp.  Append KEY_NAME to the string,
        -: 2993:   '[rev_][x]str{cmp|coll}[_df]_', to create each function name.  */
        -: 2994:#define DEFINE_SORT_FUNCTIONS(key_name, key_cmp_func)			\
        -: 2995:  /* direct, non-dirfirst versions */					\
        -: 2996:  static int xstrcoll_##key_name (V a, V b)				\
        -: 2997:  { return key_cmp_func (a, b, xstrcoll); }				\
        -: 2998:  static int strcmp_##key_name (V a, V b)				\
        -: 2999:  { return key_cmp_func (a, b, strcmp); }				\
        -: 3000:									\
        -: 3001:  /* reverse, non-dirfirst versions */					\
        -: 3002:  static int rev_xstrcoll_##key_name (V a, V b)				\
        -: 3003:  { return key_cmp_func (b, a, xstrcoll); }				\
        -: 3004:  static int rev_strcmp_##key_name (V a, V b)				\
        -: 3005:  { return key_cmp_func (b, a, strcmp); }				\
        -: 3006:									\
        -: 3007:  /* direct, dirfirst versions */					\
        -: 3008:  static int xstrcoll_df_##key_name (V a, V b)				\
        -: 3009:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, xstrcoll); }	\
        -: 3010:  static int strcmp_df_##key_name (V a, V b)				\
        -: 3011:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, strcmp); }	\
        -: 3012:									\
        -: 3013:  /* reverse, dirfirst versions */					\
        -: 3014:  static int rev_xstrcoll_df_##key_name (V a, V b)			\
        -: 3015:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, xstrcoll); }	\
        -: 3016:  static int rev_strcmp_df_##key_name (V a, V b)			\
        -: 3017:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, strcmp); }
        -: 3018:
        -: 3019:static inline int
    #####: 3020:cmp_ctime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3021:	   int (*cmp) (char const *, char const *))
        -: 3022:{
    #####: 3023:  int diff = timespec_cmp (get_stat_ctime (&b->stat),
        -: 3024:			   get_stat_ctime (&a->stat));
    #####: 3025:  return diff ? diff : cmp (a->name, b->name);
        -: 3026:}
        -: 3027:
        -: 3028:static inline int
    #####: 3029:cmp_mtime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3030:	   int (*cmp) (char const *, char const *))
        -: 3031:{
    #####: 3032:  int diff = timespec_cmp (get_stat_mtime (&b->stat),
        -: 3033:			   get_stat_mtime (&a->stat));
    #####: 3034:  return diff ? diff : cmp (a->name, b->name);
        -: 3035:}
        -: 3036:
        -: 3037:static inline int
    #####: 3038:cmp_atime (struct fileinfo const *a, struct fileinfo const *b,
        -: 3039:	   int (*cmp) (char const *, char const *))
        -: 3040:{
    #####: 3041:  int diff = timespec_cmp (get_stat_atime (&b->stat),
        -: 3042:			   get_stat_atime (&a->stat));
    #####: 3043:  return diff ? diff : cmp (a->name, b->name);
        -: 3044:}
        -: 3045:
        -: 3046:static inline int
    #####: 3047:cmp_size (struct fileinfo const *a, struct fileinfo const *b,
        -: 3048:	  int (*cmp) (char const *, char const *))
        -: 3049:{
    #####: 3050:  int diff = longdiff (b->stat.st_size, a->stat.st_size);
    #####: 3051:  return diff ? diff : cmp (a->name, b->name);
        -: 3052:}
        -: 3053:
        -: 3054:static inline int
      641: 3055:cmp_name (struct fileinfo const *a, struct fileinfo const *b,
        -: 3056:	  int (*cmp) (char const *, char const *))
        -: 3057:{
      641: 3058:  return cmp (a->name, b->name);
        -: 3059:}
        -: 3060:
        -: 3061:/* Compare file extensions.  Files with no extension are `smallest'.
        -: 3062:   If extensions are the same, compare by filenames instead.  */
        -: 3063:
        -: 3064:static inline int
    #####: 3065:cmp_extension (struct fileinfo const *a, struct fileinfo const *b,
        -: 3066:	       int (*cmp) (char const *, char const *))
        -: 3067:{
    #####: 3068:  char const *base1 = strrchr (a->name, '.');
    #####: 3069:  char const *base2 = strrchr (b->name, '.');
    #####: 3070:  int diff = cmp (base1 ? base1 : "", base2 ? base2 : "");
    #####: 3071:  return diff ? diff : cmp (a->name, b->name);
        -: 3072:}
        -: 3073:
    #####: 3074:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
    #####: 3075:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
    #####: 3076:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
    #####: 3077:DEFINE_SORT_FUNCTIONS (size, cmp_size)
      641: 3078:DEFINE_SORT_FUNCTIONS (name, cmp_name)
    #####: 3079:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
        -: 3080:
        -: 3081:/* Compare file versions.
        -: 3082:   Unlike all other compare functions above, cmp_version depends only
        -: 3083:   on strverscmp, which does not fail (even for locale reasons), and does not
        -: 3084:   need a secondary sort key.
        -: 3085:   All the other sort options, in fact, need xstrcoll and strcmp variants,
        -: 3086:   because they all use a string comparison (either as the primary or secondary
        -: 3087:   sort key), and xstrcoll has the ability to do a longjmp if strcoll fails for
        -: 3088:   locale reasons.  Last, strverscmp is ALWAYS available in coreutils,
        -: 3089:   thanks to the gnulib library. */
        -: 3090:static inline int
    #####: 3091:cmp_version (struct fileinfo const *a, struct fileinfo const *b)
        -: 3092:{
    #####: 3093:  return strverscmp (a->name, b->name);
        -: 3094:}
        -: 3095:
    #####: 3096:static int xstrcoll_version (V a, V b)
    #####: 3097:{ return cmp_version (a, b); }
    #####: 3098:static int rev_xstrcoll_version (V a, V b)
    #####: 3099:{ return cmp_version (b, a); }
    #####: 3100:static int xstrcoll_df_version (V a, V b)
    #####: 3101:{ DIRFIRST_CHECK (a, b); return cmp_version (a, b); }
    #####: 3102:static int rev_xstrcoll_df_version (V a, V b)
    #####: 3103:{ DIRFIRST_CHECK (a, b); return cmp_version (b, a); }
        -: 3104:
        -: 3105:
        -: 3106:/* We have 2^3 different variants for each sortkey function
        -: 3107:   (for 3 independent sort modes).
        -: 3108:   The function pointers stored in this array must be dereferenced as:
        -: 3109:
        -: 3110:    sort_variants[sort_key][use_strcmp][reverse][dirs_first]
        -: 3111:
        -: 3112:   Note that the order in which sortkeys are listed in the function pointer
        -: 3113:   array below is defined by the order of the elements in the time_type and
        -: 3114:   sort_type enums!  */
        -: 3115:
        -: 3116:#define LIST_SORTFUNCTION_VARIANTS(key_name)                        \
        -: 3117:  {                                                                 \
        -: 3118:    {                                                               \
        -: 3119:      { xstrcoll_##key_name, xstrcoll_df_##key_name },              \
        -: 3120:      { rev_xstrcoll_##key_name, rev_xstrcoll_df_##key_name },      \
        -: 3121:    },                                                              \
        -: 3122:    {                                                               \
        -: 3123:      { strcmp_##key_name, strcmp_df_##key_name },                  \
        -: 3124:      { rev_strcmp_##key_name, rev_strcmp_df_##key_name },          \
        -: 3125:    }                                                               \
        -: 3126:  }
        -: 3127:
        -: 3128:static qsortFunc sort_functions[][2][2][2] =
        -: 3129:  {
        -: 3130:    LIST_SORTFUNCTION_VARIANTS (name),
        -: 3131:    LIST_SORTFUNCTION_VARIANTS (extension),
        -: 3132:    LIST_SORTFUNCTION_VARIANTS (size),
        -: 3133:
        -: 3134:    {
        -: 3135:      {
        -: 3136:        { xstrcoll_version, xstrcoll_df_version },
        -: 3137:        { rev_xstrcoll_version, rev_xstrcoll_df_version },
        -: 3138:      },
        -: 3139:
        -: 3140:      /* We use NULL for the strcmp variants of version comparison
        -: 3141:         since as explained in cmp_version definition, version comparison
        -: 3142:         does not rely on xstrcoll, so it will never longjmp, and never
        -: 3143:         need to try the strcmp fallback. */
        -: 3144:      {
        -: 3145:        { NULL, NULL },
        -: 3146:        { NULL, NULL },
        -: 3147:      }
        -: 3148:    },
        -: 3149:
        -: 3150:    /* last are time sort functions */
        -: 3151:    LIST_SORTFUNCTION_VARIANTS (mtime),
        -: 3152:    LIST_SORTFUNCTION_VARIANTS (ctime),
        -: 3153:    LIST_SORTFUNCTION_VARIANTS (atime)
        -: 3154:  };
        -: 3155:
        -: 3156:/* The number of sortkeys is calculated as
        -: 3157:     the number of elements in the sort_type enum (i.e. sort_numtypes) +
        -: 3158:     the number of elements in the time_type enum (i.e. time_numtypes) - 1
        -: 3159:   This is because when sort_type==sort_time, we have up to
        -: 3160:   time_numtypes possible sortkeys.
        -: 3161:
        -: 3162:   This line verifies at compile-time that the array of sort functions has been
        -: 3163:   initialized for all possible sortkeys. */
        -: 3164:verify (ARRAY_CARDINALITY (sort_functions)
        -: 3165:	== sort_numtypes + time_numtypes - 1 );
        -: 3166:
        -: 3167:/* Set up SORTED_FILE to point to the in-use entries in CWD_FILE, in order.  */
        -: 3168:
        -: 3169:static void
        3: 3170:initialize_ordering_vector (void)
        -: 3171:{
        -: 3172:  size_t i;
      212: 3173:  for (i = 0; i < cwd_n_used; i++)
      209: 3174:    sorted_file[i] = &cwd_file[i];
        3: 3175:}
        -: 3176:
        -: 3177:/* Sort the files now in the table.  */
        -: 3178:
        -: 3179:static void
        3: 3180:sort_files (void)
        -: 3181:{
        -: 3182:  bool use_strcmp;
        -: 3183:
        3: 3184:  if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)
        -: 3185:    {
        3: 3186:      free (sorted_file);
        3: 3187:      sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);
        3: 3188:      sorted_file_alloc = 3 * cwd_n_used;
        -: 3189:    }
        -: 3190:
        3: 3191:  initialize_ordering_vector ();
        -: 3192:
        3: 3193:  if (sort_type == sort_none)
        3: 3194:    return;
        -: 3195:
        -: 3196:  /* Try strcoll.  If it fails, fall back on strcmp.  We can't safely
        -: 3197:     ignore strcoll failures, as a failing strcoll might be a
        -: 3198:     comparison function that is not a total order, and if we ignored
        -: 3199:     the failure this might cause qsort to dump core.  */
        -: 3200:
        3: 3201:  if (! setjmp (failed_strcoll))
        3: 3202:    use_strcmp = false;      /* strcoll() succeeded */
        -: 3203:  else
        -: 3204:    {
    #####: 3205:      use_strcmp = true;
    #####: 3206:      assert (sort_type != sort_version);
    #####: 3207:      initialize_ordering_vector ();
        -: 3208:    }
        -: 3209:
        -: 3210:  /* When sort_type == sort_time, use time_type as subindex.  */
        6: 3211:  mpsort ((void const **) sorted_file, cwd_n_used,
        3: 3212:	  sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]
        -: 3213:			[use_strcmp][sort_reverse]
        3: 3214:			[directories_first]);
        -: 3215:}
        -: 3216:
        -: 3217:/* List all the files now in the table.  */
        -: 3218:
        -: 3219:static void
        3: 3220:print_current_files (void)
        -: 3221:{
        -: 3222:  size_t i;
        -: 3223:
        3: 3224:  switch (format)
        -: 3225:    {
        -: 3226:    case one_per_line:
      212: 3227:      for (i = 0; i < cwd_n_used; i++)
        -: 3228:	{
      209: 3229:	  print_file_name_and_frills (sorted_file[i]);
      209: 3230:	  putchar ('\n');
        -: 3231:	}
        3: 3232:      break;
        -: 3233:
        -: 3234:    case many_per_line:
    #####: 3235:      print_many_per_line ();
    #####: 3236:      break;
        -: 3237:
        -: 3238:    case horizontal:
    #####: 3239:      print_horizontal ();
    #####: 3240:      break;
        -: 3241:
        -: 3242:    case with_commas:
    #####: 3243:      print_with_commas ();
    #####: 3244:      break;
        -: 3245:
        -: 3246:    case long_format:
    #####: 3247:      for (i = 0; i < cwd_n_used; i++)
        -: 3248:	{
    #####: 3249:	  print_long_format (sorted_file[i]);
    #####: 3250:	  DIRED_PUTCHAR ('\n');
        -: 3251:	}
    #####: 3252:      break;
        -: 3253:    }
        3: 3254:}
        -: 3255:
        -: 3256:/* Return the expected number of columns in a long-format time stamp,
        -: 3257:   or zero if it cannot be calculated.  */
        -: 3258:
        -: 3259:static int
    #####: 3260:long_time_expected_width (void)
        -: 3261:{
        -: 3262:  static int width = -1;
        -: 3263:
    #####: 3264:  if (width < 0)
        -: 3265:    {
    #####: 3266:      time_t epoch = 0;
    #####: 3267:      struct tm const *tm = localtime (&epoch);
        -: 3268:      char buf[TIME_STAMP_LEN_MAXIMUM + 1];
        -: 3269:
        -: 3270:      /* In case you're wondering if localtime can fail with an input time_t
        -: 3271:	 value of 0, let's just say it's very unlikely, but not inconceivable.
        -: 3272:	 The TZ environment variable would have to specify a time zone that
        -: 3273:	 is 2**31-1900 years or more ahead of UTC.  This could happen only on
        -: 3274:	 a 64-bit system that blindly accepts e.g., TZ=UTC+20000000000000.
        -: 3275:	 However, this is not possible with Solaris 10 or glibc-2.3.5, since
        -: 3276:	 their implementations limit the offset to 167:59 and 24:00, resp.  */
    #####: 3277:      if (tm)
        -: 3278:	{
    #####: 3279:	  size_t len =
    #####: 3280:	    nstrftime (buf, sizeof buf, long_time_format[0], tm, 0, 0);
    #####: 3281:	  if (len != 0)
    #####: 3282:	    width = mbsnwidth (buf, len, 0);
        -: 3283:	}
        -: 3284:
    #####: 3285:      if (width < 0)
    #####: 3286:	width = 0;
        -: 3287:    }
        -: 3288:
    #####: 3289:  return width;
        -: 3290:}
        -: 3291:
        -: 3292:/* Get the current time.  */
        -: 3293:
        -: 3294:static void
    #####: 3295:get_current_time (void)
        -: 3296:{
        -: 3297:#if HAVE_CLOCK_GETTIME && defined CLOCK_REALTIME
        -: 3298:  {
        -: 3299:    struct timespec timespec;
    #####: 3300:    if (clock_gettime (CLOCK_REALTIME, &timespec) == 0)
        -: 3301:      {
    #####: 3302:	current_time = timespec.tv_sec;
    #####: 3303:	current_time_ns = timespec.tv_nsec;
    #####: 3304:	return;
        -: 3305:      }
        -: 3306:  }
        -: 3307:#endif
        -: 3308:
        -: 3309:  /* The clock does not have nanosecond resolution, so get the maximum
        -: 3310:     possible value for the current time that is consistent with the
        -: 3311:     reported clock.  That way, files are not considered to be in the
        -: 3312:     future merely because their time stamps have higher resolution
        -: 3313:     than the clock resolution.  */
        -: 3314:
        -: 3315:#if HAVE_GETTIMEOFDAY
        -: 3316:  {
        -: 3317:    struct timeval timeval;
    #####: 3318:    gettimeofday (&timeval, NULL);
    #####: 3319:    current_time = timeval.tv_sec;
    #####: 3320:    current_time_ns = timeval.tv_usec * 1000 + 999;
        -: 3321:  }
        -: 3322:#else
        -: 3323:  current_time = time (NULL);
        -: 3324:  current_time_ns = 999999999;
        -: 3325:#endif
        -: 3326:}
        -: 3327:
        -: 3328:/* Print the user or group name NAME, with numeric id ID, using a
        -: 3329:   print width of WIDTH columns.  */
        -: 3330:
        -: 3331:static void
    #####: 3332:format_user_or_group (char const *name, unsigned long int id, int width)
        -: 3333:{
        -: 3334:  size_t len;
        -: 3335:
    #####: 3336:  if (name)
        -: 3337:    {
    #####: 3338:      int width_gap = width - mbswidth (name, 0);
    #####: 3339:      int pad = MAX (0, width_gap);
    #####: 3340:      fputs (name, stdout);
    #####: 3341:      len = strlen (name) + pad;
        -: 3342:
        -: 3343:      do
    #####: 3344:	putchar (' ');
    #####: 3345:      while (pad--);
        -: 3346:    }
        -: 3347:  else
        -: 3348:    {
    #####: 3349:      printf ("%*lu ", width, id);
    #####: 3350:      len = width;
        -: 3351:    }
        -: 3352:
    #####: 3353:  dired_pos += len + 1;
    #####: 3354:}
        -: 3355:
        -: 3356:/* Print the name or id of the user with id U, using a print width of
        -: 3357:   WIDTH.  */
        -: 3358:
        -: 3359:static void
    #####: 3360:format_user (uid_t u, int width, bool stat_ok)
        -: 3361:{
    #####: 3362:  format_user_or_group (! stat_ok ? "?" :
        -: 3363:			(numeric_ids ? NULL : getuser (u)), u, width);
    #####: 3364:}
        -: 3365:
        -: 3366:/* Likewise, for groups.  */
        -: 3367:
        -: 3368:static void
    #####: 3369:format_group (gid_t g, int width, bool stat_ok)
        -: 3370:{
    #####: 3371:  format_user_or_group (! stat_ok ? "?" :
        -: 3372:			(numeric_ids ? NULL : getgroup (g)), g, width);
    #####: 3373:}
        -: 3374:
        -: 3375:/* Return the number of columns that format_user_or_group will print.  */
        -: 3376:
        -: 3377:static int
    #####: 3378:format_user_or_group_width (char const *name, unsigned long int id)
        -: 3379:{
    #####: 3380:  if (name)
        -: 3381:    {
    #####: 3382:      int len = mbswidth (name, 0);
    #####: 3383:      return MAX (0, len);
        -: 3384:    }
        -: 3385:  else
        -: 3386:    {
        -: 3387:      char buf[INT_BUFSIZE_BOUND (unsigned long int)];
    #####: 3388:      sprintf (buf, "%lu", id);
    #####: 3389:      return strlen (buf);
        -: 3390:    }
        -: 3391:}
        -: 3392:
        -: 3393:/* Return the number of columns that format_user will print.  */
        -: 3394:
        -: 3395:static int
    #####: 3396:format_user_width (uid_t u)
        -: 3397:{
    #####: 3398:  return format_user_or_group_width (numeric_ids ? NULL : getuser (u), u);
        -: 3399:}
        -: 3400:
        -: 3401:/* Likewise, for groups.  */
        -: 3402:
        -: 3403:static int
    #####: 3404:format_group_width (gid_t g)
        -: 3405:{
    #####: 3406:  return format_user_or_group_width (numeric_ids ? NULL : getgroup (g), g);
        -: 3407:}
        -: 3408:
        -: 3409:
        -: 3410:/* Print information about F in long format.  */
        -: 3411:
        -: 3412:static void
    #####: 3413:print_long_format (const struct fileinfo *f)
        -: 3414:{
        -: 3415:  char modebuf[12];
        -: 3416:  char buf
        -: 3417:    [LONGEST_HUMAN_READABLE + 1		/* inode */
        -: 3418:     + LONGEST_HUMAN_READABLE + 1	/* size in blocks */
        -: 3419:     + sizeof (modebuf) - 1 + 1		/* mode string */
        -: 3420:     + INT_BUFSIZE_BOUND (uintmax_t)	/* st_nlink */
        -: 3421:     + LONGEST_HUMAN_READABLE + 2	/* major device number */
        -: 3422:     + LONGEST_HUMAN_READABLE + 1	/* minor device number */
        -: 3423:     + TIME_STAMP_LEN_MAXIMUM + 1	/* max length of time/date */
        -: 3424:     ];
        -: 3425:  size_t s;
        -: 3426:  char *p;
        -: 3427:  time_t when;
        -: 3428:  int when_ns;
        -: 3429:  struct timespec when_timespec;
        -: 3430:  struct tm *when_local;
        -: 3431:
        -: 3432:  /* Compute the mode string, except remove the trailing space if no
        -: 3433:     file in this directory has an ACL or SELinux security context.  */
    #####: 3434:  if (f->stat_ok)
    #####: 3435:    filemodestring (&f->stat, modebuf);
        -: 3436:  else
        -: 3437:    {
    #####: 3438:      modebuf[0] = filetype_letter[f->filetype];
    #####: 3439:      memset (modebuf + 1, '?', 10);
    #####: 3440:      modebuf[11] = '\0';
        -: 3441:    }
    #####: 3442:  if (! any_has_acl)
    #####: 3443:    modebuf[10] = '\0';
    #####: 3444:  else if (f->have_acl)
    #####: 3445:    modebuf[10] = '+';
        -: 3446:
    #####: 3447:  switch (time_type)
        -: 3448:    {
        -: 3449:    case time_ctime:
    #####: 3450:      when_timespec = get_stat_ctime (&f->stat);
    #####: 3451:      break;
        -: 3452:    case time_mtime:
    #####: 3453:      when_timespec = get_stat_mtime (&f->stat);
    #####: 3454:      break;
        -: 3455:    case time_atime:
    #####: 3456:      when_timespec = get_stat_atime (&f->stat);
    #####: 3457:      break;
        -: 3458:    default:
    #####: 3459:      abort ();
        -: 3460:    }
        -: 3461:
    #####: 3462:  when = when_timespec.tv_sec;
    #####: 3463:  when_ns = when_timespec.tv_nsec;
        -: 3464:
    #####: 3465:  p = buf;
        -: 3466:
    #####: 3467:  if (print_inode)
        -: 3468:    {
        -: 3469:      char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3470:      sprintf (p, "%*s ", inode_number_width,
    #####: 3471:	       (f->stat.st_ino == NOT_AN_INODE_NUMBER
        -: 3472:		? "?"
    #####: 3473:		: umaxtostr (f->stat.st_ino, hbuf)));
        -: 3474:      /* Increment by strlen (p) here, rather than by inode_number_width + 1.
        -: 3475:	 The latter is wrong when inode_number_width is zero.  */
    #####: 3476:      p += strlen (p);
        -: 3477:    }
        -: 3478:
    #####: 3479:  if (print_block_size)
        -: 3480:    {
        -: 3481:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####: 3482:      char const *blocks =
    #####: 3483:	(! f->stat_ok
        -: 3484:	 ? "?"
    #####: 3485:	 : human_readable (ST_NBLOCKS (f->stat), hbuf, human_output_opts,
        -: 3486:			   ST_NBLOCKSIZE, output_block_size));
        -: 3487:      int pad;
    #####: 3488:      for (pad = block_size_width - mbswidth (blocks, 0); 0 < pad; pad--)
    #####: 3489:	*p++ = ' ';
    #####: 3490:      while ((*p++ = *blocks++))
    #####: 3491:	continue;
    #####: 3492:      p[-1] = ' ';
        -: 3493:    }
        -: 3494:
        -: 3495:  /* The last byte of the mode string is the POSIX
        -: 3496:     "optional alternate access method flag".  */
        -: 3497:  {
        -: 3498:    char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3499:    sprintf (p, "%s %*s ", modebuf, nlink_width,
    #####: 3500:	     ! f->stat_ok ? "?" : umaxtostr (f->stat.st_nlink, hbuf));
        -: 3501:  }
        -: 3502:  /* Increment by strlen (p) here, rather than by, e.g.,
        -: 3503:     sizeof modebuf - 2 + any_has_acl + 1 + nlink_width + 1.
        -: 3504:     The latter is wrong when nlink_width is zero.  */
    #####: 3505:  p += strlen (p);
        -: 3506:
    #####: 3507:  DIRED_INDENT ();
        -: 3508:
    #####: 3509:  if (print_owner | print_group | print_author | print_scontext)
        -: 3510:    {
    #####: 3511:      DIRED_FPUTS (buf, stdout, p - buf);
        -: 3512:
    #####: 3513:      if (print_owner)
    #####: 3514:	format_user (f->stat.st_uid, owner_width, f->stat_ok);
        -: 3515:
    #####: 3516:      if (print_group)
    #####: 3517:	format_group (f->stat.st_gid, group_width, f->stat_ok);
        -: 3518:
    #####: 3519:      if (print_author)
    #####: 3520:	format_user (f->stat.st_author, author_width, f->stat_ok);
        -: 3521:
    #####: 3522:      if (print_scontext)
    #####: 3523:	format_user_or_group ((f->scontext ? f->scontext : "?"),
        -: 3524:			      0, scontext_width);
        -: 3525:
    #####: 3526:      p = buf;
        -: 3527:    }
        -: 3528:
    #####: 3529:  if (f->stat_ok
    #####: 3530:      && (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode)))
    #####: 3531:    {
        -: 3532:      char majorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
        -: 3533:      char minorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3534:      int blanks_width = (file_size_width
    #####: 3535:			  - (major_device_number_width + 2
    #####: 3536:			     + minor_device_number_width));
    #####: 3537:      sprintf (p, "%*s, %*s ",
    #####: 3538:	       major_device_number_width + MAX (0, blanks_width),
    #####: 3539:	       umaxtostr (major (f->stat.st_rdev), majorbuf),
        -: 3540:	       minor_device_number_width,
    #####: 3541:	       umaxtostr (minor (f->stat.st_rdev), minorbuf));
    #####: 3542:      p += file_size_width + 1;
        -: 3543:    }
        -: 3544:  else
        -: 3545:    {
        -: 3546:      char hbuf[LONGEST_HUMAN_READABLE + 1];
    #####: 3547:      char const *size =
    #####: 3548:	(! f->stat_ok
        -: 3549:	 ? "?"
    #####: 3550:	 : human_readable (unsigned_file_size (f->stat.st_size),
        -: 3551:			   hbuf, human_output_opts, 1, file_output_block_size));
        -: 3552:      int pad;
    #####: 3553:      for (pad = file_size_width - mbswidth (size, 0); 0 < pad; pad--)
    #####: 3554:	*p++ = ' ';
    #####: 3555:      while ((*p++ = *size++))
    #####: 3556:	continue;
    #####: 3557:      p[-1] = ' ';
        -: 3558:    }
        -: 3559:
    #####: 3560:  when_local = localtime (&when_timespec.tv_sec);
    #####: 3561:  s = 0;
    #####: 3562:  *p = '\1';
        -: 3563:
    #####: 3564:  if (f->stat_ok && when_local)
        -: 3565:    {
        -: 3566:      time_t six_months_ago;
        -: 3567:      bool recent;
        -: 3568:      char const *fmt;
        -: 3569:
        -: 3570:      /* If the file appears to be in the future, update the current
        -: 3571:	 time, in case the file happens to have been modified since
        -: 3572:	 the last time we checked the clock.  */
    #####: 3573:      if (current_time < when
    #####: 3574:	  || (current_time == when && current_time_ns < when_ns))
        -: 3575:	{
        -: 3576:	  /* Note that get_current_time calls gettimeofday which, on some non-
        -: 3577:	     compliant systems, clobbers the buffer used for localtime's result.
        -: 3578:	     But it's ok here, because we use a gettimeofday wrapper that
        -: 3579:	     saves and restores the buffer around the gettimeofday call.  */
    #####: 3580:	  get_current_time ();
        -: 3581:	}
        -: 3582:
        -: 3583:      /* Consider a time to be recent if it is within the past six
        -: 3584:	 months.  A Gregorian year has 365.2425 * 24 * 60 * 60 ==
        -: 3585:	 31556952 seconds on the average.  Write this value as an
        -: 3586:	 integer constant to avoid floating point hassles.  */
    #####: 3587:      six_months_ago = current_time - 31556952 / 2;
    #####: 3588:      recent = (six_months_ago <= when
    #####: 3589:		&& (when < current_time
    #####: 3590:		    || (when == current_time && when_ns <= current_time_ns)));
    #####: 3591:      fmt = long_time_format[recent];
        -: 3592:
    #####: 3593:      s = nstrftime (p, TIME_STAMP_LEN_MAXIMUM + 1, fmt,
        -: 3594:		     when_local, 0, when_ns);
        -: 3595:    }
        -: 3596:
    #####: 3597:  if (s || !*p)
        -: 3598:    {
    #####: 3599:      p += s;
    #####: 3600:      *p++ = ' ';
        -: 3601:
        -: 3602:      /* NUL-terminate the string -- fputs (via DIRED_FPUTS) requires it.  */
    #####: 3603:      *p = '\0';
        -: 3604:    }
        -: 3605:  else
        -: 3606:    {
        -: 3607:      /* The time cannot be converted using the desired format, so
        -: 3608:	 print it as a huge integer number of seconds.  */
        -: 3609:      char hbuf[INT_BUFSIZE_BOUND (intmax_t)];
    #####: 3610:      sprintf (p, "%*s ", long_time_expected_width (),
    #####: 3611:	       (! f->stat_ok
        -: 3612:		? "?"
        -: 3613:		: (TYPE_SIGNED (time_t)
        -: 3614:		   ? imaxtostr (when, hbuf)
        -: 3615:		   : umaxtostr (when, hbuf))));
    #####: 3616:      p += strlen (p);
        -: 3617:    }
        -: 3618:
    #####: 3619:  DIRED_FPUTS (buf, stdout, p - buf);
    #####: 3620:  print_name_with_quoting (f->name, FILE_OR_LINK_MODE (f), f->linkok,
    #####: 3621:			   f->stat_ok, f->filetype, &dired_obstack);
        -: 3622:
    #####: 3623:  if (f->filetype == symbolic_link)
        -: 3624:    {
    #####: 3625:      if (f->linkname)
        -: 3626:	{
    #####: 3627:	  DIRED_FPUTS_LITERAL (" -> ", stdout);
    #####: 3628:	  print_name_with_quoting (f->linkname, f->linkmode, f->linkok - 1,
    #####: 3629:				   f->stat_ok, f->filetype, NULL);
    #####: 3630:	  if (indicator_style != none)
    #####: 3631:	    print_type_indicator (true, f->linkmode, unknown);
        -: 3632:	}
        -: 3633:    }
    #####: 3634:  else if (indicator_style != none)
    #####: 3635:    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
    #####: 3636:}
        -: 3637:
        -: 3638:/* Output to OUT a quoted representation of the file name NAME,
        -: 3639:   using OPTIONS to control quoting.  Produce no output if OUT is NULL.
        -: 3640:   Store the number of screen columns occupied by NAME's quoted
        -: 3641:   representation into WIDTH, if non-NULL.  Return the number of bytes
        -: 3642:   produced.  */
        -: 3643:
        -: 3644:static size_t
      209: 3645:quote_name (FILE *out, const char *name, struct quoting_options const *options,
        -: 3646:	    size_t *width)
        -: 3647:{
        -: 3648:  char smallbuf[BUFSIZ];
      209: 3649:  size_t len = quotearg_buffer (smallbuf, sizeof smallbuf, name, -1, options);
        -: 3650:  char *buf;
        -: 3651:  size_t displayed_width IF_LINT (= 0);
        -: 3652:
      209: 3653:  if (len < sizeof smallbuf)
      209: 3654:    buf = smallbuf;
        -: 3655:  else
        -: 3656:    {
    #####: 3657:      buf = alloca (len + 1);
    #####: 3658:      quotearg_buffer (buf, len + 1, name, -1, options);
        -: 3659:    }
        -: 3660:
      209: 3661:  if (qmark_funny_chars)
        -: 3662:    {
        -: 3663:#if HAVE_MBRTOWC
    #####: 3664:      if (MB_CUR_MAX > 1)
        -: 3665:	{
    #####: 3666:	  char const *p = buf;
    #####: 3667:	  char const *plimit = buf + len;
    #####: 3668:	  char *q = buf;
    #####: 3669:	  displayed_width = 0;
        -: 3670:
    #####: 3671:	  while (p < plimit)
    #####: 3672:	    switch (*p)
        -: 3673:	      {
        -: 3674:		case ' ': case '!': case '"': case '#': case '%':
        -: 3675:		case '&': case '\'': case '(': case ')': case '*':
        -: 3676:		case '+': case ',': case '-': case '.': case '/':
        -: 3677:		case '0': case '1': case '2': case '3': case '4':
        -: 3678:		case '5': case '6': case '7': case '8': case '9':
        -: 3679:		case ':': case ';': case '<': case '=': case '>':
        -: 3680:		case '?':
        -: 3681:		case 'A': case 'B': case 'C': case 'D': case 'E':
        -: 3682:		case 'F': case 'G': case 'H': case 'I': case 'J':
        -: 3683:		case 'K': case 'L': case 'M': case 'N': case 'O':
        -: 3684:		case 'P': case 'Q': case 'R': case 'S': case 'T':
        -: 3685:		case 'U': case 'V': case 'W': case 'X': case 'Y':
        -: 3686:		case 'Z':
        -: 3687:		case '[': case '\\': case ']': case '^': case '_':
        -: 3688:		case 'a': case 'b': case 'c': case 'd': case 'e':
        -: 3689:		case 'f': case 'g': case 'h': case 'i': case 'j':
        -: 3690:		case 'k': case 'l': case 'm': case 'n': case 'o':
        -: 3691:		case 'p': case 'q': case 'r': case 's': case 't':
        -: 3692:		case 'u': case 'v': case 'w': case 'x': case 'y':
        -: 3693:		case 'z': case '{': case '|': case '}': case '~':
        -: 3694:		  /* These characters are printable ASCII characters.  */
    #####: 3695:		  *q++ = *p++;
    #####: 3696:		  displayed_width += 1;
    #####: 3697:		  break;
        -: 3698:		default:
        -: 3699:		  /* If we have a multibyte sequence, copy it until we
        -: 3700:		     reach its end, replacing each non-printable multibyte
        -: 3701:		     character with a single question mark.  */
        -: 3702:		  {
    #####: 3703:		    mbstate_t mbstate = { 0, };
        -: 3704:		    do
        -: 3705:		      {
        -: 3706:			wchar_t wc;
        -: 3707:			size_t bytes;
        -: 3708:			int w;
        -: 3709:
    #####: 3710:			bytes = mbrtowc (&wc, p, plimit - p, &mbstate);
        -: 3711:
    #####: 3712:			if (bytes == (size_t) -1)
        -: 3713:			  {
        -: 3714:			    /* An invalid multibyte sequence was
        -: 3715:			       encountered.  Skip one input byte, and
        -: 3716:			       put a question mark.  */
    #####: 3717:			    p++;
    #####: 3718:			    *q++ = '?';
    #####: 3719:			    displayed_width += 1;
    #####: 3720:			    break;
        -: 3721:			  }
        -: 3722:
    #####: 3723:			if (bytes == (size_t) -2)
        -: 3724:			  {
        -: 3725:			    /* An incomplete multibyte character
        -: 3726:			       at the end.  Replace it entirely with
        -: 3727:			       a question mark.  */
    #####: 3728:			    p = plimit;
    #####: 3729:			    *q++ = '?';
    #####: 3730:			    displayed_width += 1;
    #####: 3731:			    break;
        -: 3732:			  }
        -: 3733:
    #####: 3734:			if (bytes == 0)
        -: 3735:			  /* A null wide character was encountered.  */
    #####: 3736:			  bytes = 1;
        -: 3737:
    #####: 3738:			w = wcwidth (wc);
    #####: 3739:			if (w >= 0)
        -: 3740:			  {
        -: 3741:			    /* A printable multibyte character.
        -: 3742:			       Keep it.  */
    #####: 3743:			    for (; bytes > 0; --bytes)
    #####: 3744:			      *q++ = *p++;
    #####: 3745:			    displayed_width += w;
        -: 3746:			  }
        -: 3747:			else
        -: 3748:			  {
        -: 3749:			    /* An unprintable multibyte character.
        -: 3750:			       Replace it entirely with a question
        -: 3751:			       mark.  */
    #####: 3752:			    p += bytes;
    #####: 3753:			    *q++ = '?';
    #####: 3754:			    displayed_width += 1;
        -: 3755:			  }
        -: 3756:		      }
    #####: 3757:		    while (! mbsinit (&mbstate));
        -: 3758:		  }
    #####: 3759:		  break;
        -: 3760:	      }
        -: 3761:
        -: 3762:	  /* The buffer may have shrunk.  */
    #####: 3763:	  len = q - buf;
        -: 3764:	}
        -: 3765:      else
        -: 3766:#endif
        -: 3767:	{
    #####: 3768:	  char *p = buf;
    #####: 3769:	  char const *plimit = buf + len;
        -: 3770:
    #####: 3771:	  while (p < plimit)
        -: 3772:	    {
    #####: 3773:	      if (! isprint (to_uchar (*p)))
    #####: 3774:		*p = '?';
    #####: 3775:	      p++;
        -: 3776:	    }
    #####: 3777:	  displayed_width = len;
        -: 3778:	}
        -: 3779:    }
      209: 3780:  else if (width != NULL)
        -: 3781:    {
        -: 3782:#if HAVE_MBRTOWC
    #####: 3783:      if (MB_CUR_MAX > 1)
    #####: 3784:	displayed_width = mbsnwidth (buf, len, 0);
        -: 3785:      else
        -: 3786:#endif
        -: 3787:	{
    #####: 3788:	  char const *p = buf;
    #####: 3789:	  char const *plimit = buf + len;
        -: 3790:
    #####: 3791:	  displayed_width = 0;
    #####: 3792:	  while (p < plimit)
        -: 3793:	    {
    #####: 3794:	      if (isprint (to_uchar (*p)))
    #####: 3795:		displayed_width++;
    #####: 3796:	      p++;
        -: 3797:	    }
        -: 3798:	}
        -: 3799:    }
        -: 3800:
      209: 3801:  if (out != NULL)
      209: 3802:    fwrite (buf, 1, len, out);
      209: 3803:  if (width != NULL)
    #####: 3804:    *width = displayed_width;
      209: 3805:  return len;
        -: 3806:}
        -: 3807:
        -: 3808:static void
      209: 3809:print_name_with_quoting (const char *p, mode_t mode, int linkok,
        -: 3810:			 bool stat_ok, enum filetype type,
        -: 3811:			 struct obstack *stack)
        -: 3812:{
      209: 3813:  if (print_with_color)
    #####: 3814:    print_color_indicator (p, mode, linkok, stat_ok, type);
        -: 3815:
      209: 3816:  if (stack)
    #####: 3817:    PUSH_CURRENT_DIRED_POS (stack);
        -: 3818:
      209: 3819:  dired_pos += quote_name (stdout, p, filename_quoting_options, NULL);
        -: 3820:
      209: 3821:  if (stack)
    #####: 3822:    PUSH_CURRENT_DIRED_POS (stack);
        -: 3823:
      209: 3824:  if (print_with_color)
        -: 3825:    {
    #####: 3826:      process_signals ();
    #####: 3827:      prep_non_filename_text ();
        -: 3828:    }
      209: 3829:}
        -: 3830:
        -: 3831:static void
    #####: 3832:prep_non_filename_text (void)
        -: 3833:{
    #####: 3834:  if (color_indicator[C_END].string != NULL)
    #####: 3835:    put_indicator (&color_indicator[C_END]);
        -: 3836:  else
        -: 3837:    {
    #####: 3838:      put_indicator (&color_indicator[C_LEFT]);
    #####: 3839:      put_indicator (&color_indicator[C_NORM]);
    #####: 3840:      put_indicator (&color_indicator[C_RIGHT]);
        -: 3841:    }
    #####: 3842:}
        -: 3843:
        -: 3844:/* Print the file name of `f' with appropriate quoting.
        -: 3845:   Also print file size, inode number, and filetype indicator character,
        -: 3846:   as requested by switches.  */
        -: 3847:
        -: 3848:static void
      209: 3849:print_file_name_and_frills (const struct fileinfo *f)
        -: 3850:{
        -: 3851:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 3852:
      209: 3853:  if (print_inode)
    #####: 3854:    printf ("%*s ", format == with_commas ? 0 : inode_number_width,
        -: 3855:	    umaxtostr (f->stat.st_ino, buf));
        -: 3856:
      209: 3857:  if (print_block_size)
    #####: 3858:    printf ("%*s ", format == with_commas ? 0 : block_size_width,
    #####: 3859:	    human_readable (ST_NBLOCKS (f->stat), buf, human_output_opts,
        -: 3860:			    ST_NBLOCKSIZE, output_block_size));
        -: 3861:
      209: 3862:  if (print_scontext)
    #####: 3863:    printf ("%*s ", format == with_commas ? 0 : scontext_width,
    #####: 3864:	    (f->scontext ? f->scontext : "?"));
        -: 3865:
      418: 3866:  print_name_with_quoting (f->name, FILE_OR_LINK_MODE (f), f->linkok,
      209: 3867:			   f->stat_ok, f->filetype, NULL);
        -: 3868:
      209: 3869:  if (indicator_style != none)
    #####: 3870:    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
      209: 3871:}
        -: 3872:
        -: 3873:/* Given these arguments describing a file, return the single-byte
        -: 3874:   type indicator, or 0.  */
        -: 3875:static char
    #####: 3876:get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 3877:{
        -: 3878:  char c;
        -: 3879:
    #####: 3880:  if (stat_ok ? S_ISREG (mode) : type == normal)
        -: 3881:    {
    #####: 3882:      if (stat_ok && indicator_style == classify && (mode & S_IXUGO))
    #####: 3883:	c = '*';
        -: 3884:      else
    #####: 3885:	c = 0;
        -: 3886:    }
        -: 3887:  else
        -: 3888:    {
    #####: 3889:      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)
    #####: 3890:	c = '/';
    #####: 3891:      else if (indicator_style == slash)
    #####: 3892:	c = 0;
    #####: 3893:      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)
    #####: 3894:	c = '@';
    #####: 3895:      else if (stat_ok ? S_ISFIFO (mode) : type == fifo)
    #####: 3896:	c = '|';
    #####: 3897:      else if (stat_ok ? S_ISSOCK (mode) : type == sock)
    #####: 3898:	c = '=';
        -: 3899:      else if (stat_ok && S_ISDOOR (mode))
        -: 3900:	c = '>';
        -: 3901:      else
    #####: 3902:	c = 0;
        -: 3903:    }
    #####: 3904:  return c;
        -: 3905:}
        -: 3906:
        -: 3907:static void
    #####: 3908:print_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 3909:{
    #####: 3910:  char c = get_type_indicator (stat_ok, mode, type);
    #####: 3911:  if (c)
    #####: 3912:    DIRED_PUTCHAR (c);
    #####: 3913:}
        -: 3914:
        -: 3915:static void
    #####: 3916:print_color_indicator (const char *name, mode_t mode, int linkok,
        -: 3917:		       bool stat_ok, enum filetype filetype)
        -: 3918:{
        -: 3919:  int type;
        -: 3920:  struct color_ext_type *ext;	/* Color extension */
        -: 3921:  size_t len;			/* Length of name */
        -: 3922:
        -: 3923:  /* Is this a nonexistent file?  If so, linkok == -1.  */
        -: 3924:
    #####: 3925:  if (linkok == -1 && color_indicator[C_MISSING].string != NULL)
    #####: 3926:    type = C_MISSING;
    #####: 3927:  else if (! stat_ok)
        -: 3928:    {
        -: 3929:      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;
    #####: 3930:      type = filetype_indicator[filetype];
        -: 3931:    }
        -: 3932:  else
        -: 3933:    {
    #####: 3934:      if (S_ISREG (mode))
        -: 3935:	{
    #####: 3936:	  type = C_FILE;
    #####: 3937:	  if ((mode & S_ISUID) != 0)
    #####: 3938:	    type = C_SETUID;
    #####: 3939:	  else if ((mode & S_ISGID) != 0)
    #####: 3940:	    type = C_SETGID;
    #####: 3941:	  else if ((mode & S_IXUGO) != 0)
    #####: 3942:	    type = C_EXEC;
        -: 3943:	}
    #####: 3944:      else if (S_ISDIR (mode))
        -: 3945:	{
    #####: 3946:	  if ((mode & S_ISVTX) && (mode & S_IWOTH))
    #####: 3947:	    type = C_STICKY_OTHER_WRITABLE;
    #####: 3948:	  else if ((mode & S_IWOTH) != 0)
    #####: 3949:	    type = C_OTHER_WRITABLE;
    #####: 3950:	  else if ((mode & S_ISVTX) != 0)
    #####: 3951:	    type = C_STICKY;
        -: 3952:	  else
    #####: 3953:	    type = C_DIR;
        -: 3954:	}
    #####: 3955:      else if (S_ISLNK (mode))
    #####: 3956:	type = ((!linkok && color_indicator[C_ORPHAN].string)
    #####: 3957:		? C_ORPHAN : C_LINK);
    #####: 3958:      else if (S_ISFIFO (mode))
    #####: 3959:	type = C_FIFO;
    #####: 3960:      else if (S_ISSOCK (mode))
    #####: 3961:	type = C_SOCK;
    #####: 3962:      else if (S_ISBLK (mode))
    #####: 3963:	type = C_BLK;
    #####: 3964:      else if (S_ISCHR (mode))
    #####: 3965:	type = C_CHR;
        -: 3966:      else if (S_ISDOOR (mode))
        -: 3967:	type = C_DOOR;
        -: 3968:      else
        -: 3969:	{
        -: 3970:	  /* Classify a file of some other type as C_ORPHAN.  */
    #####: 3971:	  type = C_ORPHAN;
        -: 3972:	}
        -: 3973:    }
        -: 3974:
        -: 3975:  /* Check the file's suffix only if still classified as C_FILE.  */
    #####: 3976:  ext = NULL;
    #####: 3977:  if (type == C_FILE)
        -: 3978:    {
        -: 3979:      /* Test if NAME has a recognized suffix.  */
        -: 3980:
    #####: 3981:      len = strlen (name);
    #####: 3982:      name += len;		/* Pointer to final \0.  */
    #####: 3983:      for (ext = color_ext_list; ext != NULL; ext = ext->next)
        -: 3984:	{
    #####: 3985:	  if (ext->ext.len <= len
    #####: 3986:	      && strncmp (name - ext->ext.len, ext->ext.string,
        -: 3987:			  ext->ext.len) == 0)
    #####: 3988:	    break;
        -: 3989:	}
        -: 3990:    }
        -: 3991:
    #####: 3992:  put_indicator (&color_indicator[C_LEFT]);
    #####: 3993:  put_indicator (ext ? &(ext->seq) : &color_indicator[type]);
    #####: 3994:  put_indicator (&color_indicator[C_RIGHT]);
    #####: 3995:}
        -: 3996:
        -: 3997:/* Output a color indicator (which may contain nulls).  */
        -: 3998:static void
    #####: 3999:put_indicator (const struct bin_str *ind)
        -: 4000:{
        -: 4001:  size_t i;
        -: 4002:  const char *p;
        -: 4003:
    #####: 4004:  p = ind->string;
        -: 4005:
    #####: 4006:  for (i = ind->len; i != 0; --i)
    #####: 4007:    putchar (*(p++));
    #####: 4008:}
        -: 4009:
        -: 4010:static size_t
    #####: 4011:length_of_file_name_and_frills (const struct fileinfo *f)
        -: 4012:{
    #####: 4013:  size_t len = 0;
        -: 4014:  size_t name_width;
        -: 4015:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 4016:
    #####: 4017:  if (print_inode)
    #####: 4018:    len += 1 + (format == with_commas
    #####: 4019:		? strlen (umaxtostr (f->stat.st_ino, buf))
        -: 4020:		: inode_number_width);
        -: 4021:
    #####: 4022:  if (print_block_size)
    #####: 4023:    len += 1 + (format == with_commas
    #####: 4024:		? strlen (human_readable (ST_NBLOCKS (f->stat), buf,
        -: 4025:					  human_output_opts, ST_NBLOCKSIZE,
        -: 4026:					  output_block_size))
        -: 4027:		: block_size_width);
        -: 4028:
    #####: 4029:  if (print_scontext)
    #####: 4030:    len += 1 + (format == with_commas ? strlen (f->scontext) : scontext_width);
        -: 4031:
    #####: 4032:  quote_name (NULL, f->name, filename_quoting_options, &name_width);
    #####: 4033:  len += name_width;
        -: 4034:
    #####: 4035:  if (indicator_style != none)
        -: 4036:    {
    #####: 4037:      char c = get_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
    #####: 4038:      len += (c != 0);
        -: 4039:    }
        -: 4040:
    #####: 4041:  return len;
        -: 4042:}
        -: 4043:
        -: 4044:static void
    #####: 4045:print_many_per_line (void)
        -: 4046:{
        -: 4047:  size_t row;			/* Current row.  */
    #####: 4048:  size_t cols = calculate_columns (true);
    #####: 4049:  struct column_info const *line_fmt = &column_info[cols - 1];
        -: 4050:
        -: 4051:  /* Calculate the number of rows that will be in each column except possibly
        -: 4052:     for a short column on the right.  */
    #####: 4053:  size_t rows = cwd_n_used / cols + (cwd_n_used % cols != 0);
        -: 4054:
    #####: 4055:  for (row = 0; row < rows; row++)
        -: 4056:    {
    #####: 4057:      size_t col = 0;
    #####: 4058:      size_t filesno = row;
    #####: 4059:      size_t pos = 0;
        -: 4060:
        -: 4061:      /* Print the next row.  */
        -: 4062:      while (1)
        -: 4063:	{
    #####: 4064:	  struct fileinfo const *f = sorted_file[filesno];
    #####: 4065:	  size_t name_length = length_of_file_name_and_frills (f);
    #####: 4066:	  size_t max_name_length = line_fmt->col_arr[col++];
    #####: 4067:	  print_file_name_and_frills (f);
        -: 4068:
    #####: 4069:	  filesno += rows;
    #####: 4070:	  if (filesno >= cwd_n_used)
    #####: 4071:	    break;
        -: 4072:
    #####: 4073:	  indent (pos + name_length, pos + max_name_length);
    #####: 4074:	  pos += max_name_length;
    #####: 4075:	}
    #####: 4076:      putchar ('\n');
        -: 4077:    }
    #####: 4078:}
        -: 4079:
        -: 4080:static void
    #####: 4081:print_horizontal (void)
        -: 4082:{
        -: 4083:  size_t filesno;
    #####: 4084:  size_t pos = 0;
    #####: 4085:  size_t cols = calculate_columns (false);
    #####: 4086:  struct column_info const *line_fmt = &column_info[cols - 1];
    #####: 4087:  struct fileinfo const *f = sorted_file[0];
    #####: 4088:  size_t name_length = length_of_file_name_and_frills (f);
    #####: 4089:  size_t max_name_length = line_fmt->col_arr[0];
        -: 4090:
        -: 4091:  /* Print first entry.  */
    #####: 4092:  print_file_name_and_frills (f);
        -: 4093:
        -: 4094:  /* Now the rest.  */
    #####: 4095:  for (filesno = 1; filesno < cwd_n_used; ++filesno)
        -: 4096:    {
    #####: 4097:      size_t col = filesno % cols;
        -: 4098:
    #####: 4099:      if (col == 0)
        -: 4100:	{
    #####: 4101:	  putchar ('\n');
    #####: 4102:	  pos = 0;
        -: 4103:	}
        -: 4104:      else
        -: 4105:	{
    #####: 4106:	  indent (pos + name_length, pos + max_name_length);
    #####: 4107:	  pos += max_name_length;
        -: 4108:	}
        -: 4109:
    #####: 4110:      f = sorted_file[filesno];
    #####: 4111:      print_file_name_and_frills (f);
        -: 4112:
    #####: 4113:      name_length = length_of_file_name_and_frills (f);
    #####: 4114:      max_name_length = line_fmt->col_arr[col];
        -: 4115:    }
    #####: 4116:  putchar ('\n');
    #####: 4117:}
        -: 4118:
        -: 4119:static void
    #####: 4120:print_with_commas (void)
        -: 4121:{
        -: 4122:  size_t filesno;
    #####: 4123:  size_t pos = 0;
        -: 4124:
    #####: 4125:  for (filesno = 0; filesno < cwd_n_used; filesno++)
        -: 4126:    {
    #####: 4127:      struct fileinfo const *f = sorted_file[filesno];
    #####: 4128:      size_t len = length_of_file_name_and_frills (f);
        -: 4129:
    #####: 4130:      if (filesno != 0)
        -: 4131:	{
        -: 4132:	  char separator;
        -: 4133:
    #####: 4134:	  if (pos + len + 2 < line_length)
        -: 4135:	    {
    #####: 4136:	      pos += 2;
    #####: 4137:	      separator = ' ';
        -: 4138:	    }
        -: 4139:	  else
        -: 4140:	    {
    #####: 4141:	      pos = 0;
    #####: 4142:	      separator = '\n';
        -: 4143:	    }
        -: 4144:
    #####: 4145:	  putchar (',');
    #####: 4146:	  putchar (separator);
        -: 4147:	}
        -: 4148:
    #####: 4149:      print_file_name_and_frills (f);
    #####: 4150:      pos += len;
        -: 4151:    }
    #####: 4152:  putchar ('\n');
    #####: 4153:}
        -: 4154:
        -: 4155:/* Assuming cursor is at position FROM, indent up to position TO.
        -: 4156:   Use a TAB character instead of two or more spaces whenever possible.  */
        -: 4157:
        -: 4158:static void
    #####: 4159:indent (size_t from, size_t to)
        -: 4160:{
    #####: 4161:  while (from < to)
        -: 4162:    {
    #####: 4163:      if (tabsize != 0 && to / tabsize > (from + 1) / tabsize)
        -: 4164:	{
    #####: 4165:	  putchar ('\t');
    #####: 4166:	  from += tabsize - from % tabsize;
        -: 4167:	}
        -: 4168:      else
        -: 4169:	{
    #####: 4170:	  putchar (' ');
    #####: 4171:	  from++;
        -: 4172:	}
        -: 4173:    }
    #####: 4174:}
        -: 4175:
        -: 4176:/* Put DIRNAME/NAME into DEST, handling `.' and `/' properly.  */
        -: 4177:/* FIXME: maybe remove this function someday.  See about using a
        -: 4178:   non-malloc'ing version of file_name_concat.  */
        -: 4179:
        -: 4180:static void
    #####: 4181:attach (char *dest, const char *dirname, const char *name)
        -: 4182:{
    #####: 4183:  const char *dirnamep = dirname;
        -: 4184:
        -: 4185:  /* Copy dirname if it is not ".".  */
    #####: 4186:  if (dirname[0] != '.' || dirname[1] != 0)
        -: 4187:    {
    #####: 4188:      while (*dirnamep)
    #####: 4189:	*dest++ = *dirnamep++;
        -: 4190:      /* Add '/' if `dirname' doesn't already end with it.  */
    #####: 4191:      if (dirnamep > dirname && dirnamep[-1] != '/')
    #####: 4192:	*dest++ = '/';
        -: 4193:    }
    #####: 4194:  while (*name)
    #####: 4195:    *dest++ = *name++;
    #####: 4196:  *dest = 0;
    #####: 4197:}
        -: 4198:
        -: 4199:/* Allocate enough column info suitable for the current number of
        -: 4200:   files and display columns, and initialize the info to represent the
        -: 4201:   narrowest possible columns.  */
        -: 4202:
        -: 4203:static void
    #####: 4204:init_column_info (void)
        -: 4205:{
        -: 4206:  size_t i;
    #####: 4207:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4208:
        -: 4209:  /* Currently allocated columns in column_info.  */
        -: 4210:  static size_t column_info_alloc;
        -: 4211:
    #####: 4212:  if (column_info_alloc < max_cols)
        -: 4213:    {
        -: 4214:      size_t new_column_info_alloc;
        -: 4215:      size_t *p;
        -: 4216:
    #####: 4217:      if (max_cols < max_idx / 2)
        -: 4218:	{
        -: 4219:	  /* The number of columns is far less than the display width
        -: 4220:	     allows.  Grow the allocation, but only so that it's
        -: 4221:	     double the current requirements.  If the display is
        -: 4222:	     extremely wide, this avoids allocating a lot of memory
        -: 4223:	     that is never needed.  */
    #####: 4224:	  column_info = xnrealloc (column_info, max_cols,
        -: 4225:				   2 * sizeof *column_info);
    #####: 4226:	  new_column_info_alloc = 2 * max_cols;
        -: 4227:	}
        -: 4228:      else
        -: 4229:	{
    #####: 4230:	  column_info = xnrealloc (column_info, max_idx, sizeof *column_info);
    #####: 4231:	  new_column_info_alloc = max_idx;
        -: 4232:	}
        -: 4233:
        -: 4234:      /* Allocate the new size_t objects by computing the triangle
        -: 4235:	 formula n * (n + 1) / 2, except that we don't need to
        -: 4236:	 allocate the part of the triangle that we've already
        -: 4237:	 allocated.  Check for address arithmetic overflow.  */
        -: 4238:      {
    #####: 4239:	size_t column_info_growth = new_column_info_alloc - column_info_alloc;
    #####: 4240:	size_t s = column_info_alloc + 1 + new_column_info_alloc;
    #####: 4241:	size_t t = s * column_info_growth;
    #####: 4242:	if (s < new_column_info_alloc || t / column_info_growth != s)
    #####: 4243:	  xalloc_die ();
    #####: 4244:	p = xnmalloc (t / 2, sizeof *p);
        -: 4245:      }
        -: 4246:
        -: 4247:      /* Grow the triangle by parceling out the cells just allocated.  */
    #####: 4248:      for (i = column_info_alloc; i < new_column_info_alloc; i++)
        -: 4249:	{
    #####: 4250:	  column_info[i].col_arr = p;
    #####: 4251:	  p += i + 1;
        -: 4252:	}
        -: 4253:
    #####: 4254:      column_info_alloc = new_column_info_alloc;
        -: 4255:    }
        -: 4256:
    #####: 4257:  for (i = 0; i < max_cols; ++i)
        -: 4258:    {
        -: 4259:      size_t j;
        -: 4260:
    #####: 4261:      column_info[i].valid_len = true;
    #####: 4262:      column_info[i].line_len = (i + 1) * MIN_COLUMN_WIDTH;
    #####: 4263:      for (j = 0; j <= i; ++j)
    #####: 4264:	column_info[i].col_arr[j] = MIN_COLUMN_WIDTH;
        -: 4265:    }
    #####: 4266:}
        -: 4267:
        -: 4268:/* Calculate the number of columns needed to represent the current set
        -: 4269:   of files in the current display width.  */
        -: 4270:
        -: 4271:static size_t
    #####: 4272:calculate_columns (bool by_columns)
        -: 4273:{
        -: 4274:  size_t filesno;		/* Index into cwd_file.  */
        -: 4275:  size_t cols;			/* Number of files across.  */
        -: 4276:
        -: 4277:  /* Normally the maximum number of columns is determined by the
        -: 4278:     screen width.  But if few files are available this might limit it
        -: 4279:     as well.  */
    #####: 4280:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4281:
    #####: 4282:  init_column_info ();
        -: 4283:
        -: 4284:  /* Compute the maximum number of possible columns.  */
    #####: 4285:  for (filesno = 0; filesno < cwd_n_used; ++filesno)
        -: 4286:    {
    #####: 4287:      struct fileinfo const *f = sorted_file[filesno];
    #####: 4288:      size_t name_length = length_of_file_name_and_frills (f);
        -: 4289:      size_t i;
        -: 4290:
    #####: 4291:      for (i = 0; i < max_cols; ++i)
        -: 4292:	{
    #####: 4293:	  if (column_info[i].valid_len)
        -: 4294:	    {
    #####: 4295:	      size_t idx = (by_columns
    #####: 4296:			    ? filesno / ((cwd_n_used + i) / (i + 1))
    #####: 4297:			    : filesno % (i + 1));
    #####: 4298:	      size_t real_length = name_length + (idx == i ? 0 : 2);
        -: 4299:
    #####: 4300:	      if (column_info[i].col_arr[idx] < real_length)
        -: 4301:		{
    #####: 4302:		  column_info[i].line_len += (real_length
    #####: 4303:					      - column_info[i].col_arr[idx]);
    #####: 4304:		  column_info[i].col_arr[idx] = real_length;
    #####: 4305:		  column_info[i].valid_len = (column_info[i].line_len
    #####: 4306:					      < line_length);
        -: 4307:		}
        -: 4308:	    }
        -: 4309:	}
        -: 4310:    }
        -: 4311:
        -: 4312:  /* Find maximum allowed columns.  */
    #####: 4313:  for (cols = max_cols; 1 < cols; --cols)
        -: 4314:    {
    #####: 4315:      if (column_info[cols - 1].valid_len)
    #####: 4316:	break;
        -: 4317:    }
        -: 4318:
    #####: 4319:  return cols;
        -: 4320:}
        -: 4321:
        -: 4322:void
    #####: 4323:usage (int status)
        -: 4324:{
    #####: 4325:  if (status != EXIT_SUCCESS)
    #####: 4326:    fprintf (stderr, _("Try `%s --help' for more information.\n"),
        -: 4327:	     program_name);
        -: 4328:  else
        -: 4329:    {
    #####: 4330:      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
    #####: 4331:      fputs (_("\
        -: 4332:List information about the FILEs (the current directory by default).\n\
        -: 4333:Sort entries alphabetically if none of -cftuvSUX nor --sort.\n\
        -: 4334:\n\
        -: 4335:"), stdout);
    #####: 4336:      fputs (_("\
        -: 4337:Mandatory arguments to long options are mandatory for short options too.\n\
        -: 4338:"), stdout);
    #####: 4339:      fputs (_("\
        -: 4340:  -a, --all                  do not ignore entries starting with .\n\
        -: 4341:  -A, --almost-all           do not list implied . and ..\n\
        -: 4342:      --author               with -l, print the author of each file\n\
        -: 4343:  -b, --escape               print octal escapes for nongraphic characters\n\
        -: 4344:"), stdout);
    #####: 4345:      fputs (_("\
        -: 4346:      --block-size=SIZE      use SIZE-byte blocks\n\
        -: 4347:  -B, --ignore-backups       do not list implied entries ending with ~\n\
        -: 4348:  -c                         with -lt: sort by, and show, ctime (time of last\n\
        -: 4349:                               modification of file status information)\n\
        -: 4350:                               with -l: show ctime and sort by name\n\
        -: 4351:                               otherwise: sort by ctime\n\
        -: 4352:"), stdout);
    #####: 4353:      fputs (_("\
        -: 4354:  -C                         list entries by columns\n\
        -: 4355:      --color[=WHEN]         control whether color is used to distinguish file\n\
        -: 4356:                               types.  WHEN may be `never', `always', or `auto'\n\
        -: 4357:  -d, --directory            list directory entries instead of contents,\n\
        -: 4358:                               and do not dereference symbolic links\n\
        -: 4359:  -D, --dired                generate output designed for Emacs' dired mode\n\
        -: 4360:"), stdout);
    #####: 4361:      fputs (_("\
        -: 4362:  -f                         do not sort, enable -aU, disable -ls --color\n\
        -: 4363:  -F, --classify             append indicator (one of */=>@|) to entries\n\
        -: 4364:      --file-type            likewise, except do not append `*'\n\
        -: 4365:      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n\
        -: 4366:                               single-column -1, verbose -l, vertical -C\n\
        -: 4367:      --full-time            like -l --time-style=full-iso\n\
        -: 4368:"), stdout);
    #####: 4369:      fputs (_("\
        -: 4370:  -g                         like -l, but do not list owner\n\
        -: 4371:"), stdout);
    #####: 4372:      fputs (_("\
        -: 4373:      --group-directories-first\n\
        -: 4374:                             group directories before files\n\
        -: 4375:"), stdout);
    #####: 4376:      fputs (_("\
        -: 4377:  -G, --no-group             in a long listing, don't print group names\n\
        -: 4378:  -h, --human-readable       with -l, print sizes in human readable format\n\
        -: 4379:                               (e.g., 1K 234M 2G)\n\
        -: 4380:      --si                   likewise, but use powers of 1000 not 1024\n\
        -: 4381:"), stdout);
    #####: 4382:      fputs (_("\
        -: 4383:  -H, --dereference-command-line\n\
        -: 4384:                             follow symbolic links listed on the command line\n\
        -: 4385:      --dereference-command-line-symlink-to-dir\n\
        -: 4386:                             follow each command line symbolic link\n\
        -: 4387:                             that points to a directory\n\
        -: 4388:      --hide=PATTERN         do not list implied entries matching shell PATTERN\n\
        -: 4389:                               (overridden by -a or -A)\n\
        -: 4390:"), stdout);
    #####: 4391:      fputs (_("\
        -: 4392:      --indicator-style=WORD  append indicator with style WORD to entry names:\n\
        -: 4393:                               none (default), slash (-p),\n\
        -: 4394:                               file-type (--file-type), classify (-F)\n\
        -: 4395:  -i, --inode                print the index number of each file\n\
        -: 4396:  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n\
        -: 4397:  -k                         like --block-size=1K\n\
        -: 4398:"), stdout);
    #####: 4399:      fputs (_("\
        -: 4400:  -l                         use a long listing format\n\
        -: 4401:  -L, --dereference          when showing file information for a symbolic\n\
        -: 4402:                               link, show information for the file the link\n\
        -: 4403:                               references rather than for the link itself\n\
        -: 4404:  -m                         fill width with a comma separated list of entries\n\
        -: 4405:"), stdout);
    #####: 4406:      fputs (_("\
        -: 4407:  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n\
        -: 4408:  -N, --literal              print raw entry names (don't treat e.g. control\n\
        -: 4409:                               characters specially)\n\
        -: 4410:  -o                         like -l, but do not list group information\n\
        -: 4411:  -p, --indicator-style=slash\n\
        -: 4412:                             append / indicator to directories\n\
        -: 4413:"), stdout);
    #####: 4414:      fputs (_("\
        -: 4415:  -q, --hide-control-chars   print ? instead of non graphic characters\n\
        -: 4416:      --show-control-chars   show non graphic characters as-is (default\n\
        -: 4417:                             unless program is `ls' and output is a terminal)\n\
        -: 4418:  -Q, --quote-name           enclose entry names in double quotes\n\
        -: 4419:      --quoting-style=WORD   use quoting style WORD for entry names:\n\
        -: 4420:                               literal, locale, shell, shell-always, c, escape\n\
        -: 4421:"), stdout);
    #####: 4422:      fputs (_("\
        -: 4423:  -r, --reverse              reverse order while sorting\n\
        -: 4424:  -R, --recursive            list subdirectories recursively\n\
        -: 4425:  -s, --size                 print the size of each file, in blocks\n\
        -: 4426:"), stdout);
    #####: 4427:      fputs (_("\
        -: 4428:  -S                         sort by file size\n\
        -: 4429:      --sort=WORD            sort by WORD instead of name: none -U,\n\
        -: 4430:                             extension -X, size -S, time -t, version -v\n\
        -: 4431:      --time=WORD            with -l, show time as WORD instead of modification\n\
        -: 4432:                             time: atime -u, access -u, use -u, ctime -c,\n\
        -: 4433:                             or status -c; use specified time as sort key\n\
        -: 4434:                             if --sort=time\n\
        -: 4435:"), stdout);
    #####: 4436:      fputs (_("\
        -: 4437:      --time-style=STYLE     with -l, show times using style STYLE:\n\
        -: 4438:                             full-iso, long-iso, iso, locale, +FORMAT.\n\
        -: 4439:                             FORMAT is interpreted like `date'; if FORMAT is\n\
        -: 4440:                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n\
        -: 4441:                             non-recent files and FORMAT2 to recent files;\n\
        -: 4442:                             if STYLE is prefixed with `posix-', STYLE\n\
        -: 4443:                             takes effect only outside the POSIX locale\n\
        -: 4444:"), stdout);
    #####: 4445:      fputs (_("\
        -: 4446:  -t                         sort by modification time\n\
        -: 4447:  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n\
        -: 4448:"), stdout);
    #####: 4449:      fputs (_("\
        -: 4450:  -u                         with -lt: sort by, and show, access time\n\
        -: 4451:                               with -l: show access time and sort by name\n\
        -: 4452:                               otherwise: sort by access time\n\
        -: 4453:  -U                         do not sort; list entries in directory order\n\
        -: 4454:  -v                         sort by version\n\
        -: 4455:"), stdout);
    #####: 4456:      fputs (_("\
        -: 4457:  -w, --width=COLS           assume screen width instead of current value\n\
        -: 4458:  -x                         list entries by lines instead of by columns\n\
        -: 4459:  -X                         sort alphabetically by entry extension\n\
        -: 4460:  -Z, --context              print any SELinux security context of each file\n\
        -: 4461:  -1                         list one file per line\n\
        -: 4462:"), stdout);
    #####: 4463:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####: 4464:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####: 4465:      fputs (_("\n\
        -: 4466:SIZE may be (or may be an integer optionally followed by) one of following:\n\
        -: 4467:kB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n\
        -: 4468:"), stdout);
    #####: 4469:      fputs (_("\
        -: 4470:\n\
        -: 4471:By default, color is not used to distinguish types of files.  That is\n\
        -: 4472:equivalent to using --color=none.  Using the --color option without the\n\
        -: 4473:optional WHEN argument is equivalent to using --color=always.  With\n\
        -: 4474:--color=auto, color codes are output only if standard output is connected\n\
        -: 4475:to a terminal (tty).  The environment variable LS_COLORS can influence the\n\
        -: 4476:colors, and can be set easily by the dircolors command.\n\
        -: 4477:"), stdout);
    #####: 4478:      fputs (_("\
        -: 4479:\n\
        -: 4480:Exit status is 0 if OK, 1 if minor problems, 2 if serious trouble.\n\
        -: 4481:"), stdout);
    #####: 4482:      emit_bug_reporting_address ();
        -: 4483:    }
    #####: 4484:  exit (status);
        -: 4485:}
