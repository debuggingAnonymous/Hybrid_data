        -:    0:Source:src/df.c
        -:    0:Graph:src/df.gcno
        -:    0:Data:src/df.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* df - summarize free disk space
        -:    2:   Copyright (C) 1991-2012 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* Written by David MacKenzie <djm@gnu.ai.mit.edu>.
        -:   18:   --human-readable and --megabyte options added by lm@sgi.com.
        -:   19:   --si and large file support added by eggert@twinsun.com.  */
        -:   20:
        -:   21:#include <config.h>
        -:   22:#include <stdio.h>
        -:   23:#include <sys/types.h>
        -:   24:#include <getopt.h>
        -:   25:#include <assert.h>
        -:   26:
        -:   27:#include "system.h"
        -:   28:#include "canonicalize.h"
        -:   29:#include "error.h"
        -:   30:#include "fsusage.h"
        -:   31:#include "human.h"
        -:   32:#include "mbsalign.h"
        -:   33:#include "mbswidth.h"
        -:   34:#include "mountlist.h"
        -:   35:#include "quote.h"
        -:   36:#include "find-mount-point.h"
        -:   37:
        -:   38:/* The official name of this program (e.g., no 'g' prefix).  */
        -:   39:#define PROGRAM_NAME "df"
        -:   40:
        -:   41:#define AUTHORS \
        -:   42:  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
        -:   43:  proper_name ("David MacKenzie"), \
        -:   44:  proper_name ("Paul Eggert")
        -:   45:
        -:   46:/* If true, show inode information. */
        -:   47:static bool inode_format;
        -:   48:
        -:   49:/* If true, show even file systems with zero size or
        -:   50:   uninteresting types. */
        -:   51:static bool show_all_fs;
        -:   52:
        -:   53:/* If true, show only local file systems.  */
        -:   54:static bool show_local_fs;
        -:   55:
        -:   56:/* If true, output data for each file system corresponding to a
        -:   57:   command line argument -- even if it's a dummy (automounter) entry.  */
        -:   58:static bool show_listed_fs;
        -:   59:
        -:   60:/* Human-readable options for output.  */
        -:   61:static int human_output_opts;
        -:   62:
        -:   63:/* The units to use when printing sizes.  */
        -:   64:static uintmax_t output_block_size;
        -:   65:
        -:   66:/* If true, use the POSIX output format.  */
        -:   67:static bool posix_format;
        -:   68:
        -:   69:/* True if a file system has been processed for output.  */
        -:   70:static bool file_systems_processed;
        -:   71:
        -:   72:/* If true, invoke the 'sync' system call before getting any usage data.
        -:   73:   Using this option can make df very slow, especially with many or very
        -:   74:   busy disks.  Note that this may make a difference on some systems --
        -:   75:   SunOS 4.1.3, for one.  It is *not* necessary on GNU/Linux.  */
        -:   76:static bool require_sync;
        -:   77:
        -:   78:/* Desired exit status.  */
        -:   79:static int exit_status;
        -:   80:
        -:   81:/* A file system type to display. */
        -:   82:
        -:   83:struct fs_type_list
        -:   84:{
        -:   85:  char *fs_name;
        -:   86:  struct fs_type_list *fs_next;
        -:   87:};
        -:   88:
        -:   89:/* Linked list of file system types to display.
        -:   90:   If 'fs_select_list' is NULL, list all types.
        -:   91:   This table is generated dynamically from command-line options,
        -:   92:   rather than hardcoding into the program what it thinks are the
        -:   93:   valid file system types; let the user specify any file system type
        -:   94:   they want to, and if there are any file systems of that type, they
        -:   95:   will be shown.
        -:   96:
        -:   97:   Some file system types:
        -:   98:   4.2 4.3 ufs nfs swap ignore io vm efs dbg */
        -:   99:
        -:  100:static struct fs_type_list *fs_select_list;
        -:  101:
        -:  102:/* Linked list of file system types to omit.
        -:  103:   If the list is empty, don't exclude any types.  */
        -:  104:
        -:  105:static struct fs_type_list *fs_exclude_list;
        -:  106:
        -:  107:/* Linked list of mounted file systems. */
        -:  108:static struct mount_entry *mount_list;
        -:  109:
        -:  110:/* If true, print file system type as well.  */
        -:  111:static bool print_type;
        -:  112:
        -:  113:/* If true, print a grand total at the end.  */
        -:  114:static bool print_grand_total;
        -:  115:
        -:  116:/* Grand total data. */
        -:  117:static struct fs_usage grand_fsu;
        -:  118:
        -:  119:/* Display modes.  */
        -:  120:enum { DEFAULT_MODE, INODES_MODE, HUMAN_MODE, POSIX_MODE, NMODES };
        -:  121:static int header_mode = DEFAULT_MODE;
        -:  122:
        -:  123:/* Displayable fields.  */
        -:  124:enum
        -:  125:{
        -:  126:  DEV_FIELD,   /* file system */
        -:  127:  TYPE_FIELD,  /* FS type */
        -:  128:  TOTAL_FIELD, /* blocks or inodes */
        -:  129:  USED_FIELD,  /* ditto */
        -:  130:  FREE_FIELD,  /* ditto */
        -:  131:  PCENT_FIELD, /* percent used */
        -:  132:  MNT_FIELD,   /* mount point */
        -:  133:  NFIELDS
        -:  134:};
        -:  135:
        -:  136:/* Header strings for the above fields in each mode.
        -:  137:   NULL means to use the header for the default mode.  */
        -:  138:static const char *headers[NFIELDS][NMODES] = {
        -:  139:/*  DEFAULT_MODE	INODES_MODE	HUMAN_MODE	POSIX_MODE  */
        -:  140:  { N_("Filesystem"),   NULL,           NULL,           NULL },
        -:  141:  { N_("Type"),         NULL,           NULL,           NULL },
        -:  142:  { N_("blocks"),       N_("Inodes"),   N_("Size"),     NULL },
        -:  143:  { N_("Used"),         N_("IUsed"),    NULL,           NULL },
        -:  144:  { N_("Available"),    N_("IFree"),    N_("Avail"),    NULL },
        -:  145:  { N_("Use%"),         N_("IUse%"),    NULL,           N_("Capacity") },
        -:  146:  { N_("Mounted on"),   NULL,           NULL,           NULL }
        -:  147:};
        -:  148:
        -:  149:/* Alignments for the 3 textual and 4 numeric fields.  */
        -:  150:static mbs_align_t alignments[NFIELDS] = {
        -:  151:  MBS_ALIGN_LEFT, MBS_ALIGN_LEFT,
        -:  152:  MBS_ALIGN_RIGHT, MBS_ALIGN_RIGHT, MBS_ALIGN_RIGHT, MBS_ALIGN_RIGHT,
        -:  153:  MBS_ALIGN_LEFT
        -:  154:};
        -:  155:
        -:  156:/* Auto adjusted (up) widths used to align columns.  */
        -:  157:static size_t widths[NFIELDS] = { 14, 4, 5, 5, 5, 4, 0 };
        -:  158:
        -:  159:/* Storage for pointers for each string (cell of table).  */
        -:  160:static char ***table;
        -:  161:
        -:  162:/* The current number of processed rows (including header).  */
        -:  163:static size_t nrows;
        -:  164:
        -:  165:/* For long options that have no equivalent short option, use a
        -:  166:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  167:enum
        -:  168:{
        -:  169:  NO_SYNC_OPTION = CHAR_MAX + 1,
        -:  170:  SYNC_OPTION,
        -:  171:  MEGABYTES_OPTION  /* FIXME: remove long opt in Aug 2013 */
        -:  172:};
        -:  173:
        -:  174:static struct option const long_options[] =
        -:  175:{
        -:  176:  {"all", no_argument, NULL, 'a'},
        -:  177:  {"block-size", required_argument, NULL, 'B'},
        -:  178:  {"inodes", no_argument, NULL, 'i'},
        -:  179:  {"human-readable", no_argument, NULL, 'h'},
        -:  180:  {"si", no_argument, NULL, 'H'},
        -:  181:  {"local", no_argument, NULL, 'l'},
        -:  182:  {"megabytes", no_argument, NULL, MEGABYTES_OPTION}, /* obsolescent,  */
        -:  183:  {"portability", no_argument, NULL, 'P'},
        -:  184:  {"print-type", no_argument, NULL, 'T'},
        -:  185:  {"sync", no_argument, NULL, SYNC_OPTION},
        -:  186:  {"no-sync", no_argument, NULL, NO_SYNC_OPTION},
        -:  187:  {"total", no_argument, NULL, 'c'},
        -:  188:  {"type", required_argument, NULL, 't'},
        -:  189:  {"exclude-type", required_argument, NULL, 'x'},
        -:  190:  {GETOPT_HELP_OPTION_DECL},
        -:  191:  {GETOPT_VERSION_OPTION_DECL},
        -:  192:  {NULL, 0, NULL, 0}
        -:  193:};
        -:  194:
        -:  195:/* Replace problematic chars with '?'.
        -:  196:   Since only control characters are currently considered,
        -:  197:   this should work in all encodings.  */
        -:  198:
        -:  199:static char*
       66:  200:hide_problematic_chars (char *cell)
        -:  201:{
       66:  202:  char *p = cell;
      556:  203:  while (*p)
        -:  204:    {
      424:  205:      if (iscntrl (to_uchar (*p)))
    #####:  206:        *p = '?';
      424:  207:      p++;
        -:  208:    }
       66:  209:  return cell;
        -:  210:}
        -:  211:
        -:  212:/* Dynamically allocate a row of pointers in TABLE, which
        -:  213:   can then be accessed with standard 2D array notation.  */
        -:  214:
        -:  215:static void
       11:  216:alloc_table_row (void)
        -:  217:{
       11:  218:  nrows++;
       11:  219:  table = xnrealloc (table, nrows, sizeof (char *));
       11:  220:  table[nrows-1] = xnmalloc (NFIELDS, sizeof (char *));
       11:  221:}
        -:  222:
        -:  223:/* Output each cell in the table, accounting for the
        -:  224:   alignment and max width of each column.  */
        -:  225:
        -:  226:static void
        1:  227:print_table (void)
        -:  228:{
        -:  229:  size_t field, row;
        -:  230:
       12:  231:  for (row = 0; row < nrows; row ++)
        -:  232:    {
       88:  233:      for (field = 0; field < NFIELDS; field++)
        -:  234:        {
       77:  235:          size_t width = widths[field];
       77:  236:          char *cell = table[row][field];
       77:  237:          if (!cell) /* Missing type column, or mount point etc. */
       11:  238:            continue;
        -:  239:
        -:  240:          /* Note the DEV_FIELD used to be displayed on it's own line
        -:  241:             if (!posix_format && mbswidth (cell) > 20), but that
        -:  242:             functionality is probably more problematic than helpful.  */
       66:  243:          if (field != 0)
       55:  244:            putchar (' ');
       66:  245:          if (field == MNT_FIELD) /* The last one.  */
       11:  246:            fputs (cell, stdout);
        -:  247:          else
        -:  248:            {
       55:  249:              cell = ambsalign (cell, &width, alignments[field], 0);
        -:  250:              /* When ambsalign fails, output unaligned data.  */
       55:  251:              fputs (cell ? cell : table[row][field], stdout);
       55:  252:              free (cell);
        -:  253:            }
       66:  254:          IF_LINT (free (table[row][field]));
        -:  255:        }
       11:  256:      putchar ('\n');
       11:  257:      IF_LINT (free (table[row]));
        -:  258:    }
        -:  259:
        1:  260:  IF_LINT (free (table));
        1:  261:}
        -:  262:
        -:  263:/* Obtain the appropriate header entries.  */
        -:  264:
        -:  265:static void
        1:  266:get_header (void)
        -:  267:{
        -:  268:  size_t field;
        -:  269:
        1:  270:  alloc_table_row ();
        -:  271:
        8:  272:  for (field = 0; field < NFIELDS; field++)
        -:  273:    {
        7:  274:      if (field == TYPE_FIELD && !print_type)
        -:  275:        {
        1:  276:          table[nrows-1][field] = NULL;
        1:  277:          continue;
        -:  278:        }
        -:  279:
        6:  280:      char *cell = NULL;
        6:  281:      char const *header = _(headers[field][header_mode]);
        6:  282:      if (!header)
        5:  283:        header = _(headers[field][DEFAULT_MODE]);
        -:  284:
        6:  285:      if (header_mode == DEFAULT_MODE && field == TOTAL_FIELD)
    #####:  286:        {
        -:  287:          char buf[LONGEST_HUMAN_READABLE + 1];
        -:  288:
    #####:  289:          int opts = (human_suppress_point_zero
        -:  290:                      | human_autoscale | human_SI
        -:  291:                      | (human_output_opts
    #####:  292:                         & (human_group_digits | human_base_1024 | human_B)));
        -:  293:
        -:  294:          /* Prefer the base that makes the human-readable value more exact,
        -:  295:             if there is a difference.  */
        -:  296:
    #####:  297:          uintmax_t q1000 = output_block_size;
    #####:  298:          uintmax_t q1024 = output_block_size;
        -:  299:          bool divisible_by_1000;
        -:  300:          bool divisible_by_1024;
        -:  301:
        -:  302:          do
        -:  303:            {
    #####:  304:              divisible_by_1000 = q1000 % 1000 == 0;  q1000 /= 1000;
    #####:  305:              divisible_by_1024 = q1024 % 1024 == 0;  q1024 /= 1024;
        -:  306:            }
    #####:  307:          while (divisible_by_1000 & divisible_by_1024);
        -:  308:
    #####:  309:          if (divisible_by_1000 < divisible_by_1024)
    #####:  310:            opts |= human_base_1024;
    #####:  311:          if (divisible_by_1024 < divisible_by_1000)
    #####:  312:            opts &= ~human_base_1024;
    #####:  313:          if (! (opts & human_base_1024))
    #####:  314:            opts |= human_B;
        -:  315:
    #####:  316:          char *num = human_readable (output_block_size, buf, opts, 1, 1);
        -:  317:
        -:  318:          /* TRANSLATORS: this is the "1K-blocks" header in "df" output.  */
    #####:  319:          if (asprintf (&cell, _("%s-%s"), num, header) == -1)
    #####:  320:            cell = NULL;
        -:  321:        }
        6:  322:      else if (header_mode == POSIX_MODE && field == TOTAL_FIELD)
        1:  323:        {
        -:  324:          char buf[INT_BUFSIZE_BOUND (uintmax_t)];
        1:  325:          char *num = umaxtostr (output_block_size, buf);
        -:  326:
        -:  327:          /* TRANSLATORS: this is the "1024-blocks" header in "df -P".  */
        1:  328:          if (asprintf (&cell, _("%s-%s"), num, header) == -1)
    #####:  329:            cell = NULL;
        -:  330:        }
        -:  331:      else
        5:  332:        cell = strdup (header);
        -:  333:
        6:  334:      if (!cell)
    #####:  335:        xalloc_die ();
        -:  336:
        6:  337:      hide_problematic_chars (cell);
        -:  338:
        6:  339:      table[nrows-1][field] = cell;
        -:  340:
        6:  341:      widths[field] = MAX (widths[field], mbswidth (cell, 0));
        -:  342:    }
        1:  343:}
        -:  344:
        -:  345:/* Is FSTYPE a type of file system that should be listed?  */
        -:  346:
        -:  347:static bool _GL_ATTRIBUTE_PURE
       25:  348:selected_fstype (const char *fstype)
        -:  349:{
        -:  350:  const struct fs_type_list *fsp;
        -:  351:
       25:  352:  if (fs_select_list == NULL || fstype == NULL)
       25:  353:    return true;
    #####:  354:  for (fsp = fs_select_list; fsp; fsp = fsp->fs_next)
    #####:  355:    if (STREQ (fstype, fsp->fs_name))
    #####:  356:      return true;
    #####:  357:  return false;
        -:  358:}
        -:  359:
        -:  360:/* Is FSTYPE a type of file system that should be omitted?  */
        -:  361:
        -:  362:static bool _GL_ATTRIBUTE_PURE
       25:  363:excluded_fstype (const char *fstype)
        -:  364:{
        -:  365:  const struct fs_type_list *fsp;
        -:  366:
       25:  367:  if (fs_exclude_list == NULL || fstype == NULL)
       25:  368:    return false;
    #####:  369:  for (fsp = fs_exclude_list; fsp; fsp = fsp->fs_next)
    #####:  370:    if (STREQ (fstype, fsp->fs_name))
    #####:  371:      return true;
    #####:  372:  return false;
        -:  373:}
        -:  374:
        -:  375:/* Return true if N is a known integer value.  On many file systems,
        -:  376:   UINTMAX_MAX represents an unknown value; on AIX, UINTMAX_MAX - 1
        -:  377:   represents unknown.  Use a rule that works on AIX file systems, and
        -:  378:   that almost-always works on other types.  */
        -:  379:static bool
      100:  380:known_value (uintmax_t n)
        -:  381:{
      100:  382:  return n < UINTMAX_MAX - 1;
        -:  383:}
        -:  384:
        -:  385:/* Like human_readable (N, BUF, human_output_opts, INPUT_UNITS, OUTPUT_UNITS),
        -:  386:   except:
        -:  387:
        -:  388:    - If NEGATIVE, then N represents a negative number,
        -:  389:      expressed in two's complement.
        -:  390:    - Otherwise, return "-" if N is unknown.  */
        -:  391:
        -:  392:static char const *
       30:  393:df_readable (bool negative, uintmax_t n, char *buf,
        -:  394:             uintmax_t input_units, uintmax_t output_units)
        -:  395:{
       30:  396:  if (! known_value (n) && !negative)
    #####:  397:    return "-";
        -:  398:  else
        -:  399:    {
       30:  400:      char *p = human_readable (negative ? -n : n, buf + negative,
        -:  401:                                human_output_opts, input_units, output_units);
       30:  402:      if (negative)
    #####:  403:        *--p = '-';
       30:  404:      return p;
        -:  405:    }
        -:  406:}
        -:  407:
        -:  408:/* Logical equivalence */
        -:  409:#define LOG_EQ(a, b) (!(a) == !(b))
        -:  410:
        -:  411:/* Add integral value while using uintmax_t for value part and separate
        -:  412:   negation flag. It adds value of SRC and SRC_NEG to DEST and DEST_NEG.
        -:  413:   The result will be in DEST and DEST_NEG.  See df_readable to understand
        -:  414:   how the negation flag is used.  */
        -:  415:static void
       10:  416:add_uint_with_neg_flag (uintmax_t *dest, bool *dest_neg,
        -:  417:                        uintmax_t src, bool src_neg)
        -:  418:{
       10:  419:  if (LOG_EQ (*dest_neg, src_neg))
        -:  420:    {
       10:  421:      *dest += src;
       20:  422:      return;
        -:  423:    }
        -:  424:
    #####:  425:  if (*dest_neg)
    #####:  426:    *dest = -*dest;
        -:  427:
    #####:  428:  if (src_neg)
    #####:  429:    src = -src;
        -:  430:
    #####:  431:  if (src < *dest)
    #####:  432:    *dest -= src;
        -:  433:  else
        -:  434:    {
    #####:  435:      *dest = src - *dest;
    #####:  436:      *dest_neg = src_neg;
        -:  437:    }
        -:  438:
    #####:  439:  if (*dest_neg)
    #####:  440:    *dest = -*dest;
        -:  441:}
        -:  442:
        -:  443:/* Return true if S ends in a string that may be a 36-byte UUID,
        -:  444:   i.e., of the form HHHHHHHH-HHHH-HHHH-HHHH-HHHHHHHHHHHH, where
        -:  445:   each H is an upper or lower case hexadecimal digit.  */
        -:  446:static bool _GL_ATTRIBUTE_PURE
       10:  447:has_uuid_suffix (char const *s)
        -:  448:{
       10:  449:  size_t len = strlen (s);
       10:  450:  return (36 < len
       10:  451:          && strspn (s + len - 36, "-0123456789abcdefABCDEF") == 36);
        -:  452:}
        -:  453:
        -:  454:/* Obtain a space listing for the disk device with absolute file name DISK.
        -:  455:   If MOUNT_POINT is non-NULL, it is the name of the root of the
        -:  456:   file system on DISK.
        -:  457:   If STAT_FILE is non-null, it is the name of a file within the file
        -:  458:   system that the user originally asked for; this provides better
        -:  459:   diagnostics, and sometimes it provides better results on networked
        -:  460:   file systems that give different free-space results depending on
        -:  461:   where in the file system you probe.
        -:  462:   If FSTYPE is non-NULL, it is the type of the file system on DISK.
        -:  463:   If MOUNT_POINT is non-NULL, then DISK may be NULL -- certain systems may
        -:  464:   not be able to produce statistics in this case.
        -:  465:   ME_DUMMY and ME_REMOTE are the mount entry flags.
        -:  466:   Caller must set PROCESS_ALL to true when iterating over all entries, as
        -:  467:   when df is invoked with no non-option argument.  See below for details.  */
        -:  468:
        -:  469:static void
       31:  470:get_dev (char const *disk, char const *mount_point,
        -:  471:         char const *stat_file, char const *fstype,
        -:  472:         bool me_dummy, bool me_remote,
        -:  473:         const struct fs_usage *force_fsu,
        -:  474:         bool process_all)
        -:  475:{
        -:  476:  struct fs_usage fsu;
        -:  477:  char buf[LONGEST_HUMAN_READABLE + 2];
        -:  478:  uintmax_t input_units;
        -:  479:  uintmax_t output_units;
        -:  480:  uintmax_t total;
        -:  481:  uintmax_t available;
        -:  482:  bool negate_available;
        -:  483:  uintmax_t available_to_root;
        -:  484:  uintmax_t used;
        -:  485:  bool negate_used;
       31:  486:  double pct = -1;
        -:  487:  char* cell;
        -:  488:  size_t field;
        -:  489:
       31:  490:  if (me_remote && show_local_fs)
       21:  491:    return;
        -:  492:
       31:  493:  if (me_dummy && !show_all_fs && !show_listed_fs)
        6:  494:    return;
        -:  495:
       25:  496:  if (!selected_fstype (fstype) || excluded_fstype (fstype))
    #####:  497:    return;
        -:  498:
        -:  499:  /* If MOUNT_POINT is NULL, then the file system is not mounted, and this
        -:  500:     program reports on the file system that the special file is on.
        -:  501:     It would be better to report on the unmounted file system,
        -:  502:     but statfs doesn't do that on most systems.  */
       25:  503:  if (!stat_file)
       25:  504:    stat_file = mount_point ? mount_point : disk;
        -:  505:
       25:  506:  if (force_fsu)
    #####:  507:    fsu = *force_fsu;
       25:  508:  else if (get_fs_usage (stat_file, disk, &fsu))
        -:  509:    {
    #####:  510:      error (0, errno, "%s", quote (stat_file));
    #####:  511:      exit_status = EXIT_FAILURE;
    #####:  512:      return;
        -:  513:    }
        -:  514:
       25:  515:  if (fsu.fsu_blocks == 0 && !show_all_fs && !show_listed_fs)
       15:  516:    return;
        -:  517:
       10:  518:  if (! file_systems_processed)
        -:  519:    {
        1:  520:      if (! force_fsu)
        1:  521:        file_systems_processed = true;
        1:  522:      get_header ();
        -:  523:    }
        -:  524:
       10:  525:  alloc_table_row ();
        -:  526:
       10:  527:  if (! disk)
    #####:  528:    disk = "-";			/* unknown */
        -:  529:
       10:  530:  char *dev_name = xstrdup (disk);
        -:  531:  char *resolved_dev;
        -:  532:
        -:  533:  /* On some systems, dev_name is a long-named symlink like
        -:  534:     /dev/disk/by-uuid/828fc648-9f30-43d8-a0b1-f7196a2edb66 pointing to a
        -:  535:     much shorter and more useful name like /dev/sda1.  It may also look
        -:  536:     like /dev/mapper/luks-828fc648-9f30-43d8-a0b1-f7196a2edb66 and point to
        -:  537:     /dev/dm-0.  When process_all is true and dev_name is a symlink whose
        -:  538:     name ends with a UUID use the resolved name instead.  */
       10:  539:  if (process_all
       10:  540:      && has_uuid_suffix (dev_name)
    #####:  541:      && (resolved_dev = canonicalize_filename_mode (dev_name, CAN_EXISTING)))
        -:  542:    {
    #####:  543:      free (dev_name);
    #####:  544:      dev_name = resolved_dev;
        -:  545:    }
        -:  546:
       10:  547:  if (! fstype)
    #####:  548:    fstype = "-";		/* unknown */
        -:  549:
       10:  550:  if (inode_format)
        -:  551:    {
    #####:  552:      input_units = output_units = 1;
    #####:  553:      total = fsu.fsu_files;
    #####:  554:      available = fsu.fsu_ffree;
    #####:  555:      negate_available = false;
    #####:  556:      available_to_root = available;
        -:  557:
    #####:  558:      if (known_value (total))
    #####:  559:        grand_fsu.fsu_files += total;
    #####:  560:      if (known_value (available))
    #####:  561:        grand_fsu.fsu_ffree += available;
        -:  562:    }
        -:  563:  else
        -:  564:    {
       10:  565:      input_units = fsu.fsu_blocksize;
       10:  566:      output_units = output_block_size;
       10:  567:      total = fsu.fsu_blocks;
       10:  568:      available = fsu.fsu_bavail;
       20:  569:      negate_available = (fsu.fsu_bavail_top_bit_set
       10:  570:                          && known_value (available));
       10:  571:      available_to_root = fsu.fsu_bfree;
        -:  572:
       10:  573:      if (known_value (total))
       10:  574:        grand_fsu.fsu_blocks += input_units * total;
       10:  575:      if (known_value (available_to_root))
       10:  576:        grand_fsu.fsu_bfree  += input_units * available_to_root;
       10:  577:      if (known_value (available))
       10:  578:        add_uint_with_neg_flag (&grand_fsu.fsu_bavail,
        -:  579:                                &grand_fsu.fsu_bavail_top_bit_set,
        -:  580:                                input_units * available, negate_available);
        -:  581:    }
        -:  582:
       10:  583:  used = UINTMAX_MAX;
       10:  584:  negate_used = false;
       10:  585:  if (known_value (total) && known_value (available_to_root))
        -:  586:    {
       10:  587:      used = total - available_to_root;
       10:  588:      negate_used = (total < available_to_root);
        -:  589:    }
        -:  590:
       80:  591:  for (field = 0; field < NFIELDS; field++)
        -:  592:    {
       70:  593:      switch (field)
        -:  594:        {
        -:  595:        case DEV_FIELD:
       10:  596:          cell = dev_name;
       10:  597:          break;
        -:  598:
        -:  599:        case TYPE_FIELD:
       10:  600:          cell = print_type ? xstrdup (fstype) : NULL;
       10:  601:          break;
        -:  602:
        -:  603:        case TOTAL_FIELD:
       10:  604:          cell = xstrdup (df_readable (false, total, buf,
        -:  605:                                       input_units, output_units));
       10:  606:          break;
        -:  607:        case USED_FIELD:
       10:  608:          cell = xstrdup (df_readable (negate_used, used, buf,
        -:  609:                                       input_units, output_units));
       10:  610:          break;
        -:  611:        case FREE_FIELD:
       10:  612:          cell = xstrdup (df_readable (negate_available, available, buf,
        -:  613:                                       input_units, output_units));
       10:  614:          break;
        -:  615:
        -:  616:        case PCENT_FIELD:
       10:  617:          if (! known_value (used) || ! known_value (available))
        -:  618:            ;
       10:  619:          else if (!negate_used
       10:  620:                   && used <= TYPE_MAXIMUM (uintmax_t) / 100
       10:  621:                   && used + available != 0
       10:  622:                   && (used + available < used) == negate_available)
       10:  623:            {
       10:  624:              uintmax_t u100 = used * 100;
       10:  625:              uintmax_t nonroot_total = used + available;
       10:  626:              pct = u100 / nonroot_total + (u100 % nonroot_total != 0);
        -:  627:            }
        -:  628:          else
        -:  629:            {
        -:  630:              /* The calculation cannot be done easily with integer
        -:  631:                 arithmetic.  Fall back on floating point.  This can suffer
        -:  632:                 from minor rounding errors, but doing it exactly requires
        -:  633:                 multiple precision arithmetic, and it's not worth the
        -:  634:                 aggravation.  */
    #####:  635:              double u = negate_used ? - (double) - used : used;
    #####:  636:              double a = negate_available ? - (double) - available : available;
    #####:  637:              double nonroot_total = u + a;
    #####:  638:              if (nonroot_total)
        -:  639:                {
    #####:  640:                  long int lipct = pct = u * 100 / nonroot_total;
    #####:  641:                  double ipct = lipct;
        -:  642:
        -:  643:                  /* Like 'pct = ceil (dpct);', but avoid ceil so that
        -:  644:                     the math library needn't be linked.  */
    #####:  645:                  if (ipct - 1 < pct && pct <= ipct + 1)
    #####:  646:                    pct = ipct + (ipct < pct);
        -:  647:                }
        -:  648:            }
        -:  649:
       10:  650:          if (0 <= pct)
        -:  651:            {
       10:  652:              if (asprintf (&cell, "%.0f%%", pct) == -1)
    #####:  653:                cell = NULL;
        -:  654:            }
        -:  655:          else
    #####:  656:            cell = strdup ("-");
        -:  657:
       10:  658:          if (!cell)
    #####:  659:            xalloc_die ();
        -:  660:
       10:  661:          break;
        -:  662:
        -:  663:        case MNT_FIELD:
       10:  664:          if (mount_point)
        -:  665:            {
        -:  666:#ifdef HIDE_AUTOMOUNT_PREFIX
        -:  667:              /* Don't print the first directory name in MOUNT_POINT if it's an
        -:  668:                 artifact of an automounter.  This is a bit too aggressive to be
        -:  669:                 the default.  */
        -:  670:              if (STRNCMP_LIT (mount_point, "/auto/") == 0)
        -:  671:                mount_point += 5;
        -:  672:              else if (STRNCMP_LIT (mount_point, "/tmp_mnt/") == 0)
        -:  673:                mount_point += 8;
        -:  674:#endif
       10:  675:              cell = xstrdup (mount_point);
        -:  676:            }
        -:  677:          else
    #####:  678:            cell = NULL;
       10:  679:          break;
        -:  680:
        -:  681:        default:
    #####:  682:          assert (!"unhandled field");
        -:  683:        }
        -:  684:
       70:  685:      if (cell)
        -:  686:        {
       60:  687:          hide_problematic_chars (cell);
       60:  688:          widths[field] = MAX (widths[field], mbswidth (cell, 0));
        -:  689:        }
       70:  690:      table[nrows-1][field] = cell;
        -:  691:    }
        -:  692:}
        -:  693:
        -:  694:/* If DISK corresponds to a mount point, show its usage
        -:  695:   and return true.  Otherwise, return false.  */
        -:  696:static bool
    #####:  697:get_disk (char const *disk)
        -:  698:{
        -:  699:  struct mount_entry const *me;
    #####:  700:  struct mount_entry const *best_match = NULL;
        -:  701:
    #####:  702:  for (me = mount_list; me; me = me->me_next)
    #####:  703:    if (STREQ (disk, me->me_devname))
    #####:  704:      best_match = me;
        -:  705:
    #####:  706:  if (best_match)
        -:  707:    {
    #####:  708:      get_dev (best_match->me_devname, best_match->me_mountdir, NULL,
    #####:  709:               best_match->me_type, best_match->me_dummy,
    #####:  710:               best_match->me_remote, NULL, false);
    #####:  711:      return true;
        -:  712:    }
        -:  713:
    #####:  714:  return false;
        -:  715:}
        -:  716:
        -:  717:/* Figure out which device file or directory POINT is mounted on
        -:  718:   and show its disk usage.
        -:  719:   STATP must be the result of 'stat (POINT, STATP)'.  */
        -:  720:static void
    #####:  721:get_point (const char *point, const struct stat *statp)
        -:  722:{
        -:  723:  struct stat disk_stats;
        -:  724:  struct mount_entry *me;
    #####:  725:  struct mount_entry const *best_match = NULL;
        -:  726:
        -:  727:  /* Calculate the real absolute file name for POINT, and use that to find
        -:  728:     the mount point.  This avoids statting unavailable mount points,
        -:  729:     which can hang df.  */
    #####:  730:  char *resolved = canonicalize_file_name (point);
    #####:  731:  if (resolved && resolved[0] == '/')
        -:  732:    {
    #####:  733:      size_t resolved_len = strlen (resolved);
    #####:  734:      size_t best_match_len = 0;
        -:  735:
    #####:  736:      for (me = mount_list; me; me = me->me_next)
    #####:  737:      if (!STREQ (me->me_type, "lofs")
    #####:  738:          && (!best_match || best_match->me_dummy || !me->me_dummy))
        -:  739:        {
    #####:  740:          size_t len = strlen (me->me_mountdir);
    #####:  741:          if (best_match_len <= len && len <= resolved_len
    #####:  742:              && (len == 1 /* root file system */
    #####:  743:                  || ((len == resolved_len || resolved[len] == '/')
    #####:  744:                      && STREQ_LEN (me->me_mountdir, resolved, len))))
        -:  745:            {
    #####:  746:              best_match = me;
    #####:  747:              best_match_len = len;
        -:  748:            }
        -:  749:        }
        -:  750:    }
    #####:  751:  free (resolved);
    #####:  752:  if (best_match
    #####:  753:      && (stat (best_match->me_mountdir, &disk_stats) != 0
    #####:  754:          || disk_stats.st_dev != statp->st_dev))
    #####:  755:    best_match = NULL;
        -:  756:
    #####:  757:  if (! best_match)
    #####:  758:    for (me = mount_list; me; me = me->me_next)
        -:  759:      {
    #####:  760:        if (me->me_dev == (dev_t) -1)
        -:  761:          {
    #####:  762:            if (stat (me->me_mountdir, &disk_stats) == 0)
    #####:  763:              me->me_dev = disk_stats.st_dev;
        -:  764:            else
        -:  765:              {
        -:  766:                /* Report only I/O errors.  Other errors might be
        -:  767:                   caused by shadowed mount points, which means POINT
        -:  768:                   can't possibly be on this file system.  */
    #####:  769:                if (errno == EIO)
        -:  770:                  {
    #####:  771:                    error (0, errno, "%s", quote (me->me_mountdir));
    #####:  772:                    exit_status = EXIT_FAILURE;
        -:  773:                  }
        -:  774:
        -:  775:                /* So we won't try and fail repeatedly. */
    #####:  776:                me->me_dev = (dev_t) -2;
        -:  777:              }
        -:  778:          }
        -:  779:
    #####:  780:        if (statp->st_dev == me->me_dev
    #####:  781:            && !STREQ (me->me_type, "lofs")
    #####:  782:            && (!best_match || best_match->me_dummy || !me->me_dummy))
        -:  783:          {
        -:  784:            /* Skip bogus mtab entries.  */
    #####:  785:            if (stat (me->me_mountdir, &disk_stats) != 0
    #####:  786:                || disk_stats.st_dev != me->me_dev)
    #####:  787:              me->me_dev = (dev_t) -2;
        -:  788:            else
    #####:  789:              best_match = me;
        -:  790:          }
        -:  791:      }
        -:  792:
    #####:  793:  if (best_match)
    #####:  794:    get_dev (best_match->me_devname, best_match->me_mountdir, point,
    #####:  795:             best_match->me_type, best_match->me_dummy, best_match->me_remote,
        -:  796:             NULL, false);
        -:  797:  else
        -:  798:    {
        -:  799:      /* We couldn't find the mount entry corresponding to POINT.  Go ahead and
        -:  800:         print as much info as we can; methods that require the device to be
        -:  801:         present will fail at a later point.  */
        -:  802:
        -:  803:      /* Find the actual mount point.  */
    #####:  804:      char *mp = find_mount_point (point, statp);
    #####:  805:      if (mp)
        -:  806:        {
    #####:  807:          get_dev (NULL, mp, NULL, NULL, false, false, NULL, false);
    #####:  808:          free (mp);
        -:  809:        }
        -:  810:    }
    #####:  811:}
        -:  812:
        -:  813:/* Determine what kind of node NAME is and show the disk usage
        -:  814:   for it.  STATP is the results of 'stat' on NAME.  */
        -:  815:
        -:  816:static void
    #####:  817:get_entry (char const *name, struct stat const *statp)
        -:  818:{
    #####:  819:  if ((S_ISBLK (statp->st_mode) || S_ISCHR (statp->st_mode))
    #####:  820:      && get_disk (name))
    #####:  821:    return;
        -:  822:
    #####:  823:  get_point (name, statp);
        -:  824:}
        -:  825:
        -:  826:/* Show all mounted file systems, except perhaps those that are of
        -:  827:   an unselected type or are empty. */
        -:  828:
        -:  829:static void
        1:  830:get_all_entries (void)
        -:  831:{
        -:  832:  struct mount_entry *me;
        -:  833:
       32:  834:  for (me = mount_list; me; me = me->me_next)
       62:  835:    get_dev (me->me_devname, me->me_mountdir, NULL, me->me_type,
       62:  836:             me->me_dummy, me->me_remote, NULL, true);
        1:  837:}
        -:  838:
        -:  839:/* Add FSTYPE to the list of file system types to display. */
        -:  840:
        -:  841:static void
    #####:  842:add_fs_type (const char *fstype)
        -:  843:{
        -:  844:  struct fs_type_list *fsp;
        -:  845:
    #####:  846:  fsp = xmalloc (sizeof *fsp);
    #####:  847:  fsp->fs_name = (char *) fstype;
    #####:  848:  fsp->fs_next = fs_select_list;
    #####:  849:  fs_select_list = fsp;
    #####:  850:}
        -:  851:
        -:  852:/* Add FSTYPE to the list of file system types to be omitted. */
        -:  853:
        -:  854:static void
    #####:  855:add_excluded_fs_type (const char *fstype)
        -:  856:{
        -:  857:  struct fs_type_list *fsp;
        -:  858:
    #####:  859:  fsp = xmalloc (sizeof *fsp);
    #####:  860:  fsp->fs_name = (char *) fstype;
    #####:  861:  fsp->fs_next = fs_exclude_list;
    #####:  862:  fs_exclude_list = fsp;
    #####:  863:}
        -:  864:
        -:  865:void
    #####:  866:usage (int status)
        -:  867:{
    #####:  868:  if (status != EXIT_SUCCESS)
    #####:  869:    emit_try_help ();
        -:  870:  else
        -:  871:    {
    #####:  872:      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
    #####:  873:      fputs (_("\
        -:  874:Show information about the file system on which each FILE resides,\n\
        -:  875:or all file systems by default.\n\
        -:  876:\n\
        -:  877:"), stdout);
    #####:  878:      fputs (_("\
        -:  879:Mandatory arguments to long options are mandatory for short options too.\n\
        -:  880:"), stdout);
    #####:  881:      fputs (_("\
        -:  882:  -a, --all             include dummy file systems\n\
        -:  883:  -B, --block-size=SIZE  scale sizes by SIZE before printing them.  E.g.,\n\
        -:  884:                           '-BM' prints sizes in units of 1,048,576 bytes.\n\
        -:  885:                           See SIZE format below.\n\
        -:  886:      --total           produce a grand total\n\
        -:  887:  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)\
        -:  888:\n\
        -:  889:  -H, --si              likewise, but use powers of 1000 not 1024\n\
        -:  890:"), stdout);
    #####:  891:      fputs (_("\
        -:  892:  -i, --inodes          list inode information instead of block usage\n\
        -:  893:  -k                    like --block-size=1K\n\
        -:  894:  -l, --local           limit listing to local file systems\n\
        -:  895:      --no-sync         do not invoke sync before getting usage info (default)\
        -:  896:\n\
        -:  897:"), stdout);
    #####:  898:      fputs (_("\
        -:  899:  -P, --portability     use the POSIX output format\n\
        -:  900:      --sync            invoke sync before getting usage info\n\
        -:  901:  -t, --type=TYPE       limit listing to file systems of type TYPE\n\
        -:  902:  -T, --print-type      print file system type\n\
        -:  903:  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n\
        -:  904:  -v                    (ignored)\n\
        -:  905:"), stdout);
    #####:  906:      fputs (HELP_OPTION_DESCRIPTION, stdout);
    #####:  907:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
    #####:  908:      emit_blocksize_note ("DF");
    #####:  909:      emit_size_note ();
    #####:  910:      emit_ancillary_info ();
        -:  911:    }
    #####:  912:  exit (status);
        -:  913:}
        -:  914:
        -:  915:int
        1:  916:main (int argc, char **argv)
        -:  917:{
        1:  918:  struct stat *stats IF_LINT ( = 0);
        -:  919:
        -:  920:  initialize_main (&argc, &argv);
        1:  921:  set_program_name (argv[0]);
        1:  922:  setlocale (LC_ALL, "");
        -:  923:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  924:  textdomain (PACKAGE);
        -:  925:
        1:  926:  atexit (close_stdout);
        -:  927:
        1:  928:  fs_select_list = NULL;
        1:  929:  fs_exclude_list = NULL;
        1:  930:  inode_format = false;
        1:  931:  show_all_fs = false;
        1:  932:  show_listed_fs = false;
        1:  933:  human_output_opts = -1;
        1:  934:  print_type = false;
        1:  935:  file_systems_processed = false;
        1:  936:  posix_format = false;
        1:  937:  exit_status = EXIT_SUCCESS;
        1:  938:  print_grand_total = false;
        1:  939:  grand_fsu.fsu_blocksize = 1;
        -:  940:
        -:  941:  while (true)
        -:  942:    {
        3:  943:      int oi = -1;
        3:  944:      int c = getopt_long (argc, argv, "aB:iF:hHklmPTt:vx:", long_options,
        -:  945:                           &oi);
        3:  946:      if (c == -1)
        1:  947:        break;
        -:  948:
        2:  949:      switch (c)
        -:  950:        {
        -:  951:        case 'a':
    #####:  952:          show_all_fs = true;
    #####:  953:          break;
        -:  954:        case 'B':
        -:  955:          {
    #####:  956:            enum strtol_error e = human_options (optarg, &human_output_opts,
        -:  957:                                                 &output_block_size);
    #####:  958:            if (e != LONGINT_OK)
    #####:  959:              xstrtol_fatal (e, oi, c, long_options, optarg);
        -:  960:          }
    #####:  961:          break;
        -:  962:        case 'i':
    #####:  963:          inode_format = true;
    #####:  964:          break;
        -:  965:        case 'h':
    #####:  966:          human_output_opts = human_autoscale | human_SI | human_base_1024;
    #####:  967:          output_block_size = 1;
    #####:  968:          break;
        -:  969:        case 'H':
    #####:  970:          human_output_opts = human_autoscale | human_SI;
    #####:  971:          output_block_size = 1;
    #####:  972:          break;
        -:  973:        case 'k':
    #####:  974:          human_output_opts = 0;
    #####:  975:          output_block_size = 1024;
    #####:  976:          break;
        -:  977:        case 'l':
        1:  978:          show_local_fs = true;
        1:  979:          break;
        -:  980:        case MEGABYTES_OPTION:
        -:  981:          /* Distinguish between the long and the short option.
        -:  982:             As we want to remove the long option soon,
        -:  983:             give a warning when the long form is used.  */
    #####:  984:          error (0, 0, "%s%s", _("warning: "),
        -:  985:            _("long option '--megabytes' is deprecated"
        -:  986:              " and will soon be removed"));
        -:  987:        case 'm': /* obsolescent, exists for BSD compatibility */
    #####:  988:          human_output_opts = 0;
    #####:  989:          output_block_size = 1024 * 1024;
    #####:  990:          break;
        -:  991:        case 'T':
    #####:  992:          print_type = true;
    #####:  993:          break;
        -:  994:        case 'P':
        1:  995:          posix_format = true;
        1:  996:          break;
        -:  997:        case SYNC_OPTION:
    #####:  998:          require_sync = true;
    #####:  999:          break;
        -: 1000:        case NO_SYNC_OPTION:
    #####: 1001:          require_sync = false;
    #####: 1002:          break;
        -: 1003:
        -: 1004:        case 'F':
        -: 1005:          /* Accept -F as a synonym for -t for compatibility with Solaris.  */
        -: 1006:        case 't':
    #####: 1007:          add_fs_type (optarg);
    #####: 1008:          break;
        -: 1009:
        -: 1010:        case 'v':		/* For SysV compatibility. */
        -: 1011:          /* ignore */
    #####: 1012:          break;
        -: 1013:        case 'x':
    #####: 1014:          add_excluded_fs_type (optarg);
    #####: 1015:          break;
        -: 1016:
        -: 1017:        case 'c':
    #####: 1018:          print_grand_total = true;
    #####: 1019:          break;
        -: 1020:
    #####: 1021:        case_GETOPT_HELP_CHAR;
    #####: 1022:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -: 1023:
        -: 1024:        default:
    #####: 1025:          usage (EXIT_FAILURE);
        -: 1026:        }
        2: 1027:    }
        -: 1028:
        1: 1029:  if (human_output_opts == -1)
        -: 1030:    {
        1: 1031:      if (posix_format)
        -: 1032:        {
        1: 1033:          human_output_opts = 0;
        1: 1034:          output_block_size = (getenv ("POSIXLY_CORRECT") ? 512 : 1024);
        -: 1035:        }
        -: 1036:      else
    #####: 1037:        human_options (getenv ("DF_BLOCK_SIZE"),
        -: 1038:                       &human_output_opts, &output_block_size);
        -: 1039:    }
        -: 1040:
        1: 1041:  if (inode_format)
    #####: 1042:    header_mode = INODES_MODE;
        1: 1043:  else if (human_output_opts & human_autoscale)
    #####: 1044:    header_mode = HUMAN_MODE;
        1: 1045:  else if (posix_format)
        1: 1046:    header_mode = POSIX_MODE;
        -: 1047:
        -: 1048:  /* Fail if the same file system type was both selected and excluded.  */
        -: 1049:  {
        1: 1050:    bool match = false;
        -: 1051:    struct fs_type_list *fs_incl;
        1: 1052:    for (fs_incl = fs_select_list; fs_incl; fs_incl = fs_incl->fs_next)
        -: 1053:      {
        -: 1054:        struct fs_type_list *fs_excl;
    #####: 1055:        for (fs_excl = fs_exclude_list; fs_excl; fs_excl = fs_excl->fs_next)
        -: 1056:          {
    #####: 1057:            if (STREQ (fs_incl->fs_name, fs_excl->fs_name))
        -: 1058:              {
    #####: 1059:                error (0, 0,
        -: 1060:                       _("file system type %s both selected and excluded"),
    #####: 1061:                       quote (fs_incl->fs_name));
    #####: 1062:                match = true;
    #####: 1063:                break;
        -: 1064:              }
        -: 1065:          }
        -: 1066:      }
        1: 1067:    if (match)
    #####: 1068:      exit (EXIT_FAILURE);
        -: 1069:  }
        -: 1070:
        1: 1071:  if (optind < argc)
        -: 1072:    {
        -: 1073:      int i;
        -: 1074:
        -: 1075:      /* Open each of the given entries to make sure any corresponding
        -: 1076:         partition is automounted.  This must be done before reading the
        -: 1077:         file system table.  */
    #####: 1078:      stats = xnmalloc (argc - optind, sizeof *stats);
    #####: 1079:      for (i = optind; i < argc; ++i)
        -: 1080:        {
        -: 1081:          /* Prefer to open with O_NOCTTY and use fstat, but fall back
        -: 1082:             on using "stat", in case the file is unreadable.  */
    #####: 1083:          int fd = open (argv[i], O_RDONLY | O_NOCTTY);
    #####: 1084:          if ((fd < 0 || fstat (fd, &stats[i - optind]))
    #####: 1085:              && stat (argv[i], &stats[i - optind]))
        -: 1086:            {
    #####: 1087:              error (0, errno, "%s", quote (argv[i]));
    #####: 1088:              exit_status = EXIT_FAILURE;
    #####: 1089:              argv[i] = NULL;
        -: 1090:            }
    #####: 1091:          if (0 <= fd)
    #####: 1092:            close (fd);
        -: 1093:        }
        -: 1094:    }
        -: 1095:
        1: 1096:  mount_list =
        2: 1097:    read_file_system_list ((fs_select_list != NULL
        1: 1098:                            || fs_exclude_list != NULL
        1: 1099:                            || print_type
        2: 1100:                            || show_local_fs));
        -: 1101:
        1: 1102:  if (mount_list == NULL)
        -: 1103:    {
        -: 1104:      /* Couldn't read the table of mounted file systems.
        -: 1105:         Fail if df was invoked with no file name arguments,
        -: 1106:         or when either of -a, -l, -t or -x is used with file name
        -: 1107:         arguments. Otherwise, merely give a warning and proceed.  */
    #####: 1108:      int status = 0;
    #####: 1109:      if ( ! (optind < argc)
    #####: 1110:           || (show_all_fs
    #####: 1111:               || show_local_fs
    #####: 1112:               || fs_select_list != NULL
    #####: 1113:               || fs_exclude_list != NULL))
        -: 1114:        {
    #####: 1115:          status = EXIT_FAILURE;
        -: 1116:        }
    #####: 1117:      const char *warning = (status == 0 ? _("Warning: ") : "");
    #####: 1118:      error (status, errno, "%s%s", warning,
        -: 1119:             _("cannot read table of mounted file systems"));
        -: 1120:    }
        -: 1121:
        1: 1122:  if (require_sync)
    #####: 1123:    sync ();
        -: 1124:
        1: 1125:  if (optind < argc)
        -: 1126:    {
        -: 1127:      int i;
        -: 1128:
        -: 1129:      /* Display explicitly requested empty file systems. */
    #####: 1130:      show_listed_fs = true;
        -: 1131:
    #####: 1132:      for (i = optind; i < argc; ++i)
    #####: 1133:        if (argv[i])
    #####: 1134:          get_entry (argv[i], &stats[i - optind]);
        -: 1135:    }
        -: 1136:  else
        1: 1137:    get_all_entries ();
        -: 1138:
        1: 1139:  if (print_grand_total && file_systems_processed)
        -: 1140:    {
    #####: 1141:      if (inode_format)
    #####: 1142:        grand_fsu.fsu_blocks = 1;
    #####: 1143:      get_dev ("total", NULL, NULL, NULL, false, false, &grand_fsu, false);
        -: 1144:    }
        -: 1145:
        1: 1146:  print_table ();
        -: 1147:
        -: 1148:  /* Print the "no FS processed" diagnostic only if there was no preceding
        -: 1149:     diagnostic, e.g., if all have been excluded.  */
        1: 1150:  if (exit_status == EXIT_SUCCESS && ! file_systems_processed)
    #####: 1151:    error (EXIT_FAILURE, 0, _("no file systems processed"));
        -: 1152:
        1: 1153:  exit (exit_status);
        -: 1154:}
