        -:    0:Source:find.c
        -:    0:Graph:find.gcno
        -:    0:Data:find.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:/* find -- search for files in a directory hierarchy
        -:    2:   Copyright (C) 1990, 1991, 1992, 1993, 1994, 2000, 2003, 2004, 2005,
        -:    3:                 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
        -:    4:
        -:    5:   This program is free software: you can redistribute it and/or modify
        -:    6:   it under the terms of the GNU General Public License as published by
        -:    7:   the Free Software Foundation, either version 3 of the License, or
        -:    8:   (at your option) any later version.
        -:    9:
        -:   10:   This program is distributed in the hope that it will be useful,
        -:   11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:   GNU General Public License for more details.
        -:   14:
        -:   15:   You should have received a copy of the GNU General Public License
        -:   16:   along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17:*/
        -:   18:/* GNU find was written by Eric Decker <cire@soe.ucsc.edu>,
        -:   19:   with enhancements by David MacKenzie <djm@gnu.org>,
        -:   20:   Jay Plett <jay@silence.princeton.nj.us>,
        -:   21:   and Tim Wood <axolotl!tim@toad.com>.
        -:   22:   The idea for -print0 and xargs -0 came from
        -:   23:   Dan Bernstein <brnstnd@kramden.acf.nyu.edu>.
        -:   24:   Improvements have been made by James Youngman <jay@gnu.org>.
        -:   25:*/
        -:   26:
        -:   27:
        -:   28:#include <config.h>
        -:   29:#include "defs.h"
        -:   30:
        -:   31:#define USE_SAFE_CHDIR 1
        -:   32:#undef  STAT_MOUNTPOINTS
        -:   33:
        -:   34:
        -:   35:#include <errno.h>
        -:   36:#include <assert.h>
        -:   37:
        -:   38:#include <sys/stat.h>
        -:   39:#include <fcntl.h>
        -:   40:
        -:   41:#include "xalloc.h"
        -:   42:#include "human.h"
        -:   43:#include "canonicalize.h"
        -:   44:
        -:   45:#include "closein.h"
        -:   46:#include "savedirinfo.h"
        -:   47:#include "buildcmd.h"
        -:   48:#include "dirname.h"
        -:   49:#include "xgetcwd.h"
        -:   50:#include "error.h"
        -:   51:#include "fdleak.h"
        -:   52:#include "progname.h"
        -:   53:#include "save-cwd.h"
        -:   54:
        -:   55:#ifdef HAVE_LOCALE_H
        -:   56:#include <locale.h>
        -:   57:#endif
        -:   58:
        -:   59:#if ENABLE_NLS
        -:   60:# include <libintl.h>
        -:   61:# define _(Text) gettext (Text)
        -:   62:#else
        -:   63:# define _(Text) Text
        -:   64:#define textdomain(Domain)
        -:   65:#define bindtextdomain(Package, Directory)
        -:   66:#define ngettext(singular,plural,n) ((1==n) ? singular : plural)
        -:   67:#endif
        -:   68:#ifdef gettext_noop
        -:   69:# define N_(String) gettext_noop (String)
        -:   70:#else
        -:   71:/* See locate.c for explanation as to why not use (String) */
        -:   72:# define N_(String) String
        -:   73:#endif
        -:   74:
        -:   75:#ifdef STAT_MOUNTPOINTS
        -:   76:static void init_mounted_dev_list (int mandatory);
        -:   77:#endif
        -:   78:
        -:   79:static void process_top_path PARAMS((char *pathname, mode_t mode));
        -:   80:static int process_path PARAMS((char *pathname, char *name, bool leaf, char *parent, mode_t type));
        -:   81:static void process_dir PARAMS((char *pathname, char *name, int pathlen, const struct stat *statp, char *parent));
        -:   82:
        -:   83:
        -:   84:
        -:   85:/* A file descriptor open to the initial working directory.
        -:   86:   Doing it this way allows us to work when the i.w.d. has
        -:   87:   unreadable parents.  */
        -:   88:extern int starting_desc;
        -:   89:
        -:   90:/* The stat buffer of the initial working directory. */
        -:   91:static struct stat starting_stat_buf;
        -:   92:
        -:   93:enum ChdirSymlinkHandling
        -:   94:  {
        -:   95:    SymlinkHandleDefault,	/* Normally the right choice */
        -:   96:    SymlinkFollowOk		/* see comment in process_top_path() */
        -:   97:  };
        -:   98:
        -:   99:
        -:  100:enum TraversalDirection
        -:  101:  {
        -:  102:    TraversingUp,
        -:  103:    TraversingDown
        -:  104:  };
        -:  105:
        -:  106:enum WdSanityCheckFatality
        -:  107:  {
        -:  108:    FATAL_IF_SANITY_CHECK_FAILS,
        -:  109:    RETRY_IF_SANITY_CHECK_FAILS,
        -:  110:    NON_FATAL_IF_SANITY_CHECK_FAILS
        -:  111:  };
        -:  112:
        -:  113:
        -:  114:int
    #####:  115:get_current_dirfd (void)
        -:  116:{
    #####:  117:  return AT_FDCWD;
        -:  118:}
        -:  119:
        -:  120:
        -:  121:int
        4:  122:main (int argc, char **argv)
        -:  123:{
        -:  124:  int i;
        4:  125:  int end_of_leading_options = 0; /* First arg after any -H/-L etc. */
        -:  126:  struct predicate *eval_tree;
        -:  127:
        4:  128:  if (argv[0])
        4:  129:    set_program_name (argv[0]);
        -:  130:  else
    #####:  131:    set_program_name ("find");
        -:  132:
        4:  133:  state.exit_status = 0;
        -:  134:
        4:  135:  if (fd_leak_check_is_enabled ())
        -:  136:    {
        4:  137:      remember_non_cloexec_fds ();
        -:  138:    }
        -:  139:
        4:  140:  record_initial_cwd ();
        -:  141:
        4:  142:  state.already_issued_stat_error_msg = false;
        4:  143:  state.shared_files = sharefile_init ("w");
        4:  144:  if (NULL == state.shared_files)
        -:  145:    {
    #####:  146:      error (EXIT_FAILURE, errno,
        -:  147:	     _("Failed initialise shared-file hash table"));
        -:  148:    }
        -:  149:
        -:  150:  /* Set the option defaults before we do the locale
        -:  151:   * initialisation as check_nofollow () needs to be executed in the
        -:  152:   * POSIX locale.
        -:  153:   */
        4:  154:  set_option_defaults (&options);
        -:  155:
        -:  156:#ifdef HAVE_SETLOCALE
        4:  157:  setlocale (LC_ALL, "");
        -:  158:#endif
        -:  159:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  160:  textdomain (PACKAGE);
        4:  161:  atexit (close_stdin);
        -:  162:
        -:  163:  /* Check for -P, -H or -L options. */
        4:  164:  end_of_leading_options = process_leading_options (argc, argv);
        -:  165:
        4:  166:  if (options.debug_options & DebugStat)
    #####:  167:    options.xstat = debug_stat;
        -:  168:
        -:  169:#ifdef DEBUG
        -:  170:  fprintf (stderr, "cur_day_start = %s", ctime (&options.cur_day_start));
        -:  171:#endif /* DEBUG */
        -:  172:
        -:  173:  /* state.cwd_dir_fd has to be initialised before we call build_expression_tree ()
        -:  174:   * because command-line parsing may lead us to stat some files.
        -:  175:   */
        4:  176:  state.cwd_dir_fd = AT_FDCWD;
        -:  177:
        -:  178:  /* We are now processing the part of the "find" command line
        -:  179:   * after the -H/-L options (if any).
        -:  180:   */
        4:  181:  eval_tree = build_expression_tree (argc, argv, end_of_leading_options);
        -:  182:
        -:  183:
        -:  184:  /* safely_chdir () needs to check that it has ended up in the right place.
        -:  185:   * To avoid bailing out when something gets automounted, it checks if
        -:  186:   * the target directory appears to have had a directory mounted on it as
        -:  187:   * we chdir ()ed.  The problem with this is that in order to notice that
        -:  188:   * a file system was mounted, we would need to lstat () all the mount points.
        -:  189:   * That strategy loses if our machine is a client of a dead NFS server.
        -:  190:   *
        -:  191:   * Hence if safely_chdir () and wd_sanity_check () can manage without needing
        -:  192:   * to know the mounted device list, we do that.
        -:  193:   */
        4:  194:  if (!options.open_nofollow_available)
        -:  195:    {
        -:  196:#ifdef STAT_MOUNTPOINTS
        -:  197:      init_mounted_dev_list (0);
        -:  198:#endif
        -:  199:    }
        -:  200:
        -:  201:
        4:  202:  set_stat_placeholders (&starting_stat_buf);
        4:  203:  if ((*options.xstat) (".", &starting_stat_buf) != 0)
    #####:  204:    error (EXIT_FAILURE, errno, _("cannot stat current directory"));
        -:  205:
        -:  206:  /* If no paths are given, default to ".".  */
       12:  207:  for (i = end_of_leading_options; i < argc && !looks_like_expression (argv[i], true); i++)
        -:  208:    {
        8:  209:      process_top_path (argv[i], 0);
        -:  210:    }
        -:  211:
        -:  212:  /* If there were no path arguments, default to ".". */
        4:  213:  if (i == end_of_leading_options)
        -:  214:    {
        -:  215:      /*
        -:  216:       * We use a temporary variable here because some actions modify
        -:  217:       * the path temporarily.  Hence if we use a string constant,
        -:  218:       * we get a coredump.  The best example of this is if we say
        -:  219:       * "find -printf %H" (note, not "find . -printf %H").
        -:  220:       */
    #####:  221:      char defaultpath[2] = ".";
    #####:  222:      process_top_path (defaultpath, 0);
        -:  223:    }
        -:  224:
        -:  225:  /* If "-exec ... {} +" has been used, there may be some
        -:  226:   * partially-full command lines which have been built,
        -:  227:   * but which are not yet complete.   Execute those now.
        -:  228:   */
        4:  229:  show_success_rates (eval_tree);
        4:  230:  cleanup ();
        4:  231:  return state.exit_status;
        -:  232:}
        -:  233:
    #####:  234:bool is_fts_enabled (int *ftsoptions)
        -:  235:{
        -:  236:  /* this version of find (i.e. this main ()) does not use fts. */
    #####:  237:  *ftsoptions = 0;
    #####:  238:  return false;
        -:  239:}
        -:  240:
        -:  241:
        -:  242:static char *
    #####:  243:specific_dirname (const char *dir)
        -:  244:{
        -:  245:  char dirbuf[1024];
        -:  246:
    #####:  247:  if (0 == strcmp (".", dir))
        -:  248:    {
        -:  249:      /* OK, what's '.'? */
    #####:  250:      if (NULL != getcwd (dirbuf, sizeof (dirbuf)))
        -:  251:	{
    #####:  252:	  return strdup (dirbuf);
        -:  253:	}
        -:  254:      else
        -:  255:	{
    #####:  256:	  return strdup (dir);
        -:  257:	}
        -:  258:    }
        -:  259:  else
        -:  260:    {
    #####:  261:      char *result = canonicalize_filename_mode (dir, CAN_EXISTING);
    #####:  262:      if (NULL == result)
    #####:  263:	return strdup (dir);
        -:  264:      else
    #####:  265:	return result;
        -:  266:    }
        -:  267:}
        -:  268:
        -:  269:
        -:  270:
        -:  271:/* Return non-zero if FS is the name of a file system that is likely to
        -:  272: * be automounted
        -:  273: */
        -:  274:static int
    #####:  275:fs_likely_to_be_automounted (const char *fs)
        -:  276:{
    #####:  277:  return ( (0==strcmp (fs, "nfs")) || (0==strcmp (fs, "autofs")) || (0==strcmp (fs, "subfs")));
        -:  278:}
        -:  279:
        -:  280:
        -:  281:
        -:  282:#ifdef STAT_MOUNTPOINTS
        -:  283:static dev_t *mounted_devices = NULL;
        -:  284:static size_t num_mounted_devices = 0u;
        -:  285:
        -:  286:
        -:  287:static void
        -:  288:init_mounted_dev_list (int mandatory)
        -:  289:{
        -:  290:  assert (NULL == mounted_devices);
        -:  291:  assert (0 == num_mounted_devices);
        -:  292:  mounted_devices = get_mounted_devices (&num_mounted_devices);
        -:  293:  if (mandatory && (NULL == mounted_devices))
        -:  294:    {
        -:  295:      error (EXIT_FAILURE, 0, _("Cannot read list of mounted devices."));
        -:  296:    }
        -:  297:}
        -:  298:
        -:  299:static void
        -:  300:refresh_mounted_dev_list (void)
        -:  301:{
        -:  302:  if (mounted_devices)
        -:  303:    {
        -:  304:      free (mounted_devices);
        -:  305:      mounted_devices = 0;
        -:  306:    }
        -:  307:  num_mounted_devices = 0u;
        -:  308:  init_mounted_dev_list (1);
        -:  309:}
        -:  310:
        -:  311:
        -:  312:/* Search for device DEV in the array LIST, which is of size N. */
        -:  313:static int
        -:  314:dev_present (dev_t dev, const dev_t *list, size_t n)
        -:  315:{
        -:  316:  if (list)
        -:  317:    {
        -:  318:      while (n-- > 0u)
        -:  319:	{
        -:  320:	  if ( (*list++) == dev )
        -:  321:	    return 1;
        -:  322:	}
        -:  323:    }
        -:  324:  return 0;
        -:  325:}
        -:  326:
        -:  327:enum MountPointStateChange
        -:  328:  {
        -:  329:    MountPointRecentlyMounted,
        -:  330:    MountPointRecentlyUnmounted,
        -:  331:    MountPointStateUnchanged
        -:  332:  };
        -:  333:
        -:  334:
        -:  335:
        -:  336:static enum MountPointStateChange
        -:  337:get_mount_state (dev_t newdev)
        -:  338:{
        -:  339:  int new_is_present, new_was_present;
        -:  340:
        -:  341:  new_was_present = dev_present (newdev, mounted_devices, num_mounted_devices);
        -:  342:  refresh_mounted_dev_list ();
        -:  343:  new_is_present  = dev_present (newdev, mounted_devices, num_mounted_devices);
        -:  344:
        -:  345:  if (new_was_present == new_is_present)
        -:  346:    return MountPointStateUnchanged;
        -:  347:  else if (new_is_present)
        -:  348:    return MountPointRecentlyMounted;
        -:  349:  else
        -:  350:    return MountPointRecentlyUnmounted;
        -:  351:}
        -:  352:
        -:  353:
        -:  354:
        -:  355:/* We stat()ed a directory, chdir()ed into it (we know this
        -:  356: * since direction is TraversingDown), stat()ed it again,
        -:  357: * and noticed that the device numbers are different.  Check
        -:  358: * if the file system was recently mounted.
        -:  359: *
        -:  360: * If it was, it looks like chdir()ing into the directory
        -:  361: * caused a file system to be mounted.  Maybe automount is
        -:  362: * running.  Anyway, that's probably OK - but it happens
        -:  363: * only when we are moving downward.
        -:  364: *
        -:  365: * We also allow for the possibility that a similar thing
        -:  366: * has happened with the unmounting of a file system.  This
        -:  367: * is much rarer, as it relies on an automounter timeout
        -:  368: * occurring at exactly the wrong moment.
        -:  369: */
        -:  370:static enum WdSanityCheckFatality
        -:  371:dirchange_is_fatal (const char *specific_what,
        -:  372:		    enum WdSanityCheckFatality isfatal,
        -:  373:		    int silent,
        -:  374:		    struct stat *newinfo)
        -:  375:{
        -:  376:  enum MountPointStateChange transition = get_mount_state (newinfo->st_dev);
        -:  377:  switch (transition)
        -:  378:    {
        -:  379:    case MountPointRecentlyUnmounted:
        -:  380:      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
        -:  381:      if (!silent)
        -:  382:	{
        -:  383:	  error (0, 0,
        -:  384:		 _("WARNING: file system %s has recently been unmounted."),
        -:  385:		 safely_quote_err_filename (0, specific_what));
        -:  386:	}
        -:  387:      break;
        -:  388:
        -:  389:    case MountPointRecentlyMounted:
        -:  390:      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
        -:  391:      if (!silent)
        -:  392:	{
        -:  393:	  error (0, 0,
        -:  394:		 _("WARNING: file system %s has recently been mounted."),
        -:  395:		 safely_quote_err_filename (0, specific_what));
        -:  396:	}
        -:  397:      break;
        -:  398:
        -:  399:    case MountPointStateUnchanged:
        -:  400:      /* leave isfatal as it is */
        -:  401:      break;
        -:  402:    }
        -:  403:
        -:  404:  return isfatal;
        -:  405:}
        -:  406:
        -:  407:
        -:  408:#endif
        -:  409:
        -:  410:
        -:  411:
        -:  412:/* Examine the results of the stat() of a directory from before we
        -:  413: * entered or left it, with the results of stat()ing it afterward.  If
        -:  414: * these are different, the file system tree has been modified while we
        -:  415: * were traversing it.  That might be an attempt to use a race
        -:  416: * condition to persuade find to do something it didn't intend
        -:  417: * (e.g. an attempt by an ordinary user to exploit the fact that root
        -:  418: * sometimes runs find on the whole file system).  However, this can
        -:  419: * also happen if automount is running (certainly on Solaris).  With
        -:  420: * automount, moving into a directory can cause a file system to be
        -:  421: * mounted there.
        -:  422: *
        -:  423: * To cope sensibly with this, we will raise an error if we see the
        -:  424: * device number change unless we are chdir()ing into a subdirectory,
        -:  425: * and the directory we moved into has been mounted or unmounted "recently".
        -:  426: * Here "recently" means since we started "find" or we last re-read
        -:  427: * the /etc/mnttab file.
        -:  428: *
        -:  429: * If the device number does not change but the inode does, that is a
        -:  430: * problem.
        -:  431: *
        -:  432: * If the device number and inode are both the same, we are happy.
        -:  433: *
        -:  434: * If a file system is (un)mounted as we chdir() into the directory, that
        -:  435: * may mean that we're now examining a section of the file system that might
        -:  436: * have been excluded from consideration (via -prune or -quit for example).
        -:  437: * Hence we print a warning message to indicate that the output of find
        -:  438: * might be inconsistent due to the change in the file system.
        -:  439: */
        -:  440:static bool
    #####:  441:wd_sanity_check (const char *thing_to_stat,
        -:  442:		const char *progname,
        -:  443:		const char *what,
        -:  444:		dev_t old_dev,
        -:  445:		ino_t old_ino,
        -:  446:		struct stat *newinfo,
        -:  447:		int parent,
        -:  448:		int line_no,
        -:  449:		enum TraversalDirection direction,
        -:  450:		enum WdSanityCheckFatality isfatal,
        -:  451:		bool *changed) /* output parameter */
        -:  452:{
        -:  453:  const char *fstype;
    #####:  454:  char *specific_what = NULL;
    #####:  455:  int silent = 0;
    #####:  456:  const char *current_dir = ".";
        -:  457:
    #####:  458:  *changed = false;
        -:  459:
    #####:  460:  set_stat_placeholders (newinfo);
    #####:  461:  if ((*options.xstat) (current_dir, newinfo) != 0)
    #####:  462:    fatal_target_file_error (errno, thing_to_stat);
        -:  463:
    #####:  464:  if (old_dev != newinfo->st_dev)
        -:  465:    {
    #####:  466:      *changed = true;
    #####:  467:      specific_what = specific_dirname (what);
    #####:  468:      fstype = filesystem_type (newinfo, current_dir);
    #####:  469:      silent = fs_likely_to_be_automounted (fstype);
        -:  470:
        -:  471:      /* This condition is rare, so once we are here it is
        -:  472:       * reasonable to perform an expensive computation to
        -:  473:       * determine if we should continue or fail.
        -:  474:       */
    #####:  475:      if (TraversingDown == direction)
        -:  476:	{
        -:  477:#ifdef STAT_MOUNTPOINTS
        -:  478:	  isfatal = dirchange_is_fatal (specific_what,isfatal,silent,newinfo);
        -:  479:#else
    #####:  480:	  isfatal = RETRY_IF_SANITY_CHECK_FAILS;
        -:  481:#endif
        -:  482:	}
        -:  483:
    #####:  484:      switch (isfatal)
        -:  485:	{
        -:  486:	case FATAL_IF_SANITY_CHECK_FAILS:
        -:  487:	  {
    #####:  488:	    fstype = filesystem_type (newinfo, current_dir);
    #####:  489:	    error (EXIT_FAILURE, 0,
        -:  490:		   _("%s%s changed during execution of %s (old device number %ld, new device number %ld, file system type is %s) [ref %ld]"),
        -:  491:		   safely_quote_err_filename (0, specific_what),
        -:  492:		   parent ? "/.." : "",
        -:  493:		   safely_quote_err_filename (1, progname),
        -:  494:		   (long) old_dev,
    #####:  495:		   (long) newinfo->st_dev,
        -:  496:		   fstype,
        -:  497:		   (long)line_no);
        -:  498:	    /*NOTREACHED*/
    #####:  499:	    return false;
        -:  500:	  }
        -:  501:
        -:  502:	case NON_FATAL_IF_SANITY_CHECK_FAILS:
        -:  503:	  {
        -:  504:	    /* Since the device has changed under us, the inode number
        -:  505:	     * will almost certainly also be different. However, we have
        -:  506:	     * already decided that this is not a problem.  Hence we return
        -:  507:	     * without checking the inode number.
        -:  508:	     */
    #####:  509:	    free (specific_what);
    #####:  510:	    return true;
        -:  511:	  }
        -:  512:
        -:  513:	case RETRY_IF_SANITY_CHECK_FAILS:
    #####:  514:	  return false;
        -:  515:	}
        -:  516:    }
        -:  517:
        -:  518:  /* Device number was the same, check if the inode has changed. */
    #####:  519:  if (old_ino != newinfo->st_ino)
        -:  520:    {
    #####:  521:      *changed = true;
    #####:  522:      specific_what = specific_dirname (what);
    #####:  523:      fstype = filesystem_type (newinfo, current_dir);
        -:  524:
    #####:  525:      error ((isfatal == FATAL_IF_SANITY_CHECK_FAILS) ? 1 : 0,
        -:  526:	     0,			/* no relevant errno value */
        -:  527:	     _("%s%s changed during execution of %s "
        -:  528:	       "(old inode number %" PRIuMAX ", new inode number %" PRIuMAX
        -:  529:	       ", file system type is %s) [ref %ld]"),
        -:  530:	     safely_quote_err_filename (0, specific_what),
        -:  531:	     parent ? "/.." : "",
        -:  532:	     safely_quote_err_filename (1, progname),
        -:  533:	     (uintmax_t) old_ino,
        -:  534:	     (uintmax_t) newinfo->st_ino,
        -:  535:	     fstype,
        -:  536:	     (long)line_no);
    #####:  537:      free (specific_what);
    #####:  538:      return false;
        -:  539:    }
        -:  540:
    #####:  541:  return true;
        -:  542:}
        -:  543:
        -:  544:enum SafeChdirStatus
        -:  545:  {
        -:  546:    SafeChdirOK,
        -:  547:    SafeChdirFailSymlink,
        -:  548:    SafeChdirFailNotDir,
        -:  549:    SafeChdirFailStat,
        -:  550:    SafeChdirFailWouldBeUnableToReturn,
        -:  551:    SafeChdirFailChdirFailed,
        -:  552:    SafeChdirFailNonexistent,
        -:  553:    SafeChdirFailDestUnreadable
        -:  554:  };
        -:  555:
        -:  556:/* Safely perform a change in directory.  We do this by calling
        -:  557: * lstat() on the subdirectory, using chdir() to move into it, and
        -:  558: * then lstat()ing ".".  We compare the results of the two stat calls
        -:  559: * to see if they are consistent.  If not, we sound the alarm.
        -:  560: *
        -:  561: * If following_links() is true, we do follow symbolic links.
        -:  562: */
        -:  563:static enum SafeChdirStatus
    #####:  564:safely_chdir_lstat (const char *dest,
        -:  565:		    enum TraversalDirection direction,
        -:  566:		    struct stat *statbuf_dest,
        -:  567:		    enum ChdirSymlinkHandling symlink_follow_option,
        -:  568:		    bool *did_stat)
        -:  569:{
        -:  570:  struct stat statbuf_arrived;
    #####:  571:  int rv, dotfd=-1;
        -:  572:  int saved_errno;		/* specific_dirname() changes errno. */
    #####:  573:  bool rv_set = false;
    #####:  574:  bool statflag = false;
    #####:  575:  int tries = 0;
    #####:  576:  enum WdSanityCheckFatality isfatal = RETRY_IF_SANITY_CHECK_FAILS;
        -:  577:
    #####:  578:  saved_errno = errno = 0;
        -:  579:
    #####:  580:  dotfd = open_cloexec (".", O_RDONLY
        -:  581:#if defined O_LARGEFILE
        -:  582:			|O_LARGEFILE
        -:  583:#endif
        -:  584:			);
        -:  585:
        -:  586:  /* We jump back to here if wd_sanity_check()
        -:  587:   * recoverably triggers an alert.
        -:  588:   */
        -:  589: retry:
    #####:  590:  ++tries;
        -:  591:
    #####:  592:  if (dotfd >= 0)
        -:  593:    {
        -:  594:      /* Stat the directory we're going to. */
    #####:  595:      set_stat_placeholders (statbuf_dest);
    #####:  596:      if (0 == options.xstat (dest, statbuf_dest))
        -:  597:	{
    #####:  598:	  statflag = true;
        -:  599:
        -:  600:#ifdef S_ISLNK
        -:  601:	  /* symlink_follow_option might be set to SymlinkFollowOk, which
        -:  602:	   * would allow us to chdir() into a symbolic link.  This is
        -:  603:	   * only useful for the case where the directory we're
        -:  604:	   * chdir()ing into is the basename of a command line
        -:  605:	   * argument, for example where "foo/bar/baz" is specified on
        -:  606:	   * the command line.  When -P is in effect (the default),
        -:  607:	   * baz will not be followed if it is a symlink, but if bar
        -:  608:	   * is a symlink, it _should_ be followed.  Hence we need the
        -:  609:	   * ability to override the policy set by following_links().
        -:  610:	   */
    #####:  611:	  if (!following_links () && S_ISLNK(statbuf_dest->st_mode))
        -:  612:	    {
        -:  613:	      /* We're not supposed to be following links, but this is
        -:  614:	       * a link.  Check symlink_follow_option to see if we should
        -:  615:	       * make a special exception.
        -:  616:	       */
    #####:  617:	      if (symlink_follow_option == SymlinkFollowOk)
        -:  618:		{
        -:  619:		  /* We need to re-stat() the file so that the
        -:  620:		   * sanity check can pass.
        -:  621:		   */
    #####:  622:		  if (0 != stat (dest, statbuf_dest))
        -:  623:		    {
    #####:  624:		      rv = SafeChdirFailNonexistent;
    #####:  625:		      rv_set = true;
    #####:  626:		      saved_errno = errno;
    #####:  627:		      goto fail;
        -:  628:		    }
    #####:  629:		  statflag = true;
        -:  630:		}
        -:  631:	      else
        -:  632:		{
        -:  633:		  /* Not following symlinks, so the attempt to
        -:  634:		   * chdir() into a symlink should be prevented.
        -:  635:		   */
    #####:  636:		  rv = SafeChdirFailSymlink;
    #####:  637:		  rv_set = true;
    #####:  638:		  saved_errno = 0;	/* silence the error message */
    #####:  639:		  goto fail;
        -:  640:		}
        -:  641:	    }
        -:  642:#endif
        -:  643:#ifdef S_ISDIR
        -:  644:	  /* Although the immediately following chdir() would detect
        -:  645:	   * the fact that this is not a directory for us, this would
        -:  646:	   * result in an extra system call that fails.  Anybody
        -:  647:	   * examining the system-call trace should ideally not be
        -:  648:	   * concerned that something is actually failing.
        -:  649:	   */
    #####:  650:	  if (!S_ISDIR(statbuf_dest->st_mode))
        -:  651:	    {
    #####:  652:	      rv = SafeChdirFailNotDir;
    #####:  653:	      rv_set = true;
    #####:  654:	      saved_errno = 0;	/* silence the error message */
    #####:  655:	      goto fail;
        -:  656:	    }
        -:  657:#endif
        -:  658:
    #####:  659:	  if (options.debug_options & DebugSearch)
    #####:  660:	    fprintf (stderr, "safely_chdir(): chdir(\"%s\")\n", dest);
        -:  661:
    #####:  662:	  if (0 == chdir (dest))
        -:  663:	    {
        -:  664:	      /* check we ended up where we wanted to go */
    #####:  665:	      bool changed = false;
    #####:  666:	      if (!wd_sanity_check (".", program_name, ".",
        -:  667:				    statbuf_dest->st_dev,
        -:  668:				    statbuf_dest->st_ino,
        -:  669:				    &statbuf_arrived,
        -:  670:				    0, __LINE__, direction,
        -:  671:				    isfatal,
        -:  672:				    &changed))
        -:  673:		{
        -:  674:		  /* Only allow one failure. */
    #####:  675:		  if (RETRY_IF_SANITY_CHECK_FAILS == isfatal)
        -:  676:		    {
    #####:  677:		      if (0 == fchdir (dotfd))
        -:  678:			{
    #####:  679:			  isfatal = FATAL_IF_SANITY_CHECK_FAILS;
    #####:  680:			  goto retry;
        -:  681:			}
        -:  682:		      else
        -:  683:			{
        -:  684:			  /* Failed to return to original directory,
        -:  685:			   * but we know that the current working
        -:  686:			   * directory is not the one that we intend
        -:  687:			   * to be in.  Since fchdir() failed, we
        -:  688:			   * can't recover from this and so this error
        -:  689:			   * is fatal.
        -:  690:			   */
    #####:  691:			  error (EXIT_FAILURE, errno,
        -:  692:				 _("failed to return to parent directory"));
        -:  693:			}
        -:  694:		    }
        -:  695:		  else
        -:  696:		    {
        -:  697:		      /* XXX: not sure what to use as an excuse here. */
    #####:  698:		      rv = SafeChdirFailNonexistent;
    #####:  699:		      rv_set = true;
    #####:  700:		      saved_errno = 0;
    #####:  701:		      goto fail;
        -:  702:		    }
        -:  703:		}
        -:  704:
    #####:  705:	      close (dotfd);
    #####:  706:	      return SafeChdirOK;
        -:  707:	    }
        -:  708:	  else
        -:  709:	    {
    #####:  710:	      saved_errno = errno;
    #####:  711:	      if (ENOENT == saved_errno)
        -:  712:		{
    #####:  713:		  rv = SafeChdirFailNonexistent;
    #####:  714:		  rv_set = true;
    #####:  715:		  if (options.ignore_readdir_race)
    #####:  716:		    errno = 0;	/* don't issue err msg */
        -:  717:		}
    #####:  718:	      else if (ENOTDIR == saved_errno)
        -:  719:		{
        -:  720:		  /* This can happen if the we stat a directory,
        -:  721:		   * and then file system activity changes it into
        -:  722:		   * a non-directory.
        -:  723:		   */
    #####:  724:		  saved_errno = 0;	/* don't issue err msg */
    #####:  725:		  rv = SafeChdirFailNotDir;
    #####:  726:		  rv_set = true;
        -:  727:		}
        -:  728:	      else
        -:  729:		{
    #####:  730:		  rv = SafeChdirFailChdirFailed;
    #####:  731:		  rv_set = true;
        -:  732:		}
    #####:  733:	      goto fail;
        -:  734:	    }
        -:  735:	}
        -:  736:      else
        -:  737:	{
    #####:  738:	  saved_errno = errno;
    #####:  739:	  rv = SafeChdirFailStat;
    #####:  740:	  rv_set = true;
        -:  741:
    #####:  742:	  if ( (ENOENT == saved_errno) || (0 == state.curdepth))
    #####:  743:	    saved_errno = 0;	/* don't issue err msg */
    #####:  744:	  goto fail;
        -:  745:	}
        -:  746:    }
        -:  747:  else
        -:  748:    {
        -:  749:      /* We do not have read permissions on "." */
    #####:  750:      rv = SafeChdirFailWouldBeUnableToReturn;
    #####:  751:      rv_set = true;
    #####:  752:      goto fail;
        -:  753:    }
        -:  754:
        -:  755:  /* This is the success path, so we clear errno.  The caller probably
        -:  756:   * won't be calling error() anyway.
        -:  757:   */
        -:  758:  saved_errno = 0;
        -:  759:
        -:  760:  /* We use the same exit path for success or failure.
        -:  761:   * which has occurred is recorded in RV.
        -:  762:   */
        -:  763: fail:
        -:  764:  /* We do not call error() as this would result in a duplicate error
        -:  765:   * message when the caller does the same thing.
        -:  766:   */
    #####:  767:  if (saved_errno)
    #####:  768:    errno = saved_errno;
        -:  769:
    #####:  770:  if (dotfd >= 0)
        -:  771:    {
    #####:  772:      close (dotfd);
    #####:  773:      dotfd = -1;
        -:  774:    }
        -:  775:
    #####:  776:  *did_stat = statflag;
    #####:  777:  assert (rv_set);
    #####:  778:  return rv;
        -:  779:}
        -:  780:
        -:  781:#if defined O_NOFOLLOW
        -:  782:/* Safely change working directory to the specified subdirectory.  If
        -:  783: * we are not allowed to follow symbolic links, we use open() with
        -:  784: * O_NOFOLLOW, followed by fchdir().  This ensures that we don't
        -:  785: * follow symbolic links (of course, we do follow them if the -L
        -:  786: * option is in effect).
        -:  787: */
        -:  788:static enum SafeChdirStatus
       28:  789:safely_chdir_nofollow (const char *dest,
        -:  790:		       enum TraversalDirection direction,
        -:  791:		       struct stat *statbuf_dest,
        -:  792:		       enum ChdirSymlinkHandling symlink_follow_option,
        -:  793:		       bool *did_stat)
        -:  794:{
        -:  795:  int extraflags, fd;
        -:  796:
        -:  797:  (void) direction;
        -:  798:  (void) statbuf_dest;
        -:  799:
       28:  800:  extraflags = 0;
       28:  801:  *did_stat = false;
        -:  802:
       28:  803:  switch (symlink_follow_option)
        -:  804:    {
        -:  805:    case SymlinkFollowOk:
        4:  806:      extraflags = 0;
        4:  807:      break;
        -:  808:
        -:  809:    case SymlinkHandleDefault:
       24:  810:      if (following_links ())
    #####:  811:	extraflags = 0;
        -:  812:      else
       24:  813:	extraflags = O_NOFOLLOW;
       24:  814:      break;
        -:  815:    }
        -:  816:
       28:  817:  errno = 0;
       28:  818:  fd = open (dest, O_RDONLY
        -:  819:#if defined O_LARGEFILE
        -:  820:	    |O_LARGEFILE
        -:  821:#endif
        -:  822:#if defined O_CLOEXEC
        -:  823:	    |O_CLOEXEC
        -:  824:#endif
        -:  825:	    |extraflags);
       28:  826:  if (fd < 0)
        -:  827:    {
    #####:  828:      switch (errno)
        -:  829:	{
        -:  830:	case ELOOP:
    #####:  831:	  return SafeChdirFailSymlink; /* This is why we use O_NOFOLLOW */
        -:  832:	case ENOENT:
    #####:  833:	  return SafeChdirFailNonexistent;
        -:  834:	default:
    #####:  835:	  return SafeChdirFailDestUnreadable;
        -:  836:	}
        -:  837:    }
        -:  838:
       28:  839:  errno = 0;
       28:  840:  if (0 == fchdir (fd))
        -:  841:    {
       28:  842:      close (fd);
       28:  843:      return SafeChdirOK;
        -:  844:    }
        -:  845:  else
        -:  846:    {
    #####:  847:      int saved_errno = errno;
    #####:  848:      close (fd);
    #####:  849:      errno = saved_errno;
        -:  850:
    #####:  851:      switch (errno)
        -:  852:	{
        -:  853:	case ENOTDIR:
    #####:  854:	  return SafeChdirFailNotDir;
        -:  855:
        -:  856:	case EACCES:
        -:  857:	case EBADF:		/* Shouldn't happen */
        -:  858:	case EINTR:
        -:  859:	case EIO:
        -:  860:	default:
    #####:  861:	  return SafeChdirFailChdirFailed;
        -:  862:	}
        -:  863:    }
        -:  864:}
        -:  865:#endif
        -:  866:
        -:  867:static enum SafeChdirStatus
       28:  868:safely_chdir (const char *dest,
        -:  869:	      enum TraversalDirection direction,
        -:  870:	      struct stat *statbuf_dest,
        -:  871:	      enum ChdirSymlinkHandling symlink_follow_option,
        -:  872:	      bool *did_stat)
        -:  873:{
        -:  874:  enum SafeChdirStatus result;
        -:  875:
        -:  876:  /* We're about to leave a directory.  If there are any -execdir
        -:  877:   * argument lists which have been built but have not yet been
        -:  878:   * processed, do them now because they must be done in the same
        -:  879:   * directory.
        -:  880:   */
       28:  881:  complete_pending_execdirs ();
        -:  882:
        -:  883:#if !defined(O_NOFOLLOW)
        -:  884:  options.open_nofollow_available = false;
        -:  885:#endif
       28:  886:  if (options.open_nofollow_available)
        -:  887:    {
       28:  888:      result = safely_chdir_nofollow (dest, direction, statbuf_dest,
        -:  889:				     symlink_follow_option, did_stat);
       28:  890:      if (SafeChdirFailDestUnreadable != result)
        -:  891:	{
       28:  892:	  return result;
        -:  893:	}
        -:  894:      else
        -:  895:	{
        -:  896:	  /* Savannah bug #15384: fall through to use safely_chdir_lstat
        -:  897:	   * if the directory is not readable.
        -:  898:	   */
        -:  899:	  /* Do nothing. */
        -:  900:	}
        -:  901:    }
        -:  902:  /* Even if O_NOFOLLOW is available, we may need to use the alternative
        -:  903:   * method, since parent of the start point may be executable but not
        -:  904:   * readable.
        -:  905:   */
    #####:  906:  return safely_chdir_lstat (dest, direction, statbuf_dest,
        -:  907:			     symlink_follow_option, did_stat);
        -:  908:}
        -:  909:
        -:  910:
        -:  911:
        -:  912:/* Safely go back to the starting directory. */
        -:  913:static void
        8:  914:chdir_back (void)
        -:  915:{
        8:  916:  if (options.debug_options & DebugSearch)
    #####:  917:    fprintf (stderr, "chdir_back(): chdir to start point\n");
        -:  918:
        8:  919:  restore_cwd (initial_wd);
        8:  920:}
        -:  921:
        -:  922:/* Move to the parent of a given directory and then call a function,
        -:  923: * restoring the cwd.  Don't bother changing directory if the
        -:  924: * specified directory is a child of "." or is the root directory.
        -:  925: */
        -:  926:static void
        8:  927:at_top (char *pathname,
        -:  928:	mode_t mode,
        -:  929:	struct stat *pstat,
        -:  930:	void (*action)(char *pathname,
        -:  931:		       char *basename,
        -:  932:		       int mode,
        -:  933:		       struct stat *pstat))
        -:  934:{
        -:  935:  int dirchange;
        8:  936:  char *parent_dir = dir_name (pathname);
        8:  937:  char *base = last_component (pathname);
        -:  938:
        8:  939:  state.curdepth = 0;
        8:  940:  state.starting_path_length = strlen (pathname);
        -:  941:
        8:  942:  if (0 == *base
        8:  943:      || 0 == strcmp (parent_dir, "."))
        -:  944:    {
        4:  945:      dirchange = 0;
        4:  946:      base = pathname;
        -:  947:    }
        -:  948:  else
        -:  949:    {
        -:  950:      enum TraversalDirection direction;
        -:  951:      enum SafeChdirStatus chdir_status;
        -:  952:      struct stat st;
        4:  953:      bool did_stat = false;
        -:  954:
        4:  955:      dirchange = 1;
        4:  956:      if (0 == strcmp (base, ".."))
    #####:  957:	direction = TraversingUp;
        -:  958:      else
        4:  959:	direction = TraversingDown;
        -:  960:
        -:  961:      /* We pass SymlinkFollowOk to safely_chdir(), which allows it to
        -:  962:       * chdir() into a symbolic link.  This is only useful for the
        -:  963:       * case where the directory we're chdir()ing into is the
        -:  964:       * basename of a command line argument, for example where
        -:  965:       * "foo/bar/baz" is specified on the command line.  When -P is
        -:  966:       * in effect (the default), baz will not be followed if it is a
        -:  967:       * symlink, but if bar is a symlink, it _should_ be followed.
        -:  968:       * Hence we need the ability to override the policy set by
        -:  969:       * following_links().
        -:  970:       */
        4:  971:      chdir_status = safely_chdir (parent_dir, direction, &st, SymlinkFollowOk, &did_stat);
        4:  972:      if (SafeChdirOK != chdir_status)
        -:  973:	{
    #####:  974:	  const char *what = (SafeChdirFailWouldBeUnableToReturn == chdir_status) ? "." : parent_dir;
    #####:  975:	  if (errno)
    #####:  976:	    error (0, errno, "%s",
        -:  977:		   safely_quote_err_filename (0, what));
        -:  978:	  else
    #####:  979:	    error (0, 0, _("Failed to safely change directory into %s"),
        -:  980:		   safely_quote_err_filename (0, parent_dir));
        -:  981:
        -:  982:	  /* We can't process this command-line argument. */
    #####:  983:	  state.exit_status = 1;
        8:  984:	  return;
        -:  985:	}
        -:  986:    }
        -:  987:
        8:  988:  free (parent_dir);
        8:  989:  parent_dir = NULL;
        -:  990:
        8:  991:  action (pathname, base, mode, pstat);
        -:  992:
        8:  993:  if (dirchange)
        -:  994:    {
        4:  995:      chdir_back ();
        -:  996:    }
        -:  997:}
        -:  998:
        -:  999:
        8: 1000:static void do_process_top_dir (char *pathname,
        -: 1001:				char *base,
        -: 1002:				int mode,
        -: 1003:				struct stat *pstat)
        -: 1004:{
        -: 1005:  (void) pstat;
        -: 1006:
        8: 1007:  process_path (pathname, base, false, ".", mode);
        8: 1008:  complete_pending_execdirs ();
        8: 1009:}
        -: 1010:
        -: 1011:static void
    #####: 1012:do_process_predicate (char *pathname,
        -: 1013:		      char *base,
        -: 1014:		      int mode,
        -: 1015:		      struct stat *pstat)
        -: 1016:{
        -: 1017:  (void) mode;
        -: 1018:
    #####: 1019:  state.rel_pathname = base;	/* cwd_dir_fd was already set by safely_chdir */
    #####: 1020:  apply_predicate (pathname, pstat, get_eval_tree ());
    #####: 1021:}
        -: 1022:
        -: 1023:
        -: 1024:
        -: 1025:
        -: 1026:/* Descend PATHNAME, which is a command-line argument.
        -: 1027:
        -: 1028:   Actions like -execdir assume that we are in the
        -: 1029:   parent directory of the file we're examining,
        -: 1030:   and on entry to this function our working directory
        -: 1031:   is whatever it was when find was invoked.  Therefore
        -: 1032:   If PATHNAME is "." we just leave things as they are.
        -: 1033:   Otherwise, we figure out what the parent directory is,
        -: 1034:   and move to that.
        -: 1035:*/
        -: 1036:static void
        8: 1037:process_top_path (char *pathname, mode_t mode)
        -: 1038:{
        8: 1039:  at_top (pathname, mode, NULL, do_process_top_dir);
        8: 1040:}
        -: 1041:
        -: 1042:
        -: 1043:/* Info on each directory in the current tree branch, to avoid
        -: 1044:   getting stuck in symbolic link loops.  */
        -: 1045:static struct dir_id *dir_ids = NULL;
        -: 1046:/* Entries allocated in `dir_ids'.  */
        -: 1047:static int dir_alloc = 0;
        -: 1048:/* Index in `dir_ids' of directory currently being searched.
        -: 1049:   This is always the last valid entry.  */
        -: 1050:static int dir_curr = -1;
        -: 1051:/* (Arbitrary) number of entries to grow `dir_ids' by.  */
        -: 1052:#define DIR_ALLOC_STEP 32
        -: 1053:
        -: 1054:
        -: 1055:
        -: 1056:/* We've detected a file system loop.   This is caused by one of
        -: 1057: * two things:
        -: 1058: *
        -: 1059: * 1. Option -L is in effect and we've hit a symbolic link that
        -: 1060: *    points to an ancestor.  This is harmless.  We won't traverse the
        -: 1061: *    symbolic link.
        -: 1062: *
        -: 1063: * 2. We have hit a real cycle in the directory hierarchy.  In this
        -: 1064: *    case, we issue a diagnostic message (POSIX requires this) and we
        -: 1065: *    skip that directory entry.
        -: 1066: */
        -: 1067:static void
    #####: 1068:issue_loop_warning (const char *name, const char *pathname, int level)
        -: 1069:{
        -: 1070:  struct stat stbuf_link;
    #####: 1071:  if (lstat (name, &stbuf_link) != 0)
    #####: 1072:    stbuf_link.st_mode = S_IFREG;
        -: 1073:
    #####: 1074:  if (S_ISLNK(stbuf_link.st_mode))
        -: 1075:    {
    #####: 1076:      error (0, 0,
        -: 1077:	     _("Symbolic link %s is part of a loop in the directory hierarchy; we have already visited the directory to which it points."),
        -: 1078:	     safely_quote_err_filename (0, pathname));
        -: 1079:      /* XXX: POSIX appears to require that the exit status be non-zero if a
        -: 1080:       * diagnostic is issued.
        -: 1081:       */
        -: 1082:    }
        -: 1083:  else
        -: 1084:    {
    #####: 1085:      int distance = 1 + (dir_curr-level);
        -: 1086:      /* We have found an infinite loop.  POSIX requires us to
        -: 1087:       * issue a diagnostic.  Usually we won't get to here
        -: 1088:       * because when the leaf optimisation is on, it will cause
        -: 1089:       * the subdirectory to be skipped.  If /a/b/c/d is a hard
        -: 1090:       * link to /a/b, then the link count of /a/b/c is 2,
        -: 1091:       * because the ".." entry of /b/b/c/d points to /a, not
        -: 1092:       * to /a/b/c.
        -: 1093:       */
    #####: 1094:      error (0, 0,
        -: 1095:	     ngettext (
        -: 1096:		       "Filesystem loop detected; %s has the same device number and inode as "
        -: 1097:		       "a directory which is %d level higher in the file system hierarchy",
        -: 1098:		       "Filesystem loop detected; %s has the same device number and inode as "
        -: 1099:		       "a directory which is %d levels higher in the file system hierarchy",
        -: 1100:		       (long)distance),
        -: 1101:	     safely_quote_err_filename (0, pathname),
        -: 1102:	     distance);
        -: 1103:    }
    #####: 1104:}
        -: 1105:
        -: 1106:
        -: 1107:
        -: 1108:/* Recursively descend path PATHNAME, applying the predicates.
        -: 1109:   LEAF is true if PATHNAME is known to be in a directory that has no
        -: 1110:   more unexamined subdirectories, and therefore it is not a directory.
        -: 1111:   Knowing this allows us to avoid calling stat as long as possible for
        -: 1112:   leaf files.
        -: 1113:
        -: 1114:   NAME is PATHNAME relative to the current directory.  We access NAME
        -: 1115:   but print PATHNAME.
        -: 1116:
        -: 1117:   PARENT is the path of the parent of NAME, relative to find's
        -: 1118:   starting directory.
        -: 1119:
        -: 1120:   Return nonzero iff PATHNAME is a directory. */
        -: 1121:
        -: 1122:static int
       20: 1123:process_path (char *pathname, char *name, bool leaf, char *parent,
        -: 1124:	      mode_t mode)
        -: 1125:{
        -: 1126:  struct stat stat_buf;
        -: 1127:  static dev_t root_dev;	/* Device ID of current argument pathname. */
        -: 1128:  int i;
        -: 1129:  struct predicate *eval_tree;
        -: 1130:
       20: 1131:  eval_tree = get_eval_tree ();
        -: 1132:  /* Assume it is a non-directory initially. */
       20: 1133:  stat_buf.st_mode = 0;
       20: 1134:  state.rel_pathname = name;
       20: 1135:  state.type = 0;
       20: 1136:  state.have_stat = false;
       20: 1137:  state.have_type = false;
       20: 1138:  state.already_issued_stat_error_msg = false;
        -: 1139:
       20: 1140:  if (!digest_mode (&mode, pathname, name, &stat_buf, leaf))
    #####: 1141:    return 0;
        -: 1142:
       20: 1143:  if (!S_ISDIR (state.type))
        -: 1144:    {
        8: 1145:      if (state.curdepth >= options.mindepth)
        8: 1146:	apply_predicate (pathname, &stat_buf, eval_tree);
        8: 1147:      return 0;
        -: 1148:    }
        -: 1149:
        -: 1150:  /* From here on, we're working on a directory.  */
        -: 1151:
        -: 1152:
        -: 1153:  /* Now we really need to stat the directory, even if we know the
        -: 1154:   * type, because we need information like struct stat.st_rdev.
        -: 1155:   */
       12: 1156:  if (get_statinfo (pathname, name, &stat_buf) != 0)
    #####: 1157:    return 0;
        -: 1158:
       12: 1159:  state.have_stat = true;
       12: 1160:  mode = state.type = stat_buf.st_mode;	/* use full info now that we have it. */
       12: 1161:  state.stop_at_current_level =
       12: 1162:    options.maxdepth >= 0
       12: 1163:    && state.curdepth >= options.maxdepth;
        -: 1164:
        -: 1165:  /* If we've already seen this directory on this branch,
        -: 1166:     don't descend it again.  */
       20: 1167:  for (i = 0; i <= dir_curr; i++)
        8: 1168:    if (stat_buf.st_ino == dir_ids[i].ino &&
    #####: 1169:	stat_buf.st_dev == dir_ids[i].dev)
        -: 1170:      {
    #####: 1171:	state.stop_at_current_level = true;
    #####: 1172:	issue_loop_warning (name, pathname, i);
        -: 1173:      }
        -: 1174:
       12: 1175:  if (dir_alloc <= ++dir_curr)
        -: 1176:    {
        4: 1177:      dir_alloc += DIR_ALLOC_STEP;
        4: 1178:      dir_ids = (struct dir_id *)
        4: 1179:	xrealloc ((char *) dir_ids, dir_alloc * sizeof (struct dir_id));
        -: 1180:    }
       12: 1181:  dir_ids[dir_curr].ino = stat_buf.st_ino;
       12: 1182:  dir_ids[dir_curr].dev = stat_buf.st_dev;
        -: 1183:
       12: 1184:  if (options.stay_on_filesystem)
        -: 1185:    {
    #####: 1186:      if (state.curdepth == 0)
    #####: 1187:	root_dev = stat_buf.st_dev;
    #####: 1188:      else if (stat_buf.st_dev != root_dev)
    #####: 1189:	state.stop_at_current_level = true;
        -: 1190:    }
        -: 1191:
       12: 1192:  if (options.do_dir_first && state.curdepth >= options.mindepth)
       12: 1193:    apply_predicate (pathname, &stat_buf, eval_tree);
        -: 1194:
       12: 1195:  if (options.debug_options & DebugSearch)
    #####: 1196:    fprintf (stderr, "pathname = %s, stop_at_current_level = %d\n",
    #####: 1197:	     pathname, state.stop_at_current_level);
        -: 1198:
       12: 1199:  if (state.stop_at_current_level == false)
        -: 1200:    {
        -: 1201:      /* Scan directory on disk. */
       12: 1202:      process_dir (pathname, name, strlen (pathname), &stat_buf, parent);
        -: 1203:    }
        -: 1204:
       12: 1205:  if (options.do_dir_first == false && state.curdepth >= options.mindepth)
        -: 1206:    {
        -: 1207:      /* The fields in 'state' are now out of date.  Correct them.
        -: 1208:       */
    #####: 1209:      if (!digest_mode (&mode, pathname, name, &stat_buf, leaf))
    #####: 1210:	return 0;
        -: 1211:
    #####: 1212:      if (0 == dir_curr)
        -: 1213:	{
    #####: 1214:	  at_top (pathname, mode, &stat_buf, do_process_predicate);
        -: 1215:	}
        -: 1216:      else
        -: 1217:	{
    #####: 1218:	  do_process_predicate (pathname, name, mode, &stat_buf);
        -: 1219:	}
        -: 1220:    }
        -: 1221:
       12: 1222:  dir_curr--;
        -: 1223:
       12: 1224:  return 1;
        -: 1225:}
        -: 1226:
        -: 1227:
        -: 1228:/* Scan directory PATHNAME and recurse through process_path for each entry.
        -: 1229:
        -: 1230:   PATHLEN is the length of PATHNAME.
        -: 1231:
        -: 1232:   NAME is PATHNAME relative to the current directory.
        -: 1233:
        -: 1234:   STATP is the results of *options.xstat on it.
        -: 1235:
        -: 1236:   PARENT is the path of the parent of NAME, relative to find's
        -: 1237:   starting directory.  */
        -: 1238:
        -: 1239:static void
       12: 1240:process_dir (char *pathname, char *name, int pathlen, const struct stat *statp, char *parent)
        -: 1241:{
        -: 1242:  int subdirs_left;		/* Number of unexamined subdirs in PATHNAME. */
        -: 1243:  bool subdirs_unreliable;	/* if true, cannot use dir link count as subdir limif (if false, it may STILL be unreliable) */
        -: 1244:  unsigned int idx;		/* Which entry are we on? */
        -: 1245:  struct stat stat_buf;
       12: 1246:  size_t dircount = 0u;
        -: 1247:  struct savedir_dirinfo *dirinfo;
        -: 1248:#if 0
        -: 1249:  printf ("process_dir: pathname=%s name=%s statp->st_nlink=%d st_ino=%d\n",
        -: 1250:	  pathname,
        -: 1251:	  name,
        -: 1252:	  (int)statp->st_nlink,
        -: 1253:	  (int)statp->st_ino);
        -: 1254:#endif
       12: 1255:  if (statp->st_nlink < 2)
        -: 1256:    {
    #####: 1257:      subdirs_unreliable = true;
    #####: 1258:      subdirs_left = 0;
        -: 1259:    }
        -: 1260:  else
        -: 1261:    {
       12: 1262:      subdirs_unreliable = false; /* not necessarily right */
       12: 1263:      subdirs_left = statp->st_nlink - 2; /* Account for name and ".". */
        -: 1264:    }
        -: 1265:
       12: 1266:  errno = 0;
       12: 1267:  dirinfo = xsavedir (name, 0);
        -: 1268:
        -: 1269:
       12: 1270:  if (dirinfo == NULL)
        -: 1271:    {
    #####: 1272:      assert (errno != 0);
    #####: 1273:      error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####: 1274:      state.exit_status = 1;
        -: 1275:    }
        -: 1276:  else
        -: 1277:    {
        -: 1278:      register char *namep;	/* Current point in `name_space'. */
        -: 1279:      char *cur_path;		/* Full path of each file to process. */
        -: 1280:      char *cur_name;		/* Base name of each file to process. */
        -: 1281:      unsigned cur_path_size;	/* Bytes allocated for `cur_path'. */
        -: 1282:      register unsigned file_len; /* Length of each path to process. */
        -: 1283:      register unsigned pathname_len; /* PATHLEN plus trailing '/'. */
       12: 1284:      bool did_stat = false;
        -: 1285:
       12: 1286:      if (pathname[pathlen - 1] == '/')
    #####: 1287:	pathname_len = pathlen + 1; /* For '\0'; already have '/'. */
        -: 1288:      else
       12: 1289:	pathname_len = pathlen + 2; /* For '/' and '\0'. */
       12: 1290:      cur_path_size = 0;
       12: 1291:      cur_path = NULL;
        -: 1292:
        -: 1293:      /* We're about to leave the directory.  If there are any
        -: 1294:       * -execdir argument lists which have been built but have not
        -: 1295:       * yet been processed, do them now because they must be done in
        -: 1296:       * the same directory.
        -: 1297:       */
       12: 1298:      complete_pending_execdirs ();
        -: 1299:
       12: 1300:      if (strcmp (name, "."))
        -: 1301:	{
       12: 1302:	  enum SafeChdirStatus status = safely_chdir (name, TraversingDown, &stat_buf, SymlinkHandleDefault, &did_stat);
       12: 1303:	  switch (status)
        -: 1304:	    {
        -: 1305:	    case SafeChdirOK:
        -: 1306:	      /* If there had been a change but wd_sanity_check()
        -: 1307:	       * accepted it, we need to accept that on the
        -: 1308:	       * way back up as well, so modify our record
        -: 1309:	       * of what we think we should see later.
        -: 1310:	       * If there was no change, the assignments are a no-op.
        -: 1311:	       *
        -: 1312:	       * However, before performing the assignment, we need to
        -: 1313:	       * check that we have the stat information.   If O_NOFOLLOW
        -: 1314:	       * is available, safely_chdir() will not have needed to use
        -: 1315:	       * stat(), and so stat_buf will just contain random data.
        -: 1316:	       */
       12: 1317:	      if (!did_stat)
        -: 1318:		{
        -: 1319:		  /* If there is a link we need to follow it.  Hence
        -: 1320:		   * the direct call to stat() not through (options.xstat)
        -: 1321:		   */
       12: 1322:		  set_stat_placeholders (&stat_buf);
       12: 1323:		  if (0 != stat (".", &stat_buf))
    #####: 1324:		    break;	/* skip the assignment. */
        -: 1325:		}
       12: 1326:	      dir_ids[dir_curr].dev = stat_buf.st_dev;
       12: 1327:	      dir_ids[dir_curr].ino = stat_buf.st_ino;
        -: 1328:
       12: 1329:	      break;
        -: 1330:
        -: 1331:	    case SafeChdirFailWouldBeUnableToReturn:
    #####: 1332:	      error (0, errno, ".");
    #####: 1333:	      state.exit_status = 1;
    #####: 1334:	      break;
        -: 1335:
        -: 1336:	    case SafeChdirFailNonexistent:
        -: 1337:	    case SafeChdirFailDestUnreadable:
        -: 1338:	    case SafeChdirFailStat:
        -: 1339:	    case SafeChdirFailNotDir:
        -: 1340:	    case SafeChdirFailChdirFailed:
    #####: 1341:	      error (0, errno, "%s",
        -: 1342:		     safely_quote_err_filename (0, pathname));
    #####: 1343:	      state.exit_status = 1;
    #####: 1344:	      return;
        -: 1345:
        -: 1346:	    case SafeChdirFailSymlink:
    #####: 1347:	      error (0, 0,
        -: 1348:		     _("warning: not following the symbolic link %s"),
        -: 1349:		     safely_quote_err_filename (0, pathname));
    #####: 1350:	      state.exit_status = 1;
    #####: 1351:	      return;
        -: 1352:	    }
        -: 1353:	}
        -: 1354:
       24: 1355:      for (idx=0; idx < dirinfo->size; ++idx)
        -: 1356:	{
        -: 1357:	  /* savedirinfo() may return dirinfo=NULL if extended information
        -: 1358:	   * is not available.
        -: 1359:	   */
       24: 1360:	  mode_t mode = (dirinfo->entries[idx].flags & SavedirHaveFileType) ?
       12: 1361:	    dirinfo->entries[idx].type_info : 0;
       12: 1362:	  namep = dirinfo->entries[idx].name;
        -: 1363:
        -: 1364:	  /* Append this directory entry's name to the path being searched. */
       12: 1365:	  file_len = pathname_len + strlen (namep);
       12: 1366:	  if (file_len > cur_path_size)
        -: 1367:	    {
       12: 1368:	      while (file_len > cur_path_size)
        4: 1369:		cur_path_size += 1024;
        4: 1370:	      free (cur_path);
        4: 1371:	      cur_path = xmalloc (cur_path_size);
        4: 1372:	      strcpy (cur_path, pathname);
        4: 1373:	      cur_path[pathname_len - 2] = '/';
        -: 1374:	    }
       12: 1375:	  cur_name = cur_path + pathname_len - 1;
       12: 1376:	  strcpy (cur_name, namep);
        -: 1377:
       12: 1378:	  state.curdepth++;
       12: 1379:	  if (!options.no_leaf_check && !subdirs_unreliable)
        -: 1380:	    {
       12: 1381:	      if (mode && S_ISDIR(mode) && (subdirs_left == 0))
        -: 1382:		{
        -: 1383:		  /* This is a subdirectory, but the number of directories we
        -: 1384:		   * have found now exceeds the number we would expect given
        -: 1385:		   * the hard link count on the parent.   This is likely to be
        -: 1386:		   * a bug in the file system driver (e.g. Linux's
        -: 1387:		   * /proc file system) or may just be a fact that the OS
        -: 1388:		   * doesn't really handle hard links with Unix semantics.
        -: 1389:		   * In the latter case, -noleaf should be used routinely.
        -: 1390:		   */
    #####: 1391:		  error (0, 0, _("WARNING: Hard link count is wrong for %s (saw only st_nlink=%" PRIuMAX  " but we already saw %" PRIuMAX " subdirectories): this may be a bug in your file system driver.  Automatically turning on find's -noleaf option.  Earlier results may have failed to include directories that should have been searched."),
        -: 1392:			 safely_quote_err_filename(0, pathname),
        -: 1393:			 (uintmax_t) statp->st_nlink,
        -: 1394:			 (uintmax_t) dircount);
    #####: 1395:		  state.exit_status = 1; /* We know the result is wrong, now */
    #####: 1396:		  options.no_leaf_check = true;	/* Don't make same
        -: 1397:						   mistake again */
    #####: 1398:		  subdirs_unreliable = 1;
    #####: 1399:		  subdirs_left = 1; /* band-aid for this iteration. */
        -: 1400:		}
        -: 1401:
        -: 1402:	      /* Normal case optimization.  On normal Unix
        -: 1403:		 file systems, a directory that has no subdirectories
        -: 1404:		 has two links: its name, and ".".  Any additional
        -: 1405:		 links are to the ".." entries of its subdirectories.
        -: 1406:		 Once we have processed as many subdirectories as
        -: 1407:		 there are additional links, we know that the rest of
        -: 1408:		 the entries are non-directories -- in other words,
        -: 1409:		 leaf files. */
       12: 1410:	      {
        -: 1411:		int count;
       12: 1412:		count = process_path (cur_path, cur_name,
        -: 1413:					    subdirs_left == 0, pathname,
        -: 1414:					    mode);
       12: 1415:		subdirs_left -= count;
       12: 1416:		dircount += count;
        -: 1417:	      }
        -: 1418:	    }
        -: 1419:	  else
        -: 1420:	    {
        -: 1421:	      /* There might be weird (e.g., CD-ROM or MS-DOS) file systems
        -: 1422:		 mounted, which don't have Unix-like directory link counts. */
    #####: 1423:	      process_path (cur_path, cur_name, false, pathname, mode);
        -: 1424:	    }
        -: 1425:
       12: 1426:	  state.curdepth--;
        -: 1427:	}
        -: 1428:
        -: 1429:
        -: 1430:      /* We're about to leave the directory.  If there are any
        -: 1431:       * -execdir argument lists which have been built but have not
        -: 1432:       * yet been processed, do them now because they must be done in
        -: 1433:       * the same directory.
        -: 1434:       */
       12: 1435:      complete_pending_execdirs ();
        -: 1436:
       12: 1437:      if (strcmp (name, "."))
        -: 1438:	{
        -: 1439:	  enum SafeChdirStatus status;
        -: 1440:	  struct dir_id did;
        -: 1441:
        -: 1442:	  /* We could go back and do the next command-line arg
        -: 1443:	     instead, maybe using longjmp.  */
        -: 1444:	  char const *dir;
       12: 1445:	  bool deref = following_links () ? true : false;
        -: 1446:
       12: 1447:	  if ( (state.curdepth>0) && !deref)
        8: 1448:	    dir = "..";
        -: 1449:	  else
        -: 1450:	    {
        4: 1451:	      chdir_back ();
        4: 1452:	      dir = parent;
        -: 1453:	    }
        -: 1454:
       12: 1455:	  did_stat = false;
       12: 1456:	  status = safely_chdir (dir, TraversingUp, &stat_buf, SymlinkHandleDefault, &did_stat);
       12: 1457:	  switch (status)
        -: 1458:	    {
        -: 1459:	    case SafeChdirOK:
       12: 1460:	      break;
        -: 1461:
        -: 1462:	    case SafeChdirFailWouldBeUnableToReturn:
    #####: 1463:	      error (EXIT_FAILURE, errno, ".");
    #####: 1464:	      return;
        -: 1465:
        -: 1466:	    case SafeChdirFailNonexistent:
        -: 1467:	    case SafeChdirFailDestUnreadable:
        -: 1468:	    case SafeChdirFailStat:
        -: 1469:	    case SafeChdirFailSymlink:
        -: 1470:	    case SafeChdirFailNotDir:
        -: 1471:	    case SafeChdirFailChdirFailed:
    #####: 1472:	      error (EXIT_FAILURE, errno,
        -: 1473:		     "%s", safely_quote_err_filename (0, pathname));
    #####: 1474:	      return;
        -: 1475:	    }
        -: 1476:
       12: 1477:	  if (dir_curr > 0)
        -: 1478:	    {
        8: 1479:	      did.dev = dir_ids[dir_curr-1].dev;
        8: 1480:	      did.ino = dir_ids[dir_curr-1].ino;
        -: 1481:	    }
        -: 1482:	  else
        -: 1483:	    {
        4: 1484:	      did.dev = starting_stat_buf.st_dev;
        4: 1485:	      did.ino = starting_stat_buf.st_ino;
        -: 1486:	    }
        -: 1487:	}
        -: 1488:
       12: 1489:      free (cur_path);
       12: 1490:      free_dirinfo (dirinfo);
        -: 1491:    }
        -: 1492:
       12: 1493:  if (subdirs_unreliable)
        -: 1494:    {
        -: 1495:      /* Make sure we hasn't used the variable subdirs_left if we knew
        -: 1496:       * we shouldn't do so.
        -: 1497:       */
    #####: 1498:      assert (0 == subdirs_left || options.no_leaf_check);
        -: 1499:    }
        -: 1500:}
