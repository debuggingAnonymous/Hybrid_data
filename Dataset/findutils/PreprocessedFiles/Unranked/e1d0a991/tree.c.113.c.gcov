        -:    0:Source:tree.c
        -:    0:Graph:tree.gcno
        -:    0:Data:tree.gcda
        -:    0:Runs:17
        -:    0:Programs:2
        -:    1:/* tree.c -- helper functions to build and evaluate the expression tree.
        -:    2:   Copyright (C) 1990, 1991, 1992, 1993, 1994, 2000, 2003, 2004, 2005,
        -:    3:                 2006, 2007, 2010 Free Software Foundation, Inc.
        -:    4:
        -:    5:   This program is free software: you can redistribute it and/or modify
        -:    6:   it under the terms of the GNU General Public License as published by
        -:    7:   the Free Software Foundation, either version 3 of the License, or
        -:    8:   (at your option) any later version.
        -:    9:
        -:   10:   This program is distributed in the hope that it will be useful,
        -:   11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:   GNU General Public License for more details.
        -:   14:
        -:   15:   You should have received a copy of the GNU General Public License
        -:   16:   along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17:*/
        -:   18:
        -:   19:#include <config.h>
        -:   20:#include "defs.h"
        -:   21:
        -:   22:#include <assert.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <fnmatch.h>
        -:   25:
        -:   26:#include "xalloc.h"
        -:   27:#include "error.h"
        -:   28:
        -:   29:
        -:   30:#if ENABLE_NLS
        -:   31:# include <libintl.h>
        -:   32:# define _(Text) gettext (Text)
        -:   33:#else
        -:   34:# define _(Text) Text
        -:   35:#endif
        -:   36:#ifdef gettext_noop
        -:   37:# define N_(String) gettext_noop (String)
        -:   38:#else
        -:   39:/* See locate.c for explanation as to why not use (String) */
        -:   40:# define N_(String) String
        -:   41:#endif
        -:   42:
        -:   43:
        -:   44:
        -:   45:/* All predicates for each path to process. */
        -:   46:static struct predicate *predicates = NULL;
        -:   47:
        -:   48:/* The root of the evaluation tree. */
        -:   49:static struct predicate *eval_tree  = NULL;
        -:   50:
        -:   51:/* The last predicate allocated. */
        -:   52:static struct predicate *last_pred = NULL;
        -:   53:
        -:   54:/* The starting points. */
        -:   55:static char **start_points;
        -:   56:static size_t num_start_points = 0;
        -:   57:
        -:   58:
        -:   59:
        -:   60:static struct predicate *scan_rest PARAMS((struct predicate **input,
        -:   61:					   struct predicate *head,
        -:   62:					   short int prev_prec));
        -:   63:static void merge_pred PARAMS((struct predicate *beg_list, struct predicate *end_list, struct predicate **last_p));
        -:   64:static struct predicate *set_new_parent PARAMS((struct predicate *curr, enum predicate_precedence high_prec, struct predicate **prevp));
        -:   65:static const char *cost_name PARAMS((enum EvaluationCost cost));
        -:   66:
        -:   67:
        -:   68:/* Return true if the indicated path name is a start
        -:   69:   point or not.   If no start points were given on the
        -:   70:   command line, we return true for ".".
        -:   71:*/
        -:   72:bool
    #####:   73:matches_start_point (const char *glob, bool foldcase)
        -:   74:{
    #####:   75:  int fnmatch_flags = 0;
    #####:   76:  if (foldcase)
    #####:   77:    fnmatch_flags |= FNM_CASEFOLD;
        -:   78:
    #####:   79:  if (num_start_points)
        -:   80:    {
        -:   81:      size_t i;
    #####:   82:      for (i=0; i<num_start_points; i++)
        -:   83:	{
    #####:   84:	  if (fnmatch (glob, start_points[i], fnmatch_flags) == 0)
    #####:   85:	    return true;
        -:   86:	}
    #####:   87:      return false;
        -:   88:    }
        -:   89:  else
        -:   90:    {
    #####:   91:      return fnmatch (glob, ".", fnmatch_flags) == 0;
        -:   92:    }
        -:   93:}
        -:   94:
        -:   95:
        -:   96:/* Return a pointer to a tree that represents the
        -:   97:   expression prior to non-unary operator *INPUT.
        -:   98:   Set *INPUT to point at the next input predicate node.
        -:   99:
        -:  100:   Only accepts the following:
        -:  101:
        -:  102:   <primary>
        -:  103:   expression		[operators of higher precedence]
        -:  104:   <uni_op><primary>
        -:  105:   (arbitrary expression)
        -:  106:   <uni_op>(arbitrary expression)
        -:  107:
        -:  108:   In other words, you can not start out with a bi_op or close_paren.
        -:  109:
        -:  110:   If the following operator (if any) is of a higher precedence than
        -:  111:   PREV_PREC, the expression just nabbed is part of a following
        -:  112:   expression, which really is the expression that should be handed to
        -:  113:   our caller, so get_expr recurses. */
        -:  114:
        -:  115:struct predicate *
    #####:  116:get_expr (struct predicate **input,
        -:  117:	  short int prev_prec,
        -:  118:	  const struct predicate* prev_pred)
        -:  119:{
    #####:  120:  struct predicate *next = NULL;
    #####:  121:  struct predicate *this_pred = (*input);
        -:  122:
    #####:  123:  if (*input == NULL)
    #####:  124:    error (EXIT_FAILURE, 0, _("invalid expression"));
        -:  125:
    #####:  126:  switch ((*input)->p_type)
        -:  127:    {
        -:  128:    case NO_TYPE:
    #####:  129:      error (EXIT_FAILURE, 0, _("invalid expression"));
    #####:  130:      break;
        -:  131:
        -:  132:    case BI_OP:
        -:  133:      /* e.g. "find . -a" */
    #####:  134:      error (EXIT_FAILURE, 0,
        -:  135:	     _("invalid expression; you have used a binary operator '%s' with nothing before it."),
        -:  136:	     this_pred->p_name);
    #####:  137:      break;
        -:  138:
        -:  139:    case CLOSE_PAREN:
    #####:  140:      if ((UNI_OP == prev_pred->p_type
    #####:  141:	  || BI_OP == prev_pred->p_type)
    #####:  142:	  && !this_pred->artificial)
        -:  143:	{
        -:  144:	  /* e.g. "find \( -not \)" or "find \( -true -a \" */
    #####:  145:	  error (EXIT_FAILURE, 0,
        -:  146:		 _("expected an expression between '%s' and ')'"),
        -:  147:		 prev_pred->p_name);
        -:  148:	}
    #####:  149:      else if ( (*input)->artificial )
        -:  150:	{
        -:  151:	  /* We have reached the end of the user-supplied predicates
        -:  152:	   * unexpectedly.
        -:  153:	   */
        -:  154:	  /* e.g. "find . -true -a" */
    #####:  155:	  error (EXIT_FAILURE, 0,
        -:  156:		 _("expected an expression after '%s'"), prev_pred->p_name);
        -:  157:	}
        -:  158:      else
        -:  159:	{
    #####:  160:	  error (EXIT_FAILURE, 0,
        -:  161:		 _("invalid expression; you have too many ')'"));
        -:  162:	}
    #####:  163:      break;
        -:  164:
        -:  165:    case PRIMARY_TYPE:
    #####:  166:      next = *input;
    #####:  167:      *input = (*input)->pred_next;
    #####:  168:      break;
        -:  169:
        -:  170:    case UNI_OP:
    #####:  171:      next = *input;
    #####:  172:      *input = (*input)->pred_next;
    #####:  173:      next->pred_right = get_expr (input, NEGATE_PREC, next);
    #####:  174:      break;
        -:  175:
        -:  176:    case OPEN_PAREN:
    #####:  177:      if ( (NULL == (*input)->pred_next) || (*input)->pred_next->artificial )
        -:  178:	{
        -:  179:	  /* user typed something like "find . (", and so the ) we are
        -:  180:	   * looking at is from the artificial "( ) -print" that we
        -:  181:	   * add.
        -:  182:	   */
    #####:  183:	  error (EXIT_FAILURE, 0,
        -:  184:		 _("invalid expression; expected to find a ')' but didn't see one.  Perhaps you need an extra predicate after '%s'"),
        -:  185:		 this_pred->p_name);
        -:  186:	}
    #####:  187:      prev_pred = (*input);
    #####:  188:      *input = (*input)->pred_next;
    #####:  189:      if ( (*input)->p_type == CLOSE_PAREN )
        -:  190:	{
    #####:  191:	  error (EXIT_FAILURE, 0,
        -:  192:		 _("invalid expression; empty parentheses are not allowed."));
        -:  193:	}
    #####:  194:      next = get_expr (input, NO_PREC, prev_pred);
    #####:  195:      if ((*input == NULL)
    #####:  196:	  || ((*input)->p_type != CLOSE_PAREN))
    #####:  197:	error (EXIT_FAILURE, 0,
        -:  198:	       _("invalid expression; I was expecting to find a ')' somewhere but did not see one."));
        -:  199:
    #####:  200:      *input = (*input)->pred_next;	/* move over close */
    #####:  201:      break;
        -:  202:
        -:  203:    default:
    #####:  204:      error (EXIT_FAILURE, 0, _("oops -- invalid expression type!"));
    #####:  205:      break;
        -:  206:    }
        -:  207:
        -:  208:  /* We now have the first expression and are positioned to check
        -:  209:     out the next operator.  If NULL, all done.  Otherwise, if
        -:  210:     PREV_PREC < the current node precedence, we must continue;
        -:  211:     the expression we just nabbed is more tightly bound to the
        -:  212:     following expression than to the previous one. */
    #####:  213:  if (*input == NULL)
    #####:  214:    return (next);
    #####:  215:  if ((int) (*input)->p_prec > (int) prev_prec)
        -:  216:    {
    #####:  217:      next = scan_rest (input, next, prev_prec);
    #####:  218:      if (next == NULL)
    #####:  219:	error (EXIT_FAILURE, 0, _("invalid expression"));
        -:  220:    }
    #####:  221:  return (next);
        -:  222:}
        -:  223:
        -:  224:/* Scan across the remainder of a predicate input list starting
        -:  225:   at *INPUT, building the rest of the expression tree to return.
        -:  226:   Stop at the first close parenthesis or the end of the input list.
        -:  227:   Assumes that get_expr has been called to nab the first element
        -:  228:   of the expression tree.
        -:  229:
        -:  230:   *INPUT points to the current input predicate list element.
        -:  231:   It is updated as we move along the list to point to the
        -:  232:   terminating input element.
        -:  233:   HEAD points to the predicate element that was obtained
        -:  234:   by the call to get_expr.
        -:  235:   PREV_PREC is the precedence of the previous predicate element. */
        -:  236:
        -:  237:static struct predicate *
    #####:  238:scan_rest (struct predicate **input,
        -:  239:	   struct predicate *head,
        -:  240:	   short int prev_prec)
        -:  241:{
        -:  242:  struct predicate *tree;	/* The new tree we are building. */
        -:  243:
    #####:  244:  if ((*input == NULL) || ((*input)->p_type == CLOSE_PAREN))
    #####:  245:    return (NULL);
    #####:  246:  tree = head;
    #####:  247:  while ((*input != NULL) && ((int) (*input)->p_prec > (int) prev_prec))
        -:  248:    {
    #####:  249:      switch ((*input)->p_type)
        -:  250:	{
        -:  251:	case NO_TYPE:
        -:  252:	case PRIMARY_TYPE:
        -:  253:	case UNI_OP:
        -:  254:	case OPEN_PAREN:
        -:  255:	  /* I'm not sure how we get here, so it is not obvious what
        -:  256:	   * sort of mistakes might give rise to this condition.
        -:  257:	   */
    #####:  258:	  error (EXIT_FAILURE, 0, _("invalid expression"));
    #####:  259:	  break;
        -:  260:
        -:  261:	case BI_OP:
        -:  262:	  {
    #####:  263:	    struct predicate *prev = (*input);
    #####:  264:	    (*input)->pred_left = tree;
    #####:  265:	    tree = *input;
    #####:  266:	    *input = (*input)->pred_next;
    #####:  267:	    tree->pred_right = get_expr (input, tree->p_prec, prev);
    #####:  268:	    break;
        -:  269:	  }
        -:  270:
        -:  271:	case CLOSE_PAREN:
    #####:  272:	  return tree;
        -:  273:
        -:  274:	default:
    #####:  275:	  error (EXIT_FAILURE, 0,
        -:  276:		 _("oops -- invalid expression type (%d)!"),
    #####:  277:		 (int)(*input)->p_type);
    #####:  278:	  break;
        -:  279:	}
        -:  280:    }
    #####:  281:  return tree;
        -:  282:}
        -:  283:
        -:  284:/* Returns true if the specified predicate is reorderable. */
        -:  285:static bool
    #####:  286:predicate_is_cost_free (const struct predicate *p)
        -:  287:{
    #####:  288:  if (pred_is(p, pred_name) ||
    #####:  289:      pred_is(p, pred_path) ||
    #####:  290:      pred_is(p, pred_iname) ||
    #####:  291:      pred_is(p, pred_ipath))
        -:  292:    {
        -:  293:      /* Traditionally (at least 4.1.7 through 4.2.x) GNU find always
        -:  294:       * optimised these cases.
        -:  295:       */
    #####:  296:      return true;
        -:  297:    }
    #####:  298:  else if (options.optimisation_level > 0)
        -:  299:    {
    #####:  300:      if (pred_is(p, pred_and) ||
    #####:  301:	  pred_is(p, pred_negate) ||
    #####:  302:	  pred_is(p, pred_comma) ||
    #####:  303:	  pred_is(p, pred_or))
    #####:  304:	return false;
        -:  305:      else
    #####:  306:	return NeedsNothing == p->p_cost;
        -:  307:    }
        -:  308:  else
        -:  309:    {
    #####:  310:      return false;
        -:  311:    }
        -:  312:}
        -:  313:
        -:  314:/* Prints a predicate */
    #####:  315:void print_predicate (FILE *fp, const struct predicate *p)
        -:  316:{
    #####:  317:  if (p->arg_text)
        -:  318:    {
    #####:  319:      fprintf (fp, "%s %s", p->p_name, p->arg_text);
        -:  320:    }
        -:  321:  else
        -:  322:    {
    #####:  323:      fprintf (fp, "%s", p->p_name);
        -:  324:    }
    #####:  325:}
        -:  326:
        -:  327:
        -:  328:struct predlist
        -:  329:{
        -:  330:  struct predicate *head;
        -:  331:  struct predicate *tail;
        -:  332:};
        -:  333:
        -:  334:static void
    #####:  335:predlist_init (struct predlist *p)
        -:  336:{
    #####:  337:  p->head = p->tail = NULL;
    #####:  338:}
        -:  339:
        -:  340:static void
    #####:  341:predlist_insert (struct predlist *list,
        -:  342:		 struct predicate *curr,
        -:  343:		 struct predicate **pprev)
        -:  344:{
    #####:  345:  struct predicate **insertpos = &(list->head);
        -:  346:
    #####:  347:  *pprev = curr->pred_left;
    #####:  348:  if (options.optimisation_level > 2)
        -:  349:    {
        -:  350:      /* Insert the new node in the list after any other entries which
        -:  351:       * are more selective.
        -:  352:       */
        -:  353:      if (0)
        -:  354:	while ( (*insertpos) && ((*insertpos)->est_success_rate < curr->est_success_rate) )
        -:  355:	  {
        -:  356:	    insertpos = &((*insertpos)->pred_left);
        -:  357:	  }
        -:  358:    }
    #####:  359:  curr->pred_left = (*insertpos);
    #####:  360:  (*insertpos) = curr;
    #####:  361:  if (NULL == list->tail)
    #####:  362:    list->tail = list->head;
    #####:  363:}
        -:  364:
        -:  365:static int
    #####:  366:pred_cost_compare (const struct predicate *p1, const struct predicate *p2, bool wantfailure)
        -:  367:{
    #####:  368:  if (p1->p_cost == p2->p_cost)
        -:  369:    {
    #####:  370:      if (p1->est_success_rate == p2->est_success_rate)
    #####:  371:	return 0;
    #####:  372:      else if (wantfailure)
    #####:  373:	return p1->est_success_rate < p2->est_success_rate ? -1 :  1;
        -:  374:      else
    #####:  375:	return p1->est_success_rate < p2->est_success_rate ?  1 : -1;
        -:  376:    }
        -:  377:  else
        -:  378:    {
    #####:  379:      return p1->p_cost < p2->p_cost ? -1 : 1;
        -:  380:    }
        -:  381:}
        -:  382:
        -:  383:
        -:  384:static void
    #####:  385:predlist_merge_sort (struct predlist *list,
        -:  386:		     struct predicate **last)
        -:  387:{
        -:  388:  struct predlist new_list;
        -:  389:  struct predicate *p, *q;
        -:  390:
    #####:  391:  if (NULL == list->head)
    #####:  392:    return;			/* nothing to do */
        -:  393:
    #####:  394:  if (options.debug_options & DebugTreeOpt)
        -:  395:    {
    #####:  396:      fprintf (stderr, "%s:\n", "predlist before merge sort");
    #####:  397:      print_tree (stderr, list->head, 2);
        -:  398:    }
        -:  399:
    #####:  400:  calculate_derived_rates (list->head);
    #####:  401:  predlist_init (&new_list);
    #####:  402:  while (list->head)
        -:  403:    {
        -:  404:      /* remove head of source list */
    #####:  405:      q = list->head;
    #####:  406:      list->head = list->head->pred_left;
    #####:  407:      q->pred_left = NULL;
        -:  408:
        -:  409:      /* insert it into the new list */
    #####:  410:      for (p=new_list.head; p; p=p->pred_left)
        -:  411:	{
        -:  412:	  /* If these operations are OR operations, we want to get a
        -:  413:	   * successful test as soon as possible, to take advantage of
        -:  414:	   * the short-circuit evaluation.  If they're AND, we want to
        -:  415:	   * get an unsuccessful result early for the same reason.
        -:  416:	   * Therefore we invert the sense of the comparison for the
        -:  417:	   * OR case.  We only want to invert the sense of the success
        -:  418:	   * rate comparison, not the operation cost comparison.  Hence we
        -:  419:	   * pass a flag into pred_cost_compare().
        -:  420:	   */
    #####:  421:	  const bool wantfailure = (OR_PREC != p->p_prec);
    #####:  422:	  if (pred_cost_compare (p->pred_right, q->pred_right, wantfailure) >= 0)
    #####:  423:	    break;
        -:  424:	}
    #####:  425:      if (p)
        -:  426:	{
        -:  427:	  /* insert into existing list */
    #####:  428:	  q->pred_left = p->pred_left;
    #####:  429:	  if (NULL == q->pred_left)
    #####:  430:	    new_list.tail = q;
    #####:  431:	  p->pred_left = q;
        -:  432:	}
        -:  433:      else
        -:  434:	{
    #####:  435:	  q->pred_left = new_list.head;	/* prepend */
    #####:  436:	  new_list.head = q;
    #####:  437:	  if (NULL == new_list.tail)
    #####:  438:	    new_list.tail = q; /* first item in new list */
        -:  439:	}
        -:  440:    }
    #####:  441:  if (options.debug_options & DebugTreeOpt)
        -:  442:    {
    #####:  443:      fprintf (stderr, "%s:\n", "predlist after merge sort");
    #####:  444:      print_tree (stderr, new_list.head, 2);
        -:  445:    }
        -:  446:
    #####:  447:  calculate_derived_rates(new_list.head);
    #####:  448:  merge_pred (new_list.head, new_list.tail, last);
    #####:  449:  predlist_init (list);
        -:  450:}
        -:  451:
        -:  452:static void
    #####:  453:merge_lists (struct predlist lists[], int nlists,
        -:  454:	     struct predlist *name_list,
        -:  455:	     struct predlist *regex_list,
        -:  456:	     struct predicate **last)
        -:  457:{
        -:  458:  int i;
        -:  459:  static void (*mergefn)(struct predlist *, struct predicate**);
        -:  460:
    #####:  461:  mergefn = predlist_merge_sort;
        -:  462:
    #####:  463:  mergefn (name_list,   last);
    #####:  464:  mergefn (regex_list,  last);
        -:  465:
    #####:  466:  for (i=0; i<nlists; i++)
    #####:  467:    mergefn (&lists[i], last);
    #####:  468:}
        -:  469:
        -:  470:
        -:  471:
        -:  472:static bool
    #####:  473:subtree_has_side_effects (const struct predicate *p)
        -:  474:{
    #####:  475:  if (p)
        -:  476:    {
    #####:  477:      return p->side_effects
    #####:  478:	|| subtree_has_side_effects (p->pred_left)
    #####:  479:	|| subtree_has_side_effects (p->pred_right);
        -:  480:    }
        -:  481:  else
        -:  482:    {
        -:  483:
    #####:  484:      return false;
        -:  485:    }
        -:  486:}
        -:  487:
        -:  488:static int
    #####:  489:worst_cost (const struct predicate *p)
        -:  490:{
    #####:  491:  if (p)
        -:  492:    {
        -:  493:      unsigned int cost_r, cost_l, worst;
    #####:  494:      cost_l = worst_cost (p->pred_left);
    #####:  495:      cost_r = worst_cost (p->pred_right);
    #####:  496:      worst = (cost_l > cost_r) ? cost_l : cost_r;
    #####:  497:      if (worst < p->p_cost)
    #####:  498:	worst = p->p_cost;
    #####:  499:      return worst;
        -:  500:    }
        -:  501:  else
        -:  502:    {
    #####:  503:      return 0;
        -:  504:    }
        -:  505:}
        -:  506:
        -:  507:
        -:  508:
        -:  509:static void
    #####:  510:perform_arm_swap (struct predicate *p)
        -:  511:{
    #####:  512:  struct predicate *tmp = p->pred_left->pred_right;
    #####:  513:  p->pred_left->pred_right = p->pred_right;
    #####:  514:  p->pred_right = tmp;
    #####:  515:}
        -:  516:
        -:  517:/* Consider swapping p->pred_left->pred_right with p->pred_right,
        -:  518: * if that yields a faster evaluation.   Normally the left predicate is
        -:  519: * evaluated first.
        -:  520: *
        -:  521: * If the operation is an OR, we want the left predicate to be the one that
        -:  522: * succeeds most often.   If it is an AND, we want it to be the predicate that
        -:  523: * fails most often.
        -:  524: *
        -:  525: * We don't consider swapping arms of an operator where their cost is
        -:  526: * different or where they have side effects.
        -:  527: *
        -:  528: * A viable test case for this is
        -:  529: * ./find -D opt   -O3  .   \! -type f -o -type d
        -:  530: * Here, the ! -type f should be evaluated first,
        -:  531: * as we assume that 95% of inodes are vanilla files.
        -:  532: */
        -:  533:static bool
    #####:  534:consider_arm_swap (struct predicate *p)
        -:  535:{
        -:  536:  int left_cost, right_cost;
    #####:  537:  const char *reason = NULL;
        -:  538:  struct predicate **pl, **pr;
        -:  539:
    #####:  540:  if (BI_OP != p->p_type)
    #####:  541:    reason = "Not a binary operation";
        -:  542:
    #####:  543:  if (!reason)
        -:  544:    {
    #####:  545:      if (NULL == p->pred_left || NULL == p->pred_right)
    #####:  546:	reason = "Doesn't have two arms";
        -:  547:    }
        -:  548:
        -:  549:
    #####:  550:  if (!reason)
        -:  551:    {
    #####:  552:      if (NULL == p->pred_left->pred_right)
    #####:  553:	reason = "Left arm has no child on RHS";
        -:  554:    }
    #####:  555:  pr = &p->pred_right;
    #####:  556:  pl = &p->pred_left->pred_right;
        -:  557:
    #####:  558:  if (!reason)
        -:  559:    {
    #####:  560:      if (subtree_has_side_effects (*pl))
    #####:  561:	reason = "Left subtree has side-effects";
        -:  562:    }
    #####:  563:  if (!reason)
        -:  564:    {
    #####:  565:      if (subtree_has_side_effects (*pr))
    #####:  566:	reason = "Right subtree has side-effects";
        -:  567:    }
        -:  568:
    #####:  569:  if (!reason)
        -:  570:    {
    #####:  571:      left_cost = worst_cost (*pl);
    #####:  572:      right_cost = worst_cost (*pr);
        -:  573:
    #####:  574:      if (left_cost < right_cost)
        -:  575:	{
    #####:  576:	  reason = "efficient as-is";
        -:  577:	}
        -:  578:    }
    #####:  579:  if (!reason)
        -:  580:    {
        -:  581:      bool want_swap;
        -:  582:
    #####:  583:      if (left_cost == right_cost)
        -:  584:	{
        -:  585:	  /* it's a candidate */
    #####:  586:	  float succ_rate_l = (*pl)->est_success_rate;
    #####:  587:	  float succ_rate_r = (*pr)->est_success_rate;
        -:  588:
    #####:  589:	  if (options.debug_options & DebugTreeOpt)
        -:  590:	    {
    #####:  591:	      fprintf (stderr, "Success rates: l=%f, r=%f\n", succ_rate_l, succ_rate_r);
        -:  592:	    }
        -:  593:
    #####:  594:	  if (pred_is (p, pred_or))
        -:  595:	    {
    #####:  596:	      want_swap = succ_rate_r < succ_rate_l;
    #####:  597:	      if (!want_swap)
    #####:  598:		reason = "Operation is OR and right success rate >= left";
        -:  599:	    }
    #####:  600:	  else if (pred_is (p, pred_and))
        -:  601:	    {
    #####:  602:	      want_swap = succ_rate_r > succ_rate_l;
    #####:  603:	      if (!want_swap)
    #####:  604:		reason = "Operation is AND and right success rate <= left";
        -:  605:	    }
        -:  606:	  else
        -:  607:	    {
    #####:  608:	      want_swap = false;
    #####:  609:	      reason = "Not AND or OR";
        -:  610:	    }
        -:  611:	}
        -:  612:      else
        -:  613:	{
    #####:  614:	  want_swap = true;
        -:  615:	}
        -:  616:
    #####:  617:      if (want_swap)
        -:  618:	{
    #####:  619:	  if (options.debug_options & DebugTreeOpt)
        -:  620:	    {
    #####:  621:	      fprintf (stderr, "Performing arm swap on:\n");
    #####:  622:	      print_tree (stderr, p, 0);
        -:  623:	    }
    #####:  624:	  perform_arm_swap (p);
    #####:  625:	  return true;
        -:  626:	}
        -:  627:    }
        -:  628:
        -:  629:
    #####:  630:  if (options.debug_options & DebugTreeOpt)
        -:  631:    {
    #####:  632:      fprintf (stderr, "Not an arm swap candidate (%s):\n", reason);
    #####:  633:      print_tree (stderr, p, 0);
        -:  634:    }
    #####:  635:  return false;
        -:  636:}
        -:  637:
        -:  638:static bool
    #####:  639:do_arm_swaps (struct predicate *p)
        -:  640:{
    #####:  641:  if (p)
        -:  642:    {
        -:  643:      bool swapped;
        -:  644:      do
        -:  645:	{
    #####:  646:	  swapped = false;
    #####:  647:	  if (consider_arm_swap (p)
    #####:  648:	      || do_arm_swaps (p->pred_left)
    #####:  649:	      || do_arm_swaps (p->pred_right))
        -:  650:	    {
    #####:  651:	      swapped = true;
        -:  652:	    }
    #####:  653:	} while (swapped);
    #####:  654:      return swapped;
        -:  655:    }
        -:  656:  else
        -:  657:    {
    #####:  658:      return false;
        -:  659:    }
        -:  660:}
        -:  661:
        -:  662:
        -:  663:
        -:  664:/* Optimize the ordering of the predicates in the tree.  Rearrange
        -:  665:   them to minimize work.  Strategies:
        -:  666:   * Evaluate predicates that don't need inode information first;
        -:  667:     the predicates are divided into 1 or more groups separated by
        -:  668:     predicates (if any) which have "side effects", such as printing.
        -:  669:     The grouping implements the partial ordering on predicates which
        -:  670:     those with side effects impose.
        -:  671:
        -:  672:   * Place -name, -iname, -path, -ipath, -regex and -iregex at the front
        -:  673:     of a group, with -name, -iname, -path and -ipath ahead of
        -:  674:     -regex and -iregex.  Predicates which are moved to the front
        -:  675:     of a group by definition do not have side effects.  Both
        -:  676:     -regex and -iregex both use pred_regex.
        -:  677:
        -:  678:     If higher optimisation levels have been selected, reordering also
        -:  679:     occurs according to the p_cost member of each predicate (which
        -:  680:     reflects the performance cost of the test).  The ordering also
        -:  681:     bears in mind whether these operations are more likely to succeed
        -:  682:     or fail.  When evauating a chain of OR conditions, we prefer
        -:  683:     tests likely to succeed at the front of the list.  For AND, we
        -:  684:     prefer tests likely to fail at the front of the list.
        -:  685:
        -:  686:     This routine "normalizes" the predicate tree by ensuring that
        -:  687:     all expression predicates have AND (or OR or COMMA) parent nodes
        -:  688:     which are linked along the left edge of the expression tree.
        -:  689:     This makes manipulation of subtrees easier.
        -:  690:
        -:  691:     EVAL_TREEP points to the root pointer of the predicate tree
        -:  692:     to be rearranged.  opt_expr may return a new root pointer there.
        -:  693:     Return true if the tree contains side effects, false if not. */
        -:  694:
        -:  695:static bool
    #####:  696:opt_expr (struct predicate **eval_treep)
        -:  697:{
    #####:  698:  struct predlist regex_list={NULL,NULL}, name_list={NULL,NULL};
        -:  699:  struct predlist cbo_list[NumEvaluationCosts];
        -:  700:  int i;
        -:  701:  struct predicate *curr;
        -:  702:  struct predicate **prevp;	/* Address of `curr' node. */
        -:  703:  struct predicate **last_sidep; /* Last predicate with side effects. */
        -:  704:  PRED_FUNC pred_func;
        -:  705:  enum predicate_type p_type;
    #####:  706:  bool has_side_effects = false; /* Return value. */
        -:  707:  enum predicate_precedence prev_prec, /* precedence of last BI_OP in branch */
        -:  708:			    biop_prec; /* topmost BI_OP precedence in branch */
        -:  709:
    #####:  710:  if (eval_treep == NULL || *eval_treep == NULL)
    #####:  711:    return (false);
        -:  712:
    #####:  713:  for (i=0; i<NumEvaluationCosts; i++)
    #####:  714:    predlist_init (&cbo_list[i]);
        -:  715:
        -:  716:  /* Set up to normalize tree as a left-linked list of ANDs or ORs.
        -:  717:     Set `curr' to the leftmost node, `prevp' to its address, and
        -:  718:     `pred_func' to the predicate type of its parent. */
    #####:  719:  prevp = eval_treep;
    #####:  720:  prev_prec = AND_PREC;
    #####:  721:  curr = *prevp;
    #####:  722:  while (curr->pred_left != NULL)
        -:  723:    {
    #####:  724:      prevp = &curr->pred_left;
    #####:  725:      prev_prec = curr->p_prec;	/* must be a BI_OP */
    #####:  726:      curr = curr->pred_left;
        -:  727:    }
        -:  728:
        -:  729:  /* Link in the appropriate BI_OP for the last expression, if needed. */
    #####:  730:  if (curr->p_type != BI_OP)
    #####:  731:    set_new_parent (curr, prev_prec, prevp);
        -:  732:
    #####:  733:  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))
        -:  734:    {
        -:  735:      /* Normalized tree. */
    #####:  736:      fprintf (stderr, "Normalized Eval Tree:\n");
    #####:  737:      print_tree (stderr, *eval_treep, 0);
        -:  738:    }
        -:  739:
        -:  740:  /* Rearrange the predicates. */
    #####:  741:  prevp = eval_treep;
    #####:  742:  biop_prec = NO_PREC; /* not COMMA_PREC */
    #####:  743:  if ((*prevp) && (*prevp)->p_type == BI_OP)
    #####:  744:    biop_prec = (*prevp)->p_prec;
    #####:  745:  while ((curr = *prevp) != NULL)
        -:  746:    {
        -:  747:      /* If there is a BI_OP of different precedence from the first
        -:  748:	 in the pred_left chain, create a new parent of the
        -:  749:	 original precedence, link the new parent to the left of the
        -:  750:	 previous and link CURR to the right of the new parent.
        -:  751:	 This preserves the precedence of expressions in the tree
        -:  752:	 in case we rearrange them. */
    #####:  753:      if (curr->p_type == BI_OP)
        -:  754:	{
    #####:  755:          if (curr->p_prec != biop_prec)
    #####:  756:	    curr = set_new_parent (curr, biop_prec, prevp);
        -:  757:	}
        -:  758:
        -:  759:      /* See which predicate type we have. */
    #####:  760:      p_type = curr->pred_right->p_type;
    #####:  761:      pred_func = curr->pred_right->pred_func;
        -:  762:
        -:  763:
    #####:  764:      switch (p_type)
        -:  765:	{
        -:  766:	case NO_TYPE:
        -:  767:	case PRIMARY_TYPE:
        -:  768:	  /* Don't rearrange the arguments of the comma operator, it is
        -:  769:	     not commutative.  */
    #####:  770:	  if (biop_prec == COMMA_PREC)
    #####:  771:	    break;
        -:  772:
        -:  773:	  /* If this predicate has no side effects, consider reordering it. */
    #####:  774:	  if (!curr->pred_right->side_effects)
        -:  775:	    {
        -:  776:	      bool reorder;
        -:  777:
        -:  778:	      /* If it's one of our special primaries, move it to the
        -:  779:		 front of the list for that primary. */
    #####:  780:	      if (predicate_is_cost_free (curr->pred_right))
        -:  781:		{
    #####:  782:		  if (options.debug_options & DebugTreeOpt)
        -:  783:		    {
    #####:  784:		      fprintf (stderr, "-O%d: promoting cheap predicate ",
    #####:  785:			       (int)options.optimisation_level);
    #####:  786:		      print_predicate (stderr, curr->pred_right);
    #####:  787:		      fprintf (stderr, " into name_list\n");
        -:  788:		    }
    #####:  789:		  predlist_insert (&name_list, curr, prevp);
    #####:  790:		  continue;
        -:  791:		}
        -:  792:
    #####:  793:	      if (pred_func == pred_regex)
        -:  794:		{
    #####:  795:		  predlist_insert (&regex_list, curr, prevp);
    #####:  796:		  continue;
        -:  797:		}
        -:  798:
    #####:  799:	      reorder = ((options.optimisation_level > 1)
    #####:  800:			 && (NeedsType == curr->pred_right->p_cost
    #####:  801:			     || NeedsInodeNumber == curr->pred_right->p_cost)
    #####:  802:			 && !curr->pred_right->need_stat) ||
    #####:  803:		(options.optimisation_level > 2);
        -:  804:
    #####:  805:	      if (reorder)
        -:  806:		{
    #####:  807:		  if (options.debug_options & DebugTreeOpt)
        -:  808:		    {
    #####:  809:		      fprintf (stderr, "-O%d: categorising predicate ",
    #####:  810:			       (int)options.optimisation_level);
    #####:  811:		      print_predicate (stderr, curr->pred_right);
    #####:  812:		      fprintf (stderr, " by cost (%s)\n",
    #####:  813:			       cost_name(curr->pred_right->p_cost));
        -:  814:		    }
    #####:  815:		  predlist_insert (&cbo_list[curr->pred_right->p_cost], curr, prevp);
    #####:  816:		  continue;
        -:  817:		}
        -:  818:	    }
        -:  819:
    #####:  820:	  break;
        -:  821:
        -:  822:	case UNI_OP:
        -:  823:	  /* For NOT, check the expression trees below the NOT. */
    #####:  824:	  curr->pred_right->side_effects
    #####:  825:	    = opt_expr (&curr->pred_right->pred_right);
    #####:  826:	  break;
        -:  827:
        -:  828:	case BI_OP:
        -:  829:	  /* For nested AND or OR, recurse (AND/OR form layers on the left of
        -:  830:	     the tree), and continue scanning this level of AND or OR. */
    #####:  831:	  curr->pred_right->side_effects = opt_expr (&curr->pred_right);
    #####:  832:	  break;
        -:  833:
        -:  834:	  /* At this point, get_expr and scan_rest have already removed
        -:  835:	     all of the user's parentheses. */
        -:  836:
        -:  837:	default:
    #####:  838:	  error (EXIT_FAILURE, 0, _("oops -- invalid expression type!"));
    #####:  839:	  break;
        -:  840:	}
        -:  841:
    #####:  842:      if (curr->pred_right->side_effects == true)
        -:  843:	{
    #####:  844:	  last_sidep = prevp;
        -:  845:
        -:  846:	  /* Incorporate lists and reset list pointers for this group.  */
    #####:  847:	  merge_lists (cbo_list, NumEvaluationCosts, &name_list, &regex_list, last_sidep);
    #####:  848:	  has_side_effects = true;
        -:  849:	}
        -:  850:
    #####:  851:      prevp = &curr->pred_left;
        -:  852:    }
        -:  853:
        -:  854:  /* Do final list merges. */
    #####:  855:  last_sidep = prevp;
    #####:  856:  merge_lists (cbo_list, NumEvaluationCosts, &name_list, &regex_list, last_sidep);
    #####:  857:  return has_side_effects;
        -:  858:}
        -:  859:
        -:  860:static float
    #####:  861:constrain_rate (float rate)
        -:  862:{
    #####:  863:  if (rate > 1.0f)
    #####:  864:    return 1.0;
    #####:  865:  else if (rate < 0.0)
    #####:  866:    return 0.0;
        -:  867:  else
    #####:  868:    return rate;
        -:  869:}
        -:  870:
        -:  871:/* Link in a new parent BI_OP node for CURR, at *PREVP, with precedence
        -:  872:   HIGH_PREC. */
        -:  873:
        -:  874:static struct predicate *
    #####:  875:set_new_parent (struct predicate *curr, enum predicate_precedence high_prec, struct predicate **prevp)
        -:  876:{
        -:  877:  struct predicate *new_parent;
        -:  878:
    #####:  879:  new_parent = xmalloc (sizeof (struct predicate));
    #####:  880:  new_parent->p_type = BI_OP;
    #####:  881:  new_parent->p_prec = high_prec;
    #####:  882:  new_parent->need_stat = false;
    #####:  883:  new_parent->need_type = false;
    #####:  884:  new_parent->need_inum = false;
    #####:  885:  new_parent->p_cost = NeedsNothing;
    #####:  886:  new_parent->arg_text = NULL;
        -:  887:
    #####:  888:  switch (high_prec)
        -:  889:    {
        -:  890:    case COMMA_PREC:
    #####:  891:      new_parent->pred_func = pred_comma;
    #####:  892:      new_parent->p_name = ",";
    #####:  893:      new_parent->est_success_rate = 1.0;
    #####:  894:      break;
        -:  895:    case OR_PREC:
    #####:  896:      new_parent->pred_func = pred_or;
    #####:  897:      new_parent->p_name = "-o";
    #####:  898:      new_parent->est_success_rate = constrain_rate (curr->est_success_rate);
    #####:  899:      break;
        -:  900:    case AND_PREC:
    #####:  901:      new_parent->pred_func = pred_and;
    #####:  902:      new_parent->p_name = "-a";
    #####:  903:      new_parent->est_success_rate = constrain_rate (curr->est_success_rate);
    #####:  904:      break;
        -:  905:    default:
        -:  906:      ;				/* empty */
        -:  907:    }
        -:  908:
    #####:  909:  new_parent->side_effects = false;
    #####:  910:  new_parent->no_default_print = false;
    #####:  911:  new_parent->args.str = NULL;
    #####:  912:  new_parent->pred_next = NULL;
        -:  913:
        -:  914:  /* Link in new_parent.
        -:  915:     Pushes rest of left branch down 1 level to new_parent->pred_right. */
    #####:  916:  new_parent->pred_left = NULL;
    #####:  917:  new_parent->pred_right = curr;
    #####:  918:  *prevp = new_parent;
        -:  919:
    #####:  920:  return new_parent;
        -:  921:}
        -:  922:
        -:  923:/* Merge the predicate list that starts at BEG_LIST and ends at END_LIST
        -:  924:   into the tree at LAST_P. */
        -:  925:
        -:  926:static void
    #####:  927:merge_pred (struct predicate *beg_list, struct predicate *end_list, struct predicate **last_p)
        -:  928:{
    #####:  929:  end_list->pred_left = *last_p;
    #####:  930:  *last_p = beg_list;
    #####:  931:}
        -:  932:
        -:  933:/* Find the first node in expression tree TREE that requires
        -:  934:   a stat call and mark the operator above it as needing a stat
        -:  935:   before calling the node.   Since the expression precedences
        -:  936:   are represented in the tree, some preds that need stat may not
        -:  937:   get executed (because the expression value is determined earlier.)
        -:  938:   So every expression needing stat must be marked as such, not just
        -:  939:   the earliest, to be sure to obtain the stat.  This still guarantees
        -:  940:   that a stat is made as late as possible.  Return true if the top node
        -:  941:   in TREE requires a stat, false if not. */
        -:  942:
        -:  943:
        -:  944:struct pred_cost_lookup
        -:  945:{
        -:  946:  PRED_FUNC             fn;
        -:  947:  enum EvaluationCost   cost;
        -:  948:};
        -:  949:static struct pred_cost_lookup costlookup[] =
        -:  950:  {
        -:  951:    { pred_amin      ,  NeedsStatInfo        },
        -:  952:    { pred_and       ,  NeedsNothing,        },
        -:  953:    { pred_anewer    ,  NeedsStatInfo,       },
        -:  954:    { pred_atime     ,  NeedsStatInfo,       },
        -:  955:    { pred_closeparen,  NeedsNothing         },
        -:  956:    { pred_cmin      ,  NeedsStatInfo,       },
        -:  957:    { pred_cnewer    ,  NeedsStatInfo,       },
        -:  958:    { pred_comma     ,  NeedsNothing,        },
        -:  959:    { pred_context   ,  NeedsAccessInfo      },
        -:  960:    { pred_ctime     ,  NeedsStatInfo,       },
        -:  961:    { pred_delete    ,  NeedsSyncDiskHit     },
        -:  962:    { pred_empty     ,  NeedsStatInfo        },
        -:  963:    { pred_exec      ,  NeedsEventualExec    },
        -:  964:    { pred_execdir   ,  NeedsEventualExec    },
        -:  965:    { pred_executable,  NeedsAccessInfo      },
        -:  966:    { pred_false     ,  NeedsNothing         },
        -:  967:    { pred_fprint    ,  NeedsNothing         },
        -:  968:    { pred_fprint0   ,  NeedsNothing         },
        -:  969:    { pred_fprintf   ,  NeedsNothing         },
        -:  970:    { pred_fstype    ,  NeedsStatInfo        }, /* true for amortised cost */
        -:  971:    { pred_gid       ,  NeedsStatInfo        },
        -:  972:    { pred_group     ,  NeedsStatInfo        },
        -:  973:    { pred_ilname    ,  NeedsLinkName        },
        -:  974:    { pred_iname     ,  NeedsNothing         },
        -:  975:    { pred_inum      ,  NeedsInodeNumber     },
        -:  976:    { pred_ipath     ,  NeedsNothing         },
        -:  977:    { pred_links     ,  NeedsStatInfo        },
        -:  978:    { pred_lname     ,  NeedsLinkName        },
        -:  979:    { pred_ls        ,  NeedsStatInfo        },
        -:  980:    { pred_fls       ,  NeedsStatInfo        },
        -:  981:    { pred_mmin	     ,  NeedsStatInfo        },
        -:  982:    { pred_mtime     ,  NeedsStatInfo        },
        -:  983:    { pred_name	     ,  NeedsNothing         },
        -:  984:    { pred_negate    ,  NeedsNothing,        },
        -:  985:    { pred_newer     ,  NeedsStatInfo,       },
        -:  986:    { pred_newerXY   ,  NeedsStatInfo,       },
        -:  987:    { pred_nogroup   ,  NeedsStatInfo        }, /* true for amortised cost if caching is on */
        -:  988:    { pred_nouser    ,  NeedsStatInfo        }, /* true for amortised cost if caching is on */
        -:  989:    { pred_ok        ,  NeedsUserInteraction },
        -:  990:    { pred_okdir     ,  NeedsUserInteraction },
        -:  991:    { pred_openparen ,  NeedsNothing         },
        -:  992:    { pred_or        ,  NeedsNothing,        },
        -:  993:    { pred_path	     ,  NeedsNothing         },
        -:  994:    { pred_perm	     ,  NeedsStatInfo        },
        -:  995:    { pred_print     ,  NeedsNothing         },
        -:  996:    { pred_print0    ,  NeedsNothing         },
        -:  997:    { pred_prune     ,  NeedsNothing         },
        -:  998:    { pred_quit	     ,  NeedsNothing         },
        -:  999:    { pred_readable  ,  NeedsAccessInfo      },
        -: 1000:    { pred_regex     ,  NeedsNothing         },
        -: 1001:    { pred_samefile  ,  NeedsStatInfo        },
        -: 1002:    { pred_size      ,  NeedsStatInfo        },
        -: 1003:    { pred_true	     ,  NeedsNothing         },
        -: 1004:    { pred_type      ,  NeedsType            },
        -: 1005:    { pred_uid       ,  NeedsStatInfo        },
        -: 1006:    { pred_used      ,  NeedsStatInfo        },
        -: 1007:    { pred_user      ,  NeedsStatInfo        },
        -: 1008:    { pred_writable  ,  NeedsAccessInfo      },
        -: 1009:    { pred_xtype     ,  NeedsType            } /* roughly correct unless most files are symlinks */
        -: 1010:  };
        -: 1011:static int pred_table_sorted = 0;
        -: 1012:
        -: 1013:static bool
    #####: 1014:check_sorted (void *base, size_t members, size_t membersize,
        -: 1015:	      int (*cmpfn)(const void*, const void*))
        -: 1016:{
    #####: 1017:  const char *p = base;
        -: 1018:  size_t i;
    #####: 1019:  for (i=1u; i<members; ++i)
        -: 1020:    {
    #####: 1021:      int result = cmpfn (p+i*membersize, p+(i-1)*membersize);
    #####: 1022:      if (result < 0)
    #####: 1023:	return false;
    #####: 1024:      result = cmpfn (p+(i-1)*membersize, p+i*membersize);
    #####: 1025:      assert (result <= 0);
        -: 1026:    }
    #####: 1027:  return true;
        -: 1028:}
        -: 1029:
        -: 1030:
        -: 1031:static int
    #####: 1032:cost_table_comparison (const void *p1, const void *p2)
        -: 1033:{
        -: 1034:  /* We have to compare the function pointers with memcmp(),
        -: 1035:   * because ISO C does not allow magnitude comparison of
        -: 1036:   * function pointers (just equality testing).
        -: 1037:   */
    #####: 1038:  const struct pred_cost_lookup *pc1 = p1;
    #####: 1039:  const struct pred_cost_lookup *pc2 = p2;
        -: 1040:  union {
        -: 1041:    PRED_FUNC pfn;
        -: 1042:    char mem[sizeof (PRED_FUNC)];
        -: 1043:  } u1, u2;
        -: 1044:
    #####: 1045:  u1.pfn = pc1->fn;
    #####: 1046:  u2.pfn = pc2->fn;
    #####: 1047:  return memcmp (u1.mem, u2.mem, sizeof(u1.pfn));
        -: 1048:}
        -: 1049:
        -: 1050:static enum EvaluationCost
    #####: 1051:get_pred_cost (const struct predicate *p)
        -: 1052:{
    #####: 1053:  enum EvaluationCost data_requirement_cost = NeedsNothing;
    #####: 1054:  enum EvaluationCost inherent_cost = NeedsUnknown;
        -: 1055:
    #####: 1056:  if (p->need_stat)
        -: 1057:    {
    #####: 1058:      data_requirement_cost = NeedsStatInfo;
        -: 1059:    }
    #####: 1060:  else if (p->need_inum)
        -: 1061:    {
    #####: 1062:      data_requirement_cost = NeedsInodeNumber;
        -: 1063:    }
    #####: 1064:  else if (p->need_type)
        -: 1065:    {
    #####: 1066:      data_requirement_cost = NeedsType;
        -: 1067:    }
        -: 1068:  else
        -: 1069:    {
    #####: 1070:      data_requirement_cost = NeedsNothing;
        -: 1071:    }
        -: 1072:
    #####: 1073:  if (pred_is (p, pred_exec) || pred_is(p, pred_execdir))
        -: 1074:    {
    #####: 1075:      if (p->args.exec_vec.multiple)
    #####: 1076:	inherent_cost = NeedsEventualExec;
        -: 1077:      else
    #####: 1078:	inherent_cost = NeedsImmediateExec;
        -: 1079:    }
    #####: 1080:  else if (pred_is (p, pred_fprintf))
        -: 1081:    {
        -: 1082:      /* the parser calculated the cost for us. */
    #####: 1083:      inherent_cost = p->p_cost;
        -: 1084:    }
        -: 1085:  else
        -: 1086:    {
        -: 1087:      struct pred_cost_lookup key;
        -: 1088:      void *entry;
        -: 1089:
    #####: 1090:      if (!pred_table_sorted)
        -: 1091:	{
    #####: 1092:	  qsort (costlookup,
        -: 1093:		 sizeof(costlookup)/sizeof(costlookup[0]),
        -: 1094:		 sizeof(costlookup[0]),
        -: 1095:		 cost_table_comparison);
        -: 1096:
    #####: 1097:	  if (!check_sorted (costlookup,
        -: 1098:			     sizeof(costlookup)/sizeof(costlookup[0]),
        -: 1099:			     sizeof(costlookup[0]),
        -: 1100:			     cost_table_comparison))
        -: 1101:	    {
    #####: 1102:	      error (EXIT_FAILURE, 0,
        -: 1103:		     "failed to sort the costlookup array");
        -: 1104:	    }
    #####: 1105:	  pred_table_sorted = 1;
        -: 1106:	}
    #####: 1107:      key.fn = p->pred_func;
    #####: 1108:      entry = bsearch (&key, costlookup,
        -: 1109:		       sizeof(costlookup)/sizeof(costlookup[0]),
        -: 1110:		       sizeof(costlookup[0]),
        -: 1111:		       cost_table_comparison);
    #####: 1112:      if (entry)
        -: 1113:	{
    #####: 1114:	  inherent_cost = ((const struct pred_cost_lookup*)entry)->cost;
        -: 1115:	}
        -: 1116:      else
        -: 1117:	{
        -: 1118:	  /* This message indicates a bug.  If we issue the message, we
        -: 1119:	     actually have two bugs: if find emits a diagnostic, its result
        -: 1120:	     should be nonzero.  However, not having an entry for a predicate
        -: 1121:	     will not affect the output (just the performance) so I think it
        -: 1122:	     would be confusing to exit with a nonzero status.
        -: 1123:	  */
    #####: 1124:	  error (0, 0,
        -: 1125:		 _("warning: there is no entry in the predicate evaluation "
        -: 1126:		   "cost table for predicate %s; please report this as a bug"),
        -: 1127:		 p->p_name);
    #####: 1128:	  inherent_cost = NeedsUnknown;
        -: 1129:	}
        -: 1130:    }
        -: 1131:
    #####: 1132:  if (inherent_cost > data_requirement_cost)
    #####: 1133:    return inherent_cost;
        -: 1134:  else
    #####: 1135:    return data_requirement_cost;
        -: 1136:}
        -: 1137:
        -: 1138:static void
    #####: 1139:estimate_costs (struct predicate *tree)
        -: 1140:{
    #####: 1141:  if (tree)
        -: 1142:    {
    #####: 1143:      estimate_costs (tree->pred_right);
    #####: 1144:      estimate_costs (tree->pred_left);
        -: 1145:
    #####: 1146:      tree->p_cost = get_pred_cost(tree);
        -: 1147:    }
    #####: 1148:}
        -: 1149:
        -: 1150:struct predicate*
    #####: 1151:get_eval_tree (void)
        -: 1152:{
    #####: 1153:  return eval_tree;
        -: 1154:}
        -: 1155:
        -: 1156:static float
    #####: 1157:getrate (const struct predicate *p)
        -: 1158:{
    #####: 1159:  if (p)
    #####: 1160:    return p->est_success_rate;
        -: 1161:  else
    #####: 1162:    return 1.0f;
        -: 1163:}
        -: 1164:
        -: 1165:
        -: 1166:float
    #####: 1167:calculate_derived_rates (struct predicate *p)
        -: 1168:{
    #####: 1169:  assert (NULL != p);
        -: 1170:
    #####: 1171:  if (p->pred_right)
    #####: 1172:    calculate_derived_rates (p->pred_right);
    #####: 1173:  if (p->pred_left)
    #####: 1174:    calculate_derived_rates (p->pred_left);
        -: 1175:
    #####: 1176:  assert (p->p_type != CLOSE_PAREN);
    #####: 1177:  assert (p->p_type != OPEN_PAREN);
        -: 1178:
    #####: 1179:  switch (p->p_type)
        -: 1180:    {
        -: 1181:    case NO_TYPE:
    #####: 1182:      assert (NULL == p->pred_right);
    #####: 1183:      assert (NULL == p->pred_left);
    #####: 1184:      return p->est_success_rate;
        -: 1185:
        -: 1186:    case PRIMARY_TYPE:
    #####: 1187:      assert (NULL == p->pred_right);
    #####: 1188:      assert (NULL == p->pred_left);
    #####: 1189:      return p->est_success_rate;
        -: 1190:
        -: 1191:    case UNI_OP:
        -: 1192:      /* Unary operators must have exactly one operand */
    #####: 1193:      assert (pred_is (p, pred_negate));
    #####: 1194:      assert (NULL == p->pred_left);
    #####: 1195:      p->est_success_rate = (1.0 - p->pred_right->est_success_rate);
    #####: 1196:      return p->est_success_rate;
        -: 1197:
        -: 1198:    case BI_OP:
        -: 1199:      {
        -: 1200:	float rate;
        -: 1201:	/* Binary operators must have two operands */
    #####: 1202:	if (pred_is (p, pred_and))
        -: 1203:	  {
    #####: 1204:	    rate = getrate (p->pred_right) * getrate(p->pred_left);
        -: 1205:	  }
    #####: 1206:	else if (pred_is (p, pred_comma))
        -: 1207:	  {
    #####: 1208:	    rate = 1.0f;
        -: 1209:	  }
    #####: 1210:	else if (pred_is (p, pred_or))
        -: 1211:	  {
    #####: 1212:	    rate = getrate (p->pred_right) + getrate(p->pred_left);
        -: 1213:	  }
        -: 1214:	else
        -: 1215:	  {
        -: 1216:	    /* only and, or and comma are BI_OP. */
    #####: 1217:	    assert (0);
        -: 1218:	    abort ();
        -: 1219:	  }
    #####: 1220:	p->est_success_rate = constrain_rate (rate);
        -: 1221:      }
    #####: 1222:      return p->est_success_rate;
        -: 1223:
        -: 1224:    case OPEN_PAREN:
        -: 1225:    case CLOSE_PAREN:
    #####: 1226:      p->est_success_rate = 1.0;
    #####: 1227:      return p->est_success_rate;
        -: 1228:    }
    #####: 1229:  assert (0);
        -: 1230:  abort ();
        -: 1231:}
        -: 1232:
        -: 1233:/* opt_expr() rearranges predicates such that each left subtree is
        -: 1234: * rooted at a logical predicate (e.g. and or or).  check_normalization()
        -: 1235: * asserts that this property still holds.
        -: 1236: *
        -: 1237: */
        -: 1238:static void
    #####: 1239:check_normalization (struct predicate *p, bool at_root)
        -: 1240:{
    #####: 1241:  if (at_root)
        -: 1242:    {
    #####: 1243:      assert (BI_OP == p->p_type);
        -: 1244:    }
        -: 1245:
    #####: 1246:  if (p->pred_left)
        -: 1247:    {
    #####: 1248:      assert (BI_OP == p->pred_left->p_type);
    #####: 1249:      check_normalization(p->pred_left, false);
        -: 1250:    }
    #####: 1251:  if (p->pred_right)
        -: 1252:    {
    #####: 1253:      check_normalization (p->pred_right, false);
        -: 1254:    }
    #####: 1255:}
        -: 1256:
        -: 1257:struct predicate*
       17: 1258:build_expression_tree (int argc, char *argv[], int end_of_leading_options)
        -: 1259:{
        -: 1260:  const struct parser_table *parse_entry; /* Pointer to the parsing table entry for this expression. */
        -: 1261:  char *predicate_name;		/* Name of predicate being parsed. */
        -: 1262:  struct predicate *cur_pred;
        -: 1263:  const struct parser_table *entry_close, *entry_print, *entry_open;
        -: 1264:  int i, oldi;
        -: 1265:
       17: 1266:  predicates = NULL;
        -: 1267:
        -: 1268:  /* Find where in ARGV the predicates begin by skipping the list of
        -: 1269:   * start points.  As a side effect, also figure out which is the
        -: 1270:   * first and last start point.
        -: 1271:   */
       17: 1272:  start_points = argv + end_of_leading_options;
       33: 1273:  for (i = end_of_leading_options; i < argc && !looks_like_expression(argv[i], true); i++)
        -: 1274:    {
       16: 1275:      ++num_start_points;
        -: 1276:    }
        -: 1277:
        -: 1278:  /* Enclose the expression in `( ... )' so a default -print will
        -: 1279:     apply to the whole expression. */
       17: 1280:  entry_open  = find_parser ("(");
       17: 1281:  entry_close = find_parser (")");
       17: 1282:  entry_print = find_parser ("print");
       17: 1283:  assert (entry_open  != NULL);
       17: 1284:  assert (entry_close != NULL);
       17: 1285:  assert (entry_print != NULL);
        -: 1286:
       17: 1287:  parse_openparen (entry_open, argv, &argc);
       17: 1288:  last_pred->p_name = "(";
       17: 1289:  predicates->artificial = true;
       17: 1290:  parse_begin_user_args (argv, argc, last_pred, predicates);
       17: 1291:  pred_sanity_check (last_pred);
        -: 1292:
        -: 1293:  /* Build the input order list. */
       34: 1294:  while (i < argc )
        -: 1295:    {
       17: 1296:      state.already_issued_stat_error_msg = false;
       17: 1297:      if (!looks_like_expression (argv[i], false))
        -: 1298:	{
    #####: 1299:	  error (0, 0, _("paths must precede expression: %s"), argv[i]);
    #####: 1300:	  usage (stderr, 1, NULL);
        -: 1301:	}
        -: 1302:
       17: 1303:      predicate_name = argv[i];
       17: 1304:      parse_entry = find_parser (predicate_name);
       17: 1305:      if (parse_entry == NULL)
        -: 1306:	{
        -: 1307:	  /* Command line option not recognized */
    #####: 1308:	  error (EXIT_FAILURE, 0, _("unknown predicate `%s'"), predicate_name);
        -: 1309:	}
        -: 1310:
        -: 1311:      /* We have recognised a test of the form -foo.  Eat that,
        -: 1312:       * unless it is a predicate like -newerXY.
        -: 1313:       */
       17: 1314:      if (parse_entry->type != ARG_SPECIAL_PARSE)
        -: 1315:	{
       17: 1316:	  i++;
        -: 1317:	}
       17: 1318:      oldi = i;
       17: 1319:      if (!(*(parse_entry->parser_func)) (parse_entry, argv, &i))
        -: 1320:	{
    #####: 1321:	  if (argv[i])
        -: 1322:	    {
    #####: 1323:	      if ( (ARG_SPECIAL_PARSE == parse_entry->type) && (i == oldi) )
        -: 1324:		{
        -: 1325:		  /* The special parse function spat out the
        -: 1326:		   * predicate.  It must be invalid, or not tasty.
        -: 1327:		   */
    #####: 1328:		  error (EXIT_FAILURE, 0, _("invalid predicate `%s'"),
        -: 1329:			 predicate_name);
        -: 1330:		}
        -: 1331:	      else
        -: 1332:		{
    #####: 1333:		  error (EXIT_FAILURE, 0, _("invalid argument `%s' to `%s'"),
    #####: 1334:			 argv[i], predicate_name);
        -: 1335:		}
        -: 1336:	    }
        -: 1337:	  else
        -: 1338:	    {
        -: 1339:	      /* Command line option requires an argument */
    #####: 1340:	      error (EXIT_FAILURE, 0,
        -: 1341:		     _("missing argument to `%s'"), predicate_name);
        -: 1342:	    }
        -: 1343:	}
        -: 1344:      else
        -: 1345:	{
    #####: 1346:	  last_pred->p_name = predicate_name;
        -: 1347:
        -: 1348:	  /* If the parser consumed an argument, save it. */
    #####: 1349:	  if (i != oldi)
    #####: 1350:	    last_pred->arg_text = argv[oldi];
        -: 1351:	  else
    #####: 1352:	    last_pred->arg_text = NULL;
        -: 1353:	}
    #####: 1354:      pred_sanity_check(last_pred);
    #####: 1355:      pred_sanity_check(predicates); /* XXX: expensive */
        -: 1356:    }
    #####: 1357:  parse_end_user_args (argv, argc, last_pred, predicates);
    #####: 1358:  if (predicates->pred_next == NULL)
        -: 1359:    {
        -: 1360:      /* No predicates that do something other than set a global variable
        -: 1361:	 were given; remove the unneeded initial `(' and add `-print'. */
    #####: 1362:      cur_pred = predicates;
    #####: 1363:      predicates = last_pred = predicates->pred_next;
    #####: 1364:      free (cur_pred);
    #####: 1365:      parse_print (entry_print, argv, &argc);
    #####: 1366:      last_pred->p_name = "-print";
    #####: 1367:      pred_sanity_check(last_pred);
    #####: 1368:      pred_sanity_check(predicates); /* XXX: expensive */
        -: 1369:    }
    #####: 1370:  else if (!default_prints (predicates->pred_next))
        -: 1371:    {
        -: 1372:      /* One or more predicates that produce output were given;
        -: 1373:	 remove the unneeded initial `('. */
    #####: 1374:      cur_pred = predicates;
    #####: 1375:      predicates = predicates->pred_next;
    #####: 1376:      pred_sanity_check (predicates); /* XXX: expensive */
    #####: 1377:      free (cur_pred);
        -: 1378:    }
        -: 1379:  else
        -: 1380:    {
        -: 1381:      /* `( user-supplied-expression ) -print'. */
    #####: 1382:      parse_closeparen (entry_close, argv, &argc);
    #####: 1383:      last_pred->p_name = ")";
    #####: 1384:      last_pred->artificial = true;
    #####: 1385:      pred_sanity_check (last_pred);
    #####: 1386:      parse_print (entry_print, argv, &argc);
    #####: 1387:      last_pred->p_name = "-print";
    #####: 1388:      last_pred->artificial = true;
    #####: 1389:      pred_sanity_check (last_pred);
    #####: 1390:      pred_sanity_check (predicates); /* XXX: expensive */
        -: 1391:    }
        -: 1392:
    #####: 1393:  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))
        -: 1394:    {
    #####: 1395:      fprintf (stderr, "Predicate List:\n");
    #####: 1396:      print_list (stderr, predicates);
        -: 1397:    }
        -: 1398:
        -: 1399:  /* do a sanity check */
    #####: 1400:  check_option_combinations (predicates);
    #####: 1401:  pred_sanity_check (predicates);
        -: 1402:
        -: 1403:  /* Done parsing the predicates.  Build the evaluation tree. */
    #####: 1404:  cur_pred = predicates;
    #####: 1405:  eval_tree = get_expr (&cur_pred, NO_PREC, NULL);
    #####: 1406:  calculate_derived_rates (eval_tree);
        -: 1407:
        -: 1408:  /* Check if we have any left-over predicates (this fixes
        -: 1409:   * Debian bug #185202).
        -: 1410:   */
    #####: 1411:  if (cur_pred != NULL)
        -: 1412:    {
        -: 1413:      /* cur_pred->p_name is often NULL here */
    #####: 1414:      if (pred_is (cur_pred, pred_closeparen))
        -: 1415:	{
        -: 1416:	  /* e.g. "find \( -true \) \)" */
    #####: 1417:	  error (EXIT_FAILURE, 0, _("you have too many ')'"));
        -: 1418:	}
        -: 1419:      else
        -: 1420:	{
    #####: 1421:	  if (cur_pred->p_name)
    #####: 1422:	    error (EXIT_FAILURE, 0,
    #####: 1423:		   _("unexpected extra predicate '%s'"), cur_pred->p_name);
        -: 1424:	  else
    #####: 1425:	    error (EXIT_FAILURE, 0, _("unexpected extra predicate"));
        -: 1426:	}
        -: 1427:    }
        -: 1428:
    #####: 1429:  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))
        -: 1430:    {
    #####: 1431:      fprintf (stderr, "Eval Tree:\n");
    #####: 1432:      print_tree (stderr, eval_tree, 0);
        -: 1433:    }
        -: 1434:
    #####: 1435:  estimate_costs (eval_tree);
        -: 1436:
        -: 1437:  /* Rearrange the eval tree in optimal-predicate order. */
    #####: 1438:  opt_expr (&eval_tree);
        -: 1439:
        -: 1440:  /* Check that the tree is in normalised order (opt_expr does this) */
    #####: 1441:  check_normalization (eval_tree, true);
        -: 1442:
    #####: 1443:  do_arm_swaps (eval_tree);
        -: 1444:
        -: 1445:  /* Check that the tree is still in normalised order */
    #####: 1446:  check_normalization (eval_tree, true);
        -: 1447:
    #####: 1448:  if (options.debug_options & (DebugExpressionTree|DebugTreeOpt))
        -: 1449:    {
    #####: 1450:      fprintf (stderr, "Optimized Eval Tree:\n");
    #####: 1451:      print_tree (stderr, eval_tree, 0);
    #####: 1452:      fprintf (stderr, "Optimized command line:\n");
    #####: 1453:      print_optlist (stderr, eval_tree);
    #####: 1454:      fprintf (stderr, "\n");
        -: 1455:    }
        -: 1456:
    #####: 1457:  return eval_tree;
        -: 1458:}
        -: 1459:
        -: 1460:/* Initialise the performance data for a predicate.
        -: 1461: */
        -: 1462:static void
       17: 1463:init_pred_perf (struct predicate *pred)
        -: 1464:{
       17: 1465:  struct predicate_performance_info *p = &pred->perf;
       17: 1466:  p->visits = p->successes = 0;
       17: 1467:}
        -: 1468:
        -: 1469:
        -: 1470:struct predicate *
    #####: 1471:get_new_pred_noarg (const struct parser_table *entry)
        -: 1472:{
    #####: 1473:  struct predicate *p = get_new_pred (entry);
    #####: 1474:  if (p)
        -: 1475:    {
    #####: 1476:      p->arg_text = NULL;
        -: 1477:    }
    #####: 1478:  return p;
        -: 1479:}
        -: 1480:
        -: 1481:
        -: 1482:/* Return a pointer to a new predicate structure, which has been
        -: 1483:   linked in as the last one in the predicates list.
        -: 1484:
        -: 1485:   Set `predicates' to point to the start of the predicates list.
        -: 1486:   Set `last_pred' to point to the new last predicate in the list.
        -: 1487:
        -: 1488:   Set all cells in the new structure to the default values. */
        -: 1489:
        -: 1490:struct predicate *
       17: 1491:get_new_pred (const struct parser_table *entry)
        -: 1492:{
        -: 1493:  register struct predicate *new_pred;
        -: 1494:  (void) entry;
        -: 1495:
        -: 1496:  /* Options should not be turned into predicates. */
       17: 1497:  assert (entry->type != ARG_OPTION);
       17: 1498:  assert (entry->type != ARG_POSITIONAL_OPTION);
        -: 1499:
       17: 1500:  if (predicates == NULL)
        -: 1501:    {
       17: 1502:      predicates = (struct predicate *)
       17: 1503:	xmalloc (sizeof (struct predicate));
       17: 1504:      last_pred = predicates;
        -: 1505:    }
        -: 1506:  else
        -: 1507:    {
    #####: 1508:      new_pred = xmalloc (sizeof (struct predicate));
    #####: 1509:      last_pred->pred_next = new_pred;
    #####: 1510:      last_pred = new_pred;
        -: 1511:    }
       17: 1512:  last_pred->parser_entry = entry;
       17: 1513:  last_pred->pred_func = NULL;
       17: 1514:  last_pred->p_name = NULL;
       17: 1515:  last_pred->p_type = NO_TYPE;
       17: 1516:  last_pred->p_prec = NO_PREC;
       17: 1517:  last_pred->side_effects = false;
       17: 1518:  last_pred->no_default_print = false;
       17: 1519:  last_pred->need_stat = true;
       17: 1520:  last_pred->need_type = true;
       17: 1521:  last_pred->need_inum = false;
       17: 1522:  last_pred->p_cost = NeedsUnknown;
       17: 1523:  last_pred->arg_text = "ThisShouldBeSetToSomethingElse";
       17: 1524:  last_pred->args.str = NULL;
       17: 1525:  last_pred->args.scontext = NULL;
       17: 1526:  last_pred->pred_next = NULL;
       17: 1527:  last_pred->pred_left = NULL;
       17: 1528:  last_pred->pred_right = NULL;
       17: 1529:  last_pred->literal_control_chars = options.literal_control_chars;
       17: 1530:  last_pred->artificial = false;
       17: 1531:  last_pred->est_success_rate = 1.0;
       17: 1532:  init_pred_perf (last_pred);
       17: 1533:  return last_pred;
        -: 1534:}
        -: 1535:
        -: 1536:/* Return a pointer to a new predicate, with operator check.
        -: 1537:   Like get_new_pred, but it checks to make sure that the previous
        -: 1538:   predicate is an operator.  If it isn't, the AND operator is inserted. */
        -: 1539:
        -: 1540:struct predicate *
       17: 1541:get_new_pred_chk_op (const struct parser_table *entry,
        -: 1542:		     const char *arg)
        -: 1543:{
        -: 1544:  struct predicate *new_pred;
        -: 1545:  static const struct parser_table *entry_and = NULL;
        -: 1546:
        -: 1547:  /* Locate the entry in the parser table for the "and" operator */
       17: 1548:  if (NULL == entry_and)
       17: 1549:    entry_and = find_parser ("and");
        -: 1550:
        -: 1551:  /* Check that it's actually there. If not, that is a bug.*/
       17: 1552:  assert (entry_and != NULL);
        -: 1553:
       17: 1554:  if (last_pred)
    #####: 1555:    switch (last_pred->p_type)
        -: 1556:      {
        -: 1557:      case NO_TYPE:
    #####: 1558:	error (EXIT_FAILURE, 0, _("oops -- invalid default insertion of and!"));
    #####: 1559:	break;
        -: 1560:
        -: 1561:      case PRIMARY_TYPE:
        -: 1562:      case CLOSE_PAREN:
        -: 1563:	/* We need to interpose the and operator. */
    #####: 1564:	new_pred = get_new_pred_noarg (entry_and);
    #####: 1565:	new_pred->pred_func = pred_and;
    #####: 1566:	new_pred->p_name = "-a";
    #####: 1567:	new_pred->p_type = BI_OP;
    #####: 1568:	new_pred->p_prec = AND_PREC;
    #####: 1569:	new_pred->need_stat = false;
    #####: 1570:	new_pred->need_type = false;
    #####: 1571:	new_pred->need_inum = false;
    #####: 1572:	new_pred->arg_text = NULL;
    #####: 1573:	new_pred->args.str = NULL;
    #####: 1574:	new_pred->side_effects = false;
    #####: 1575:	new_pred->no_default_print = false;
    #####: 1576:	break;
        -: 1577:
        -: 1578:      default:
    #####: 1579:	break;
        -: 1580:      }
        -: 1581:
       17: 1582:  new_pred = get_new_pred (entry);
       17: 1583:  new_pred->arg_text = arg;
       17: 1584:  new_pred->parser_entry = entry;
       17: 1585:  return new_pred;
        -: 1586:}
        -: 1587:
        -: 1588:struct cost_assoc
        -: 1589:{
        -: 1590:  enum EvaluationCost cost;
        -: 1591:  char *name;
        -: 1592:};
        -: 1593:struct cost_assoc cost_table[] =
        -: 1594:  {
        -: 1595:    { NeedsNothing,         "Nothing" },
        -: 1596:    { NeedsInodeNumber,     "InodeNumber" },
        -: 1597:    { NeedsType,            "Type" },
        -: 1598:    { NeedsStatInfo,        "StatInfo" },
        -: 1599:    { NeedsLinkName,        "LinkName" },
        -: 1600:    { NeedsAccessInfo,      "AccessInfo" },
        -: 1601:    { NeedsSyncDiskHit,     "SyncDiskHit" },
        -: 1602:    { NeedsEventualExec,    "EventualExec" },
        -: 1603:    { NeedsImmediateExec,   "ImmediateExec" },
        -: 1604:    { NeedsUserInteraction, "UserInteraction" },
        -: 1605:    { NeedsUnknown,         "Unknown" }
        -: 1606:  };
        -: 1607:
        -: 1608:struct prec_assoc
        -: 1609:{
        -: 1610:  short prec;
        -: 1611:  char *prec_name;
        -: 1612:};
        -: 1613:
        -: 1614:static struct prec_assoc prec_table[] =
        -: 1615:{
        -: 1616:  {NO_PREC, "no"},
        -: 1617:  {COMMA_PREC, "comma"},
        -: 1618:  {OR_PREC, "or"},
        -: 1619:  {AND_PREC, "and"},
        -: 1620:  {NEGATE_PREC, "negate"},
        -: 1621:  {MAX_PREC, "max"},
        -: 1622:  {-1, "unknown "}
        -: 1623:};
        -: 1624:
        -: 1625:struct op_assoc
        -: 1626:{
        -: 1627:  short type;
        -: 1628:  char *type_name;
        -: 1629:};
        -: 1630:
        -: 1631:static struct op_assoc type_table[] =
        -: 1632:{
        -: 1633:  {NO_TYPE,      "no"},
        -: 1634:  {PRIMARY_TYPE, "primary"},
        -: 1635:  {UNI_OP,       "uni_op"},
        -: 1636:  {BI_OP,        "bi_op"},
        -: 1637:  {OPEN_PAREN,   "open_paren  "},
        -: 1638:  {CLOSE_PAREN,  "close_paren "},
        -: 1639:  {-1,           "unknown"}
        -: 1640:};
        -: 1641:
        -: 1642:static const char *
    #####: 1643:cost_name (enum EvaluationCost cost)
        -: 1644:{
        -: 1645:  unsigned int i;
    #####: 1646:  unsigned int n = sizeof (cost_table)/sizeof(cost_table[0]);
        -: 1647:
    #####: 1648:  for (i = 0; i<n; ++i)
    #####: 1649:    if (cost_table[i].cost == cost)
    #####: 1650:      return cost_table[i].name;
    #####: 1651:  return "unknown";
        -: 1652:}
        -: 1653:
        -: 1654:
        -: 1655:static char *
    #####: 1656:type_name (type)
        -: 1657:     short type;
        -: 1658:{
        -: 1659:  int i;
        -: 1660:
    #####: 1661:  for (i = 0; type_table[i].type != (short) -1; i++)
    #####: 1662:    if (type_table[i].type == type)
    #####: 1663:      break;
    #####: 1664:  return (type_table[i].type_name);
        -: 1665:}
        -: 1666:
        -: 1667:static char *
    #####: 1668:prec_name (prec)
        -: 1669:     short prec;
        -: 1670:{
        -: 1671:  int i;
        -: 1672:
    #####: 1673:  for (i = 0; prec_table[i].prec != (short) -1; i++)
    #####: 1674:    if (prec_table[i].prec == prec)
    #####: 1675:      break;
    #####: 1676:  return (prec_table[i].prec_name);
        -: 1677:}
        -: 1678:
        -: 1679:
        -: 1680:/* Walk the expression tree NODE to stdout.
        -: 1681:   INDENT is the number of levels to indent the left margin. */
        -: 1682:
        -: 1683:void
    #####: 1684:print_tree (FILE *fp, struct predicate *node, int indent)
        -: 1685:{
        -: 1686:  int i;
        -: 1687:
    #####: 1688:  if (node == NULL)
    #####: 1689:    return;
    #####: 1690:  for (i = 0; i < indent; i++)
    #####: 1691:    fprintf (fp, "    ");
    #####: 1692:  fprintf (fp, "pred=[");
    #####: 1693:  print_predicate (fp, node);
    #####: 1694:  fprintf (fp, "] type=%s prec=%s",
    #####: 1695:	  type_name (node->p_type), prec_name (node->p_prec));
    #####: 1696:  fprintf (fp, " cost=%s rate=%#03.2g %sside effects ",
        -: 1697:	   cost_name (node->p_cost),
    #####: 1698:	   node->est_success_rate,
    #####: 1699:	   (node->side_effects ? "" : "no "));
        -: 1700:
    #####: 1701:  if (node->need_stat || node->need_type || node->need_inum)
        -: 1702:    {
    #####: 1703:      int comma = 0;
        -: 1704:
    #####: 1705:      fprintf (fp, "Needs ");
    #####: 1706:      if (node->need_stat)
        -: 1707:	{
    #####: 1708:	  fprintf (fp, "stat");
    #####: 1709:	  comma = 1;
        -: 1710:	}
    #####: 1711:      if (node->need_inum)
        -: 1712:	{
    #####: 1713:	  fprintf (fp, "%sinode", comma ? "," : "");
    #####: 1714:	  comma = 1;
        -: 1715:	}
    #####: 1716:      if (node->need_type)
        -: 1717:	{
    #####: 1718:	  fprintf (fp, "%stype", comma ? "," : "");
        -: 1719:	}
        -: 1720:    }
    #####: 1721:  fprintf (fp, "\n");
        -: 1722:
        -: 1723:
    #####: 1724:  for (i = 0; i < indent; i++)
    #####: 1725:    fprintf (fp, "    ");
    #####: 1726:  if (NULL == node->pred_left && NULL == node->pred_right)
        -: 1727:    {
    #####: 1728:      fprintf (fp, "no children.\n");
        -: 1729:    }
        -: 1730:  else
        -: 1731:    {
    #####: 1732:      if (node->pred_left)
        -: 1733:	{
    #####: 1734:	  fprintf (fp, "left:\n");
    #####: 1735:	  print_tree (fp, node->pred_left, indent + 1);
        -: 1736:	}
        -: 1737:      else
        -: 1738:	{
    #####: 1739:	  fprintf (fp, "no left.\n");
        -: 1740:	}
        -: 1741:
    #####: 1742:      for (i = 0; i < indent; i++)
    #####: 1743:	fprintf (fp, "    ");
    #####: 1744:      if (node->pred_right)
        -: 1745:	{
    #####: 1746:	  fprintf (fp, "right:\n");
    #####: 1747:	  print_tree (fp, node->pred_right, indent + 1);
        -: 1748:	}
        -: 1749:      else
        -: 1750:	{
    #####: 1751:	  fprintf (fp, "no right.\n");
        -: 1752:	}
        -: 1753:    }
        -: 1754:}
