        -:    0:Source:pred.c
        -:    0:Graph:pred.gcno
        -:    0:Data:pred.gcda
        -:    0:Runs:9
        -:    0:Programs:2
        -:    1:/* pred.c -- execute the expression tree.
        -:    2:   Copyright (C) 1990, 1991, 1992, 1993, 1994, 2000, 2003,
        -:    3:                 2004, 2005, 2006, 2007, 2008, 2009,
        -:    4:                 2010 Free Software Foundation, Inc.
        -:    5:
        -:    6:   This program is free software: you can redistribute it and/or modify
        -:    7:   it under the terms of the GNU General Public License as published by
        -:    8:   the Free Software Foundation, either version 3 of the License, or
        -:    9:   (at your option) any later version.
        -:   10:
        -:   11:   This program is distributed in the hope that it will be useful,
        -:   12:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:   GNU General Public License for more details.
        -:   15:
        -:   16:   You should have received a copy of the GNU General Public License
        -:   17:   along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   18:*/
        -:   19:
        -:   20:#include <config.h>
        -:   21:#include "defs.h"
        -:   22:
        -:   23:#include <fnmatch.h>
        -:   24:#include <signal.h>
        -:   25:#include <math.h>
        -:   26:#include <pwd.h>
        -:   27:#include <grp.h>
        -:   28:#include <sys/types.h>
        -:   29:#include <sys/stat.h>
        -:   30:#include <errno.h>
        -:   31:#include <assert.h>
        -:   32:#include <stdarg.h>
        -:   33:#include <fcntl.h>
        -:   34:#include <locale.h>
        -:   35:#include <ctype.h>
        -:   36:#include <unistd.h> /* for unlinkat() */
        -:   37:#include "xalloc.h"
        -:   38:#include "dirname.h"
        -:   39:#include "human.h"
        -:   40:#include "filemode.h"
        -:   41:#include "printquoted.h"
        -:   42:#include "buildcmd.h"
        -:   43:#include "yesno.h"
        -:   44:#include "listfile.h"
        -:   45:#include "stat-time.h"
        -:   46:#include "dircallback.h"
        -:   47:#include "error.h"
        -:   48:#include "verify.h"
        -:   49:#include "fdleak.h"
        -:   50:#include "areadlink.h"
        -:   51:#include "cloexec.h"
        -:   52:#include "save-cwd.h"
        -:   53:
        -:   54:#include <selinux/selinux.h>
        -:   55:
        -:   56:#if ENABLE_NLS
        -:   57:# include <libintl.h>
        -:   58:# define _(Text) gettext (Text)
        -:   59:#else
        -:   60:# define _(Text) Text
        -:   61:#endif
        -:   62:#ifdef gettext_noop
        -:   63:# define N_(String) gettext_noop (String)
        -:   64:#else
        -:   65:/* See locate.c for explanation as to why not use (String) */
        -:   66:# define N_(String) String
        -:   67:#endif
        -:   68:
        -:   69:#if !defined(SIGCHLD) && defined(SIGCLD)
        -:   70:#define SIGCHLD SIGCLD
        -:   71:#endif
        -:   72:
        -:   73:
        -:   74:#include <sys/wait.h>
        -:   75:
        -:   76:#if HAVE_DIRENT_H
        -:   77:# include <dirent.h>
        -:   78:# define NAMLEN(dirent) strlen((dirent)->d_name)
        -:   79:#else
        -:   80:# define dirent direct
        -:   81:# define NAMLEN(dirent) (dirent)->d_namlen
        -:   82:# if HAVE_SYS_NDIR_H
        -:   83:#  include <sys/ndir.h>
        -:   84:# endif
        -:   85:# if HAVE_SYS_DIR_H
        -:   86:#  include <sys/dir.h>
        -:   87:# endif
        -:   88:# if HAVE_NDIR_H
        -:   89:#  include <ndir.h>
        -:   90:# endif
        -:   91:#endif
        -:   92:
        -:   93:#ifdef CLOSEDIR_VOID
        -:   94:/* Fake a return value. */
        -:   95:#define CLOSEDIR(d) (closedir (d), 0)
        -:   96:#else
        -:   97:#define CLOSEDIR(d) closedir (d)
        -:   98:#endif
        -:   99:
        -:  100:
        -:  101:
        -:  102:
        -:  103:/* Get or fake the disk device blocksize.
        -:  104:   Usually defined by sys/param.h (if at all).  */
        -:  105:#ifndef DEV_BSIZE
        -:  106:# ifdef BSIZE
        -:  107:#  define DEV_BSIZE BSIZE
        -:  108:# else /* !BSIZE */
        -:  109:#  define DEV_BSIZE 4096
        -:  110:# endif /* !BSIZE */
        -:  111:#endif /* !DEV_BSIZE */
        -:  112:
        -:  113:/* Extract or fake data from a `struct stat'.
        -:  114:   ST_BLKSIZE: Preferred I/O blocksize for the file, in bytes.
        -:  115:   ST_NBLOCKS: Number of blocks in the file, including indirect blocks.
        -:  116:   ST_NBLOCKSIZE: Size of blocks used when calculating ST_NBLOCKS.  */
        -:  117:#ifndef HAVE_STRUCT_STAT_ST_BLOCKS
        -:  118:# define ST_BLKSIZE(statbuf) DEV_BSIZE
        -:  119:# if defined _POSIX_SOURCE || !defined BSIZE /* fileblocks.c uses BSIZE.  */
        -:  120:#  define ST_NBLOCKS(statbuf) \
        -:  121:  (S_ISREG ((statbuf).st_mode) \
        -:  122:   || S_ISDIR ((statbuf).st_mode) \
        -:  123:   ? (statbuf).st_size / ST_NBLOCKSIZE + ((statbuf).st_size % ST_NBLOCKSIZE != 0) : 0)
        -:  124:# else /* !_POSIX_SOURCE && BSIZE */
        -:  125:#  define ST_NBLOCKS(statbuf) \
        -:  126:  (S_ISREG ((statbuf).st_mode) \
        -:  127:   || S_ISDIR ((statbuf).st_mode) \
        -:  128:   ? st_blocks ((statbuf).st_size) : 0)
        -:  129:# endif /* !_POSIX_SOURCE && BSIZE */
        -:  130:#else /* HAVE_STRUCT_STAT_ST_BLOCKS */
        -:  131:/* Some systems, like Sequents, return st_blksize of 0 on pipes. */
        -:  132:# define ST_BLKSIZE(statbuf) ((statbuf).st_blksize > 0 \
        -:  133:			       ? (statbuf).st_blksize : DEV_BSIZE)
        -:  134:# if defined hpux || defined __hpux__ || defined __hpux
        -:  135:/* HP-UX counts st_blocks in 1024-byte units.
        -:  136:   This loses when mixing HP-UX and BSD file systems with NFS.  */
        -:  137:#  define ST_NBLOCKSIZE 1024
        -:  138:# else /* !hpux */
        -:  139:#  if defined _AIX && defined _I386
        -:  140:/* AIX PS/2 counts st_blocks in 4K units.  */
        -:  141:#   define ST_NBLOCKSIZE (4 * 1024)
        -:  142:#  else /* not AIX PS/2 */
        -:  143:#   if defined _CRAY
        -:  144:#    define ST_NBLOCKS(statbuf) \
        -:  145:  (S_ISREG ((statbuf).st_mode) \
        -:  146:   || S_ISDIR ((statbuf).st_mode) \
        -:  147:   ? (statbuf).st_blocks * ST_BLKSIZE(statbuf)/ST_NBLOCKSIZE : 0)
        -:  148:#   endif /* _CRAY */
        -:  149:#  endif /* not AIX PS/2 */
        -:  150:# endif /* !hpux */
        -:  151:#endif /* HAVE_STRUCT_STAT_ST_BLOCKS */
        -:  152:
        -:  153:#ifndef ST_NBLOCKS
        -:  154:# define ST_NBLOCKS(statbuf) \
        -:  155:  (S_ISREG ((statbuf).st_mode) \
        -:  156:   || S_ISDIR ((statbuf).st_mode) \
        -:  157:   ? (statbuf).st_blocks : 0)
        -:  158:#endif
        -:  159:
        -:  160:#ifndef ST_NBLOCKSIZE
        -:  161:# define ST_NBLOCKSIZE 512
        -:  162:#endif
        -:  163:
        -:  164:
        -:  165:#undef MAX
        -:  166:#define MAX(a, b) ((a) > (b) ? (a) : (b))
        -:  167:
        -:  168:static bool match_lname PARAMS((const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, bool ignore_case));
        -:  169:
        -:  170:static char *format_date PARAMS((struct timespec ts, int kind));
        -:  171:static char *ctime_format PARAMS((struct timespec ts));
        -:  172:
        -:  173:#ifdef	DEBUG
        -:  174:struct pred_assoc
        -:  175:{
        -:  176:  PRED_FUNC pred_func;
        -:  177:  char *pred_name;
        -:  178:};
        -:  179:
        -:  180:struct pred_assoc pred_table[] =
        -:  181:{
        -:  182:  {pred_amin, "amin    "},
        -:  183:  {pred_and, "and     "},
        -:  184:  {pred_anewer, "anewer  "},
        -:  185:  {pred_atime, "atime   "},
        -:  186:  {pred_closeparen, ")       "},
        -:  187:  {pred_cmin, "cmin    "},
        -:  188:  {pred_cnewer, "cnewer  "},
        -:  189:  {pred_comma, ",       "},
        -:  190:  {pred_ctime, "ctime   "},
        -:  191:  {pred_delete, "delete  "},
        -:  192:  {pred_empty, "empty   "},
        -:  193:  {pred_exec, "exec    "},
        -:  194:  {pred_execdir, "execdir "},
        -:  195:  {pred_executable, "executable "},
        -:  196:  {pred_false, "false   "},
        -:  197:  {pred_fprint, "fprint  "},
        -:  198:  {pred_fprint0, "fprint0 "},
        -:  199:  {pred_fprintf, "fprintf "},
        -:  200:  {pred_fstype, "fstype  "},
        -:  201:  {pred_gid, "gid     "},
        -:  202:  {pred_group, "group   "},
        -:  203:  {pred_ilname, "ilname  "},
        -:  204:  {pred_iname, "iname   "},
        -:  205:  {pred_inum, "inum    "},
        -:  206:  {pred_ipath, "ipath   "},
        -:  207:  {pred_links, "links   "},
        -:  208:  {pred_lname, "lname   "},
        -:  209:  {pred_ls, "ls      "},
        -:  210:  {pred_mmin, "mmin    "},
        -:  211:  {pred_mtime, "mtime   "},
        -:  212:  {pred_name, "name    "},
        -:  213:  {pred_negate, "not     "},
        -:  214:  {pred_newer, "newer   "},
        -:  215:  {pred_newerXY, "newerXY   "},
        -:  216:  {pred_nogroup, "nogroup "},
        -:  217:  {pred_nouser, "nouser  "},
        -:  218:  {pred_ok, "ok      "},
        -:  219:  {pred_okdir, "okdir   "},
        -:  220:  {pred_openparen, "(       "},
        -:  221:  {pred_or, "or      "},
        -:  222:  {pred_path, "path    "},
        -:  223:  {pred_perm, "perm    "},
        -:  224:  {pred_print, "print   "},
        -:  225:  {pred_print0, "print0  "},
        -:  226:  {pred_prune, "prune   "},
        -:  227:  {pred_quit, "quit    "},
        -:  228:  {pred_readable, "readable    "},
        -:  229:  {pred_regex, "regex   "},
        -:  230:  {pred_samefile,"samefile "},
        -:  231:  {pred_size, "size    "},
        -:  232:  {pred_true, "true    "},
        -:  233:  {pred_type, "type    "},
        -:  234:  {pred_uid, "uid     "},
        -:  235:  {pred_used, "used    "},
        -:  236:  {pred_user, "user    "},
        -:  237:  {pred_writable, "writable "},
        -:  238:  {pred_xtype, "xtype   "},
        -:  239:  {pred_context, "context"},
        -:  240:  {0, "none    "}
        -:  241:};
        -:  242:#endif
        -:  243:
        -:  244:/* Returns ts1 - ts2 */
    #####:  245:static double ts_difference (struct timespec ts1,
        -:  246:			     struct timespec ts2)
        -:  247:{
    #####:  248:  double d =  difftime (ts1.tv_sec, ts2.tv_sec)
    #####:  249:    + (1.0e-9 * (ts1.tv_nsec - ts2.tv_nsec));
    #####:  250:  return d;
        -:  251:}
        -:  252:
        -:  253:
        -:  254:static int
    #####:  255:compare_ts (struct timespec ts1,
        -:  256:	    struct timespec ts2)
        -:  257:{
    #####:  258:  if ((ts1.tv_sec == ts2.tv_sec) &&
    #####:  259:      (ts1.tv_nsec == ts2.tv_nsec))
        -:  260:    {
    #####:  261:      return 0;
        -:  262:    }
        -:  263:  else
        -:  264:    {
    #####:  265:      double diff = ts_difference (ts1, ts2);
    #####:  266:      return diff < 0.0 ? -1 : +1;
        -:  267:    }
        -:  268:}
        -:  269:
        -:  270:/* Predicate processing routines.
        -:  271:
        -:  272:   PATHNAME is the full pathname of the file being checked.
        -:  273:   *STAT_BUF contains information about PATHNAME.
        -:  274:   *PRED_PTR contains information for applying the predicate.
        -:  275:
        -:  276:   Return true if the file passes this predicate, false if not. */
        -:  277:
        -:  278:
        -:  279:/* pred_timewindow
        -:  280: *
        -:  281: * Returns true if THE_TIME is
        -:  282: * COMP_GT: after the specified time
        -:  283: * COMP_LT: before the specified time
        -:  284: * COMP_EQ: after the specified time but by not more than WINDOW seconds.
        -:  285: */
        -:  286:static bool
    #####:  287:pred_timewindow (struct timespec ts, struct predicate const *pred_ptr, int window)
        -:  288:{
    #####:  289:  switch (pred_ptr->args.reftime.kind)
        -:  290:    {
        -:  291:    case COMP_GT:
    #####:  292:      return compare_ts (ts, pred_ptr->args.reftime.ts) > 0;
        -:  293:
        -:  294:    case COMP_LT:
    #####:  295:      return compare_ts (ts, pred_ptr->args.reftime.ts) < 0;
        -:  296:
        -:  297:    case COMP_EQ:
        -:  298:      {
        -:  299:	/* consider "find . -mtime 0".
        -:  300:	 *
        -:  301:	 * Here, the origin is exactly 86400 seconds before the start
        -:  302:	 * of the program (since -daystart was not specified).   This
        -:  303:	 * function will be called with window=86400 and
        -:  304:	 * pred_ptr->args.reftime.ts as the origin.  Hence a file
        -:  305:	 * created the instant the program starts will show a time
        -:  306:	 * difference (value of delta) of 86400.   Similarly, a file
        -:  307:	 * created exactly 24h ago would be the newest file which was
        -:  308:	 * _not_ created today.   So, if delta is 0.0, the file
        -:  309:	 * was not created today.  If the delta is 86400, the file
        -:  310:	 * was created this instant.
        -:  311:	 */
    #####:  312:	double delta = ts_difference (ts, pred_ptr->args.reftime.ts);
    #####:  313:	return (delta > 0.0 && delta <= window);
        -:  314:      }
        -:  315:    }
    #####:  316:  assert (0);
        -:  317:  abort ();
        -:  318:}
        -:  319:
        -:  320:
        -:  321:bool
    #####:  322:pred_amin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  323:{
        -:  324:  (void) &pathname;
    #####:  325:  return pred_timewindow (get_stat_atime(stat_buf), pred_ptr, 60);
        -:  326:}
        -:  327:
        -:  328:bool
       48:  329:pred_and (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  330:{
       48:  331:  if (pred_ptr->pred_left == NULL
       24:  332:      || apply_predicate (pathname, stat_buf, pred_ptr->pred_left))
        -:  333:    {
       48:  334:      return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -:  335:    }
        -:  336:  else
    #####:  337:    return false;
        -:  338:}
        -:  339:
        -:  340:bool
    #####:  341:pred_anewer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  342:{
        -:  343:  (void) &pathname;
    #####:  344:  assert (COMP_GT == pred_ptr->args.reftime.kind);
    #####:  345:  return compare_ts (get_stat_atime(stat_buf), pred_ptr->args.reftime.ts) > 0;
        -:  346:}
        -:  347:
        -:  348:bool
    #####:  349:pred_atime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  350:{
        -:  351:  (void) &pathname;
    #####:  352:  return pred_timewindow (get_stat_atime(stat_buf), pred_ptr, DAYSECS);
        -:  353:}
        -:  354:
        -:  355:bool
    #####:  356:pred_closeparen (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  357:{
        -:  358:  (void) &pathname;
        -:  359:  (void) &stat_buf;
        -:  360:  (void) &pred_ptr;
        -:  361:
    #####:  362:  return true;
        -:  363:}
        -:  364:
        -:  365:bool
    #####:  366:pred_cmin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  367:{
        -:  368:  (void) pathname;
    #####:  369:  return pred_timewindow (get_stat_ctime(stat_buf), pred_ptr, 60);
        -:  370:}
        -:  371:
        -:  372:bool
    #####:  373:pred_cnewer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  374:{
        -:  375:  (void) pathname;
        -:  376:
    #####:  377:  assert (COMP_GT == pred_ptr->args.reftime.kind);
    #####:  378:  return compare_ts (get_stat_ctime(stat_buf), pred_ptr->args.reftime.ts) > 0;
        -:  379:}
        -:  380:
        -:  381:bool
    #####:  382:pred_comma (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  383:{
    #####:  384:  if (pred_ptr->pred_left != NULL)
        -:  385:    {
    #####:  386:      apply_predicate (pathname, stat_buf,pred_ptr->pred_left);
        -:  387:    }
    #####:  388:  return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -:  389:}
        -:  390:
        -:  391:bool
    #####:  392:pred_ctime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  393:{
        -:  394:  (void) &pathname;
    #####:  395:  return pred_timewindow (get_stat_ctime(stat_buf), pred_ptr, DAYSECS);
        -:  396:}
        -:  397:
        -:  398:static bool
    #####:  399:perform_delete (int flags)
        -:  400:{
    #####:  401:  return 0 == unlinkat (state.cwd_dir_fd, state.rel_pathname, flags);
        -:  402:}
        -:  403:
        -:  404:
        -:  405:bool
    #####:  406:pred_delete (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  407:{
        -:  408:  (void) pred_ptr;
        -:  409:  (void) stat_buf;
    #####:  410:  if (strcmp (state.rel_pathname, "."))
        -:  411:    {
    #####:  412:      int flags=0;
    #####:  413:      if (state.have_stat && S_ISDIR(stat_buf->st_mode))
    #####:  414:	flags |= AT_REMOVEDIR;
    #####:  415:      if (perform_delete (flags))
        -:  416:	{
    #####:  417:	  return true;
        -:  418:	}
        -:  419:      else
        -:  420:	{
    #####:  421:	  if (EISDIR == errno)
        -:  422:	    {
    #####:  423:	      if ((flags & AT_REMOVEDIR) == 0)
        -:  424:		{
        -:  425:		  /* unlink() operation failed because we should have done rmdir(). */
    #####:  426:		  flags |= AT_REMOVEDIR;
    #####:  427:		  if (perform_delete (flags))
    #####:  428:		    return true;
        -:  429:		}
        -:  430:	    }
        -:  431:	}
    #####:  432:      error (0, errno, _("cannot delete %s"),
        -:  433:	     safely_quote_err_filename (0, pathname));
        -:  434:      /* Previously I had believed that having the -delete action
        -:  435:       * return false provided the user with control over whether an
        -:  436:       * error message is issued.  While this is true, the policy of
        -:  437:       * not affecting the exit status is contrary to the POSIX
        -:  438:       * requirement that diagnostic messages are accompanied by a
        -:  439:       * nonzero exit status.  While -delete is not a POSIX option and
        -:  440:       * we can therefore opt not to follow POSIX in this case, that
        -:  441:       * seems somewhat arbitrary and confusing.  So, as of
        -:  442:       * findutils-4.3.11, we also set the exit status in this case.
        -:  443:       */
    #####:  444:      state.exit_status = 1;
    #####:  445:      return false;
        -:  446:    }
        -:  447:  else
        -:  448:    {
        -:  449:      /* nothing to do. */
    #####:  450:      return true;
        -:  451:    }
        -:  452:}
        -:  453:
        -:  454:bool
    #####:  455:pred_empty (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  456:{
        -:  457:  (void) pathname;
        -:  458:  (void) pred_ptr;
        -:  459:
    #####:  460:  if (S_ISDIR (stat_buf->st_mode))
        -:  461:    {
        -:  462:      int fd;
        -:  463:      DIR *d;
        -:  464:      struct dirent *dp;
    #####:  465:      bool empty = true;
        -:  466:
    #####:  467:      errno = 0;
    #####:  468:      if ((fd = openat (state.cwd_dir_fd, state.rel_pathname, O_RDONLY
        -:  469:#if defined O_LARGEFILE
        -:  470:			|O_LARGEFILE
        -:  471:#endif
        -:  472:		       )) < 0)
        -:  473:	{
    #####:  474:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####:  475:	  state.exit_status = 1;
    #####:  476:	  return false;
        -:  477:	}
    #####:  478:      d = fdopendir (fd);
    #####:  479:      if (d == NULL)
        -:  480:	{
    #####:  481:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####:  482:	  state.exit_status = 1;
    #####:  483:	  return false;
        -:  484:	}
    #####:  485:      for (dp = readdir (d); dp; dp = readdir (d))
        -:  486:	{
    #####:  487:	  if (dp->d_name[0] != '.'
    #####:  488:	      || (dp->d_name[1] != '\0'
    #####:  489:		  && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
        -:  490:	    {
    #####:  491:	      empty = false;
    #####:  492:	      break;
        -:  493:	    }
        -:  494:	}
    #####:  495:      if (CLOSEDIR (d))
        -:  496:	{
    #####:  497:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####:  498:	  state.exit_status = 1;
    #####:  499:	  return false;
        -:  500:	}
    #####:  501:      return (empty);
        -:  502:    }
    #####:  503:  else if (S_ISREG (stat_buf->st_mode))
    #####:  504:    return (stat_buf->st_size == 0);
        -:  505:  else
    #####:  506:    return (false);
        -:  507:}
        -:  508:
        -:  509:
        -:  510:static bool
    #####:  511:record_exec_dir (struct exec_val *execp)
        -:  512:{
    #####:  513:  if (!execp->wd_for_exec)
        -:  514:    {
        -:  515:      /* working directory not already known, so must be a *dir variant,
        -:  516:	 and this must be the first arg we added.   However, this may
        -:  517:	 be -execdir foo {} \; (i.e. not multiple).  */
    #####:  518:      assert (!execp->state.todo);
        -:  519:
        -:  520:      /* Record the WD. */
    #####:  521:      execp->wd_for_exec = xmalloc (sizeof (*execp->wd_for_exec));
    #####:  522:      execp->wd_for_exec->name = NULL;
    #####:  523:      execp->wd_for_exec->desc = openat (state.cwd_dir_fd, ".", O_RDONLY);
    #####:  524:      if (execp->wd_for_exec->desc < 0)
    #####:  525:	return false;
    #####:  526:      set_cloexec_flag (execp->wd_for_exec->desc, true);
        -:  527:    }
    #####:  528:  return true;
        -:  529:}
        -:  530:
        -:  531:
        -:  532:static bool
    #####:  533:new_impl_pred_exec (const char *pathname,
        -:  534:		    struct stat *stat_buf,
        -:  535:		    struct predicate *pred_ptr,
        -:  536:		    const char *prefix, size_t pfxlen)
        -:  537:{
    #####:  538:  struct exec_val *execp = &pred_ptr->args.exec_vec;
    #####:  539:  size_t len = strlen (pathname);
        -:  540:
        -:  541:  (void) stat_buf;
        -:  542:
    #####:  543:  if (is_exec_in_local_dir (pred_ptr->pred_func))
        -:  544:    {
        -:  545:      /* For -execdir/-okdir predicates, the parser did not fill in
        -:  546:	 the wd_for_exec member of sturct exec_val.  So for those
        -:  547:	 predicates, we do so now.
        -:  548:      */
    #####:  549:      if (!record_exec_dir (execp))
        -:  550:	{
    #####:  551:	  error (EXIT_FAILURE, errno,
        -:  552:		 _("Failed to save working directory in order to "
        -:  553:		   "run a command on %s"),
        -:  554:		 safely_quote_err_filename (0, pathname));
        -:  555:	  /*NOTREACHED*/
        -:  556:	}
        -:  557:    }
        -:  558:  else
        -:  559:    {
        -:  560:      /* For the others (-exec, -ok), the parder should
        -:  561:	 have set wd_for_exec to initial_wd, indicating
        -:  562:	 that the exec should take place from find's initial
        -:  563:	 working directory.
        -:  564:      */
    #####:  565:      assert (execp->wd_for_exec == initial_wd);
        -:  566:    }
        -:  567:
    #####:  568:  if (execp->multiple)
        -:  569:    {
        -:  570:      /* Push the argument onto the current list.
        -:  571:       * The command may or may not be run at this point,
        -:  572:       * depending on the command line length limits.
        -:  573:       */
    #####:  574:      bc_push_arg (&execp->ctl,
        -:  575:		   &execp->state,
        -:  576:		   pathname, len+1,
        -:  577:		   prefix, pfxlen,
        -:  578:		   0);
        -:  579:
        -:  580:      /* remember that there are pending execdirs. */
    #####:  581:      state.execdirs_outstanding = true;
        -:  582:
        -:  583:      /* POSIX: If the primary expression is punctuated by a plus
        -:  584:       * sign, the primary shall always evaluate as true
        -:  585:       */
    #####:  586:      return true;
        -:  587:    }
        -:  588:  else
        -:  589:    {
        -:  590:      int i;
        -:  591:
    #####:  592:      for (i=0; i<execp->num_args; ++i)
        -:  593:	{
    #####:  594:	  bc_do_insert (&execp->ctl,
        -:  595:			&execp->state,
    #####:  596:			execp->replace_vec[i],
    #####:  597:			strlen (execp->replace_vec[i]),
        -:  598:			prefix, pfxlen,
        -:  599:			pathname, len,
        -:  600:			0);
        -:  601:	}
        -:  602:
        -:  603:      /* Actually invoke the command. */
    #####:  604:      bc_do_exec (&execp->ctl, &execp->state);
    #####:  605:      if (WIFEXITED(execp->last_child_status))
        -:  606:	{
    #####:  607:	  if (0 == WEXITSTATUS(execp->last_child_status))
    #####:  608:	    return true;	/* The child succeeded. */
        -:  609:	  else
    #####:  610:	    return false;
        -:  611:	}
        -:  612:      else
        -:  613:	{
    #####:  614:	  return false;
        -:  615:	}
        -:  616:    }
        -:  617:}
        -:  618:
        -:  619:
        -:  620:bool
    #####:  621:pred_exec (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  622:{
    #####:  623:  return new_impl_pred_exec (pathname, stat_buf, pred_ptr, NULL, 0);
        -:  624:}
        -:  625:
        -:  626:bool
    #####:  627:pred_execdir (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  628:{
    #####:  629:   const char *prefix = (state.rel_pathname[0] == '/') ? NULL : "./";
        -:  630:   (void) &pathname;
    #####:  631:   return new_impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr,
        -:  632:			      prefix, (prefix ? 2 : 0));
        -:  633:}
        -:  634:
        -:  635:bool
    #####:  636:pred_false (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  637:{
        -:  638:  (void) &pathname;
        -:  639:  (void) &stat_buf;
        -:  640:  (void) &pred_ptr;
        -:  641:
        -:  642:
    #####:  643:  return (false);
        -:  644:}
        -:  645:
        -:  646:bool
    #####:  647:pred_fls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  648:{
    #####:  649:  FILE * stream = pred_ptr->args.printf_vec.stream;
    #####:  650:  list_file (pathname, state.cwd_dir_fd, state.rel_pathname, stat_buf,
        -:  651:	     options.start_time.tv_sec,
        -:  652:	     options.output_block_size,
    #####:  653:	     pred_ptr->literal_control_chars, stream);
    #####:  654:  return true;
        -:  655:}
        -:  656:
        -:  657:bool
    #####:  658:pred_fprint (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  659:{
        -:  660:  (void) &pathname;
        -:  661:  (void) &stat_buf;
        -:  662:
    #####:  663:  print_quoted (pred_ptr->args.printf_vec.stream,
    #####:  664:		pred_ptr->args.printf_vec.quote_opts,
    #####:  665:		pred_ptr->args.printf_vec.dest_is_tty,
        -:  666:		"%s\n",
        -:  667:		pathname);
    #####:  668:  return true;
        -:  669:}
        -:  670:
        -:  671:bool
    #####:  672:pred_fprint0 (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  673:{
    #####:  674:  FILE * fp = pred_ptr->args.printf_vec.stream;
        -:  675:
        -:  676:  (void) &stat_buf;
        -:  677:
    #####:  678:  fputs (pathname, fp);
    #####:  679:  putc (0, fp);
    #####:  680:  return true;
        -:  681:}
        -:  682:
        -:  683:
        -:  684:
        -:  685:static char*
    #####:  686:mode_to_filetype (mode_t m)
        -:  687:{
        -:  688:#define HANDLE_TYPE(t,letter) if (m==t) { return letter; }
        -:  689:#ifdef S_IFREG
    #####:  690:  HANDLE_TYPE(S_IFREG,  "f");	/* regular file */
        -:  691:#endif
        -:  692:#ifdef S_IFDIR
    #####:  693:  HANDLE_TYPE(S_IFDIR,  "d");	/* directory */
        -:  694:#endif
        -:  695:#ifdef S_IFLNK
    #####:  696:  HANDLE_TYPE(S_IFLNK,  "l");	/* symbolic link */
        -:  697:#endif
        -:  698:#ifdef S_IFSOCK
    #####:  699:  HANDLE_TYPE(S_IFSOCK, "s");	/* Unix domain socket */
        -:  700:#endif
        -:  701:#ifdef S_IFBLK
    #####:  702:  HANDLE_TYPE(S_IFBLK,  "b");	/* block device */
        -:  703:#endif
        -:  704:#ifdef S_IFCHR
    #####:  705:  HANDLE_TYPE(S_IFCHR,  "c");	/* character device */
        -:  706:#endif
        -:  707:#ifdef S_IFIFO
    #####:  708:  HANDLE_TYPE(S_IFIFO,  "p");	/* FIFO */
        -:  709:#endif
        -:  710:#ifdef S_IFDOOR
        -:  711:  HANDLE_TYPE(S_IFDOOR, "D");	/* Door (e.g. on Solaris) */
        -:  712:#endif
    #####:  713:  return "U";			/* Unknown */
        -:  714:}
        -:  715:
        -:  716:static double
    #####:  717:file_sparseness (const struct stat *p)
        -:  718:{
        -:  719:#if defined HAVE_STRUCT_STAT_ST_BLOCKS
    #####:  720:  if (0 == p->st_size)
        -:  721:    {
    #####:  722:      if (0 == p->st_blocks)
    #####:  723:	return 1.0;
        -:  724:      else
    #####:  725:	return p->st_blocks < 0 ? -HUGE_VAL : HUGE_VAL;
        -:  726:    }
        -:  727:  else
        -:  728:    {
    #####:  729:      double blklen = file_blocksize (p) * (double)p->st_blocks;
    #####:  730:      return blklen / p->st_size;
        -:  731:    }
        -:  732:#else
        -:  733:  return 1.0;
        -:  734:#endif
        -:  735:}
        -:  736:
        -:  737:
        -:  738:
        -:  739:static void
    #####:  740:checked_fprintf (struct format_val *dest, const char *fmt, ...)
        -:  741:{
        -:  742:  int rv;
        -:  743:  va_list ap;
        -:  744:
    #####:  745:  va_start (ap, fmt);
    #####:  746:  rv = vfprintf (dest->stream, fmt, ap);
    #####:  747:  if (rv < 0)
    #####:  748:    nonfatal_nontarget_file_error (errno, dest->filename);
    #####:  749:}
        -:  750:
        -:  751:
        -:  752:static void
    #####:  753:checked_print_quoted (struct format_val *dest,
        -:  754:			   const char *format, const char *s)
        -:  755:{
    #####:  756:  int rv = print_quoted (dest->stream, dest->quote_opts, dest->dest_is_tty,
        -:  757:			 format, s);
    #####:  758:  if (rv < 0)
    #####:  759:    nonfatal_nontarget_file_error (errno, dest->filename);
    #####:  760:}
        -:  761:
        -:  762:
        -:  763:static void
    #####:  764:checked_fwrite (void *p, size_t siz, size_t nmemb, struct format_val *dest)
        -:  765:{
    #####:  766:  int items_written = fwrite (p, siz, nmemb, dest->stream);
    #####:  767:  if (items_written < nmemb)
    #####:  768:    nonfatal_nontarget_file_error (errno, dest->filename);
    #####:  769:}
        -:  770:
        -:  771:static void
    #####:  772:checked_fflush (struct format_val *dest)
        -:  773:{
    #####:  774:  if (0 != fflush (dest->stream))
        -:  775:    {
    #####:  776:      nonfatal_nontarget_file_error (errno, dest->filename);
        -:  777:    }
    #####:  778:}
        -:  779:
        -:  780:static void
    #####:  781:do_fprintf (struct format_val *dest,
        -:  782:	    struct segment *segment,
        -:  783:	    const char *pathname,
        -:  784:	    const struct stat *stat_buf)
        -:  785:{
        -:  786:  char hbuf[LONGEST_HUMAN_READABLE + 1];
        -:  787:  const char *cp;
        -:  788:
    #####:  789:  switch (segment->segkind)
        -:  790:    {
        -:  791:    case KIND_PLAIN:	/* Plain text string (no % conversion). */
        -:  792:      /* trusted */
    #####:  793:      checked_fwrite(segment->text, 1, segment->text_len, dest);
    #####:  794:      break;
        -:  795:
        -:  796:    case KIND_STOP:		/* Terminate argument and flush output. */
        -:  797:      /* trusted */
    #####:  798:      checked_fwrite (segment->text, 1, segment->text_len, dest);
    #####:  799:      checked_fflush (dest);
    #####:  800:      break;
        -:  801:
        -:  802:    case KIND_FORMAT:
    #####:  803:      switch (segment->format_char[0])
        -:  804:	{
        -:  805:	case 'a':		/* atime in `ctime' format. */
        -:  806:	  /* UNTRUSTED, probably unexploitable */
    #####:  807:	  checked_fprintf (dest, segment->text, ctime_format (get_stat_atime (stat_buf)));
    #####:  808:	  break;
        -:  809:	case 'b':		/* size in 512-byte blocks */
        -:  810:	  /* UNTRUSTED, probably unexploitable */
    #####:  811:	  checked_fprintf (dest, segment->text,
    #####:  812:			   human_readable ((uintmax_t) ST_NBLOCKS (*stat_buf),
        -:  813:					   hbuf, human_ceiling,
        -:  814:					   ST_NBLOCKSIZE, 512));
    #####:  815:	  break;
        -:  816:	case 'c':		/* ctime in `ctime' format */
        -:  817:	  /* UNTRUSTED, probably unexploitable */
    #####:  818:	  checked_fprintf (dest, segment->text, ctime_format (get_stat_ctime (stat_buf)));
    #####:  819:	  break;
        -:  820:	case 'd':		/* depth in search tree */
        -:  821:	  /* UNTRUSTED, probably unexploitable */
    #####:  822:	  checked_fprintf (dest, segment->text, state.curdepth);
    #####:  823:	  break;
        -:  824:	case 'D':		/* Device on which file exists (stat.st_dev) */
        -:  825:	  /* trusted */
    #####:  826:	  checked_fprintf (dest, segment->text,
        -:  827:			   human_readable ((uintmax_t) stat_buf->st_dev, hbuf,
        -:  828:					   human_ceiling, 1, 1));
    #####:  829:	  break;
        -:  830:	case 'f':		/* base name of path */
        -:  831:	  /* sanitised */
        -:  832:	  {
    #####:  833:	    char *base = base_name (pathname);
    #####:  834:	    checked_print_quoted (dest, segment->text, base);
    #####:  835:	    free (base);
        -:  836:	  }
    #####:  837:	  break;
        -:  838:	case 'F':		/* file system type */
        -:  839:	  /* trusted */
    #####:  840:	  checked_print_quoted (dest, segment->text, filesystem_type (stat_buf, pathname));
    #####:  841:	  break;
        -:  842:	case 'g':		/* group name */
        -:  843:	  /* trusted */
        -:  844:	  /* (well, the actual group is selected by the user but
        -:  845:	   * its name was selected by the system administrator)
        -:  846:	   */
        -:  847:	  {
        -:  848:	    struct group *g;
        -:  849:
    #####:  850:	    g = getgrgid (stat_buf->st_gid);
    #####:  851:	    if (g)
        -:  852:	      {
    #####:  853:		segment->text[segment->text_len] = 's';
    #####:  854:		checked_fprintf (dest, segment->text, g->gr_name);
    #####:  855:		break;
        -:  856:	      }
        -:  857:	    else
        -:  858:	      {
        -:  859:		/* Do nothing. */
        -:  860:		/*FALLTHROUGH*/
        -:  861:	      }
        -:  862:	  }
        -:  863:	  /*FALLTHROUGH*/ /*...sometimes, so 'G' case.*/
        -:  864:
        -:  865:	case 'G':		/* GID number */
        -:  866:	  /* UNTRUSTED, probably unexploitable */
    #####:  867:	  checked_fprintf (dest, segment->text,
    #####:  868:			   human_readable ((uintmax_t) stat_buf->st_gid, hbuf,
        -:  869:					   human_ceiling, 1, 1));
    #####:  870:	  break;
        -:  871:	case 'h':		/* leading directories part of path */
        -:  872:	  /* sanitised */
        -:  873:	  {
    #####:  874:	    cp = strrchr (pathname, '/');
    #####:  875:	    if (cp == NULL)	/* No leading directories. */
        -:  876:	      {
        -:  877:		/* If there is no slash in the pathname, we still
        -:  878:		 * print the string because it contains characters
        -:  879:		 * other than just '%s'.  The %h expands to ".".
        -:  880:		 */
    #####:  881:		checked_print_quoted (dest, segment->text, ".");
        -:  882:	      }
        -:  883:	    else
        -:  884:	      {
    #####:  885:		char *s = strdup (pathname);
    #####:  886:		s[cp - pathname] = 0;
    #####:  887:		checked_print_quoted (dest, segment->text, s);
    #####:  888:		free (s);
        -:  889:	      }
        -:  890:	  }
    #####:  891:	  break;
        -:  892:
        -:  893:	case 'H':		/* ARGV element file was found under */
        -:  894:	  /* trusted */
        -:  895:	  {
    #####:  896:	    char *s = xmalloc (state.starting_path_length+1);
    #####:  897:	    memcpy (s, pathname, state.starting_path_length);
    #####:  898:	    s[state.starting_path_length] = 0;
    #####:  899:	    checked_fprintf (dest, segment->text, s);
    #####:  900:	    free (s);
        -:  901:	  }
    #####:  902:	  break;
        -:  903:
        -:  904:	case 'i':		/* inode number */
        -:  905:	  /* UNTRUSTED, but not exploitable I think */
    #####:  906:	  checked_fprintf (dest, segment->text,
        -:  907:			   human_readable ((uintmax_t) stat_buf->st_ino, hbuf,
        -:  908:					   human_ceiling,
        -:  909:					   1, 1));
    #####:  910:	  break;
        -:  911:	case 'k':		/* size in 1K blocks */
        -:  912:	  /* UNTRUSTED, but not exploitable I think */
    #####:  913:	  checked_fprintf (dest, segment->text,
    #####:  914:			   human_readable ((uintmax_t) ST_NBLOCKS (*stat_buf),
        -:  915:					   hbuf, human_ceiling,
        -:  916:					   ST_NBLOCKSIZE, 1024));
    #####:  917:	  break;
        -:  918:	case 'l':		/* object of symlink */
        -:  919:	  /* sanitised */
        -:  920:#ifdef S_ISLNK
        -:  921:	  {
    #####:  922:	    char *linkname = 0;
        -:  923:
    #####:  924:	    if (S_ISLNK (stat_buf->st_mode))
        -:  925:	      {
    #####:  926:		linkname = areadlinkat (state.cwd_dir_fd, state.rel_pathname);
    #####:  927:		if (linkname == NULL)
        -:  928:		  {
    #####:  929:		    nonfatal_target_file_error (errno, pathname);
    #####:  930:		    state.exit_status = 1;
        -:  931:		  }
        -:  932:	      }
    #####:  933:	    if (linkname)
        -:  934:	      {
    #####:  935:		checked_print_quoted (dest, segment->text, linkname);
        -:  936:	      }
        -:  937:	    else
        -:  938:	      {
        -:  939:		/* We still need to honour the field width etc., so this is
        -:  940:		 * not a no-op.
        -:  941:		 */
    #####:  942:		checked_print_quoted (dest, segment->text, "");
        -:  943:	      }
    #####:  944:	    free (linkname);
        -:  945:	  }
        -:  946:#endif				/* S_ISLNK */
    #####:  947:	  break;
        -:  948:
        -:  949:	case 'M':		/* mode as 10 chars (eg., "-rwxr-x--x" */
        -:  950:	  /* UNTRUSTED, probably unexploitable */
        -:  951:	  {
        -:  952:	    char modestring[16] ;
    #####:  953:	    filemodestring (stat_buf, modestring);
    #####:  954:	    modestring[10] = '\0';
    #####:  955:	    checked_fprintf (dest, segment->text, modestring);
        -:  956:	  }
    #####:  957:	  break;
        -:  958:
        -:  959:	case 'm':		/* mode as octal number (perms only) */
        -:  960:	  /* UNTRUSTED, probably unexploitable */
        -:  961:	  {
        -:  962:	    /* Output the mode portably using the traditional numbers,
        -:  963:	       even if the host unwisely uses some other numbering
        -:  964:	       scheme.  But help the compiler in the common case where
        -:  965:	       the host uses the traditional numbering scheme.  */
    #####:  966:	    mode_t m = stat_buf->st_mode;
    #####:  967:	    bool traditional_numbering_scheme =
        -:  968:	      (S_ISUID == 04000 && S_ISGID == 02000 && S_ISVTX == 01000
        -:  969:	       && S_IRUSR == 00400 && S_IWUSR == 00200 && S_IXUSR == 00100
        -:  970:	       && S_IRGRP == 00040 && S_IWGRP == 00020 && S_IXGRP == 00010
        -:  971:	       && S_IROTH == 00004 && S_IWOTH == 00002 && S_IXOTH == 00001);
    #####:  972:	    checked_fprintf (dest, segment->text,
        -:  973:		     (traditional_numbering_scheme
        -:  974:		      ? m & MODE_ALL
    #####:  975:		      : ((m & S_ISUID ? 04000 : 0)
        -:  976:			 | (m & S_ISGID ? 02000 : 0)
        -:  977:			 | (m & S_ISVTX ? 01000 : 0)
        -:  978:			 | (m & S_IRUSR ? 00400 : 0)
        -:  979:			 | (m & S_IWUSR ? 00200 : 0)
        -:  980:			 | (m & S_IXUSR ? 00100 : 0)
        -:  981:			 | (m & S_IRGRP ? 00040 : 0)
        -:  982:			 | (m & S_IWGRP ? 00020 : 0)
        -:  983:			 | (m & S_IXGRP ? 00010 : 0)
        -:  984:			 | (m & S_IROTH ? 00004 : 0)
    #####:  985:			 | (m & S_IWOTH ? 00002 : 0)
    #####:  986:			 | (m & S_IXOTH ? 00001 : 0))));
        -:  987:	  }
    #####:  988:	  break;
        -:  989:
        -:  990:	case 'n':		/* number of links */
        -:  991:	  /* UNTRUSTED, probably unexploitable */
    #####:  992:	  checked_fprintf (dest, segment->text,
        -:  993:		   human_readable ((uintmax_t) stat_buf->st_nlink,
        -:  994:				   hbuf,
        -:  995:				   human_ceiling,
        -:  996:				   1, 1));
    #####:  997:	  break;
        -:  998:
        -:  999:	case 'p':		/* pathname */
        -: 1000:	  /* sanitised */
    #####: 1001:	  checked_print_quoted (dest, segment->text, pathname);
    #####: 1002:	  break;
        -: 1003:
        -: 1004:	case 'P':		/* pathname with ARGV element stripped */
        -: 1005:	  /* sanitised */
    #####: 1006:	  if (state.curdepth > 0)
        -: 1007:	    {
    #####: 1008:	      cp = pathname + state.starting_path_length;
    #####: 1009:	      if (*cp == '/')
        -: 1010:		/* Move past the slash between the ARGV element
        -: 1011:		   and the rest of the pathname.  But if the ARGV element
        -: 1012:		   ends in a slash, we didn't add another, so we've
        -: 1013:		   already skipped past it.  */
    #####: 1014:		cp++;
        -: 1015:	    }
        -: 1016:	  else
        -: 1017:	    {
    #####: 1018:	      cp = "";
        -: 1019:	    }
    #####: 1020:	  checked_print_quoted (dest, segment->text, cp);
    #####: 1021:	  break;
        -: 1022:
        -: 1023:	case 's':		/* size in bytes */
        -: 1024:	  /* UNTRUSTED, probably unexploitable */
    #####: 1025:	  checked_fprintf (dest, segment->text,
    #####: 1026:		   human_readable ((uintmax_t) stat_buf->st_size,
        -: 1027:				   hbuf, human_ceiling, 1, 1));
    #####: 1028:	  break;
        -: 1029:
        -: 1030:	case 'S':		/* sparseness */
        -: 1031:	  /* UNTRUSTED, probably unexploitable */
    #####: 1032:	  checked_fprintf (dest, segment->text, file_sparseness (stat_buf));;
    #####: 1033:	  break;
        -: 1034:
        -: 1035:	case 't':		/* mtime in `ctime' format */
        -: 1036:	  /* UNTRUSTED, probably unexploitable */
    #####: 1037:	  checked_fprintf (dest, segment->text,
        -: 1038:			   ctime_format (get_stat_mtime (stat_buf)));
    #####: 1039:	  break;
        -: 1040:
        -: 1041:	case 'u':		/* user name */
        -: 1042:	  /* trusted */
        -: 1043:	  /* (well, the actual user is selected by the user on systems
        -: 1044:	   * where chown is not restricted, but the user name was
        -: 1045:	   * selected by the system administrator)
        -: 1046:	   */
        -: 1047:	  {
        -: 1048:	    struct passwd *p;
        -: 1049:
    #####: 1050:	    p = getpwuid (stat_buf->st_uid);
    #####: 1051:	    if (p)
        -: 1052:	      {
    #####: 1053:		segment->text[segment->text_len] = 's';
    #####: 1054:		checked_fprintf (dest, segment->text, p->pw_name);
    #####: 1055:		break;
        -: 1056:	      }
        -: 1057:	    /* else fallthru */
        -: 1058:	  }
        -: 1059:	  /* FALLTHROUGH*/ /* .. to case U */
        -: 1060:
        -: 1061:	case 'U':		/* UID number */
        -: 1062:	  /* UNTRUSTED, probably unexploitable */
    #####: 1063:	  checked_fprintf (dest, segment->text,
    #####: 1064:			   human_readable ((uintmax_t) stat_buf->st_uid, hbuf,
        -: 1065:					   human_ceiling, 1, 1));
    #####: 1066:	  break;
        -: 1067:
        -: 1068:	  /* %Y: type of file system entry like `ls -l`:
        -: 1069:	   *     (d,-,l,s,p,b,c,n) n=nonexistent (symlink)
        -: 1070:	   */
        -: 1071:	case 'Y':		/* in case of symlink */
        -: 1072:	  /* trusted */
        -: 1073:	  {
        -: 1074:#ifdef S_ISLNK
    #####: 1075:	    if (S_ISLNK (stat_buf->st_mode))
        -: 1076:	      {
        -: 1077:		struct stat sbuf;
        -: 1078:		/* If we would normally follow links, do not do so.
        -: 1079:		 * If we would normally not follow links, do so.
        -: 1080:		 */
    #####: 1081:		if ((following_links () ? optionp_stat : optionl_stat)
    #####: 1082:		    (state.rel_pathname, &sbuf) != 0)
        -: 1083:		  {
    #####: 1084:		    if ( errno == ENOENT )
        -: 1085:		      {
    #####: 1086:			checked_fprintf (dest, segment->text, "N");
    #####: 1087:			break;
        -: 1088:		      }
    #####: 1089:		    else if ( errno == ELOOP )
        -: 1090:		      {
    #####: 1091:			checked_fprintf (dest, segment->text, "L");
    #####: 1092:			break;
        -: 1093:		      }
        -: 1094:		    else
        -: 1095:		      {
    #####: 1096:			checked_fprintf (dest, segment->text, "?");
    #####: 1097:			error (0, errno, "%s",
        -: 1098:			       safely_quote_err_filename (0, pathname));
        -: 1099:			/* exit_status = 1;
        -: 1100:			   return ; */
    #####: 1101:			break;
        -: 1102:		      }
        -: 1103:		  }
    #####: 1104:		checked_fprintf (dest, segment->text,
    #####: 1105:				 mode_to_filetype (sbuf.st_mode & S_IFMT));
        -: 1106:	      }
        -: 1107:#endif /* S_ISLNK */
        -: 1108:	    else
        -: 1109:	      {
    #####: 1110:		checked_fprintf (dest, segment->text,
    #####: 1111:				 mode_to_filetype (stat_buf->st_mode & S_IFMT));
        -: 1112:	      }
        -: 1113:	  }
    #####: 1114:	  break;
        -: 1115:
        -: 1116:	case 'y':
        -: 1117:	  /* trusted */
        -: 1118:	  {
    #####: 1119:	    checked_fprintf (dest, segment->text,
    #####: 1120:			     mode_to_filetype (stat_buf->st_mode & S_IFMT));
        -: 1121:	  }
    #####: 1122:	  break;
        -: 1123:
        -: 1124:	case 'Z':               /* SELinux security context */
        -: 1125:	  {
        -: 1126:	    security_context_t scontext;
    #####: 1127:	    int rv = (*options.x_getfilecon) (state.cwd_dir_fd, state.rel_pathname,
        -: 1128:					      &scontext);
    #####: 1129:	    if (rv < 0)
        -: 1130:	      {
        -: 1131:		/* If getfilecon fails, there will in the general case
        -: 1132:		   still be some text to print.   We just make %Z expand
        -: 1133:		   to an empty string. */
    #####: 1134:		checked_fprintf (dest, segment->text, "");
        -: 1135:
    #####: 1136:		error (0, errno, _("getfilecon failed: %s"),
        -: 1137:		    safely_quote_err_filename (0, pathname));
    #####: 1138:		state.exit_status = 1;
        -: 1139:	      }
        -: 1140:	    else
        -: 1141:	      {
    #####: 1142:		checked_fprintf (dest, segment->text, scontext);
    #####: 1143:		freecon (scontext);
        -: 1144:	      }
        -: 1145:	  }
    #####: 1146:	  break;
        -: 1147:	}
        -: 1148:      /* end of KIND_FORMAT case */
    #####: 1149:      break;
        -: 1150:    }
    #####: 1151:}
        -: 1152:
        -: 1153:bool
    #####: 1154:pred_fprintf (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1155:{
    #####: 1156:  struct format_val *dest = &pred_ptr->args.printf_vec;
        -: 1157:  struct segment *segment;
        -: 1158:
    #####: 1159:  for (segment = dest->segment; segment; segment = segment->next)
        -: 1160:    {
    #####: 1161:      if ( (KIND_FORMAT == segment->segkind) && segment->format_char[1]) /* Component of date. */
    #####: 1162:	{
        -: 1163:	  struct timespec ts;
    #####: 1164:	  int valid = 0;
        -: 1165:
    #####: 1166:	  switch (segment->format_char[0])
        -: 1167:	    {
        -: 1168:	    case 'A':
    #####: 1169:	      ts = get_stat_atime (stat_buf);
    #####: 1170:	      valid = 1;
    #####: 1171:	      break;
        -: 1172:	    case 'B':
    #####: 1173:	      ts = get_stat_birthtime (stat_buf);
    #####: 1174:	      if ('@' == segment->format_char[1])
    #####: 1175:		valid = 1;
        -: 1176:	      else
    #####: 1177:		valid = (ts.tv_nsec >= 0);
    #####: 1178:	      break;
        -: 1179:	    case 'C':
    #####: 1180:	      ts = get_stat_ctime (stat_buf);
    #####: 1181:	      valid = 1;
    #####: 1182:	      break;
        -: 1183:	    case 'T':
    #####: 1184:	      ts = get_stat_mtime (stat_buf);
    #####: 1185:	      valid = 1;
    #####: 1186:	      break;
        -: 1187:	    default:
    #####: 1188:	      assert (0);
        -: 1189:	      abort ();
        -: 1190:	    }
        -: 1191:	  /* We trust the output of format_date not to contain
        -: 1192:	   * nasty characters, though the value of the date
        -: 1193:	   * is itself untrusted data.
        -: 1194:	   */
    #####: 1195:	  if (valid)
        -: 1196:	    {
        -: 1197:	      /* trusted */
    #####: 1198:	      checked_fprintf (dest, segment->text,
    #####: 1199:			       format_date (ts, segment->format_char[1]));
        -: 1200:	    }
        -: 1201:	  else
        -: 1202:	    {
        -: 1203:	      /* The specified timestamp is not available, output
        -: 1204:	       * nothing for the timestamp, but use the rest (so that
        -: 1205:	       * for example find foo -printf '[%Bs] %p\n' can print
        -: 1206:	       * "[] foo").
        -: 1207:	       */
        -: 1208:	      /* trusted */
    #####: 1209:	      checked_fprintf (dest, segment->text, "");
        -: 1210:	    }
        -: 1211:	}
        -: 1212:      else
        -: 1213:	{
        -: 1214:	  /* Print a segment which is not a date. */
    #####: 1215:	  do_fprintf (dest, segment, pathname, stat_buf);
        -: 1216:	}
        -: 1217:    }
    #####: 1218:  return true;
        -: 1219:}
        -: 1220:
        -: 1221:bool
    #####: 1222:pred_fstype (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1223:{
        -: 1224:  (void) pathname;
        -: 1225:
    #####: 1226:  if (strcmp (filesystem_type (stat_buf, pathname), pred_ptr->args.str) == 0)
    #####: 1227:    return true;
        -: 1228:  else
    #####: 1229:    return false;
        -: 1230:}
        -: 1231:
        -: 1232:bool
    #####: 1233:pred_gid (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1234:{
        -: 1235:  (void) pathname;
        -: 1236:
    #####: 1237:  switch (pred_ptr->args.numinfo.kind)
        -: 1238:    {
        -: 1239:    case COMP_GT:
    #####: 1240:      if (stat_buf->st_gid > pred_ptr->args.numinfo.l_val)
    #####: 1241:	return (true);
    #####: 1242:      break;
        -: 1243:    case COMP_LT:
    #####: 1244:      if (stat_buf->st_gid < pred_ptr->args.numinfo.l_val)
    #####: 1245:	return (true);
    #####: 1246:      break;
        -: 1247:    case COMP_EQ:
    #####: 1248:      if (stat_buf->st_gid == pred_ptr->args.numinfo.l_val)
    #####: 1249:	return (true);
    #####: 1250:      break;
        -: 1251:    }
    #####: 1252:  return (false);
        -: 1253:}
        -: 1254:
        -: 1255:bool
    #####: 1256:pred_group (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1257:{
        -: 1258:  (void) pathname;
        -: 1259:
    #####: 1260:  if (pred_ptr->args.gid == stat_buf->st_gid)
    #####: 1261:    return (true);
        -: 1262:  else
    #####: 1263:    return (false);
        -: 1264:}
        -: 1265:
        -: 1266:bool
    #####: 1267:pred_ilname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1268:{
    #####: 1269:  return match_lname (pathname, stat_buf, pred_ptr, true);
        -: 1270:}
        -: 1271:
        -: 1272:/* Common code between -name, -iname.  PATHNAME is being visited, STR
        -: 1273:   is name to compare basename against, and FLAGS are passed to
        -: 1274:   fnmatch.  Recall that 'find / -name /' is one of the few times where a '/'
        -: 1275:   in the -name must actually find something. */
        -: 1276:static bool
    #####: 1277:pred_name_common (const char *pathname, const char *str, int flags)
        -: 1278:{
        -: 1279:  bool b;
        -: 1280:  /* We used to use last_component() here, but that would not allow us to modify the
        -: 1281:   * input string, which is const.   We could optimise by duplicating the string only
        -: 1282:   * if we need to modify it, and I'll do that if there is a measurable
        -: 1283:   * performance difference on a machine built after 1990...
        -: 1284:   */
    #####: 1285:  char *base = base_name (pathname);
        -: 1286:  /* remove trailing slashes, but leave  "/" or "//foo" unchanged. */
    #####: 1287:  strip_trailing_slashes (base);
        -: 1288:
        -: 1289:  /* FNM_PERIOD is not used here because POSIX requires that it not be.
        -: 1290:   * See http://standards.ieee.org/reading/ieee/interp/1003-2-92_int/pasc-1003.2-126.html
        -: 1291:   */
    #####: 1292:  b = fnmatch (str, base, flags) == 0;
    #####: 1293:  free (base);
    #####: 1294:  return b;
        -: 1295:}
        -: 1296:
        -: 1297:bool
    #####: 1298:pred_iname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1299:{
        -: 1300:  (void) stat_buf;
    #####: 1301:  return pred_name_common (pathname, pred_ptr->args.str, FNM_CASEFOLD);
        -: 1302:}
        -: 1303:
        -: 1304:bool
    #####: 1305:pred_inum (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1306:{
        -: 1307:  (void) pathname;
        -: 1308:
    #####: 1309:  assert (stat_buf->st_ino != 0);
        -: 1310:
    #####: 1311:  switch (pred_ptr->args.numinfo.kind)
        -: 1312:    {
        -: 1313:    case COMP_GT:
    #####: 1314:      if (stat_buf->st_ino > pred_ptr->args.numinfo.l_val)
    #####: 1315:	return (true);
    #####: 1316:      break;
        -: 1317:    case COMP_LT:
    #####: 1318:      if (stat_buf->st_ino < pred_ptr->args.numinfo.l_val)
    #####: 1319:	return (true);
    #####: 1320:      break;
        -: 1321:    case COMP_EQ:
    #####: 1322:      if (stat_buf->st_ino == pred_ptr->args.numinfo.l_val)
    #####: 1323:	return (true);
    #####: 1324:      break;
        -: 1325:    }
    #####: 1326:  return (false);
        -: 1327:}
        -: 1328:
        -: 1329:bool
    #####: 1330:pred_ipath (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1331:{
        -: 1332:  (void) stat_buf;
        -: 1333:
    #####: 1334:  if (fnmatch (pred_ptr->args.str, pathname, FNM_CASEFOLD) == 0)
    #####: 1335:    return (true);
    #####: 1336:  return (false);
        -: 1337:}
        -: 1338:
        -: 1339:bool
    #####: 1340:pred_links (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1341:{
        -: 1342:  (void) pathname;
        -: 1343:
    #####: 1344:  switch (pred_ptr->args.numinfo.kind)
        -: 1345:    {
        -: 1346:    case COMP_GT:
    #####: 1347:      if (stat_buf->st_nlink > pred_ptr->args.numinfo.l_val)
    #####: 1348:	return (true);
    #####: 1349:      break;
        -: 1350:    case COMP_LT:
    #####: 1351:      if (stat_buf->st_nlink < pred_ptr->args.numinfo.l_val)
    #####: 1352:	return (true);
    #####: 1353:      break;
        -: 1354:    case COMP_EQ:
    #####: 1355:      if (stat_buf->st_nlink == pred_ptr->args.numinfo.l_val)
    #####: 1356:	return (true);
    #####: 1357:      break;
        -: 1358:    }
    #####: 1359:  return (false);
        -: 1360:}
        -: 1361:
        -: 1362:bool
    #####: 1363:pred_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1364:{
    #####: 1365:  return match_lname (pathname, stat_buf, pred_ptr, false);
        -: 1366:}
        -: 1367:
        -: 1368:static bool
    #####: 1369:match_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, bool ignore_case)
        -: 1370:{
    #####: 1371:  bool ret = false;
        -: 1372:#ifdef S_ISLNK
    #####: 1373:  if (S_ISLNK (stat_buf->st_mode))
        -: 1374:    {
    #####: 1375:      char *linkname = areadlinkat (state.cwd_dir_fd, state.rel_pathname);
    #####: 1376:      if (linkname)
        -: 1377:	{
    #####: 1378:	  if (fnmatch (pred_ptr->args.str, linkname,
        -: 1379:		       ignore_case ? FNM_CASEFOLD : 0) == 0)
    #####: 1380:	    ret = true;
        -: 1381:	}
        -: 1382:      else
        -: 1383:	{
    #####: 1384:	  nonfatal_target_file_error (errno, pathname);
    #####: 1385:	  state.exit_status = 1;
        -: 1386:	}
    #####: 1387:      free (linkname);
        -: 1388:    }
        -: 1389:#endif /* S_ISLNK */
    #####: 1390:  return ret;
        -: 1391:}
        -: 1392:
        -: 1393:bool
    #####: 1394:pred_ls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1395:{
    #####: 1396:  return pred_fls (pathname, stat_buf, pred_ptr);
        -: 1397:}
        -: 1398:
        -: 1399:bool
    #####: 1400:pred_mmin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1401:{
        -: 1402:  (void) &pathname;
    #####: 1403:  return pred_timewindow (get_stat_mtime(stat_buf), pred_ptr, 60);
        -: 1404:}
        -: 1405:
        -: 1406:bool
    #####: 1407:pred_mtime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1408:{
        -: 1409:  (void) pathname;
    #####: 1410:  return pred_timewindow (get_stat_mtime(stat_buf), pred_ptr, DAYSECS);
        -: 1411:}
        -: 1412:
        -: 1413:bool
    #####: 1414:pred_name (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1415:{
        -: 1416:  (void) stat_buf;
    #####: 1417:  return pred_name_common (pathname, pred_ptr->args.str, 0);
        -: 1418:}
        -: 1419:
        -: 1420:bool
    #####: 1421:pred_negate (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1422:{
    #####: 1423:  return !apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -: 1424:}
        -: 1425:
        -: 1426:bool
    #####: 1427:pred_newer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1428:{
        -: 1429:  (void) pathname;
        -: 1430:
    #####: 1431:  assert (COMP_GT == pred_ptr->args.reftime.kind);
    #####: 1432:  return compare_ts (get_stat_mtime(stat_buf), pred_ptr->args.reftime.ts) > 0;
        -: 1433:}
        -: 1434:
        -: 1435:bool
    #####: 1436:pred_newerXY (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1437:{
        -: 1438:  struct timespec ts;
    #####: 1439:  bool collected = false;
        -: 1440:
    #####: 1441:  assert (COMP_GT == pred_ptr->args.reftime.kind);
        -: 1442:
    #####: 1443:  switch (pred_ptr->args.reftime.xval)
        -: 1444:    {
        -: 1445:    case XVAL_TIME:
    #####: 1446:      assert (pred_ptr->args.reftime.xval != XVAL_TIME);
    #####: 1447:      return false;
        -: 1448:
        -: 1449:    case XVAL_ATIME:
    #####: 1450:      ts = get_stat_atime (stat_buf);
    #####: 1451:      collected = true;
    #####: 1452:      break;
        -: 1453:
        -: 1454:    case XVAL_BIRTHTIME:
    #####: 1455:      ts = get_stat_birthtime (stat_buf);
    #####: 1456:      collected = true;
    #####: 1457:      if (ts.tv_nsec < 0);
        -: 1458:	{
        -: 1459:	  /* XXX: Cannot determine birth time.  Warn once. */
    #####: 1460:	  error (0, 0, _("WARNING: cannot determine birth time of file %s"),
        -: 1461:		 safely_quote_err_filename (0, pathname));
    #####: 1462:	  return false;
        -: 1463:	}
        -: 1464:      break;
        -: 1465:
        -: 1466:    case XVAL_CTIME:
    #####: 1467:      ts = get_stat_ctime (stat_buf);
    #####: 1468:      collected = true;
    #####: 1469:      break;
        -: 1470:
        -: 1471:    case XVAL_MTIME:
    #####: 1472:      ts = get_stat_mtime (stat_buf);
    #####: 1473:      collected = true;
    #####: 1474:      break;
        -: 1475:    }
        -: 1476:
    #####: 1477:  assert (collected);
    #####: 1478:  return compare_ts (ts, pred_ptr->args.reftime.ts) > 0;
        -: 1479:}
        -: 1480:
        -: 1481:bool
    #####: 1482:pred_nogroup (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1483:{
        -: 1484:  (void) pathname;
        -: 1485:  (void) pred_ptr;
        -: 1486:
        -: 1487:#ifdef CACHE_IDS
        -: 1488:  extern char *gid_unused;
        -: 1489:
        -: 1490:  return gid_unused[(unsigned) stat_buf->st_gid];
        -: 1491:#else
    #####: 1492:  return getgrgid (stat_buf->st_gid) == NULL;
        -: 1493:#endif
        -: 1494:}
        -: 1495:
        -: 1496:bool
    #####: 1497:pred_nouser (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1498:{
        -: 1499:#ifdef CACHE_IDS
        -: 1500:  extern char *uid_unused;
        -: 1501:#endif
        -: 1502:
        -: 1503:  (void) pathname;
        -: 1504:  (void) pred_ptr;
        -: 1505:
        -: 1506:#ifdef CACHE_IDS
        -: 1507:  return uid_unused[(unsigned) stat_buf->st_uid];
        -: 1508:#else
    #####: 1509:  return getpwuid (stat_buf->st_uid) == NULL;
        -: 1510:#endif
        -: 1511:}
        -: 1512:
        -: 1513:
        -: 1514:static bool
    #####: 1515:is_ok (const char *program, const char *arg)
        -: 1516:{
    #####: 1517:  fflush (stdout);
        -: 1518:  /* The draft open standard requires that, in the POSIX locale,
        -: 1519:     the last non-blank character of this prompt be '?'.
        -: 1520:     The exact format is not specified.
        -: 1521:     This standard does not have requirements for locales other than POSIX
        -: 1522:  */
        -: 1523:  /* XXX: printing UNTRUSTED data here. */
    #####: 1524:  fprintf (stderr, _("< %s ... %s > ? "), program, arg);
    #####: 1525:  fflush (stderr);
    #####: 1526:  return yesno ();
        -: 1527:}
        -: 1528:
        -: 1529:bool
    #####: 1530:pred_ok (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1531:{
    #####: 1532:  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))
    #####: 1533:    return new_impl_pred_exec (pathname, stat_buf, pred_ptr, NULL, 0);
        -: 1534:  else
    #####: 1535:    return false;
        -: 1536:}
        -: 1537:
        -: 1538:bool
    #####: 1539:pred_okdir (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1540:{
    #####: 1541:  const char *prefix = (state.rel_pathname[0] == '/') ? NULL : "./";
    #####: 1542:  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))
    #####: 1543:    return new_impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr,
        -: 1544:			       prefix, (prefix ? 2 : 0));
        -: 1545:  else
    #####: 1546:    return false;
        -: 1547:}
        -: 1548:
        -: 1549:bool
    #####: 1550:pred_openparen (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1551:{
        -: 1552:  (void) pathname;
        -: 1553:  (void) stat_buf;
        -: 1554:  (void) pred_ptr;
    #####: 1555:  return true;
        -: 1556:}
        -: 1557:
        -: 1558:bool
    #####: 1559:pred_or (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1560:{
    #####: 1561:  if (pred_ptr->pred_left == NULL
    #####: 1562:      || !apply_predicate (pathname, stat_buf, pred_ptr->pred_left))
        -: 1563:    {
    #####: 1564:      return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -: 1565:    }
        -: 1566:  else
    #####: 1567:    return true;
        -: 1568:}
        -: 1569:
        -: 1570:bool
    #####: 1571:pred_path (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1572:{
        -: 1573:  (void) stat_buf;
    #####: 1574:  if (fnmatch (pred_ptr->args.str, pathname, 0) == 0)
    #####: 1575:    return (true);
    #####: 1576:  return (false);
        -: 1577:}
        -: 1578:
        -: 1579:bool
       24: 1580:pred_perm (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1581:{
       24: 1582:  mode_t mode = stat_buf->st_mode;
       24: 1583:  mode_t perm_val = pred_ptr->args.perm.val[S_ISDIR (mode) != 0];
        -: 1584:  (void) pathname;
       24: 1585:  switch (pred_ptr->args.perm.kind)
        -: 1586:    {
        -: 1587:    case PERM_AT_LEAST:
       24: 1588:      return (mode & perm_val) == perm_val;
        -: 1589:      break;
        -: 1590:
        -: 1591:    case PERM_ANY:
        -: 1592:      /* True if any of the bits set in the mask are also set in the file's mode.
        -: 1593:       *
        -: 1594:       *
        -: 1595:       * Otherwise, if onum is prefixed by a hyphen, the primary shall
        -: 1596:       * evaluate as true if at least all of the bits specified in
        -: 1597:       * onum that are also set in the octal mask 07777 are set.
        -: 1598:       *
        -: 1599:       * Eric Blake's interpretation is that the mode argument is zero,
        -: 1600:
        -: 1601:       */
    #####: 1602:      if (0 == perm_val)
    #####: 1603:	return true;		/* Savannah bug 14748; we used to return false */
        -: 1604:      else
    #####: 1605:	return (mode & perm_val) != 0;
        -: 1606:      break;
        -: 1607:
        -: 1608:    case PERM_EXACT:
    #####: 1609:      return (mode & MODE_ALL) == perm_val;
        -: 1610:      break;
        -: 1611:
        -: 1612:    default:
    #####: 1613:      abort ();
        -: 1614:      break;
        -: 1615:    }
        -: 1616:}
        -: 1617:
        -: 1618:
        -: 1619:bool
    #####: 1620:pred_executable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1621:{
        -: 1622:  (void) pathname;
        -: 1623:  (void) stat_buf;
        -: 1624:  (void) pred_ptr;
        -: 1625:
        -: 1626:  /* As for access, the check is performed with the real user id. */
    #####: 1627:  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, X_OK, 0);
        -: 1628:}
        -: 1629:
        -: 1630:bool
    #####: 1631:pred_readable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1632:{
        -: 1633:  (void) pathname;
        -: 1634:  (void) stat_buf;
        -: 1635:  (void) pred_ptr;
        -: 1636:
        -: 1637:  /* As for access, the check is performed with the real user id. */
    #####: 1638:  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, R_OK, 0);
        -: 1639:}
        -: 1640:
        -: 1641:bool
    #####: 1642:pred_writable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1643:{
        -: 1644:  (void) pathname;
        -: 1645:  (void) stat_buf;
        -: 1646:  (void) pred_ptr;
        -: 1647:
        -: 1648:  /* As for access, the check is performed with the real user id. */
    #####: 1649:  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, W_OK, 0);
        -: 1650:}
        -: 1651:
        -: 1652:bool
       24: 1653:pred_print (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1654:{
        -: 1655:  (void) stat_buf;
        -: 1656:  (void) pred_ptr;
        -: 1657:
       48: 1658:  print_quoted (pred_ptr->args.printf_vec.stream,
       24: 1659:		pred_ptr->args.printf_vec.quote_opts,
       24: 1660:		pred_ptr->args.printf_vec.dest_is_tty,
        -: 1661:		"%s\n", pathname);
       24: 1662:  return true;
        -: 1663:}
        -: 1664:
        -: 1665:bool
    #####: 1666:pred_print0 (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1667:{
    #####: 1668:  return pred_fprint0(pathname, stat_buf, pred_ptr);
        -: 1669:}
        -: 1670:
        -: 1671:bool
    #####: 1672:pred_prune (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1673:{
        -: 1674:  (void) pathname;
        -: 1675:  (void) pred_ptr;
        -: 1676:
    #####: 1677:  if (options.do_dir_first == true) { /* no effect with -depth */
    #####: 1678:    assert (state.have_stat);
    #####: 1679:    if (stat_buf != NULL &&
    #####: 1680:	S_ISDIR(stat_buf->st_mode))
    #####: 1681:      state.stop_at_current_level = true;
        -: 1682:  }
        -: 1683:
        -: 1684:  /* findutils used to return options.do_dir_first here, so that -prune
        -: 1685:   * returns true only if -depth is not in effect.   But POSIX requires
        -: 1686:   * that -prune always evaluate as true.
        -: 1687:   */
    #####: 1688:  return true;
        -: 1689:}
        -: 1690:
        -: 1691:bool
    #####: 1692:pred_quit (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1693:{
        -: 1694:  (void) pathname;
        -: 1695:  (void) stat_buf;
        -: 1696:  (void) pred_ptr;
        -: 1697:
        -: 1698:  /* Run any cleanups.  This includes executing any command lines
        -: 1699:   * we have partly built but not executed.
        -: 1700:   */
    #####: 1701:  cleanup ();
        -: 1702:
        -: 1703:  /* Since -exec and friends don't leave child processes running in the
        -: 1704:   * background, there is no need to wait for them here.
        -: 1705:   */
    #####: 1706:  exit (state.exit_status);	/* 0 for success, etc. */
        -: 1707:}
        -: 1708:
        -: 1709:bool
    #####: 1710:pred_regex (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1711:{
    #####: 1712:  int len = strlen (pathname);
        -: 1713:(void) stat_buf;
    #####: 1714:  if (re_match (pred_ptr->args.regex, pathname, len, 0,
        -: 1715:		(struct re_registers *) NULL) == len)
    #####: 1716:    return (true);
    #####: 1717:  return (false);
        -: 1718:}
        -: 1719:
        -: 1720:bool
    #####: 1721:pred_size (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1722:{
        -: 1723:  uintmax_t f_val;
        -: 1724:
        -: 1725:  (void) pathname;
    #####: 1726:  f_val = ((stat_buf->st_size / pred_ptr->args.size.blocksize)
    #####: 1727:	   + (stat_buf->st_size % pred_ptr->args.size.blocksize != 0));
    #####: 1728:  switch (pred_ptr->args.size.kind)
        -: 1729:    {
        -: 1730:    case COMP_GT:
    #####: 1731:      if (f_val > pred_ptr->args.size.size)
    #####: 1732:	return (true);
    #####: 1733:      break;
        -: 1734:    case COMP_LT:
    #####: 1735:      if (f_val < pred_ptr->args.size.size)
    #####: 1736:	return (true);
    #####: 1737:      break;
        -: 1738:    case COMP_EQ:
    #####: 1739:      if (f_val == pred_ptr->args.size.size)
    #####: 1740:	return (true);
    #####: 1741:      break;
        -: 1742:    }
    #####: 1743:  return (false);
        -: 1744:}
        -: 1745:
        -: 1746:bool
    #####: 1747:pred_samefile (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1748:{
        -: 1749:  /* Potential optimisation: because of the loop protection, we always
        -: 1750:   * know the device of the current directory, hence the device number
        -: 1751:   * of the file we're currently considering.  If -L is not in effect,
        -: 1752:   * and the device number of the file we're looking for is not the
        -: 1753:   * same as the device number of the current directory, this
        -: 1754:   * predicate cannot return true.  Hence there would be no need to
        -: 1755:   * stat the file we're looking at.
        -: 1756:   *
        -: 1757:   * For the moment, we simply compare inode numbers, which should cut
        -: 1758:   * down greatly on the number of calls to stat.  Some of the
        -: 1759:   * remainder will be unnecessary, but the additional complexity
        -: 1760:   * probably isn't worthwhile.
        -: 1761:   */
        -: 1762:  (void) pathname;
        -: 1763:
        -: 1764:  /* We will often still have an fd open on the file under consideration,
        -: 1765:   * but that's just to ensure inode number stability by maintaining
        -: 1766:   * a reference to it; we don't need the file for anything else.
        -: 1767:   */
    #####: 1768:  if (stat_buf->st_ino)
        -: 1769:    {
    #####: 1770:      if (stat_buf->st_ino != pred_ptr->args.samefileid.ino)
    #####: 1771:	return false;
        -: 1772:    }
        -: 1773:  /* Now stat the file to check the device number. */
    #####: 1774:  if (0 == get_statinfo (pathname, state.rel_pathname, stat_buf))
        -: 1775:    {
        -: 1776:      /* the repeated test here is necessary in case stat_buf.st_ino had been zero. */
    #####: 1777:      return stat_buf->st_ino == pred_ptr->args.samefileid.ino
    #####: 1778:	&& stat_buf->st_dev == pred_ptr->args.samefileid.dev;
        -: 1779:    }
        -: 1780:  else
        -: 1781:    {
        -: 1782:      /* get_statinfo will already have emitted an error message. */
    #####: 1783:      return false;
        -: 1784:    }
        -: 1785:}
        -: 1786:
        -: 1787:bool
    #####: 1788:pred_true (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1789:{
        -: 1790:  (void) pathname;
        -: 1791:  (void) stat_buf;
        -: 1792:  (void) pred_ptr;
    #####: 1793:  return true;
        -: 1794:}
        -: 1795:
        -: 1796:bool
    #####: 1797:pred_type (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1798:{
        -: 1799:  mode_t mode;
    #####: 1800:  mode_t type = pred_ptr->args.type;
        -: 1801:
    #####: 1802:  assert (state.have_type);
        -: 1803:
    #####: 1804:  if (0 == state.type)
        -: 1805:    {
        -: 1806:      /* This can sometimes happen with broken NFS servers.
        -: 1807:       * See Savannah bug #16378.
        -: 1808:       */
    #####: 1809:      return false;
        -: 1810:    }
        -: 1811:
        -: 1812:  (void) pathname;
        -: 1813:
    #####: 1814:  if (state.have_stat)
    #####: 1815:     mode = stat_buf->st_mode;
        -: 1816:  else
    #####: 1817:     mode = state.type;
        -: 1818:
        -: 1819:#ifndef S_IFMT
        -: 1820:  /* POSIX system; check `mode' the slow way. */
        -: 1821:  if ((S_ISBLK (mode) && type == S_IFBLK)
        -: 1822:      || (S_ISCHR (mode) && type == S_IFCHR)
        -: 1823:      || (S_ISDIR (mode) && type == S_IFDIR)
        -: 1824:      || (S_ISREG (mode) && type == S_IFREG)
        -: 1825:#ifdef S_IFLNK
        -: 1826:      || (S_ISLNK (mode) && type == S_IFLNK)
        -: 1827:#endif
        -: 1828:#ifdef S_IFIFO
        -: 1829:      || (S_ISFIFO (mode) && type == S_IFIFO)
        -: 1830:#endif
        -: 1831:#ifdef S_IFSOCK
        -: 1832:      || (S_ISSOCK (mode) && type == S_IFSOCK)
        -: 1833:#endif
        -: 1834:#ifdef S_IFDOOR
        -: 1835:      || (S_ISDOOR (mode) && type == S_IFDOOR)
        -: 1836:#endif
        -: 1837:      )
        -: 1838:#else /* S_IFMT */
        -: 1839:  /* Unix system; check `mode' the fast way. */
    #####: 1840:  if ((mode & S_IFMT) == type)
        -: 1841:#endif /* S_IFMT */
    #####: 1842:    return (true);
        -: 1843:  else
    #####: 1844:    return (false);
        -: 1845:}
        -: 1846:
        -: 1847:bool
    #####: 1848:pred_uid (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1849:{
        -: 1850:  (void) pathname;
    #####: 1851:  switch (pred_ptr->args.numinfo.kind)
        -: 1852:    {
        -: 1853:    case COMP_GT:
    #####: 1854:      if (stat_buf->st_uid > pred_ptr->args.numinfo.l_val)
    #####: 1855:	return (true);
    #####: 1856:      break;
        -: 1857:    case COMP_LT:
    #####: 1858:      if (stat_buf->st_uid < pred_ptr->args.numinfo.l_val)
    #####: 1859:	return (true);
    #####: 1860:      break;
        -: 1861:    case COMP_EQ:
    #####: 1862:      if (stat_buf->st_uid == pred_ptr->args.numinfo.l_val)
    #####: 1863:	return (true);
    #####: 1864:      break;
        -: 1865:    }
    #####: 1866:  return (false);
        -: 1867:}
        -: 1868:
        -: 1869:bool
    #####: 1870:pred_used (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1871:{
        -: 1872:  struct timespec delta, at, ct;
        -: 1873:
        -: 1874:  (void) pathname;
        -: 1875:
        -: 1876:  /* TODO: this needs to be retested carefully (manually, if necessary) */
    #####: 1877:  at = get_stat_atime (stat_buf);
    #####: 1878:  ct = get_stat_ctime (stat_buf);
    #####: 1879:  delta.tv_sec  = at.tv_sec  - ct.tv_sec;
    #####: 1880:  delta.tv_nsec = at.tv_nsec - ct.tv_nsec;
    #####: 1881:  if (delta.tv_nsec < 0)
        -: 1882:    {
    #####: 1883:      delta.tv_nsec += 1000000000;
    #####: 1884:      delta.tv_sec  -=          1;
        -: 1885:    }
    #####: 1886:  return pred_timewindow (delta, pred_ptr, DAYSECS);
        -: 1887:}
        -: 1888:
        -: 1889:bool
    #####: 1890:pred_user (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1891:{
        -: 1892:  (void) pathname;
    #####: 1893:  if (pred_ptr->args.uid == stat_buf->st_uid)
    #####: 1894:    return (true);
        -: 1895:  else
    #####: 1896:    return (false);
        -: 1897:}
        -: 1898:
        -: 1899:bool
    #####: 1900:pred_xtype (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1901:{
        -: 1902:  struct stat sbuf;		/* local copy, not stat_buf because we're using a different stat method */
        -: 1903:  int (*ystat) (const char*, struct stat *p);
        -: 1904:
        -: 1905:  /* If we would normally stat the link itself, stat the target instead.
        -: 1906:   * If we would normally follow the link, stat the link itself instead.
        -: 1907:   */
    #####: 1908:  if (following_links ())
    #####: 1909:    ystat = optionp_stat;
        -: 1910:  else
    #####: 1911:    ystat = optionl_stat;
        -: 1912:
    #####: 1913:  set_stat_placeholders (&sbuf);
    #####: 1914:  if ((*ystat) (state.rel_pathname, &sbuf) != 0)
        -: 1915:    {
    #####: 1916:      if (following_links () && errno == ENOENT)
        -: 1917:	{
        -: 1918:	  /* If we failed to follow the symlink,
        -: 1919:	   * fall back on looking at the symlink itself.
        -: 1920:	   */
        -: 1921:	  /* Mimic behavior of ls -lL. */
    #####: 1922:	  return (pred_type (pathname, stat_buf, pred_ptr));
        -: 1923:	}
        -: 1924:      else
        -: 1925:	{
    #####: 1926:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####: 1927:	  state.exit_status = 1;
        -: 1928:	}
    #####: 1929:      return false;
        -: 1930:    }
        -: 1931:  /* Now that we have our stat() information, query it in the same
        -: 1932:   * way that -type does.
        -: 1933:   */
    #####: 1934:  return (pred_type (pathname, &sbuf, pred_ptr));
        -: 1935:}
        -: 1936:
        -: 1937:
        -: 1938:bool
    #####: 1939:pred_context (const char *pathname, struct stat *stat_buf,
        -: 1940:	      struct predicate *pred_ptr)
        -: 1941:{
        -: 1942:  security_context_t scontext;
    #####: 1943:  int rv = (*options.x_getfilecon) (state.cwd_dir_fd, state.rel_pathname,
        -: 1944:				    &scontext);
    #####: 1945:  if (rv < 0)
        -: 1946:    {
    #####: 1947:      error (0, errno, _("getfilecon failed: %s"),
        -: 1948:	     safely_quote_err_filename (0, pathname));
    #####: 1949:      return false;
        -: 1950:    }
        -: 1951:
    #####: 1952:  rv = (fnmatch (pred_ptr->args.scontext, scontext, 0) == 0);
    #####: 1953:  freecon (scontext);
    #####: 1954:  return rv;
        -: 1955:}
        -: 1956:
        -: 1957:
        -: 1958:/*  1) fork to get a child; parent remembers the child pid
        -: 1959:    2) child execs the command requested
        -: 1960:    3) parent waits for child; checks for proper pid of child
        -: 1961:
        -: 1962:    Possible returns:
        -: 1963:
        -: 1964:    ret		errno	status(h)   status(l)
        -: 1965:
        -: 1966:    pid		x	signal#	    0177	stopped
        -: 1967:    pid		x	exit arg    0		term by _exit
        -: 1968:    pid		x	0	    signal #	term by signal
        -: 1969:    -1		EINTR				parent got signal
        -: 1970:    -1		other				some other kind of error
        -: 1971:
        -: 1972:    Return true only if the pid matches, status(l) is
        -: 1973:    zero, and the exit arg (status high) is 0.
        -: 1974:    Otherwise return false, possibly printing an error message. */
        -: 1975:
        -: 1976:
        -: 1977:static bool
    #####: 1978:prep_child_for_exec (bool close_stdin, const struct saved_cwd *wd)
        -: 1979:{
    #####: 1980:  bool ok = true;
    #####: 1981:  if (close_stdin)
        -: 1982:    {
    #####: 1983:      const char inputfile[] = "/dev/null";
        -: 1984:
    #####: 1985:      if (close (0) < 0)
        -: 1986:	{
    #####: 1987:	  error (0, errno, _("Cannot close standard input"));
    #####: 1988:	  ok = false;
        -: 1989:	}
        -: 1990:      else
        -: 1991:	{
    #####: 1992:	  if (open (inputfile, O_RDONLY
        -: 1993:#if defined O_LARGEFILE
        -: 1994:		   |O_LARGEFILE
        -: 1995:#endif
        -: 1996:		   ) < 0)
        -: 1997:	    {
        -: 1998:	      /* This is not entirely fatal, since
        -: 1999:	       * executing the child with a closed
        -: 2000:	       * stdin is almost as good as executing it
        -: 2001:	       * with its stdin attached to /dev/null.
        -: 2002:	       */
    #####: 2003:	      error (0, errno, "%s", safely_quote_err_filename (0, inputfile));
        -: 2004:	      /* do not set ok=false, it is OK to continue anyway. */
        -: 2005:	    }
        -: 2006:	}
        -: 2007:    }
        -: 2008:
        -: 2009:  /* Even if DebugSearch is set, don't announce our change of
        -: 2010:   * directory, since we're not going to emit a subsequent
        -: 2011:   * announcement of a call to stat() anyway, as we're about to exec
        -: 2012:   * something.
        -: 2013:   */
    #####: 2014:  if (0 != restore_cwd (wd))
        -: 2015:    {
    #####: 2016:      error (0, errno, _("Failed to change directory"));
    #####: 2017:      ok = false;
        -: 2018:    }
    #####: 2019:  return ok;
        -: 2020:}
        -: 2021:
        -: 2022:
        -: 2023:
        -: 2024:
        -: 2025:
        -: 2026:
        -: 2027:int
    #####: 2028:launch (struct buildcmd_control *ctl, void *usercontext, int argc, char **argv)
        -: 2029:{
        -: 2030:  pid_t child_pid;
        -: 2031:  static int first_time = 1;
    #####: 2032:  struct exec_val *execp = usercontext;
        -: 2033:
        -: 2034:  /* Make sure output of command doesn't get mixed with find output. */
    #####: 2035:  fflush (stdout);
    #####: 2036:  fflush (stderr);
        -: 2037:
        -: 2038:  /* Make sure to listen for the kids.  */
    #####: 2039:  if (first_time)
        -: 2040:    {
    #####: 2041:      first_time = 0;
    #####: 2042:      signal (SIGCHLD, SIG_DFL);
        -: 2043:    }
        -: 2044:
    #####: 2045:  child_pid = fork ();
    #####: 2046:  if (child_pid == -1)
    #####: 2047:    error (EXIT_FAILURE, errno, _("cannot fork"));
    #####: 2048:  if (child_pid == 0)
        -: 2049:    {
        -: 2050:      /* We are the child. */
    #####: 2051:      assert (NULL != execp->wd_for_exec);
    #####: 2052:      if (!prep_child_for_exec (execp->close_stdin, execp->wd_for_exec))
        -: 2053:	{
    #####: 2054:	  _exit (1);
        -: 2055:	}
        -: 2056:      else
        -: 2057:	{
    #####: 2058:	  if (fd_leak_check_is_enabled ())
        -: 2059:	    {
    #####: 2060:	      complain_about_leaky_fds ();
        -: 2061:	    }
        -: 2062:	}
        -: 2063:
    #####: 2064:      if (bc_args_exceed_testing_limit (argv))
    #####: 2065:	errno = E2BIG;
        -: 2066:      else
    #####: 2067:	execvp (argv[0], argv);
        -: 2068:      /* TODO: use a pipe to pass back the errno value, like xargs does */
    #####: 2069:      error (0, errno, "%s",
        -: 2070:	     safely_quote_err_filename (0, argv[0]));
    #####: 2071:      _exit (1);
        -: 2072:    }
        -: 2073:
    #####: 2074:  while (waitpid (child_pid, &(execp->last_child_status), 0) == (pid_t) -1)
        -: 2075:    {
    #####: 2076:      if (errno != EINTR)
        -: 2077:	{
    #####: 2078:	  error (0, errno, _("error waiting for %s"),
        -: 2079:		 safely_quote_err_filename (0, argv[0]));
    #####: 2080:	  state.exit_status = 1;
    #####: 2081:	  return 0;		/* FAIL */
        -: 2082:	}
        -: 2083:    }
        -: 2084:
    #####: 2085:  if (WIFSIGNALED (execp->last_child_status))
        -: 2086:    {
    #####: 2087:      error (0, 0, _("%s terminated by signal %d"),
        -: 2088:	     quotearg_n_style (0, options.err_quoting_style, argv[0]),
    #####: 2089:	     WTERMSIG (execp->last_child_status));
        -: 2090:
    #####: 2091:      if (execp->multiple)
        -: 2092:	{
        -: 2093:	  /* -exec   \; just returns false if the invoked command fails.
        -: 2094:	   * -exec {} + returns true if the invoked command fails, but
        -: 2095:	   *            sets the program exit status.
        -: 2096:	   */
    #####: 2097:	  state.exit_status = 1;
        -: 2098:	}
        -: 2099:
    #####: 2100:      return 1;			/* OK */
        -: 2101:    }
        -: 2102:
    #####: 2103:  if (0 == WEXITSTATUS (execp->last_child_status))
        -: 2104:    {
    #####: 2105:      return 1;			/* OK */
        -: 2106:    }
        -: 2107:  else
        -: 2108:    {
    #####: 2109:      if (execp->multiple)
        -: 2110:	{
        -: 2111:	  /* -exec   \; just returns false if the invoked command fails.
        -: 2112:	   * -exec {} + returns true if the invoked command fails, but
        -: 2113:	   *            sets the program exit status.
        -: 2114:	   */
    #####: 2115:	  state.exit_status = 1;
        -: 2116:	}
        -: 2117:      /* The child failed, but this is the exec callback.  We
        -: 2118:       * don't want to run the child again in this case anwyay.
        -: 2119:       */
    #####: 2120:      return 1;			/* FAIL (but don't try again) */
        -: 2121:    }
        -: 2122:
        -: 2123:}
        -: 2124:
        -: 2125:
        -: 2126:static bool
    #####: 2127:scan_for_digit_differences (const char *p, const char *q,
        -: 2128:			    size_t *first, size_t *n)
        -: 2129:{
    #####: 2130:  bool seen = false;
        -: 2131:  size_t i;
        -: 2132:
    #####: 2133:  for (i=0; p[i] && q[i]; i++)
        -: 2134:    {
    #####: 2135:      if (p[i] != q[i])
        -: 2136:	{
    #####: 2137:	  if (!isdigit ((unsigned char)q[i]) || !isdigit ((unsigned char)q[i]))
    #####: 2138:	    return false;
        -: 2139:
    #####: 2140:	  if (!seen)
        -: 2141:	    {
    #####: 2142:	      *first = i;
    #####: 2143:	      *n = 1;
    #####: 2144:	      seen = 1;
        -: 2145:	    }
        -: 2146:	  else
        -: 2147:	    {
    #####: 2148:	      if (i-*first == *n)
        -: 2149:		{
        -: 2150:		  /* Still in the first sequence of differing digits. */
    #####: 2151:		  ++*n;
        -: 2152:		}
        -: 2153:	      else
        -: 2154:		{
        -: 2155:		  /* More than one differing contiguous character sequence. */
    #####: 2156:		  return false;
        -: 2157:		}
        -: 2158:	    }
        -: 2159:	}
        -: 2160:    }
    #####: 2161:  if (p[i] || q[i])
        -: 2162:    {
        -: 2163:      /* strings are different lengths. */
    #####: 2164:      return false;
        -: 2165:    }
    #####: 2166:  return true;
        -: 2167:}
        -: 2168:
        -: 2169:
        -: 2170:static char*
    #####: 2171:do_time_format (const char *fmt, const struct tm *p, const char *ns, size_t ns_size)
        -: 2172:{
        -: 2173:  static char *buf = NULL;
        -: 2174:  static size_t buf_size;
    #####: 2175:  char *timefmt = NULL;
        -: 2176:  struct tm altered_time;
        -: 2177:
        -: 2178:
        -: 2179:  /* If the format expands to nothing (%p in some locales, for
        -: 2180:   * example), strftime can return 0.  We actually want to distinguish
        -: 2181:   * the error case where the buffer is too short, so we just prepend
        -: 2182:   * an otherwise uninteresting character to prevent the no-output
        -: 2183:   * case.
        -: 2184:   */
    #####: 2185:  timefmt = xmalloc (strlen (fmt) + 2u);
    #####: 2186:  sprintf (timefmt, "_%s", fmt);
        -: 2187:
        -: 2188:  /* altered_time is a similar time, but in which both
        -: 2189:   * digits of the seconds field are different.
        -: 2190:   */
    #####: 2191:  altered_time = *p;
    #####: 2192:  if (altered_time.tm_sec >= 11)
    #####: 2193:    altered_time.tm_sec -= 11;
        -: 2194:  else
    #####: 2195:    altered_time.tm_sec += 11;
        -: 2196:
        -: 2197:  /* If we call strftime() with buf_size=0, the program will coredump
        -: 2198:   * on Solaris, since it unconditionally writes the terminating null
        -: 2199:   * character.
        -: 2200:   */
    #####: 2201:  buf_size = 1u;
    #####: 2202:  buf = xmalloc (buf_size);
        -: 2203:  while (true)
        -: 2204:    {
        -: 2205:      /* I'm not sure that Solaris will return 0 when the buffer is too small.
        -: 2206:       * Therefore we do not check for (buf_used != 0) as the termination
        -: 2207:       * condition.
        -: 2208:       */
    #####: 2209:      size_t buf_used = strftime (buf, buf_size, timefmt, p);
    #####: 2210:      if (buf_used		/* Conforming POSIX system */
    #####: 2211:	  && (buf_used < buf_size)) /* Solaris workaround */
        -: 2212:	{
        -: 2213:	  char *altbuf;
    #####: 2214:	  size_t i = 0, n = 0;
    #####: 2215:	  size_t final_len = (buf_used
        -: 2216:			      + 1u /* for \0 */
    #####: 2217:			      + ns_size);
    #####: 2218:	  buf = xrealloc (buf, final_len);
    #####: 2219:	  altbuf = xmalloc (final_len);
    #####: 2220:	  strftime (altbuf, buf_size, timefmt, &altered_time);
        -: 2221:
        -: 2222:	  /* Find the seconds digits; they should be the only changed part.
        -: 2223:	   * In theory the result of the two formatting operations could differ in
        -: 2224:	   * more than just one sequence of decimal digits (for example %X might
        -: 2225:	   * in theory return a spelled-out time like "thirty seconds past noon").
        -: 2226:	   * When that happens, we just avoid inserting the nanoseconds field.
        -: 2227:	   */
    #####: 2228:	  if (scan_for_digit_differences (buf, altbuf, &i, &n)
    #####: 2229:	      && (2==n) && !isdigit ((unsigned char)buf[i+n]))
        -: 2230:	    {
    #####: 2231:	      const size_t end_of_seconds = i + n;
    #####: 2232:	      const size_t suffix_len = buf_used-(end_of_seconds)+1;
        -: 2233:
        -: 2234:	      /* Move the tail (including the \0).  Note that this
        -: 2235:	       * is a move of an overlapping memory block, so we
        -: 2236:	       * must use memmove instead of memcpy.  Then insert
        -: 2237:	       * the nanoseconds (but not its trailing \0).
        -: 2238:	       */
    #####: 2239:	      assert (end_of_seconds + ns_size + suffix_len == final_len);
    #####: 2240:	      memmove (buf+end_of_seconds+ns_size,
    #####: 2241:		       buf+end_of_seconds,
        -: 2242:		       suffix_len);
    #####: 2243:	      memcpy (buf+i+n, ns, ns_size);
        -: 2244:	    }
        -: 2245:	  else
        -: 2246:	    {
        -: 2247:	      /* No seconds digits.  No need to insert anything. */
        -: 2248:	    }
        -: 2249:	  /* The first character of buf is the underscore, which we actually
        -: 2250:	   * don't want.
        -: 2251:	   */
    #####: 2252:	  free (timefmt);
    #####: 2253:	  return buf+1;
        -: 2254:	}
        -: 2255:      else
        -: 2256:	{
    #####: 2257:	  buf = x2nrealloc (buf, &buf_size, 2u);
        -: 2258:	}
    #####: 2259:    }
        -: 2260:}
        -: 2261:
        -: 2262:
        -: 2263:
        -: 2264:/* Return a static string formatting the time WHEN according to the
        -: 2265: * strftime format character KIND.
        -: 2266: *
        -: 2267: * This function contains a number of assertions.  These look like
        -: 2268: * runtime checks of the results of computations, which would be a
        -: 2269: * problem since external events should not be tested for with
        -: 2270: * "assert" (instead you should use "if").  However, they are not
        -: 2271: * really runtime checks.  The assertions actually exist to verify
        -: 2272: * that the various buffers are correctly sized.
        -: 2273: */
        -: 2274:static char *
    #####: 2275:format_date (struct timespec ts, int kind)
        -: 2276:{
        -: 2277:  /* In theory, we use an extra 10 characters for 9 digits of
        -: 2278:   * nanoseconds and 1 for the decimal point.  However, the real
        -: 2279:   * world is more complex than that.
        -: 2280:   *
        -: 2281:   * For example, some systems return junk in the tv_nsec part of
        -: 2282:   * st_birthtime.  An example of this is the NetBSD-4.0-RELENG kernel
        -: 2283:   * (at Sat Mar 24 18:46:46 2007) running a NetBSD-3.1-RELEASE
        -: 2284:   * runtime and examining files on an msdos filesytem.  So for that
        -: 2285:   * reason we set NS_BUF_LEN to 32, which is simply "long enough" as
        -: 2286:   * opposed to "exactly the right size".  Note that the behaviour of
        -: 2287:   * NetBSD appears to be a result of the use of uninitialised data,
        -: 2288:   * as it's not 100% reproducible (more like 25%).
        -: 2289:   */
        -: 2290:  enum {
        -: 2291:    NS_BUF_LEN = 32,
        -: 2292:    DATE_LEN_PERCENT_APLUS=21	/* length of result of %A+ (it's longer than %c)*/
        -: 2293:  };
        -: 2294:  static char buf[128u+10u + MAX(DATE_LEN_PERCENT_APLUS,
        -: 2295:			    MAX (LONGEST_HUMAN_READABLE + 2, NS_BUF_LEN+64+200))];
        -: 2296:  char ns_buf[NS_BUF_LEN]; /* -.9999999990 (- sign can happen!)*/
        -: 2297:  int  charsprinted, need_ns_suffix;
        -: 2298:  struct tm *tm;
        -: 2299:  char fmt[6];
        -: 2300:
        -: 2301:  /* human_readable() assumes we pass a buffer which is at least as
        -: 2302:   * long as LONGEST_HUMAN_READABLE.  We use an assertion here to
        -: 2303:   * ensure that no nasty unsigned overflow happend in our calculation
        -: 2304:   * of the size of buf.  Do the assertion here rather than in the
        -: 2305:   * code for %@ so that we find the problem quickly if it exists.  If
        -: 2306:   * you want to submit a patch to move this into the if statement, go
        -: 2307:   * ahead, I'll apply it.  But include performance timings
        -: 2308:   * demonstrating that the performance difference is actually
        -: 2309:   * measurable.
        -: 2310:   */
        -: 2311:  verify (sizeof (buf) >= LONGEST_HUMAN_READABLE);
        -: 2312:
    #####: 2313:  charsprinted = 0;
    #####: 2314:  need_ns_suffix = 0;
        -: 2315:
        -: 2316:  /* Format the main part of the time. */
    #####: 2317:  if (kind == '+')
        -: 2318:    {
    #####: 2319:      strcpy (fmt, "%F+%T");
    #####: 2320:      need_ns_suffix = 1;
        -: 2321:    }
        -: 2322:  else
        -: 2323:    {
    #####: 2324:      fmt[0] = '%';
    #####: 2325:      fmt[1] = kind;
    #####: 2326:      fmt[2] = '\0';
        -: 2327:
        -: 2328:      /* %a, %c, and %t are handled in ctime_format() */
    #####: 2329:      switch (kind)
        -: 2330:	{
        -: 2331:	case 'S':
        -: 2332:	case 'T':
        -: 2333:	case 'X':
        -: 2334:	case '@':
    #####: 2335:	  need_ns_suffix = 1;
    #####: 2336:	  break;
        -: 2337:	default:
    #####: 2338:	  need_ns_suffix = 0;
    #####: 2339:	  break;
        -: 2340:	}
        -: 2341:    }
        -: 2342:
    #####: 2343:  if (need_ns_suffix)
        -: 2344:    {
        -: 2345:      /* Format the nanoseconds part.  Leave a trailing zero to
        -: 2346:       * discourage people from writing scripts which extract the
        -: 2347:       * fractional part of the timestamp by using column offsets.
        -: 2348:       * The reason for discouraging this is that in the future, the
        -: 2349:       * granularity may not be nanoseconds.
        -: 2350:       */
    #####: 2351:      charsprinted = snprintf (ns_buf, NS_BUF_LEN, ".%09ld0", (long int)ts.tv_nsec);
    #####: 2352:      assert (charsprinted < NS_BUF_LEN);
        -: 2353:    }
        -: 2354:  else
        -: 2355:    {
    #####: 2356:      charsprinted = 0;
    #####: 2357:      ns_buf[0] = 0;
        -: 2358:    }
        -: 2359:
    #####: 2360:  if (kind != '@')
        -: 2361:    {
    #####: 2362:      tm = localtime (&ts.tv_sec);
    #####: 2363:      if (tm)
        -: 2364:	{
    #####: 2365:	  char *s = do_time_format (fmt, tm, ns_buf, charsprinted);
    #####: 2366:	  if (s)
    #####: 2367:	    return s;
        -: 2368:	}
        -: 2369:    }
        -: 2370:
        -: 2371:  /* If we get to here, either the format was %@, or we have fallen back to it
        -: 2372:   * because strftime failed.
        -: 2373:   */
        -: 2374:  if (1)
        -: 2375:    {
    #####: 2376:      uintmax_t w = ts.tv_sec;
        -: 2377:      size_t used, len, remaining;
        -: 2378:
        -: 2379:      /* XXX: note that we are negating an unsigned type which is the
        -: 2380:       * widest possible unsigned type.
        -: 2381:       */
    #####: 2382:      char *p = human_readable (ts.tv_sec < 0 ? -w : w, buf + 1,
        -: 2383:				human_ceiling, 1, 1);
    #####: 2384:      assert (p > buf);
    #####: 2385:      assert (p < (buf + (sizeof buf)));
    #####: 2386:      if (ts.tv_sec < 0)
    #####: 2387:	*--p = '-'; /* XXX: Ugh, relying on internal details of human_readable(). */
        -: 2388:
        -: 2389:      /* Add the nanoseconds part.  Because we cannot enforce a
        -: 2390:       * particlar implementation of human_readable, we cannot assume
        -: 2391:       * any particular value for (p-buf).  So we need to be careful
        -: 2392:       * that there is enough space remaining in the buffer.
        -: 2393:       */
    #####: 2394:      if (need_ns_suffix)
        -: 2395:	{
    #####: 2396:	  len = strlen (p);
    #####: 2397:	  used = (p-buf) + len;	/* Offset into buf of current end */
    #####: 2398:	  assert (sizeof buf > used); /* Ensure we can perform subtraction safely. */
    #####: 2399:	  remaining = sizeof buf - used - 1u; /* allow space for NUL */
        -: 2400:
    #####: 2401:	  if (strlen (ns_buf) >= remaining)
        -: 2402:	    {
    #####: 2403:	      error (0, 0,
        -: 2404:		     "charsprinted=%ld but remaining=%lu: ns_buf=%s",
        -: 2405:		     (long)charsprinted, (unsigned long)remaining, ns_buf);
        -: 2406:	    }
    #####: 2407:	  assert (strlen (ns_buf) < remaining);
    #####: 2408:	  strcat (p, ns_buf);
        -: 2409:	}
    #####: 2410:      return p;
        -: 2411:    }
        -: 2412:}
        -: 2413:
        -: 2414:static const char *weekdays[] =
        -: 2415:  {
        -: 2416:    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
        -: 2417:  };
        -: 2418:static char * months[] =
        -: 2419:  {
        -: 2420:    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        -: 2421:    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
        -: 2422:  };
        -: 2423:
        -: 2424:
        -: 2425:static char *
    #####: 2426:ctime_format (struct timespec ts)
        -: 2427:{
        -: 2428:  const struct tm * ptm;
        -: 2429:#define TIME_BUF_LEN 1024u
        -: 2430:  static char resultbuf[TIME_BUF_LEN];
        -: 2431:  int nout;
        -: 2432:
    #####: 2433:  ptm = localtime (&ts.tv_sec);
    #####: 2434:  if (ptm)
        -: 2435:    {
    #####: 2436:      assert (ptm->tm_wday >=  0);
    #####: 2437:      assert (ptm->tm_wday <   7);
    #####: 2438:      assert (ptm->tm_mon  >=  0);
    #####: 2439:      assert (ptm->tm_mon  <  12);
    #####: 2440:      assert (ptm->tm_hour >=  0);
    #####: 2441:      assert (ptm->tm_hour <  24);
    #####: 2442:      assert (ptm->tm_min  <  60);
    #####: 2443:      assert (ptm->tm_sec  <= 61); /* allows 2 leap seconds. */
        -: 2444:
        -: 2445:      /* wkday mon mday hh:mm:ss.nnnnnnnnn yyyy */
    #####: 2446:      nout = snprintf (resultbuf, TIME_BUF_LEN,
        -: 2447:		       "%3s %3s %2d %02d:%02d:%02d.%010ld %04d",
    #####: 2448:		       weekdays[ptm->tm_wday],
    #####: 2449:		       months[ptm->tm_mon],
        -: 2450:		       ptm->tm_mday,
        -: 2451:		       ptm->tm_hour,
        -: 2452:		       ptm->tm_min,
        -: 2453:		       ptm->tm_sec,
        -: 2454:		       (long int)ts.tv_nsec,
    #####: 2455:		       1900 + ptm->tm_year);
        -: 2456:
    #####: 2457:      assert (nout < TIME_BUF_LEN);
    #####: 2458:      return resultbuf;
        -: 2459:    }
        -: 2460:  else
        -: 2461:    {
        -: 2462:      /* The time cannot be represented as a struct tm.
        -: 2463:	 Output it as an integer.  */
    #####: 2464:      return format_date (ts, '@');
        -: 2465:    }
        -: 2466:}
        -: 2467:
        -: 2468:/* Copy STR into BUF and trim blanks from the end of BUF.
        -: 2469:   Return BUF. */
        -: 2470:
        -: 2471:static char *
    #####: 2472:blank_rtrim (str, buf)
        -: 2473:     char *str;
        -: 2474:     char *buf;
        -: 2475:{
        -: 2476:  int i;
        -: 2477:
    #####: 2478:  if (str == NULL)
    #####: 2479:    return (NULL);
    #####: 2480:  strcpy (buf, str);
    #####: 2481:  i = strlen (buf) - 1;
    #####: 2482:  while ((i >= 0) && ((buf[i] == ' ') || buf[i] == '\t'))
    #####: 2483:    i--;
    #####: 2484:  buf[++i] = '\0';
    #####: 2485:  return (buf);
        -: 2486:}
        -: 2487:
        -: 2488:/* Print out the predicate list starting at NODE. */
        -: 2489:void
    #####: 2490:print_list (FILE *fp, struct predicate *node)
        -: 2491:{
        -: 2492:  struct predicate *cur;
        -: 2493:  char name[256];
        -: 2494:
    #####: 2495:  cur = node;
    #####: 2496:  while (cur != NULL)
        -: 2497:    {
    #####: 2498:      fprintf (fp, "[%s] ", blank_rtrim (cur->p_name, name));
    #####: 2499:      cur = cur->pred_next;
        -: 2500:    }
    #####: 2501:  fprintf (fp, "\n");
    #####: 2502:}
        -: 2503:
        -: 2504:/* Print out the predicate list starting at NODE. */
        -: 2505:static void
    #####: 2506:print_parenthesised (FILE *fp, struct predicate *node)
        -: 2507:{
    #####: 2508:  int parens = 0;
        -: 2509:
    #####: 2510:  if (node)
        -: 2511:    {
    #####: 2512:      if ((pred_is (node, pred_or) || pred_is (node, pred_and))
    #####: 2513:	  && node->pred_left == NULL)
        -: 2514:	{
        -: 2515:	  /* We print "<nothing> or  X" as just "X"
        -: 2516:	   * We print "<nothing> and X" as just "X"
        -: 2517:	   */
    #####: 2518:	  print_parenthesised(fp, node->pred_right);
        -: 2519:	}
        -: 2520:      else
        -: 2521:	{
    #####: 2522:	  if (node->pred_left || node->pred_right)
    #####: 2523:	    parens = 1;
        -: 2524:
    #####: 2525:	  if (parens)
    #####: 2526:	    fprintf (fp, "%s", " ( ");
    #####: 2527:	  print_optlist (fp, node);
    #####: 2528:	  if (parens)
    #####: 2529:	    fprintf (fp, "%s", " ) ");
        -: 2530:	}
        -: 2531:    }
    #####: 2532:}
        -: 2533:
        -: 2534:void
    #####: 2535:print_optlist (FILE *fp, const struct predicate *p)
        -: 2536:{
    #####: 2537:  if (p)
        -: 2538:    {
    #####: 2539:      print_parenthesised (fp, p->pred_left);
    #####: 2540:      fprintf (fp,
        -: 2541:	       "%s%s%s",
    #####: 2542:	       p->need_stat ? "[call stat] " : "",
    #####: 2543:	       p->need_type ? "[need type] " : "",
    #####: 2544:	       p->need_inum ? "[need inum] " : "");
    #####: 2545:      print_predicate (fp, p);
    #####: 2546:      fprintf (fp, " [%g] ", p->est_success_rate);
    #####: 2547:      if (options.debug_options & DebugSuccessRates)
        -: 2548:	{
    #####: 2549:	  fprintf (fp, "[%ld/%ld", p->perf.successes, p->perf.visits);
    #####: 2550:	  if (p->perf.visits)
        -: 2551:	    {
    #####: 2552:	      double real_rate = (double)p->perf.successes / (double)p->perf.visits;
    #####: 2553:	      fprintf (fp, "=%g] ", real_rate);
        -: 2554:	    }
        -: 2555:	  else
        -: 2556:	    {
    #####: 2557:	      fprintf (fp, "=_] ");
        -: 2558:	    }
        -: 2559:	}
    #####: 2560:      print_parenthesised (fp, p->pred_right);
        -: 2561:    }
    #####: 2562:}
        -: 2563:
        8: 2564:void show_success_rates (const struct predicate *p)
        -: 2565:{
        8: 2566:  if (options.debug_options & DebugSuccessRates)
        -: 2567:    {
    #####: 2568:      fprintf (stderr, "Predicate success rates after completion:\n");
    #####: 2569:      print_optlist (stderr, p);
    #####: 2570:      fprintf (stderr, "\n");
        -: 2571:    }
        8: 2572:}
        -: 2573:
        -: 2574:
        -: 2575:
        -: 2576:
        -: 2577:#ifdef _NDEBUG
        -: 2578:/* If _NDEBUG is defined, the assertions will do nothing.   Hence
        -: 2579: * there is no point in having a function body for pred_sanity_check()
        -: 2580: * if that preprocessor macro is defined.
        -: 2581: */
        -: 2582:void
        -: 2583:pred_sanity_check (const struct predicate *predicates)
        -: 2584:{
        -: 2585:  /* Do nothing, since assert is a no-op with _NDEBUG set */
        -: 2586:  return;
        -: 2587:}
        -: 2588:#else
        -: 2589:void
       57: 2590:pred_sanity_check (const struct predicate *predicates)
        -: 2591:{
        -: 2592:  const struct predicate *p;
        -: 2593:
      178: 2594:  for (p=predicates; p != NULL; p=p->pred_next)
        -: 2595:    {
        -: 2596:      /* All predicates must do something. */
      121: 2597:      assert (p->pred_func != NULL);
        -: 2598:
        -: 2599:      /* All predicates must have a parser table entry. */
      121: 2600:      assert (p->parser_entry != NULL);
        -: 2601:
        -: 2602:      /* If the parser table tells us that just one predicate function is
        -: 2603:       * possible, verify that that is still the one that is in effect.
        -: 2604:       * If the parser has NULL for the predicate function, that means that
        -: 2605:       * the parse_xxx function fills it in, so we can't check it.
        -: 2606:       */
      121: 2607:      if (p->parser_entry->pred_func)
        -: 2608:	{
      121: 2609:	  assert (p->parser_entry->pred_func == p->pred_func);
        -: 2610:	}
        -: 2611:
      121: 2612:      switch (p->parser_entry->type)
        -: 2613:	{
        -: 2614:	  /* Options all take effect during parsing, so there should
        -: 2615:	   * be no predicate entries corresponding to them.  Hence we
        -: 2616:	   * should not see any ARG_OPTION or ARG_POSITIONAL_OPTION
        -: 2617:	   * items.
        -: 2618:	   *
        -: 2619:	   * This is a silly way of coding this test, but it prevents
        -: 2620:	   * a compiler warning (i.e. otherwise it would think that
        -: 2621:	   * there would be case statements missing).
        -: 2622:	   */
        -: 2623:	case ARG_OPTION:
        -: 2624:	case ARG_POSITIONAL_OPTION:
    #####: 2625:	  assert (p->parser_entry->type != ARG_OPTION);
    #####: 2626:	  assert (p->parser_entry->type != ARG_POSITIONAL_OPTION);
    #####: 2627:	  break;
        -: 2628:
        -: 2629:	case ARG_ACTION:
       32: 2630:	  assert (p->side_effects); /* actions have side effects. */
       32: 2631:	  if (!pred_is (p, pred_prune) && !pred_is(p, pred_quit))
        -: 2632:	    {
        -: 2633:	      /* actions other than -prune and -quit should
        -: 2634:	       * inhibit the default -print
        -: 2635:	       */
       32: 2636:	      assert (p->no_default_print);
        -: 2637:	    }
       32: 2638:	  break;
        -: 2639:
        -: 2640:	/* We happen to know that the only user of ARG_SPECIAL_PARSE
        -: 2641:	 * is a test, so handle it like ARG_TEST.
        -: 2642:	 */
        -: 2643:	case ARG_SPECIAL_PARSE:
        -: 2644:	case ARG_TEST:
        -: 2645:	case ARG_PUNCTUATION:
        -: 2646:	case ARG_NOOP:
        -: 2647:	  /* Punctuation and tests should have no side
        -: 2648:	   * effects and not inhibit default print.
        -: 2649:	   */
       89: 2650:	  assert (!p->no_default_print);
       89: 2651:	  assert (!p->side_effects);
       89: 2652:	  break;
        -: 2653:	}
        -: 2654:    }
       57: 2655:}
        -: 2656:#endif
