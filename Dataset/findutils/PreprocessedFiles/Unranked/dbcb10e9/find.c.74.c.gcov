        -:    0:Source:find.c
        -:    0:Graph:find.gcno
        -:    0:Data:find.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:/* find -- search for files in a directory hierarchy
        -:    2:   Copyright (C) 1990, 91, 92, 93, 94, 2000, 
        -:    3:                 2003, 2004, 2005 Free Software Foundation, Inc.
        -:    4:
        -:    5:   This program is free software; you can redistribute it and/or modify
        -:    6:   it under the terms of the GNU General Public License as published by
        -:    7:   the Free Software Foundation; either version 2, or (at your option)
        -:    8:   any later version.
        -:    9:
        -:   10:   This program is distributed in the hope that it will be useful,
        -:   11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:   GNU General Public License for more details.
        -:   14:
        -:   15:   You should have received a copy of the GNU General Public License
        -:   16:   along with this program; if not, write to the Free Software
        -:   17:   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
        -:   18:   USA.*/
        -:   19:
        -:   20:/* GNU find was written by Eric Decker <cire@cisco.com>,
        -:   21:   with enhancements by David MacKenzie <djm@gnu.org>,
        -:   22:   Jay Plett <jay@silence.princeton.nj.us>,
        -:   23:   and Tim Wood <axolotl!tim@toad.com>.
        -:   24:   The idea for -print0 and xargs -0 came from
        -:   25:   Dan Bernstein <brnstnd@kramden.acf.nyu.edu>.  
        -:   26:   Improvements have been made by James Youngman <jay@gnu.org>.
        -:   27:*/
        -:   28:
        -:   29:
        -:   30:#include <config.h>
        -:   31:#include "defs.h"
        -:   32:
        -:   33:#define USE_SAFE_CHDIR 1
        -:   34:#undef  STAT_MOUNTPOINTS
        -:   35:
        -:   36:
        -:   37:#include <errno.h>
        -:   38:#include <assert.h>
        -:   39:
        -:   40:
        -:   41:#ifdef HAVE_FCNTL_H
        -:   42:#include <fcntl.h>
        -:   43:#else
        -:   44:#include <sys/file.h>
        -:   45:#endif
        -:   46:#include <openat.h>
        -:   47:
        -:   48:#include "xalloc.h"
        -:   49:#include "human.h"
        -:   50:#include "canonicalize.h"
        -:   51:#include <modetype.h>
        -:   52:
        -:   53:#include "closeout.h"
        -:   54:#include "savedirinfo.h"
        -:   55:#include "buildcmd.h"
        -:   56:#include "dirname.h"
        -:   57:#include "quote.h"
        -:   58:#include "quotearg.h"
        -:   59:#include "xgetcwd.h"
        -:   60:#include "error.h"
        -:   61:
        -:   62:#ifdef HAVE_LOCALE_H
        -:   63:#include <locale.h>
        -:   64:#endif
        -:   65:
        -:   66:#if ENABLE_NLS
        -:   67:# include <libintl.h>
        -:   68:# define _(Text) gettext (Text)
        -:   69:#else
        -:   70:# define _(Text) Text
        -:   71:#define textdomain(Domain)
        -:   72:#define bindtextdomain(Package, Directory)
        -:   73:#endif
        -:   74:#ifdef gettext_noop
        -:   75:# define N_(String) gettext_noop (String)
        -:   76:#else
        -:   77:/* See locate.c for explanation as to why not use (String) */
        -:   78:# define N_(String) String
        -:   79:#endif
        -:   80:
        -:   81:#ifdef STAT_MOUNTPOINTS
        -:   82:static void init_mounted_dev_list(int mandatory);
        -:   83:#endif
        -:   84:
        -:   85:static void process_top_path PARAMS((char *pathname, mode_t mode));
        -:   86:static int process_path PARAMS((char *pathname, char *name, boolean leaf, char *parent, mode_t type));
        -:   87:static void process_dir PARAMS((char *pathname, char *name, int pathlen, const struct stat *statp, char *parent));
        -:   88:
        -:   89:
        -:   90:
        -:   91:/* Name this program was run with. */
        -:   92:char *program_name;
        -:   93:
        -:   94:/* A file descriptor open to the initial working directory.
        -:   95:   Doing it this way allows us to work when the i.w.d. has
        -:   96:   unreadable parents.  */
        -:   97:int starting_desc;
        -:   98:
        -:   99:/* The stat buffer of the initial working directory. */
        -:  100:static struct stat starting_stat_buf;
        -:  101:
        -:  102:enum ChdirSymlinkHandling
        -:  103:  {
        -:  104:    SymlinkHandleDefault,	/* Normally the right choice */
        -:  105:    SymlinkFollowOk		/* see comment in process_top_path() */
        -:  106:  };
        -:  107:
        -:  108:
        -:  109:enum TraversalDirection
        -:  110:  {
        -:  111:    TraversingUp,
        -:  112:    TraversingDown
        -:  113:  };
        -:  114:
        -:  115:enum WdSanityCheckFatality
        -:  116:  {
        -:  117:    FATAL_IF_SANITY_CHECK_FAILS,
        -:  118:    RETRY_IF_SANITY_CHECK_FAILS,
        -:  119:    NON_FATAL_IF_SANITY_CHECK_FAILS
        -:  120:  };
        -:  121:
        -:  122:
      192:  123:int get_current_dirfd(void)
        -:  124:{
      192:  125:  return AT_FDCWD;
        -:  126:}
        -:  127:
        -:  128:
        -:  129:int
        4:  130:main (int argc, char **argv)
        -:  131:{
        -:  132:  int i;
        4:  133:  int end_of_leading_options = 0; /* First arg after any -H/-L etc. */
        -:  134:  struct predicate *eval_tree;
        -:  135:
        4:  136:  program_name = argv[0];
        4:  137:  state.exit_status = 0;
        -:  138:
        -:  139:  /* Set the option defaults before we do the the locale
        -:  140:   * initialisation as check_nofollow() needs to be executed in the
        -:  141:   * POSIX locale.
        -:  142:   */
        4:  143:  set_option_defaults(&options);
        -:  144:
        -:  145:#ifdef HAVE_SETLOCALE
        4:  146:  setlocale (LC_ALL, "");
        -:  147:#endif
        -:  148:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  149:  textdomain (PACKAGE);
        4:  150:  atexit (close_stdout);
        -:  151:
        -:  152:  /* Check for -P, -H or -L options. */
        4:  153:  end_of_leading_options = process_leading_options(argc, argv);
        -:  154:
        4:  155:  if (options.debug_options & DebugStat)
    #####:  156:    options.xstat = debug_stat;
        -:  157:
        -:  158:#ifdef DEBUG
        -:  159:  fprintf (stderr, "cur_day_start = %s", ctime (&options.cur_day_start));
        -:  160:#endif /* DEBUG */
        -:  161:
        -:  162:  /* state.cwd_dir_fd has to be initialised before we call build_expression_tree()
        -:  163:   * because command-line parsing may lead us to stat some files.
        -:  164:   */
        4:  165:  state.cwd_dir_fd = AT_FDCWD;
        -:  166:  
        -:  167:  /* We are now processing the part of the "find" command line 
        -:  168:   * after the -H/-L options (if any).
        -:  169:   */
        4:  170:  eval_tree = build_expression_tree(argc, argv, end_of_leading_options);
        -:  171:
        -:  172:  
        -:  173:  /* safely_chdir() needs to check that it has ended up in the right place. 
        -:  174:   * To avoid bailing out when something gets automounted, it checks if 
        -:  175:   * the target directory appears to have had a directory mounted on it as
        -:  176:   * we chdir()ed.  The problem with this is that in order to notice that 
        -:  177:   * a filesystem was mounted, we would need to lstat() all the mount points.
        -:  178:   * That strategy loses if our machine is a client of a dead NFS server.
        -:  179:   *
        -:  180:   * Hence if safely_chdir() and wd_sanity_check() can manage without needing 
        -:  181:   * to know the mounted device list, we do that.  
        -:  182:   */
        4:  183:  if (!options.open_nofollow_available)
        -:  184:    {
        -:  185:#ifdef STAT_MOUNTPOINTS
        -:  186:      init_mounted_dev_list(0);
        -:  187:#endif
        -:  188:    }
        -:  189:  
        -:  190:
        4:  191:  starting_desc = open (".", O_RDONLY
        -:  192:#if defined O_LARGEFILE
        -:  193:			|O_LARGEFILE
        -:  194:#endif
        -:  195:			);
        4:  196:  if (0 <= starting_desc && fchdir (starting_desc) != 0)
        -:  197:    {
    #####:  198:      close (starting_desc);
    #####:  199:      starting_desc = -1;
        -:  200:    }
        4:  201:  assert(starting_desc >= 0);
        -:  202:
        4:  203:  if (starting_desc < 0)
        -:  204:    {
    #####:  205:      starting_dir = xgetcwd ();
    #####:  206:      if (! starting_dir)
    #####:  207:	error (1, errno, _("cannot get current directory"));
        -:  208:    }
        4:  209:  set_stat_placeholders(&starting_stat_buf);
        4:  210:  if ((*options.xstat) (".", &starting_stat_buf) != 0)
    #####:  211:    error (1, errno, _("cannot stat current directory"));
        -:  212:
        -:  213:  /* If no paths are given, default to ".".  */
        8:  214:  for (i = end_of_leading_options; i < argc && !looks_like_expression(argv[i], true); i++)
        -:  215:    {
        4:  216:      process_top_path (argv[i], 0);
        -:  217:    }
        -:  218:
        -:  219:  /* If there were no path arguments, default to ".". */
        4:  220:  if (i == end_of_leading_options)
        -:  221:    {
        -:  222:      /* 
        -:  223:       * We use a temporary variable here because some actions modify 
        -:  224:       * the path temporarily.  Hence if we use a string constant, 
        -:  225:       * we get a coredump.  The best example of this is if we say 
        -:  226:       * "find -printf %H" (note, not "find . -printf %H").
        -:  227:       */
    #####:  228:      char defaultpath[2] = ".";
    #####:  229:      process_top_path (defaultpath, 0);
        -:  230:    }
        -:  231:
        -:  232:  /* If "-exec ... {} +" has been used, there may be some 
        -:  233:   * partially-full command lines which have been built, 
        -:  234:   * but which are not yet complete.   Execute those now.
        -:  235:   */
        4:  236:  show_success_rates(eval_tree);
        4:  237:  cleanup();
        4:  238:  return state.exit_status;
        -:  239:}
        -:  240:
    #####:  241:boolean is_fts_enabled(int *ftsoptions)
        -:  242:{
        -:  243:  /* this version of find (i.e. this main()) does not use fts. */
    #####:  244:  *ftsoptions = 0;
    #####:  245:  return false;
        -:  246:}
        -:  247:
        -:  248:
        -:  249:static char *
    #####:  250:specific_dirname(const char *dir)
        -:  251:{
        -:  252:  char dirbuf[1024];
        -:  253:
    #####:  254:  if (0 == strcmp(".", dir))
        -:  255:    {
        -:  256:      /* OK, what's '.'? */
    #####:  257:      if (NULL != getcwd(dirbuf, sizeof(dirbuf)))
        -:  258:	{
    #####:  259:	  return strdup(dirbuf);
        -:  260:	}
        -:  261:      else
        -:  262:	{
    #####:  263:	  return strdup(dir);
        -:  264:	}
        -:  265:    }
        -:  266:  else
        -:  267:    {
    #####:  268:      char *result = canonicalize_filename_mode(dir, CAN_EXISTING);
    #####:  269:      if (NULL == result)
    #####:  270:	return strdup(dir);
        -:  271:      else
    #####:  272:	return result;
        -:  273:    }
        -:  274:}
        -:  275:
        -:  276:
        -:  277:
        -:  278:/* Return non-zero if FS is the name of a filesystem that is likely to
        -:  279: * be automounted
        -:  280: */
        -:  281:static int
    #####:  282:fs_likely_to_be_automounted(const char *fs)
        -:  283:{
    #####:  284:  return ( (0==strcmp(fs, "nfs")) || (0==strcmp(fs, "autofs")) || (0==strcmp(fs, "subfs")));
        -:  285:}
        -:  286:
        -:  287:
        -:  288:
        -:  289:#ifdef STAT_MOUNTPOINTS
        -:  290:static dev_t *mounted_devices = NULL;
        -:  291:static size_t num_mounted_devices = 0u;
        -:  292:
        -:  293:
        -:  294:static void
        -:  295:init_mounted_dev_list(int mandatory)
        -:  296:{
        -:  297:  assert(NULL == mounted_devices);
        -:  298:  assert(0 == num_mounted_devices);
        -:  299:  mounted_devices = get_mounted_devices(&num_mounted_devices);
        -:  300:  if (mandatory && (NULL == mounted_devices))
        -:  301:    {
        -:  302:      error(1, 0, "Cannot read list of mounted devices.");
        -:  303:    }
        -:  304:}
        -:  305:
        -:  306:static void
        -:  307:refresh_mounted_dev_list(void)
        -:  308:{
        -:  309:  if (mounted_devices)
        -:  310:    {
        -:  311:      free(mounted_devices);
        -:  312:      mounted_devices = 0;
        -:  313:    }
        -:  314:  num_mounted_devices = 0u;
        -:  315:  init_mounted_dev_list(1);
        -:  316:}
        -:  317:
        -:  318:
        -:  319:/* Search for device DEV in the array LIST, which is of size N. */
        -:  320:static int
        -:  321:dev_present(dev_t dev, const dev_t *list, size_t n)
        -:  322:{
        -:  323:  if (list)
        -:  324:    {
        -:  325:      while (n-- > 0u)
        -:  326:	{
        -:  327:	  if ( (*list++) == dev )
        -:  328:	    return 1;
        -:  329:	}
        -:  330:    }
        -:  331:  return 0;
        -:  332:}
        -:  333:
        -:  334:enum MountPointStateChange
        -:  335:  {
        -:  336:    MountPointRecentlyMounted,
        -:  337:    MountPointRecentlyUnmounted,
        -:  338:    MountPointStateUnchanged
        -:  339:  };
        -:  340:
        -:  341:
        -:  342:
        -:  343:static enum MountPointStateChange
        -:  344:get_mount_state(dev_t newdev)
        -:  345:{
        -:  346:  int new_is_present, new_was_present;
        -:  347:  
        -:  348:  new_was_present = dev_present(newdev, mounted_devices, num_mounted_devices);
        -:  349:  refresh_mounted_dev_list();
        -:  350:  new_is_present  = dev_present(newdev, mounted_devices, num_mounted_devices);
        -:  351:  
        -:  352:  if (new_was_present == new_is_present)
        -:  353:    return MountPointStateUnchanged;
        -:  354:  else if (new_is_present)
        -:  355:    return MountPointRecentlyMounted;
        -:  356:  else
        -:  357:    return MountPointRecentlyUnmounted;
        -:  358:}
        -:  359:
        -:  360:
        -:  361:
        -:  362:/* We stat()ed a directory, chdir()ed into it (we know this 
        -:  363: * since direction is TraversingDown), stat()ed it again,
        -:  364: * and noticed that the device numbers are different.  Check
        -:  365: * if the filesystem was recently mounted. 
        -:  366: * 
        -:  367: * If it was, it looks like chdir()ing into the directory
        -:  368: * caused a filesystem to be mounted.  Maybe automount is
        -:  369: * running.  Anyway, that's probably OK - but it happens
        -:  370: * only when we are moving downward.
        -:  371: *
        -:  372: * We also allow for the possibility that a similar thing
        -:  373: * has happened with the unmounting of a filesystem.  This
        -:  374: * is much rarer, as it relies on an automounter timeout
        -:  375: * occurring at exactly the wrong moment.
        -:  376: */
        -:  377:static enum WdSanityCheckFatality
        -:  378:dirchange_is_fatal(const char *specific_what,
        -:  379:		   enum WdSanityCheckFatality isfatal,
        -:  380:		   int silent,
        -:  381:		   struct stat *newinfo)
        -:  382:{
        -:  383:  enum MountPointStateChange transition = get_mount_state(newinfo->st_dev);
        -:  384:  switch (transition)
        -:  385:    {
        -:  386:    case MountPointRecentlyUnmounted:
        -:  387:      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
        -:  388:      if (!silent)
        -:  389:	{
        -:  390:	  error (0, 0,
        -:  391:		 _("Warning: filesystem %s has recently been unmounted."),
        -:  392:		 safely_quote_err_filename(0, specific_what));
        -:  393:	}
        -:  394:      break;
        -:  395:	      
        -:  396:    case MountPointRecentlyMounted:
        -:  397:      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
        -:  398:      if (!silent)
        -:  399:	{
        -:  400:	  error (0, 0,
        -:  401:		 _("Warning: filesystem %s has recently been mounted."),
        -:  402:		 safely_quote_err_filename(0, specific_what));
        -:  403:	}
        -:  404:      break;
        -:  405:
        -:  406:    case MountPointStateUnchanged:
        -:  407:      /* leave isfatal as it is */
        -:  408:      break;
        -:  409:    }
        -:  410:  
        -:  411:  return isfatal;
        -:  412:}
        -:  413:
        -:  414:
        -:  415:#endif
        -:  416:
        -:  417:
        -:  418:
        -:  419:/* Examine the results of the stat() of a directory from before we
        -:  420: * entered or left it, with the results of stat()ing it afterward.  If
        -:  421: * these are different, the filesystem tree has been modified while we
        -:  422: * were traversing it.  That might be an attempt to use a race
        -:  423: * condition to persuade find to do something it didn't intend
        -:  424: * (e.g. an attempt by an ordinary user to exploit the fact that root
        -:  425: * sometimes runs find on the whole filesystem).  However, this can
        -:  426: * also happen if automount is running (certainly on Solaris).  With 
        -:  427: * automount, moving into a directory can cause a filesystem to be 
        -:  428: * mounted there.
        -:  429: *
        -:  430: * To cope sensibly with this, we will raise an error if we see the
        -:  431: * device number change unless we are chdir()ing into a subdirectory,
        -:  432: * and the directory we moved into has been mounted or unmounted "recently".  
        -:  433: * Here "recently" means since we started "find" or we last re-read 
        -:  434: * the /etc/mnttab file. 
        -:  435: *
        -:  436: * If the device number does not change but the inode does, that is a
        -:  437: * problem.
        -:  438: *
        -:  439: * If the device number and inode are both the same, we are happy.
        -:  440: *
        -:  441: * If a filesystem is (un)mounted as we chdir() into the directory, that 
        -:  442: * may mean that we're now examining a section of the filesystem that might 
        -:  443: * have been excluded from consideration (via -prune or -quit for example).
        -:  444: * Hence we print a warning message to indicate that the output of find 
        -:  445: * might be inconsistent due to the change in the filesystem.
        -:  446: */
        -:  447:static boolean
    #####:  448:wd_sanity_check(const char *thing_to_stat,
        -:  449:		const char *progname,
        -:  450:		const char *what,
        -:  451:		dev_t old_dev,
        -:  452:		ino_t old_ino,
        -:  453:		struct stat *newinfo,
        -:  454:		int parent,
        -:  455:		int line_no,
        -:  456:		enum TraversalDirection direction,
        -:  457:		enum WdSanityCheckFatality isfatal,
        -:  458:		boolean *changed) /* output parameter */
        -:  459:{
        -:  460:  const char *fstype;
    #####:  461:  char *specific_what = NULL;
    #####:  462:  int silent = 0;
    #####:  463:  const char *current_dir = ".";
        -:  464:  
    #####:  465:  *changed = false;
        -:  466:  
    #####:  467:  set_stat_placeholders(newinfo);
    #####:  468:  if ((*options.xstat) (current_dir, newinfo) != 0)
    #####:  469:    fatal_file_error(thing_to_stat);
        -:  470:  
    #####:  471:  if (old_dev != newinfo->st_dev)
        -:  472:    {
    #####:  473:      *changed = true;
    #####:  474:      specific_what = specific_dirname(what);
    #####:  475:      fstype = filesystem_type(newinfo, current_dir);
    #####:  476:      silent = fs_likely_to_be_automounted(fstype);
        -:  477:
        -:  478:      /* This condition is rare, so once we are here it is 
        -:  479:       * reasonable to perform an expensive computation to 
        -:  480:       * determine if we should continue or fail. 
        -:  481:       */
    #####:  482:      if (TraversingDown == direction)
        -:  483:	{
        -:  484:#ifdef STAT_MOUNTPOINTS
        -:  485:	  isfatal = dirchange_is_fatal(specific_what,isfatal,silent,newinfo);
        -:  486:#else
    #####:  487:	  isfatal = RETRY_IF_SANITY_CHECK_FAILS;
        -:  488:#endif
        -:  489:	}
        -:  490:
    #####:  491:      switch (isfatal)
        -:  492:	{
        -:  493:	case FATAL_IF_SANITY_CHECK_FAILS:
        -:  494:	  {
    #####:  495:	    fstype = filesystem_type(newinfo, current_dir);
    #####:  496:	    error (1, 0,
        -:  497:		   _("%s%s changed during execution of %s (old device number %ld, new device number %ld, filesystem type is %s) [ref %ld]"),
        -:  498:		   safely_quote_err_filename(0, specific_what),
        -:  499:		   parent ? "/.." : "",
        -:  500:		   safely_quote_err_filename(1, progname),
        -:  501:		   (long) old_dev,
    #####:  502:		   (long) newinfo->st_dev,
        -:  503:		   fstype,
        -:  504:		   (long)line_no);
        -:  505:	    /*NOTREACHED*/
    #####:  506:	    return false;
        -:  507:	  }
        -:  508:	  
        -:  509:	case NON_FATAL_IF_SANITY_CHECK_FAILS:
        -:  510:	  {
        -:  511:	    /* Since the device has changed under us, the inode number 
        -:  512:	     * will almost certainly also be different. However, we have 
        -:  513:	     * already decided that this is not a problem.  Hence we return
        -:  514:	     * without checking the inode number.
        -:  515:	     */
    #####:  516:	    free(specific_what);
    #####:  517:	    return true;
        -:  518:	  }
        -:  519:
        -:  520:	case RETRY_IF_SANITY_CHECK_FAILS:
    #####:  521:	  return false;
        -:  522:	}
        -:  523:    }
        -:  524:
        -:  525:  /* Device number was the same, check if the inode has changed. */
    #####:  526:  if (old_ino != newinfo->st_ino)
        -:  527:    {
    #####:  528:      *changed = true;
    #####:  529:      specific_what = specific_dirname(what);
    #####:  530:      fstype = filesystem_type(newinfo, current_dir);
        -:  531:      
    #####:  532:      error ((isfatal == FATAL_IF_SANITY_CHECK_FAILS) ? 1 : 0,
        -:  533:	     0,			/* no relevant errno value */
        -:  534:	     _("%s%s changed during execution of %s (old inode number %ld, new inode number %ld, filesystem type is %s) [ref %ld]"),
        -:  535:	     safely_quote_err_filename(0, specific_what), 
        -:  536:	     parent ? "/.." : "",
        -:  537:	     safely_quote_err_filename(1, progname),
        -:  538:	     (long) old_ino,
    #####:  539:	     (long) newinfo->st_ino,
        -:  540:	     fstype,
        -:  541:	     (long)line_no);
    #####:  542:      free(specific_what);
    #####:  543:      return false;
        -:  544:    }
        -:  545:  
    #####:  546:  return true;
        -:  547:}
        -:  548:
        -:  549:enum SafeChdirStatus
        -:  550:  {
        -:  551:    SafeChdirOK,
        -:  552:    SafeChdirFailSymlink,
        -:  553:    SafeChdirFailNotDir,
        -:  554:    SafeChdirFailStat,
        -:  555:    SafeChdirFailWouldBeUnableToReturn,
        -:  556:    SafeChdirFailChdirFailed,
        -:  557:    SafeChdirFailNonexistent,
        -:  558:    SafeChdirFailDestUnreadable
        -:  559:  };
        -:  560:
        -:  561:/* Safely perform a change in directory.  We do this by calling
        -:  562: * lstat() on the subdirectory, using chdir() to move into it, and
        -:  563: * then lstat()ing ".".  We compare the results of the two stat calls
        -:  564: * to see if they are consistent.  If not, we sound the alarm.
        -:  565: *
        -:  566: * If following_links() is true, we do follow symbolic links.
        -:  567: */
        -:  568:static enum SafeChdirStatus
    #####:  569:safely_chdir_lstat(const char *dest,
        -:  570:		   enum TraversalDirection direction,
        -:  571:		   struct stat *statbuf_dest,
        -:  572:		   enum ChdirSymlinkHandling symlink_follow_option,
        -:  573:		   boolean *did_stat)
        -:  574:{
        -:  575:  struct stat statbuf_arrived;
    #####:  576:  int rv, dotfd=-1;
        -:  577:  int saved_errno;		/* specific_dirname() changes errno. */
    #####:  578:  boolean rv_set = false;
    #####:  579:  boolean statflag = false;
    #####:  580:  int tries = 0;
    #####:  581:  enum WdSanityCheckFatality isfatal = RETRY_IF_SANITY_CHECK_FAILS;
        -:  582:  
    #####:  583:  saved_errno = errno = 0;
        -:  584:
    #####:  585:  dotfd = open(".", O_RDONLY
        -:  586:#if defined O_LARGEFILE
        -:  587:	       |O_LARGEFILE
        -:  588:#endif
        -:  589:	       );
        -:  590:
        -:  591:  /* We jump back to here if wd_sanity_check()
        -:  592:   * recoverably triggers an alert.
        -:  593:   */
        -:  594: retry:
    #####:  595:  ++tries;
        -:  596:  
    #####:  597:  if (dotfd >= 0)
        -:  598:    {
        -:  599:      /* Stat the directory we're going to. */
    #####:  600:      set_stat_placeholders(statbuf_dest);
    #####:  601:      if (0 == options.xstat(dest, statbuf_dest))
        -:  602:	{
    #####:  603:	  statflag = true;
        -:  604:	  
        -:  605:#ifdef S_ISLNK
        -:  606:	  /* symlink_follow_option might be set to SymlinkFollowOk, which
        -:  607:	   * would allow us to chdir() into a symbolic link.  This is
        -:  608:	   * only useful for the case where the directory we're
        -:  609:	   * chdir()ing into is the basename of a command line
        -:  610:	   * argument, for example where "foo/bar/baz" is specified on
        -:  611:	   * the command line.  When -P is in effect (the default),
        -:  612:	   * baz will not be followed if it is a symlink, but if bar
        -:  613:	   * is a symlink, it _should_ be followed.  Hence we need the
        -:  614:	   * ability to override the policy set by following_links().
        -:  615:	   */
    #####:  616:	  if (!following_links() && S_ISLNK(statbuf_dest->st_mode))
        -:  617:	    {
        -:  618:	      /* We're not supposed to be following links, but this is 
        -:  619:	       * a link.  Check symlink_follow_option to see if we should 
        -:  620:	       * make a special exception.
        -:  621:	       */
    #####:  622:	      if (symlink_follow_option == SymlinkFollowOk)
        -:  623:		{
        -:  624:		  /* We need to re-stat() the file so that the 
        -:  625:		   * sanity check can pass. 
        -:  626:		   */
    #####:  627:		  if (0 != stat(dest, statbuf_dest))
        -:  628:		    {
    #####:  629:		      rv = SafeChdirFailNonexistent;
    #####:  630:		      rv_set = true;
    #####:  631:		      saved_errno = errno;
    #####:  632:		      goto fail;
        -:  633:		    }
    #####:  634:		  statflag = true;
        -:  635:		}
        -:  636:	      else
        -:  637:		{
        -:  638:		  /* Not following symlinks, so the attempt to
        -:  639:		   * chdir() into a symlink should be prevented.
        -:  640:		   */
    #####:  641:		  rv = SafeChdirFailSymlink;
    #####:  642:		  rv_set = true;
    #####:  643:		  saved_errno = 0;	/* silence the error message */
    #####:  644:		  goto fail;
        -:  645:		}
        -:  646:	    }
        -:  647:#endif	  
        -:  648:#ifdef S_ISDIR
        -:  649:	  /* Although the immediately following chdir() would detect
        -:  650:	   * the fact that this is not a directory for us, this would
        -:  651:	   * result in an extra system call that fails.  Anybody
        -:  652:	   * examining the system-call trace should ideally not be
        -:  653:	   * concerned that something is actually failing.
        -:  654:	   */
    #####:  655:	  if (!S_ISDIR(statbuf_dest->st_mode))
        -:  656:	    {
    #####:  657:	      rv = SafeChdirFailNotDir;
    #####:  658:	      rv_set = true;
    #####:  659:	      saved_errno = 0;	/* silence the error message */
    #####:  660:	      goto fail;
        -:  661:	    }
        -:  662:#endif
        -:  663:	  
    #####:  664:	  if (options.debug_options & DebugSearch)
    #####:  665:	    fprintf(stderr, "safely_chdir(): chdir(\"%s\")\n", dest);
        -:  666:
    #####:  667:	  if (0 == chdir(dest))
        -:  668:	    {
        -:  669:	      /* check we ended up where we wanted to go */
    #####:  670:	      boolean changed = false;
    #####:  671:	      if (!wd_sanity_check(".", program_name, ".",
        -:  672:				   statbuf_dest->st_dev,
        -:  673:				   statbuf_dest->st_ino,
        -:  674:				   &statbuf_arrived, 
        -:  675:				   0, __LINE__, direction,
        -:  676:				   isfatal,
        -:  677:				   &changed))
        -:  678:		{
        -:  679:		  /* Only allow one failure. */
    #####:  680:		  if (RETRY_IF_SANITY_CHECK_FAILS == isfatal)
        -:  681:		    {
    #####:  682:		      if (0 == fchdir(dotfd))
        -:  683:			{
    #####:  684:			  isfatal = FATAL_IF_SANITY_CHECK_FAILS;
    #####:  685:			  goto retry;
        -:  686:			}
        -:  687:		      else
        -:  688:			{
        -:  689:			  /* Failed to return to original directory,
        -:  690:			   * but we know that the current working
        -:  691:			   * directory is not the one that we intend
        -:  692:			   * to be in.  Since fchdir() failed, we
        -:  693:			   * can't recover from this and so this error
        -:  694:			   * is fatal.
        -:  695:			   */
    #####:  696:			  error(1, errno,
        -:  697:				"failed to return to parent directory");
        -:  698:			}
        -:  699:		    }
        -:  700:		  else
        -:  701:		    {
        -:  702:		      /* XXX: not sure what to use as an excuse here. */
    #####:  703:		      rv = SafeChdirFailNonexistent;
    #####:  704:		      rv_set = true;
    #####:  705:		      saved_errno = 0;
    #####:  706:		      goto fail;
        -:  707:		    }
        -:  708:		}
        -:  709:
    #####:  710:	      close(dotfd);
    #####:  711:	      return SafeChdirOK;
        -:  712:	    }
        -:  713:	  else
        -:  714:	    {
    #####:  715:	      saved_errno = errno;
    #####:  716:	      if (ENOENT == saved_errno)
        -:  717:		{
    #####:  718:		  rv = SafeChdirFailNonexistent;
    #####:  719:		  rv_set = true;
    #####:  720:		  if (options.ignore_readdir_race)
    #####:  721:		    errno = 0;	/* don't issue err msg */
        -:  722:		}
    #####:  723:	      else if (ENOTDIR == saved_errno)
        -:  724:		{
        -:  725:		  /* This can happen if the we stat a directory,
        -:  726:		   * and then filesystem activity changes it into 
        -:  727:		   * a non-directory.
        -:  728:		   */
    #####:  729:		  saved_errno = 0;	/* don't issue err msg */
    #####:  730:		  rv = SafeChdirFailNotDir;
    #####:  731:		  rv_set = true;
        -:  732:		}
        -:  733:	      else
        -:  734:		{
    #####:  735:		  rv = SafeChdirFailChdirFailed;
    #####:  736:		  rv_set = true;
        -:  737:		}
    #####:  738:	      goto fail;
        -:  739:	    }
        -:  740:	}
        -:  741:      else
        -:  742:	{
    #####:  743:	  saved_errno = errno;
    #####:  744:	  rv = SafeChdirFailStat;
    #####:  745:	  rv_set = true;
        -:  746:
    #####:  747:	  if ( (ENOENT == saved_errno) || (0 == state.curdepth))
    #####:  748:	    saved_errno = 0;	/* don't issue err msg */
    #####:  749:	  goto fail;
        -:  750:	}
        -:  751:    }
        -:  752:  else
        -:  753:    {
        -:  754:      /* We do not have read permissions on "." */
    #####:  755:      rv = SafeChdirFailWouldBeUnableToReturn;
    #####:  756:      rv_set = true;
    #####:  757:      goto fail;
        -:  758:    }
        -:  759:
        -:  760:  /* This is the success path, so we clear errno.  The caller probably
        -:  761:   * won't be calling error() anyway.
        -:  762:   */
        -:  763:  saved_errno = 0;
        -:  764:  
        -:  765:  /* We use the same exit path for success or failure. 
        -:  766:   * which has occurred is recorded in RV. 
        -:  767:   */
        -:  768: fail:
        -:  769:  /* We do not call error() as this would result in a duplicate error
        -:  770:   * message when the caller does the same thing.
        -:  771:   */
    #####:  772:  if (saved_errno)
    #####:  773:    errno = saved_errno;
        -:  774:  
    #####:  775:  if (dotfd >= 0)
        -:  776:    {
    #####:  777:      close(dotfd);
    #####:  778:      dotfd = -1;
        -:  779:    }
        -:  780:  
    #####:  781:  *did_stat = statflag;
    #####:  782:  assert(rv_set);
    #####:  783:  return rv;
        -:  784:}
        -:  785:
        -:  786:#if defined(O_NOFOLLOW)
        -:  787:/* Safely change working directory to the specified subdirectory.  If
        -:  788: * we are not allowed to follow symbolic links, we use open() with
        -:  789: * O_NOFOLLOW, followed by fchdir().  This ensures that we don't
        -:  790: * follow symbolic links (of course, we do follow them if the -L
        -:  791: * option is in effect).
        -:  792: */
        -:  793:static enum SafeChdirStatus
       96:  794:safely_chdir_nofollow(const char *dest,
        -:  795:		      enum TraversalDirection direction,
        -:  796:		      struct stat *statbuf_dest,
        -:  797:		      enum ChdirSymlinkHandling symlink_follow_option,
        -:  798:		      boolean *did_stat)
        -:  799:{
        -:  800:  int extraflags, fd;
        -:  801:
        -:  802:  (void) direction;
        -:  803:  (void) statbuf_dest;
        -:  804:  
       96:  805:  extraflags = 0;
       96:  806:  *did_stat = false;
        -:  807:  
       96:  808:  switch (symlink_follow_option)
        -:  809:    {
        -:  810:    case SymlinkFollowOk:
        8:  811:      extraflags = 0;
        8:  812:      break;
        -:  813:      
        -:  814:    case SymlinkHandleDefault:
       88:  815:      if (following_links())
    #####:  816:	extraflags = 0;
        -:  817:      else
       88:  818:	extraflags = O_NOFOLLOW;
       88:  819:      break;
        -:  820:    }
        -:  821:  
       96:  822:  errno = 0;
       96:  823:  fd = open(dest, O_RDONLY
        -:  824:#if defined O_LARGEFILE
        -:  825:	    |O_LARGEFILE
        -:  826:#endif
        -:  827:	    |extraflags);
       96:  828:  if (fd < 0)
        -:  829:    {
    #####:  830:      switch (errno)
        -:  831:	{
        -:  832:	case ELOOP:
    #####:  833:	  return SafeChdirFailSymlink; /* This is why we use O_NOFOLLOW */
        -:  834:	case ENOENT:
    #####:  835:	  return SafeChdirFailNonexistent;
        -:  836:	default:
    #####:  837:	  return SafeChdirFailDestUnreadable;
        -:  838:	}
        -:  839:    }
        -:  840:  
       96:  841:  errno = 0;
       96:  842:  if (0 == fchdir(fd))
        -:  843:    {
       96:  844:      close(fd);
       96:  845:      return SafeChdirOK;
        -:  846:    }
        -:  847:  else
        -:  848:    {
    #####:  849:      int saved_errno = errno;
    #####:  850:      close(fd);
    #####:  851:      errno = saved_errno;
        -:  852:      
    #####:  853:      switch (errno)
        -:  854:	{
        -:  855:	case ENOTDIR:
    #####:  856:	  return SafeChdirFailNotDir;
        -:  857:	  
        -:  858:	case EACCES:
        -:  859:	case EBADF:		/* Shouldn't happen */
        -:  860:	case EINTR:
        -:  861:	case EIO:
        -:  862:	default:
    #####:  863:	  return SafeChdirFailChdirFailed;
        -:  864:	}
        -:  865:    }
        -:  866:}
        -:  867:#endif
        -:  868:
        -:  869:static enum SafeChdirStatus
       96:  870:safely_chdir(const char *dest,
        -:  871:	     enum TraversalDirection direction,
        -:  872:	     struct stat *statbuf_dest,
        -:  873:	     enum ChdirSymlinkHandling symlink_follow_option,
        -:  874:	     boolean *did_stat)
        -:  875:{
        -:  876:  enum SafeChdirStatus result;
        -:  877:  
        -:  878:  /* We're about to leave a directory.  If there are any -execdir
        -:  879:   * argument lists which have been built but have not yet been
        -:  880:   * processed, do them now because they must be done in the same
        -:  881:   * directory.
        -:  882:   */
       96:  883:  complete_pending_execdirs(get_current_dirfd());
        -:  884:
        -:  885:#if !defined(O_NOFOLLOW)
        -:  886:  options.open_nofollow_available = false;
        -:  887:#endif
       96:  888:  if (options.open_nofollow_available)
       96:  889:    result = safely_chdir_nofollow(dest, direction, statbuf_dest, symlink_follow_option, did_stat);
        -:  890:  else
    #####:  891:    result = safely_chdir_lstat(dest, direction, statbuf_dest, symlink_follow_option, did_stat);
       96:  892:  return result;
        -:  893:}
        -:  894:
        -:  895:
        -:  896:
        -:  897:/* Safely go back to the starting directory. */
        -:  898:static void
       12:  899:chdir_back (void)
        -:  900:{
        -:  901:  struct stat stat_buf;
        -:  902:  boolean dummy;
        -:  903:  
       12:  904:  if (starting_desc < 0)
        -:  905:    {
    #####:  906:      if (options.debug_options & DebugSearch)
    #####:  907:	fprintf(stderr, "chdir_back(): chdir(\"%s\")\n", starting_dir);
        -:  908:      
        -:  909:#ifdef STAT_MOUNTPOINTS
        -:  910:      /* We will need the mounted device list.  Get it now if we don't
        -:  911:       * already have it.
        -:  912:       */
        -:  913:      if (NULL == mounted_devices)
        -:  914:	init_mounted_dev_list(1);
        -:  915:#endif
        -:  916:      
    #####:  917:      if (chdir (starting_dir) != 0)
    #####:  918:	fatal_file_error(starting_dir);
        -:  919:
    #####:  920:      wd_sanity_check(starting_dir,
        -:  921:		      program_name,
        -:  922:		      starting_dir,
        -:  923:		      starting_stat_buf.st_dev,
        -:  924:		      starting_stat_buf.st_ino,
        -:  925:		      &stat_buf, 0, __LINE__,
        -:  926:		      TraversingUp,
        -:  927:		      FATAL_IF_SANITY_CHECK_FAILS,
        -:  928:		      &dummy);
        -:  929:    }
        -:  930:  else
        -:  931:    {
       12:  932:      if (options.debug_options & DebugSearch)
    #####:  933:	fprintf(stderr, "chdir_back(): chdir(<starting-point>)\n");
        -:  934:
       12:  935:      if (fchdir (starting_desc) != 0)
        -:  936:	{
    #####:  937:	  fatal_file_error(starting_dir);
        -:  938:	}
        -:  939:    }
       12:  940:}
        -:  941:
        -:  942:/* Move to the parent of a given directory and then call a function,
        -:  943: * restoring the cwd.  Don't bother changing directory if the
        -:  944: * specified directory is a child of "." or is the root directory.
        -:  945: */
        -:  946:static void
        8:  947:at_top (char *pathname,
        -:  948:	mode_t mode,
        -:  949:	struct stat *pstat,
        -:  950:	void (*action)(char *pathname,
        -:  951:		       char *basename,
        -:  952:		       int mode,
        -:  953:		       struct stat *pstat))
        -:  954:{
        -:  955:  int dirchange;
        8:  956:  char *parent_dir = dir_name(pathname);
        8:  957:  char *base = base_name(pathname);
        -:  958:  
        8:  959:  state.curdepth = 0;
        8:  960:  state.starting_path_length = strlen (pathname);
        -:  961:
        8:  962:  if (0 == strcmp(pathname, parent_dir)
        8:  963:      || 0 == strcmp(parent_dir, "."))
        -:  964:    {
    #####:  965:      dirchange = 0;
    #####:  966:      base = pathname;
        -:  967:    }
        -:  968:  else
        -:  969:    {
        -:  970:      enum TraversalDirection direction;
        -:  971:      enum SafeChdirStatus chdir_status;
        -:  972:      struct stat st;
        8:  973:      boolean did_stat = false;
        -:  974:      
        8:  975:      dirchange = 1;
        8:  976:      if (0 == strcmp(base, ".."))
    #####:  977:	direction = TraversingUp;
        -:  978:      else
        8:  979:	direction = TraversingDown;
        -:  980:
        -:  981:      /* We pass SymlinkFollowOk to safely_chdir(), which allows it to
        -:  982:       * chdir() into a symbolic link.  This is only useful for the
        -:  983:       * case where the directory we're chdir()ing into is the
        -:  984:       * basename of a command line argument, for example where
        -:  985:       * "foo/bar/baz" is specified on the command line.  When -P is
        -:  986:       * in effect (the default), baz will not be followed if it is a
        -:  987:       * symlink, but if bar is a symlink, it _should_ be followed.
        -:  988:       * Hence we need the ability to override the policy set by
        -:  989:       * following_links().
        -:  990:       */
        8:  991:      chdir_status = safely_chdir(parent_dir, direction, &st, SymlinkFollowOk, &did_stat);
        8:  992:      if (SafeChdirOK != chdir_status)
        -:  993:	{
    #####:  994:	  const char *what = (SafeChdirFailWouldBeUnableToReturn == chdir_status) ? "." : parent_dir;
    #####:  995:	  if (errno)
    #####:  996:	    error (0, errno, "%s",
        -:  997:		   safely_quote_err_filename(0, what));
        -:  998:	  else
    #####:  999:	    error (0, 0, "Failed to safely change directory into %s",
        -: 1000:		   safely_quote_err_filename(0, parent_dir));
        -: 1001:	    
        -: 1002:	  /* We can't process this command-line argument. */
    #####: 1003:	  state.exit_status = 1;
        8: 1004:	  return;
        -: 1005:	}
        -: 1006:    }
        -: 1007:
        8: 1008:  free (parent_dir);
        8: 1009:  parent_dir = NULL;
        -: 1010:  
        8: 1011:  action(pathname, base, mode, pstat);
        -: 1012:  
        8: 1013:  if (dirchange)
        -: 1014:    {
        8: 1015:      chdir_back();
        -: 1016:    }
        -: 1017:}
        -: 1018:
        -: 1019:
        4: 1020:static void do_process_top_dir(char *pathname,
        -: 1021:			       char *base,
        -: 1022:			       int mode,
        -: 1023:			       struct stat *pstat)
        -: 1024:{
        -: 1025:  (void) pstat;
        -: 1026:  
        4: 1027:  process_path (pathname, base, false, ".", mode);
        4: 1028:  complete_pending_execdirs(get_current_dirfd());
        4: 1029:}
        -: 1030:
       44: 1031:static void do_process_predicate(char *pathname,
        -: 1032:				 char *base,
        -: 1033:				 int mode,
        -: 1034:				 struct stat *pstat)
        -: 1035:{
        -: 1036:  (void) mode;
        -: 1037:  
       44: 1038:  state.rel_pathname = base;	/* cwd_dir_fd was already set by safely_chdir */
       44: 1039:  apply_predicate (pathname, pstat, get_eval_tree());
       44: 1040:}
        -: 1041:
        -: 1042:
        -: 1043:
        -: 1044:
        -: 1045:/* Descend PATHNAME, which is a command-line argument.  
        -: 1046:
        -: 1047:   Actions like -execdir assume that we are in the 
        -: 1048:   parent directory of the file we're examining, 
        -: 1049:   and on entry to this function our working directory
        -: 1050:   is whatever it was when find was invoked.  Therefore
        -: 1051:   If PATHNAME is "." we just leave things as they are. 
        -: 1052:   Otherwise, we figure out what the parent directory is, 
        -: 1053:   and move to that.
        -: 1054:*/
        -: 1055:static void
        4: 1056:process_top_path (char *pathname, mode_t mode)
        -: 1057:{
        4: 1058:  at_top(pathname, mode, NULL, do_process_top_dir);
        4: 1059:}
        -: 1060:
        -: 1061:
        -: 1062:/* Info on each directory in the current tree branch, to avoid
        -: 1063:   getting stuck in symbolic link loops.  */
        -: 1064:static struct dir_id *dir_ids = NULL;
        -: 1065:/* Entries allocated in `dir_ids'.  */
        -: 1066:static int dir_alloc = 0;
        -: 1067:/* Index in `dir_ids' of directory currently being searched.
        -: 1068:   This is always the last valid entry.  */
        -: 1069:static int dir_curr = -1;
        -: 1070:/* (Arbitrary) number of entries to grow `dir_ids' by.  */
        -: 1071:#define DIR_ALLOC_STEP 32
        -: 1072:
        -: 1073:
        -: 1074:
        -: 1075:/* We've detected a filesystem loop.   This is caused by one of 
        -: 1076: * two things:
        -: 1077: *
        -: 1078: * 1. Option -L is in effect and we've hit a symbolic link that 
        -: 1079: *    points to an ancestor.  This is harmless.  We won't traverse the 
        -: 1080: *    symbolic link.
        -: 1081: *
        -: 1082: * 2. We have hit a real cycle in the directory hierarchy.  In this 
        -: 1083: *    case, we issue a diagnostic message (POSIX requires this) and we
        -: 1084: *    skip that directory entry.
        -: 1085: */
        -: 1086:static void
    #####: 1087:issue_loop_warning(const char *name, const char *pathname, int level)
        -: 1088:{
        -: 1089:  struct stat stbuf_link;
    #####: 1090:  if (lstat(name, &stbuf_link) != 0)
    #####: 1091:    stbuf_link.st_mode = S_IFREG;
        -: 1092:  
    #####: 1093:  if (S_ISLNK(stbuf_link.st_mode))
        -: 1094:    {
    #####: 1095:      error(0, 0,
        -: 1096:	    _("Symbolic link %s is part of a loop in the directory hierarchy; we have already visited the directory to which it points."),
        -: 1097:	    safely_quote_err_filename(0, pathname));
        -: 1098:    }
        -: 1099:  else
        -: 1100:    {
    #####: 1101:      int distance = 1 + (dir_curr-level);
        -: 1102:      /* We have found an infinite loop.  POSIX requires us to
        -: 1103:       * issue a diagnostic.  Usually we won't get to here
        -: 1104:       * because when the leaf optimisation is on, it will cause
        -: 1105:       * the subdirectory to be skipped.  If /a/b/c/d is a hard
        -: 1106:       * link to /a/b, then the link count of /a/b/c is 2,
        -: 1107:       * because the ".." entry of /b/b/c/d points to /a, not
        -: 1108:       * to /a/b/c.
        -: 1109:       */
    #####: 1110:      error(0, 0,
        -: 1111:	    _("Filesystem loop detected; %s has the same device number and inode as a directory which is %d %s."),
        -: 1112:	    safely_quote_err_filename(0, pathname),
        -: 1113:	    distance,
        -: 1114:	    (distance == 1 ?
        -: 1115:	     _("level higher in the filesystem hierarchy") :
        -: 1116:	     _("levels higher in the filesystem hierarchy")));
        -: 1117:    }
    #####: 1118:}
        -: 1119:
        -: 1120:
        -: 1121:
        -: 1122:/* Recursively descend path PATHNAME, applying the predicates.
        -: 1123:   LEAF is true if PATHNAME is known to be in a directory that has no
        -: 1124:   more unexamined subdirectories, and therefore it is not a directory.
        -: 1125:   Knowing this allows us to avoid calling stat as long as possible for
        -: 1126:   leaf files.
        -: 1127:
        -: 1128:   NAME is PATHNAME relative to the current directory.  We access NAME
        -: 1129:   but print PATHNAME.
        -: 1130:
        -: 1131:   PARENT is the path of the parent of NAME, relative to find's
        -: 1132:   starting directory.
        -: 1133:
        -: 1134:   Return nonzero iff PATHNAME is a directory. */
        -: 1135:
        -: 1136:static int
      324: 1137:process_path (char *pathname, char *name, boolean leaf, char *parent,
        -: 1138:	      mode_t mode)
        -: 1139:{
        -: 1140:  struct stat stat_buf;
        -: 1141:  static dev_t root_dev;	/* Device ID of current argument pathname. */
        -: 1142:  int i;
        -: 1143:  struct predicate *eval_tree;
        -: 1144:
      324: 1145:  eval_tree = get_eval_tree();
        -: 1146:  /* Assume it is a non-directory initially. */
      324: 1147:  stat_buf.st_mode = 0;
      324: 1148:  state.rel_pathname = name;
      324: 1149:  state.type = 0;
      324: 1150:  state.have_stat = false;
      324: 1151:  state.have_type = false;
        -: 1152:
      324: 1153:  if (!digest_mode(mode, pathname, name, &stat_buf, leaf))
    #####: 1154:    return 0;
        -: 1155:  
      324: 1156:  if (!S_ISDIR (state.type))
        -: 1157:    {
      280: 1158:      if (state.curdepth >= options.mindepth)
      280: 1159:	apply_predicate (pathname, &stat_buf, eval_tree);
      280: 1160:      return 0;
        -: 1161:    }
        -: 1162:
        -: 1163:  /* From here on, we're working on a directory.  */
        -: 1164:
        -: 1165:  
        -: 1166:  /* Now we really need to stat the directory, even if we know the
        -: 1167:   * type, because we need information like struct stat.st_rdev.
        -: 1168:   */
       44: 1169:  if (get_statinfo(pathname, name, &stat_buf) != 0)
    #####: 1170:    return 0;
        -: 1171:
       44: 1172:  state.have_stat = true;
       44: 1173:  mode = state.type = stat_buf.st_mode;	/* use full info now that we have it. */
       44: 1174:  state.stop_at_current_level =
       44: 1175:    options.maxdepth >= 0
       44: 1176:    && state.curdepth >= options.maxdepth;
        -: 1177:
        -: 1178:  /* If we've already seen this directory on this branch,
        -: 1179:     don't descend it again.  */
      136: 1180:  for (i = 0; i <= dir_curr; i++)
       92: 1181:    if (stat_buf.st_ino == dir_ids[i].ino &&
    #####: 1182:	stat_buf.st_dev == dir_ids[i].dev)
        -: 1183:      {
    #####: 1184:	state.stop_at_current_level = true;
    #####: 1185:	issue_loop_warning(name, pathname, i);
        -: 1186:      }
        -: 1187:  
       44: 1188:  if (dir_alloc <= ++dir_curr)
        -: 1189:    {
        4: 1190:      dir_alloc += DIR_ALLOC_STEP;
        4: 1191:      dir_ids = (struct dir_id *)
        4: 1192:	xrealloc ((char *) dir_ids, dir_alloc * sizeof (struct dir_id));
        -: 1193:    }
       44: 1194:  dir_ids[dir_curr].ino = stat_buf.st_ino;
       44: 1195:  dir_ids[dir_curr].dev = stat_buf.st_dev;
        -: 1196:
       44: 1197:  if (options.stay_on_filesystem)
        -: 1198:    {
    #####: 1199:      if (state.curdepth == 0)
    #####: 1200:	root_dev = stat_buf.st_dev;
    #####: 1201:      else if (stat_buf.st_dev != root_dev)
    #####: 1202:	state.stop_at_current_level = true;
        -: 1203:    }
        -: 1204:
       44: 1205:  if (options.do_dir_first && state.curdepth >= options.mindepth)
    #####: 1206:    apply_predicate (pathname, &stat_buf, eval_tree);
        -: 1207:
       44: 1208:  if (options.debug_options & DebugSearch)
    #####: 1209:    fprintf(stderr, "pathname = %s, stop_at_current_level = %d\n",
    #####: 1210:	    pathname, state.stop_at_current_level);
        -: 1211:  
       44: 1212:  if (state.stop_at_current_level == false)
        -: 1213:    {
        -: 1214:      /* Scan directory on disk. */
       44: 1215:      process_dir (pathname, name, strlen (pathname), &stat_buf, parent);
        -: 1216:    }
        -: 1217:
       44: 1218:  if (options.do_dir_first == false && state.curdepth >= options.mindepth)
        -: 1219:    {
        -: 1220:      /* The fields in 'state' are now out of date.  Correct them.
        -: 1221:       */
       44: 1222:      if (!digest_mode(mode, pathname, name, &stat_buf, leaf))
    #####: 1223:	return 0;
        -: 1224:
       44: 1225:      if (0 == dir_curr)
        -: 1226:	{
        4: 1227:	  at_top(pathname, mode, &stat_buf, do_process_predicate);
        -: 1228:	}
        -: 1229:      else
        -: 1230:	{
       40: 1231:	  do_process_predicate(pathname, name, mode, &stat_buf);
        -: 1232:	}
        -: 1233:    }
        -: 1234:
       44: 1235:  dir_curr--;
        -: 1236:
       44: 1237:  return 1;
        -: 1238:}
        -: 1239:
        -: 1240:
        -: 1241:/* Scan directory PATHNAME and recurse through process_path for each entry.
        -: 1242:
        -: 1243:   PATHLEN is the length of PATHNAME.
        -: 1244:
        -: 1245:   NAME is PATHNAME relative to the current directory.
        -: 1246:
        -: 1247:   STATP is the results of *options.xstat on it.
        -: 1248:
        -: 1249:   PARENT is the path of the parent of NAME, relative to find's
        -: 1250:   starting directory.  */
        -: 1251:
        -: 1252:static void
       44: 1253:process_dir (char *pathname, char *name, int pathlen, const struct stat *statp, char *parent)
        -: 1254:{
        -: 1255:  int subdirs_left;		/* Number of unexamined subdirs in PATHNAME. */
        -: 1256:  boolean subdirs_unreliable;	/* if true, cannot use dir link count as subdir limif (if false, it may STILL be unreliable) */
        -: 1257:  unsigned int idx;		/* Which entry are we on? */
        -: 1258:  struct stat stat_buf;
       44: 1259:  size_t dircount = 0u;
        -: 1260:  struct savedir_dirinfo *dirinfo;
        -: 1261:#if 0
        -: 1262:  printf("process_dir: pathname=%s name=%s statp->st_nlink=%d st_ino=%d\n",
        -: 1263:	 pathname,
        -: 1264:	 name,
        -: 1265:	 (int)statp->st_nlink,
        -: 1266:	 (int)statp->st_ino);
        -: 1267:#endif  
       44: 1268:  if (statp->st_nlink < 2)
        -: 1269:    {
    #####: 1270:      subdirs_unreliable = true;
    #####: 1271:      subdirs_left = 0;
        -: 1272:    }
        -: 1273:  else
        -: 1274:    {
       44: 1275:      subdirs_unreliable = false; /* not necessarily right */
       44: 1276:      subdirs_left = statp->st_nlink - 2; /* Account for name and ".". */
        -: 1277:    }
        -: 1278:  
       44: 1279:  errno = 0;
       44: 1280:  dirinfo = xsavedir(name, 0);
        -: 1281:
        -: 1282:  
       44: 1283:  if (dirinfo == NULL)
        -: 1284:    {
    #####: 1285:      assert(errno != 0);
    #####: 1286:      error (0, errno, "%s", safely_quote_err_filename(0, pathname));
    #####: 1287:      state.exit_status = 1;
        -: 1288:    }
        -: 1289:  else
        -: 1290:    {
        -: 1291:      register char *namep;	/* Current point in `name_space'. */
        -: 1292:      char *cur_path;		/* Full path of each file to process. */
        -: 1293:      char *cur_name;		/* Base name of each file to process. */
        -: 1294:      unsigned cur_path_size;	/* Bytes allocated for `cur_path'. */
        -: 1295:      register unsigned file_len; /* Length of each path to process. */
        -: 1296:      register unsigned pathname_len; /* PATHLEN plus trailing '/'. */
       44: 1297:      boolean did_stat = false;
        -: 1298:      
       44: 1299:      if (pathname[pathlen - 1] == '/')
    #####: 1300:	pathname_len = pathlen + 1; /* For '\0'; already have '/'. */
        -: 1301:      else
       44: 1302:	pathname_len = pathlen + 2; /* For '/' and '\0'. */
       44: 1303:      cur_path_size = 0;
       44: 1304:      cur_path = NULL;
        -: 1305:
        -: 1306:      /* We're about to leave the directory.  If there are any
        -: 1307:       * -execdir argument lists which have been built but have not
        -: 1308:       * yet been processed, do them now because they must be done in
        -: 1309:       * the same directory.
        -: 1310:       */
       44: 1311:      complete_pending_execdirs(get_current_dirfd());
        -: 1312:      
       44: 1313:      if (strcmp (name, "."))
        -: 1314:	{
       44: 1315:	  enum SafeChdirStatus status = safely_chdir (name, TraversingDown, &stat_buf, SymlinkHandleDefault, &did_stat);
       44: 1316:	  switch (status)
        -: 1317:	    {
        -: 1318:	    case SafeChdirOK:
        -: 1319:	      /* If there had been a change but wd_sanity_check()
        -: 1320:	       * accepted it, we need to accept that on the 
        -: 1321:	       * way back up as well, so modify our record 
        -: 1322:	       * of what we think we should see later.
        -: 1323:	       * If there was no change, the assignments are a no-op.
        -: 1324:	       *
        -: 1325:	       * However, before performing the assignment, we need to
        -: 1326:	       * check that we have the stat information.   If O_NOFOLLOW
        -: 1327:	       * is available, safely_chdir() will not have needed to use 
        -: 1328:	       * stat(), and so stat_buf will just contain random data.
        -: 1329:	       */
       44: 1330:	      if (!did_stat)
        -: 1331:		{
        -: 1332:		  /* If there is a link we need to follow it.  Hence 
        -: 1333:		   * the direct call to stat() not through (options.xstat)
        -: 1334:		   */
       44: 1335:		  set_stat_placeholders(&stat_buf);
       44: 1336:		  if (0 != stat(".", &stat_buf))
    #####: 1337:		    break;	/* skip the assignment. */
        -: 1338:		}
       44: 1339:	      dir_ids[dir_curr].dev = stat_buf.st_dev;
       44: 1340:	      dir_ids[dir_curr].ino = stat_buf.st_ino;
        -: 1341:	      
       44: 1342:	      break;
        -: 1343:      
        -: 1344:	    case SafeChdirFailWouldBeUnableToReturn:
    #####: 1345:	      error (0, errno, ".");
    #####: 1346:	      state.exit_status = 1;
    #####: 1347:	      break;
        -: 1348:	      
        -: 1349:	    case SafeChdirFailNonexistent:
        -: 1350:	    case SafeChdirFailDestUnreadable:
        -: 1351:	    case SafeChdirFailStat:
        -: 1352:	    case SafeChdirFailNotDir:
        -: 1353:	    case SafeChdirFailChdirFailed:
    #####: 1354:	      error (0, errno, "%s",
        -: 1355:		     safely_quote_err_filename(0, pathname));
    #####: 1356:	      state.exit_status = 1;
    #####: 1357:	      return;
        -: 1358:	      
        -: 1359:	    case SafeChdirFailSymlink:
    #####: 1360:	      error (0, 0,
        -: 1361:		     _("warning: not following the symbolic link %s"),
        -: 1362:		     safely_quote_err_filename(0, pathname));
    #####: 1363:	      state.exit_status = 1;
    #####: 1364:	      return;
        -: 1365:	    }
        -: 1366:	}
        -: 1367:
      364: 1368:      for (idx=0; idx < dirinfo->size; ++idx)
        -: 1369:	{
        -: 1370:	  /* savedirinfo() may return dirinfo=NULL if extended information 
        -: 1371:	   * is not available. 
        -: 1372:	   */
      640: 1373:	  mode_t mode = (dirinfo->entries[idx].flags & SavedirHaveFileType) ? 
      320: 1374:	    dirinfo->entries[idx].type_info : 0;
      320: 1375:	  namep = dirinfo->entries[idx].name;
        -: 1376:
        -: 1377:	  /* Append this directory entry's name to the path being searched. */
      320: 1378:	  file_len = pathname_len + strlen (namep);
      320: 1379:	  if (file_len > cur_path_size)
        -: 1380:	    {
       72: 1381:	      while (file_len > cur_path_size)
       24: 1382:		cur_path_size += 1024;
       24: 1383:	      if (cur_path)
    #####: 1384:		free (cur_path);
       24: 1385:	      cur_path = xmalloc (cur_path_size);
       24: 1386:	      strcpy (cur_path, pathname);
       24: 1387:	      cur_path[pathname_len - 2] = '/';
        -: 1388:	    }
      320: 1389:	  cur_name = cur_path + pathname_len - 1;
      320: 1390:	  strcpy (cur_name, namep);
        -: 1391:
      320: 1392:	  state.curdepth++;
      320: 1393:	  if (!options.no_leaf_check && !subdirs_unreliable)
        -: 1394:	    {
      320: 1395:	      if (mode && S_ISDIR(mode) && (subdirs_left == 0))
        -: 1396:		{
        -: 1397:		  /* This is a subdirectory, but the number of directories we 
        -: 1398:		   * have found now exceeds the number we would expect given 
        -: 1399:		   * the hard link count on the parent.   This is likely to be 
        -: 1400:		   * a bug in the filesystem driver (e.g. Linux's 
        -: 1401:		   * /proc filesystem) or may just be a fact that the OS 
        -: 1402:		   * doesn't really handle hard links with Unix semantics.
        -: 1403:		   * In the latter case, -noleaf should be used routinely.
        -: 1404:		   */
    #####: 1405:		  error(0, 0, _("WARNING: Hard link count is wrong for %s (saw only st_nlink=%d but we already saw %d subdirectories): this may be a bug in your filesystem driver.  Automatically turning on find's -noleaf option.  Earlier results may have failed to include directories that should have been searched."),
        -: 1406:			safely_quote_err_filename(0, pathname),
        -: 1407:			statp->st_nlink,
        -: 1408:			dircount);
    #####: 1409:		  state.exit_status = 1; /* We know the result is wrong, now */
    #####: 1410:		  options.no_leaf_check = true;	/* Don't make same
        -: 1411:						   mistake again */
    #####: 1412:		  subdirs_unreliable = 1;
    #####: 1413:		  subdirs_left = 1; /* band-aid for this iteration. */
        -: 1414:		}
        -: 1415:	      
        -: 1416:	      /* Normal case optimization.  On normal Unix
        -: 1417:		 filesystems, a directory that has no subdirectories
        -: 1418:		 has two links: its name, and ".".  Any additional
        -: 1419:		 links are to the ".." entries of its subdirectories.
        -: 1420:		 Once we have processed as many subdirectories as
        -: 1421:		 there are additional links, we know that the rest of
        -: 1422:		 the entries are non-directories -- in other words,
        -: 1423:		 leaf files. */
      320: 1424:	      {
        -: 1425:		int count;
      320: 1426:		count = process_path (cur_path, cur_name,
        -: 1427:					    subdirs_left == 0, pathname,
        -: 1428:					    mode);
      320: 1429:		subdirs_left -= count;
      320: 1430:		dircount += count;
        -: 1431:	      }
        -: 1432:	    }
        -: 1433:	  else
        -: 1434:	    {
        -: 1435:	      /* There might be weird (e.g., CD-ROM or MS-DOS) filesystems
        -: 1436:		 mounted, which don't have Unix-like directory link counts. */
    #####: 1437:	      process_path (cur_path, cur_name, false, pathname, mode);
        -: 1438:	    }
        -: 1439:	  
      320: 1440:	  state.curdepth--;
        -: 1441:	}
        -: 1442:
        -: 1443:
        -: 1444:      /* We're about to leave the directory.  If there are any
        -: 1445:       * -execdir argument lists which have been built but have not
        -: 1446:       * yet been processed, do them now because they must be done in
        -: 1447:       * the same directory.
        -: 1448:       */
       44: 1449:      complete_pending_execdirs(get_current_dirfd()); 
        -: 1450:
       44: 1451:      if (strcmp (name, "."))
        -: 1452:	{
        -: 1453:	  enum SafeChdirStatus status;
        -: 1454:	  struct dir_id did;
        -: 1455:	  
        -: 1456:	  /* We could go back and do the next command-line arg
        -: 1457:	     instead, maybe using longjmp.  */
        -: 1458:	  char const *dir;
       44: 1459:	  boolean deref = following_links() ? true : false;
        -: 1460:	  
       44: 1461:	  if ( (state.curdepth>0) && !deref)
       40: 1462:	    dir = "..";
        -: 1463:	  else
        -: 1464:	    {
        4: 1465:	      chdir_back ();
        4: 1466:	      dir = parent;
        -: 1467:	    }
        -: 1468:	  
       44: 1469:	  did_stat = false;
       44: 1470:	  status = safely_chdir (dir, TraversingUp, &stat_buf, SymlinkHandleDefault, &did_stat);
       44: 1471:	  switch (status)
        -: 1472:	    {
        -: 1473:	    case SafeChdirOK:
       44: 1474:	      break;
        -: 1475:      
        -: 1476:	    case SafeChdirFailWouldBeUnableToReturn:
    #####: 1477:	      error (1, errno, ".");
    #####: 1478:	      return;
        -: 1479:	      
        -: 1480:	    case SafeChdirFailNonexistent:
        -: 1481:	    case SafeChdirFailDestUnreadable:
        -: 1482:	    case SafeChdirFailStat:
        -: 1483:	    case SafeChdirFailSymlink:
        -: 1484:	    case SafeChdirFailNotDir:
        -: 1485:	    case SafeChdirFailChdirFailed:
    #####: 1486:	      error (1, errno, "%s", safely_quote_err_filename(0, pathname));
    #####: 1487:	      return;
        -: 1488:	    }
        -: 1489:
       44: 1490:	  if (dir_curr > 0)
        -: 1491:	    {
       40: 1492:	      did.dev = dir_ids[dir_curr-1].dev;
       40: 1493:	      did.ino = dir_ids[dir_curr-1].ino;
        -: 1494:	    }
        -: 1495:	  else
        -: 1496:	    {
        4: 1497:	      did.dev = starting_stat_buf.st_dev;
        4: 1498:	      did.ino = starting_stat_buf.st_ino;
        -: 1499:	    }
        -: 1500:	}
        -: 1501:
       44: 1502:      if (cur_path)
       24: 1503:	free (cur_path);
       44: 1504:      free_dirinfo(dirinfo);
        -: 1505:    }
        -: 1506:
       44: 1507:  if (subdirs_unreliable)
        -: 1508:    {
        -: 1509:      /* Make sure we hasn't used the variable subdirs_left if we knew
        -: 1510:       * we shouldn't do so.
        -: 1511:       */
    #####: 1512:      assert(0 == subdirs_left || options.no_leaf_check);
        -: 1513:    }
        -: 1514:}
