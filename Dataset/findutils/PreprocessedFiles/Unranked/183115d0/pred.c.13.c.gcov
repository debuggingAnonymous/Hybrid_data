        -:    0:Source:pred.c
        -:    0:Graph:pred.gcno
        -:    0:Data:pred.gcda
        -:    0:Runs:9
        -:    0:Programs:2
        -:    1:/* pred.c -- execute the expression tree.
        -:    2:   Copyright (C) 1990, 1991, 1992, 1993, 1994, 2000, 2003, 2004, 2005,
        -:    3:   2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
        -:    4:
        -:    5:   This program is free software: you can redistribute it and/or modify
        -:    6:   it under the terms of the GNU General Public License as published by
        -:    7:   the Free Software Foundation, either version 3 of the License, or
        -:    8:   (at your option) any later version.
        -:    9:
        -:   10:   This program is distributed in the hope that it will be useful,
        -:   11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:   GNU General Public License for more details.
        -:   14:
        -:   15:   You should have received a copy of the GNU General Public License
        -:   16:   along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17:*/
        -:   18:
        -:   19:/* config.h always comes first. */
        -:   20:#include <config.h>
        -:   21:
        -:   22:/* system headers. */
        -:   23:#include <assert.h>
        -:   24:#include <ctype.h>
        -:   25:#include <dirent.h>
        -:   26:#include <errno.h>
        -:   27:#include <fcntl.h>
        -:   28:#include <grp.h>
        -:   29:#include <locale.h>
        -:   30:#include <math.h>
        -:   31:#include <pwd.h>
        -:   32:#include <selinux/selinux.h>
        -:   33:#include <stdarg.h>
        -:   34:#include <sys/stat.h>
        -:   35:#include <sys/types.h>
        -:   36:#include <sys/wait.h>
        -:   37:#include <unistd.h> /* for unlinkat() */
        -:   38:
        -:   39:/* gnulib headers. */
        -:   40:#include "areadlink.h"
        -:   41:#include "dirname.h"
        -:   42:#include "error.h"
        -:   43:#include "fnmatch.h"
        -:   44:#include "gettext.h"
        -:   45:#include "stat-size.h"
        -:   46:#include "stat-time.h"
        -:   47:#include "yesno.h"
        -:   48:
        -:   49:/* find headers. */
        -:   50:#include "defs.h"
        -:   51:#include "dircallback.h"
        -:   52:#include "listfile.h"
        -:   53:#include "printquoted.h"
        -:   54:
        -:   55:
        -:   56:
        -:   57:#if ENABLE_NLS
        -:   58:# include <libintl.h>
        -:   59:# define _(Text) gettext (Text)
        -:   60:#else
        -:   61:# define _(Text) Text
        -:   62:#endif
        -:   63:#ifdef gettext_noop
        -:   64:# define N_(String) gettext_noop (String)
        -:   65:#else
        -:   66:/* See locate.c for explanation as to why not use (String) */
        -:   67:# define N_(String) String
        -:   68:#endif
        -:   69:
        -:   70:#ifdef CLOSEDIR_VOID
        -:   71:/* Fake a return value. */
        -:   72:#define CLOSEDIR(d) (closedir (d), 0)
        -:   73:#else
        -:   74:#define CLOSEDIR(d) closedir (d)
        -:   75:#endif
        -:   76:
        -:   77:static bool match_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, bool ignore_case);
        -:   78:
        -:   79:#ifdef	DEBUG
        -:   80:struct pred_assoc
        -:   81:{
        -:   82:  PRED_FUNC pred_func;
        -:   83:  char *pred_name;
        -:   84:};
        -:   85:
        -:   86:struct pred_assoc pred_table[] =
        -:   87:{
        -:   88:  {pred_amin, "amin    "},
        -:   89:  {pred_and, "and     "},
        -:   90:  {pred_anewer, "anewer  "},
        -:   91:  {pred_atime, "atime   "},
        -:   92:  {pred_closeparen, ")       "},
        -:   93:  {pred_cmin, "cmin    "},
        -:   94:  {pred_cnewer, "cnewer  "},
        -:   95:  {pred_comma, ",       "},
        -:   96:  {pred_ctime, "ctime   "},
        -:   97:  {pred_delete, "delete  "},
        -:   98:  {pred_empty, "empty   "},
        -:   99:  {pred_exec, "exec    "},
        -:  100:  {pred_execdir, "execdir "},
        -:  101:  {pred_executable, "executable "},
        -:  102:  {pred_false, "false   "},
        -:  103:  {pred_fprint, "fprint  "},
        -:  104:  {pred_fprint0, "fprint0 "},
        -:  105:  {pred_fprintf, "fprintf "},
        -:  106:  {pred_fstype, "fstype  "},
        -:  107:  {pred_gid, "gid     "},
        -:  108:  {pred_group, "group   "},
        -:  109:  {pred_ilname, "ilname  "},
        -:  110:  {pred_iname, "iname   "},
        -:  111:  {pred_inum, "inum    "},
        -:  112:  {pred_ipath, "ipath   "},
        -:  113:  {pred_links, "links   "},
        -:  114:  {pred_lname, "lname   "},
        -:  115:  {pred_ls, "ls      "},
        -:  116:  {pred_mmin, "mmin    "},
        -:  117:  {pred_mtime, "mtime   "},
        -:  118:  {pred_name, "name    "},
        -:  119:  {pred_negate, "not     "},
        -:  120:  {pred_newer, "newer   "},
        -:  121:  {pred_newerXY, "newerXY   "},
        -:  122:  {pred_nogroup, "nogroup "},
        -:  123:  {pred_nouser, "nouser  "},
        -:  124:  {pred_ok, "ok      "},
        -:  125:  {pred_okdir, "okdir   "},
        -:  126:  {pred_openparen, "(       "},
        -:  127:  {pred_or, "or      "},
        -:  128:  {pred_path, "path    "},
        -:  129:  {pred_perm, "perm    "},
        -:  130:  {pred_print, "print   "},
        -:  131:  {pred_print0, "print0  "},
        -:  132:  {pred_prune, "prune   "},
        -:  133:  {pred_quit, "quit    "},
        -:  134:  {pred_readable, "readable    "},
        -:  135:  {pred_regex, "regex   "},
        -:  136:  {pred_samefile,"samefile "},
        -:  137:  {pred_size, "size    "},
        -:  138:  {pred_true, "true    "},
        -:  139:  {pred_type, "type    "},
        -:  140:  {pred_uid, "uid     "},
        -:  141:  {pred_used, "used    "},
        -:  142:  {pred_user, "user    "},
        -:  143:  {pred_writable, "writable "},
        -:  144:  {pred_xtype, "xtype   "},
        -:  145:  {pred_context, "context"},
        -:  146:  {0, "none    "}
        -:  147:};
        -:  148:#endif
        -:  149:
        -:  150:/* Returns ts1 - ts2 */
    #####:  151:static double ts_difference (struct timespec ts1,
        -:  152:			     struct timespec ts2)
        -:  153:{
    #####:  154:  double d =  difftime (ts1.tv_sec, ts2.tv_sec)
    #####:  155:    + (1.0e-9 * (ts1.tv_nsec - ts2.tv_nsec));
    #####:  156:  return d;
        -:  157:}
        -:  158:
        -:  159:
        -:  160:static int
    #####:  161:compare_ts (struct timespec ts1,
        -:  162:	    struct timespec ts2)
        -:  163:{
    #####:  164:  if ((ts1.tv_sec == ts2.tv_sec) &&
    #####:  165:      (ts1.tv_nsec == ts2.tv_nsec))
        -:  166:    {
    #####:  167:      return 0;
        -:  168:    }
        -:  169:  else
        -:  170:    {
    #####:  171:      double diff = ts_difference (ts1, ts2);
    #####:  172:      return diff < 0.0 ? -1 : +1;
        -:  173:    }
        -:  174:}
        -:  175:
        -:  176:/* Predicate processing routines.
        -:  177:
        -:  178:   PATHNAME is the full pathname of the file being checked.
        -:  179:   *STAT_BUF contains information about PATHNAME.
        -:  180:   *PRED_PTR contains information for applying the predicate.
        -:  181:
        -:  182:   Return true if the file passes this predicate, false if not. */
        -:  183:
        -:  184:
        -:  185:/* pred_timewindow
        -:  186: *
        -:  187: * Returns true if THE_TIME is
        -:  188: * COMP_GT: after the specified time
        -:  189: * COMP_LT: before the specified time
        -:  190: * COMP_EQ: after the specified time but by not more than WINDOW seconds.
        -:  191: */
        -:  192:static bool
    #####:  193:pred_timewindow (struct timespec ts, struct predicate const *pred_ptr, int window)
        -:  194:{
    #####:  195:  switch (pred_ptr->args.reftime.kind)
        -:  196:    {
        -:  197:    case COMP_GT:
    #####:  198:      return compare_ts (ts, pred_ptr->args.reftime.ts) > 0;
        -:  199:
        -:  200:    case COMP_LT:
    #####:  201:      return compare_ts (ts, pred_ptr->args.reftime.ts) < 0;
        -:  202:
        -:  203:    case COMP_EQ:
        -:  204:      {
        -:  205:	/* consider "find . -mtime 0".
        -:  206:	 *
        -:  207:	 * Here, the origin is exactly 86400 seconds before the start
        -:  208:	 * of the program (since -daystart was not specified).   This
        -:  209:	 * function will be called with window=86400 and
        -:  210:	 * pred_ptr->args.reftime.ts as the origin.  Hence a file
        -:  211:	 * created the instant the program starts will show a time
        -:  212:	 * difference (value of delta) of 86400.   Similarly, a file
        -:  213:	 * created exactly 24h ago would be the newest file which was
        -:  214:	 * _not_ created today.   So, if delta is 0.0, the file
        -:  215:	 * was not created today.  If the delta is 86400, the file
        -:  216:	 * was created this instant.
        -:  217:	 */
    #####:  218:	double delta = ts_difference (ts, pred_ptr->args.reftime.ts);
    #####:  219:	return (delta > 0.0 && delta <= window);
        -:  220:      }
        -:  221:    }
    #####:  222:  assert (0);
        -:  223:  abort ();
        -:  224:}
        -:  225:
        -:  226:
        -:  227:bool
    #####:  228:pred_amin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  229:{
        -:  230:  (void) &pathname;
    #####:  231:  return pred_timewindow (get_stat_atime(stat_buf), pred_ptr, 60);
        -:  232:}
        -:  233:
        -:  234:bool
       16:  235:pred_and (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  236:{
       16:  237:  if (pred_ptr->pred_left == NULL
    #####:  238:      || apply_predicate (pathname, stat_buf, pred_ptr->pred_left))
        -:  239:    {
       16:  240:      return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -:  241:    }
        -:  242:  else
    #####:  243:    return false;
        -:  244:}
        -:  245:
        -:  246:bool
    #####:  247:pred_anewer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  248:{
        -:  249:  (void) &pathname;
    #####:  250:  assert (COMP_GT == pred_ptr->args.reftime.kind);
    #####:  251:  return compare_ts (get_stat_atime(stat_buf), pred_ptr->args.reftime.ts) > 0;
        -:  252:}
        -:  253:
        -:  254:bool
    #####:  255:pred_atime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  256:{
        -:  257:  (void) &pathname;
    #####:  258:  return pred_timewindow (get_stat_atime(stat_buf), pred_ptr, DAYSECS);
        -:  259:}
        -:  260:
        -:  261:bool
    #####:  262:pred_closeparen (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  263:{
        -:  264:  (void) &pathname;
        -:  265:  (void) &stat_buf;
        -:  266:  (void) &pred_ptr;
        -:  267:
    #####:  268:  return true;
        -:  269:}
        -:  270:
        -:  271:bool
    #####:  272:pred_cmin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  273:{
        -:  274:  (void) pathname;
    #####:  275:  return pred_timewindow (get_stat_ctime(stat_buf), pred_ptr, 60);
        -:  276:}
        -:  277:
        -:  278:bool
    #####:  279:pred_cnewer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  280:{
        -:  281:  (void) pathname;
        -:  282:
    #####:  283:  assert (COMP_GT == pred_ptr->args.reftime.kind);
    #####:  284:  return compare_ts (get_stat_ctime(stat_buf), pred_ptr->args.reftime.ts) > 0;
        -:  285:}
        -:  286:
        -:  287:bool
    #####:  288:pred_comma (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  289:{
    #####:  290:  if (pred_ptr->pred_left != NULL)
        -:  291:    {
    #####:  292:      apply_predicate (pathname, stat_buf,pred_ptr->pred_left);
        -:  293:    }
    #####:  294:  return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -:  295:}
        -:  296:
        -:  297:bool
    #####:  298:pred_ctime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  299:{
        -:  300:  (void) &pathname;
    #####:  301:  return pred_timewindow (get_stat_ctime(stat_buf), pred_ptr, DAYSECS);
        -:  302:}
        -:  303:
        -:  304:static bool
    #####:  305:perform_delete (int flags)
        -:  306:{
    #####:  307:  return 0 == unlinkat (state.cwd_dir_fd, state.rel_pathname, flags);
        -:  308:}
        -:  309:
        -:  310:
        -:  311:bool
    #####:  312:pred_delete (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  313:{
        -:  314:  (void) pred_ptr;
        -:  315:  (void) stat_buf;
    #####:  316:  if (strcmp (state.rel_pathname, "."))
        -:  317:    {
    #####:  318:      int flags=0;
    #####:  319:      if (state.have_stat && S_ISDIR(stat_buf->st_mode))
    #####:  320:	flags |= AT_REMOVEDIR;
    #####:  321:      if (perform_delete (flags))
        -:  322:	{
    #####:  323:	  return true;
        -:  324:	}
        -:  325:      else
        -:  326:	{
    #####:  327:	  if (EISDIR == errno)
        -:  328:	    {
    #####:  329:	      if ((flags & AT_REMOVEDIR) == 0)
        -:  330:		{
        -:  331:		  /* unlink() operation failed because we should have done rmdir(). */
    #####:  332:		  flags |= AT_REMOVEDIR;
    #####:  333:		  if (perform_delete (flags))
    #####:  334:		    return true;
        -:  335:		}
        -:  336:	    }
        -:  337:	}
    #####:  338:      error (0, errno, _("cannot delete %s"),
        -:  339:	     safely_quote_err_filename (0, pathname));
        -:  340:      /* Previously I had believed that having the -delete action
        -:  341:       * return false provided the user with control over whether an
        -:  342:       * error message is issued.  While this is true, the policy of
        -:  343:       * not affecting the exit status is contrary to the POSIX
        -:  344:       * requirement that diagnostic messages are accompanied by a
        -:  345:       * nonzero exit status.  While -delete is not a POSIX option and
        -:  346:       * we can therefore opt not to follow POSIX in this case, that
        -:  347:       * seems somewhat arbitrary and confusing.  So, as of
        -:  348:       * findutils-4.3.11, we also set the exit status in this case.
        -:  349:       */
    #####:  350:      state.exit_status = 1;
    #####:  351:      return false;
        -:  352:    }
        -:  353:  else
        -:  354:    {
        -:  355:      /* nothing to do. */
    #####:  356:      return true;
        -:  357:    }
        -:  358:}
        -:  359:
        -:  360:bool
    #####:  361:pred_empty (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  362:{
        -:  363:  (void) pathname;
        -:  364:  (void) pred_ptr;
        -:  365:
    #####:  366:  if (S_ISDIR (stat_buf->st_mode))
        -:  367:    {
        -:  368:      int fd;
        -:  369:      DIR *d;
        -:  370:      struct dirent *dp;
    #####:  371:      bool empty = true;
        -:  372:
    #####:  373:      errno = 0;
    #####:  374:      if ((fd = openat (state.cwd_dir_fd, state.rel_pathname, O_RDONLY
        -:  375:#if defined O_LARGEFILE
        -:  376:			|O_LARGEFILE
        -:  377:#endif
        -:  378:		       )) < 0)
        -:  379:	{
    #####:  380:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####:  381:	  state.exit_status = 1;
    #####:  382:	  return false;
        -:  383:	}
    #####:  384:      d = fdopendir (fd);
    #####:  385:      if (d == NULL)
        -:  386:	{
    #####:  387:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####:  388:	  state.exit_status = 1;
    #####:  389:	  return false;
        -:  390:	}
    #####:  391:      for (dp = readdir (d); dp; dp = readdir (d))
        -:  392:	{
    #####:  393:	  if (dp->d_name[0] != '.'
    #####:  394:	      || (dp->d_name[1] != '\0'
    #####:  395:		  && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
        -:  396:	    {
    #####:  397:	      empty = false;
    #####:  398:	      break;
        -:  399:	    }
        -:  400:	}
    #####:  401:      if (CLOSEDIR (d))
        -:  402:	{
    #####:  403:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####:  404:	  state.exit_status = 1;
    #####:  405:	  return false;
        -:  406:	}
    #####:  407:      return (empty);
        -:  408:    }
    #####:  409:  else if (S_ISREG (stat_buf->st_mode))
    #####:  410:    return (stat_buf->st_size == 0);
        -:  411:  else
    #####:  412:    return (false);
        -:  413:}
        -:  414:
        -:  415:
        -:  416:bool
    #####:  417:pred_exec (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  418:{
    #####:  419:  return impl_pred_exec (pathname, stat_buf, pred_ptr);
        -:  420:}
        -:  421:
        -:  422:bool
       16:  423:pred_execdir (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  424:{
        -:  425:   (void) &pathname;
       16:  426:   return impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr);
        -:  427:}
        -:  428:
        -:  429:bool
    #####:  430:pred_false (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  431:{
        -:  432:  (void) &pathname;
        -:  433:  (void) &stat_buf;
        -:  434:  (void) &pred_ptr;
        -:  435:
        -:  436:
    #####:  437:  return (false);
        -:  438:}
        -:  439:
        -:  440:bool
    #####:  441:pred_fls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  442:{
    #####:  443:  FILE * stream = pred_ptr->args.printf_vec.stream;
    #####:  444:  list_file (pathname, state.cwd_dir_fd, state.rel_pathname, stat_buf,
        -:  445:	     options.start_time.tv_sec,
        -:  446:	     options.output_block_size,
    #####:  447:	     pred_ptr->literal_control_chars, stream);
    #####:  448:  return true;
        -:  449:}
        -:  450:
        -:  451:bool
    #####:  452:pred_fprint (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  453:{
        -:  454:  (void) &pathname;
        -:  455:  (void) &stat_buf;
        -:  456:
    #####:  457:  print_quoted (pred_ptr->args.printf_vec.stream,
    #####:  458:		pred_ptr->args.printf_vec.quote_opts,
    #####:  459:		pred_ptr->args.printf_vec.dest_is_tty,
        -:  460:		"%s\n",
        -:  461:		pathname);
    #####:  462:  return true;
        -:  463:}
        -:  464:
        -:  465:bool
    #####:  466:pred_fprint0 (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  467:{
    #####:  468:  FILE * fp = pred_ptr->args.printf_vec.stream;
        -:  469:
        -:  470:  (void) &stat_buf;
        -:  471:
    #####:  472:  fputs (pathname, fp);
    #####:  473:  putc (0, fp);
    #####:  474:  return true;
        -:  475:}
        -:  476:
        -:  477:
        -:  478:
        -:  479:bool
    #####:  480:pred_fstype (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  481:{
        -:  482:  (void) pathname;
        -:  483:
    #####:  484:  if (strcmp (filesystem_type (stat_buf, pathname), pred_ptr->args.str) == 0)
    #####:  485:    return true;
        -:  486:  else
    #####:  487:    return false;
        -:  488:}
        -:  489:
        -:  490:bool
    #####:  491:pred_gid (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  492:{
        -:  493:  (void) pathname;
        -:  494:
    #####:  495:  switch (pred_ptr->args.numinfo.kind)
        -:  496:    {
        -:  497:    case COMP_GT:
    #####:  498:      if (stat_buf->st_gid > pred_ptr->args.numinfo.l_val)
    #####:  499:	return (true);
    #####:  500:      break;
        -:  501:    case COMP_LT:
    #####:  502:      if (stat_buf->st_gid < pred_ptr->args.numinfo.l_val)
    #####:  503:	return (true);
    #####:  504:      break;
        -:  505:    case COMP_EQ:
    #####:  506:      if (stat_buf->st_gid == pred_ptr->args.numinfo.l_val)
    #####:  507:	return (true);
    #####:  508:      break;
        -:  509:    }
    #####:  510:  return (false);
        -:  511:}
        -:  512:
        -:  513:bool
    #####:  514:pred_group (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  515:{
        -:  516:  (void) pathname;
        -:  517:
    #####:  518:  if (pred_ptr->args.gid == stat_buf->st_gid)
    #####:  519:    return (true);
        -:  520:  else
    #####:  521:    return (false);
        -:  522:}
        -:  523:
        -:  524:bool
    #####:  525:pred_ilname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  526:{
    #####:  527:  return match_lname (pathname, stat_buf, pred_ptr, true);
        -:  528:}
        -:  529:
        -:  530:/* Common code between -name, -iname.  PATHNAME is being visited, STR
        -:  531:   is name to compare basename against, and FLAGS are passed to
        -:  532:   fnmatch.  Recall that 'find / -name /' is one of the few times where a '/'
        -:  533:   in the -name must actually find something. */
        -:  534:static bool
    #####:  535:pred_name_common (const char *pathname, const char *str, int flags)
        -:  536:{
        -:  537:  bool b;
        -:  538:  /* We used to use last_component() here, but that would not allow us to modify the
        -:  539:   * input string, which is const.   We could optimise by duplicating the string only
        -:  540:   * if we need to modify it, and I'll do that if there is a measurable
        -:  541:   * performance difference on a machine built after 1990...
        -:  542:   */
    #####:  543:  char *base = base_name (pathname);
        -:  544:  /* remove trailing slashes, but leave  "/" or "//foo" unchanged. */
    #####:  545:  strip_trailing_slashes (base);
        -:  546:
        -:  547:  /* FNM_PERIOD is not used here because POSIX requires that it not be.
        -:  548:   * See http://standards.ieee.org/reading/ieee/interp/1003-2-92_int/pasc-1003.2-126.html
        -:  549:   */
    #####:  550:  b = fnmatch (str, base, flags) == 0;
    #####:  551:  free (base);
    #####:  552:  return b;
        -:  553:}
        -:  554:
        -:  555:bool
    #####:  556:pred_iname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  557:{
        -:  558:  (void) stat_buf;
    #####:  559:  return pred_name_common (pathname, pred_ptr->args.str, FNM_CASEFOLD);
        -:  560:}
        -:  561:
        -:  562:bool
    #####:  563:pred_inum (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  564:{
        -:  565:  (void) pathname;
        -:  566:
    #####:  567:  assert (stat_buf->st_ino != 0);
        -:  568:
    #####:  569:  switch (pred_ptr->args.numinfo.kind)
        -:  570:    {
        -:  571:    case COMP_GT:
    #####:  572:      if (stat_buf->st_ino > pred_ptr->args.numinfo.l_val)
    #####:  573:	return (true);
    #####:  574:      break;
        -:  575:    case COMP_LT:
    #####:  576:      if (stat_buf->st_ino < pred_ptr->args.numinfo.l_val)
    #####:  577:	return (true);
    #####:  578:      break;
        -:  579:    case COMP_EQ:
    #####:  580:      if (stat_buf->st_ino == pred_ptr->args.numinfo.l_val)
    #####:  581:	return (true);
    #####:  582:      break;
        -:  583:    }
    #####:  584:  return (false);
        -:  585:}
        -:  586:
        -:  587:bool
    #####:  588:pred_ipath (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  589:{
        -:  590:  (void) stat_buf;
        -:  591:
    #####:  592:  if (fnmatch (pred_ptr->args.str, pathname, FNM_CASEFOLD) == 0)
    #####:  593:    return (true);
    #####:  594:  return (false);
        -:  595:}
        -:  596:
        -:  597:bool
    #####:  598:pred_links (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  599:{
        -:  600:  (void) pathname;
        -:  601:
    #####:  602:  switch (pred_ptr->args.numinfo.kind)
        -:  603:    {
        -:  604:    case COMP_GT:
    #####:  605:      if (stat_buf->st_nlink > pred_ptr->args.numinfo.l_val)
    #####:  606:	return (true);
    #####:  607:      break;
        -:  608:    case COMP_LT:
    #####:  609:      if (stat_buf->st_nlink < pred_ptr->args.numinfo.l_val)
    #####:  610:	return (true);
    #####:  611:      break;
        -:  612:    case COMP_EQ:
    #####:  613:      if (stat_buf->st_nlink == pred_ptr->args.numinfo.l_val)
    #####:  614:	return (true);
    #####:  615:      break;
        -:  616:    }
    #####:  617:  return (false);
        -:  618:}
        -:  619:
        -:  620:bool
    #####:  621:pred_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  622:{
    #####:  623:  return match_lname (pathname, stat_buf, pred_ptr, false);
        -:  624:}
        -:  625:
        -:  626:static bool
    #####:  627:match_lname (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, bool ignore_case)
        -:  628:{
    #####:  629:  bool ret = false;
        -:  630:#ifdef S_ISLNK
    #####:  631:  if (S_ISLNK (stat_buf->st_mode))
        -:  632:    {
    #####:  633:      char *linkname = areadlinkat (state.cwd_dir_fd, state.rel_pathname);
    #####:  634:      if (linkname)
        -:  635:	{
    #####:  636:	  if (fnmatch (pred_ptr->args.str, linkname,
        -:  637:		       ignore_case ? FNM_CASEFOLD : 0) == 0)
    #####:  638:	    ret = true;
        -:  639:	}
        -:  640:      else
        -:  641:	{
    #####:  642:	  nonfatal_target_file_error (errno, pathname);
    #####:  643:	  state.exit_status = 1;
        -:  644:	}
    #####:  645:      free (linkname);
        -:  646:    }
        -:  647:#endif /* S_ISLNK */
    #####:  648:  return ret;
        -:  649:}
        -:  650:
        -:  651:bool
    #####:  652:pred_ls (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  653:{
    #####:  654:  return pred_fls (pathname, stat_buf, pred_ptr);
        -:  655:}
        -:  656:
        -:  657:bool
    #####:  658:pred_mmin (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  659:{
        -:  660:  (void) &pathname;
    #####:  661:  return pred_timewindow (get_stat_mtime(stat_buf), pred_ptr, 60);
        -:  662:}
        -:  663:
        -:  664:bool
    #####:  665:pred_mtime (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  666:{
        -:  667:  (void) pathname;
    #####:  668:  return pred_timewindow (get_stat_mtime(stat_buf), pred_ptr, DAYSECS);
        -:  669:}
        -:  670:
        -:  671:bool
    #####:  672:pred_name (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  673:{
        -:  674:  (void) stat_buf;
    #####:  675:  return pred_name_common (pathname, pred_ptr->args.str, 0);
        -:  676:}
        -:  677:
        -:  678:bool
    #####:  679:pred_negate (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  680:{
    #####:  681:  return !apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -:  682:}
        -:  683:
        -:  684:bool
    #####:  685:pred_newer (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  686:{
        -:  687:  (void) pathname;
        -:  688:
    #####:  689:  assert (COMP_GT == pred_ptr->args.reftime.kind);
    #####:  690:  return compare_ts (get_stat_mtime(stat_buf), pred_ptr->args.reftime.ts) > 0;
        -:  691:}
        -:  692:
        -:  693:bool
    #####:  694:pred_newerXY (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  695:{
        -:  696:  struct timespec ts;
    #####:  697:  bool collected = false;
        -:  698:
    #####:  699:  assert (COMP_GT == pred_ptr->args.reftime.kind);
        -:  700:
    #####:  701:  switch (pred_ptr->args.reftime.xval)
        -:  702:    {
        -:  703:    case XVAL_TIME:
    #####:  704:      assert (pred_ptr->args.reftime.xval != XVAL_TIME);
    #####:  705:      return false;
        -:  706:
        -:  707:    case XVAL_ATIME:
    #####:  708:      ts = get_stat_atime (stat_buf);
    #####:  709:      collected = true;
    #####:  710:      break;
        -:  711:
        -:  712:    case XVAL_BIRTHTIME:
    #####:  713:      ts = get_stat_birthtime (stat_buf);
    #####:  714:      collected = true;
    #####:  715:      if (ts.tv_nsec < 0)
        -:  716:	{
        -:  717:	  /* XXX: Cannot determine birth time.  Warn once. */
    #####:  718:	  error (0, 0, _("WARNING: cannot determine birth time of file %s"),
        -:  719:		 safely_quote_err_filename (0, pathname));
    #####:  720:	  return false;
        -:  721:	}
    #####:  722:      break;
        -:  723:
        -:  724:    case XVAL_CTIME:
    #####:  725:      ts = get_stat_ctime (stat_buf);
    #####:  726:      collected = true;
    #####:  727:      break;
        -:  728:
        -:  729:    case XVAL_MTIME:
    #####:  730:      ts = get_stat_mtime (stat_buf);
    #####:  731:      collected = true;
    #####:  732:      break;
        -:  733:    }
        -:  734:
    #####:  735:  assert (collected);
    #####:  736:  return compare_ts (ts, pred_ptr->args.reftime.ts) > 0;
        -:  737:}
        -:  738:
        -:  739:bool
    #####:  740:pred_nogroup (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  741:{
        -:  742:  (void) pathname;
        -:  743:  (void) pred_ptr;
        -:  744:
        -:  745:#ifdef CACHE_IDS
        -:  746:  extern char *gid_unused;
        -:  747:
        -:  748:  return gid_unused[(unsigned) stat_buf->st_gid];
        -:  749:#else
    #####:  750:  return getgrgid (stat_buf->st_gid) == NULL;
        -:  751:#endif
        -:  752:}
        -:  753:
        -:  754:bool
    #####:  755:pred_nouser (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  756:{
        -:  757:#ifdef CACHE_IDS
        -:  758:  extern char *uid_unused;
        -:  759:#endif
        -:  760:
        -:  761:  (void) pathname;
        -:  762:  (void) pred_ptr;
        -:  763:
        -:  764:#ifdef CACHE_IDS
        -:  765:  return uid_unused[(unsigned) stat_buf->st_uid];
        -:  766:#else
    #####:  767:  return getpwuid (stat_buf->st_uid) == NULL;
        -:  768:#endif
        -:  769:}
        -:  770:
        -:  771:
        -:  772:static bool
    #####:  773:is_ok (const char *program, const char *arg)
        -:  774:{
    #####:  775:  fflush (stdout);
        -:  776:  /* The draft open standard requires that, in the POSIX locale,
        -:  777:     the last non-blank character of this prompt be '?'.
        -:  778:     The exact format is not specified.
        -:  779:     This standard does not have requirements for locales other than POSIX
        -:  780:  */
        -:  781:  /* XXX: printing UNTRUSTED data here. */
    #####:  782:  fprintf (stderr, _("< %s ... %s > ? "), program, arg);
    #####:  783:  fflush (stderr);
    #####:  784:  return yesno ();
        -:  785:}
        -:  786:
        -:  787:bool
    #####:  788:pred_ok (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  789:{
    #####:  790:  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))
    #####:  791:    return impl_pred_exec (pathname, stat_buf, pred_ptr);
        -:  792:  else
    #####:  793:    return false;
        -:  794:}
        -:  795:
        -:  796:bool
    #####:  797:pred_okdir (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  798:{
    #####:  799:  if (is_ok (pred_ptr->args.exec_vec.replace_vec[0], pathname))
    #####:  800:    return impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr);
        -:  801:  else
    #####:  802:    return false;
        -:  803:}
        -:  804:
        -:  805:bool
    #####:  806:pred_openparen (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  807:{
        -:  808:  (void) pathname;
        -:  809:  (void) stat_buf;
        -:  810:  (void) pred_ptr;
    #####:  811:  return true;
        -:  812:}
        -:  813:
        -:  814:bool
    #####:  815:pred_or (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  816:{
    #####:  817:  if (pred_ptr->pred_left == NULL
    #####:  818:      || !apply_predicate (pathname, stat_buf, pred_ptr->pred_left))
        -:  819:    {
    #####:  820:      return apply_predicate (pathname, stat_buf, pred_ptr->pred_right);
        -:  821:    }
        -:  822:  else
    #####:  823:    return true;
        -:  824:}
        -:  825:
        -:  826:bool
    #####:  827:pred_path (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  828:{
        -:  829:  (void) stat_buf;
    #####:  830:  if (fnmatch (pred_ptr->args.str, pathname, 0) == 0)
    #####:  831:    return (true);
    #####:  832:  return (false);
        -:  833:}
        -:  834:
        -:  835:bool
    #####:  836:pred_perm (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  837:{
    #####:  838:  mode_t mode = stat_buf->st_mode;
    #####:  839:  mode_t perm_val = pred_ptr->args.perm.val[S_ISDIR (mode) != 0];
        -:  840:  (void) pathname;
    #####:  841:  switch (pred_ptr->args.perm.kind)
        -:  842:    {
        -:  843:    case PERM_AT_LEAST:
    #####:  844:      return (mode & perm_val) == perm_val;
        -:  845:      break;
        -:  846:
        -:  847:    case PERM_ANY:
        -:  848:      /* True if any of the bits set in the mask are also set in the file's mode.
        -:  849:       *
        -:  850:       *
        -:  851:       * Otherwise, if onum is prefixed by a hyphen, the primary shall
        -:  852:       * evaluate as true if at least all of the bits specified in
        -:  853:       * onum that are also set in the octal mask 07777 are set.
        -:  854:       *
        -:  855:       * Eric Blake's interpretation is that the mode argument is zero,
        -:  856:
        -:  857:       */
    #####:  858:      if (0 == perm_val)
    #####:  859:	return true;		/* Savannah bug 14748; we used to return false */
        -:  860:      else
    #####:  861:	return (mode & perm_val) != 0;
        -:  862:      break;
        -:  863:
        -:  864:    case PERM_EXACT:
    #####:  865:      return (mode & MODE_ALL) == perm_val;
        -:  866:      break;
        -:  867:
        -:  868:    default:
    #####:  869:      abort ();
        -:  870:      break;
        -:  871:    }
        -:  872:}
        -:  873:
        -:  874:
        -:  875:bool
    #####:  876:pred_executable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  877:{
        -:  878:  (void) pathname;
        -:  879:  (void) stat_buf;
        -:  880:  (void) pred_ptr;
        -:  881:
        -:  882:  /* As for access, the check is performed with the real user id. */
    #####:  883:  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, X_OK, 0);
        -:  884:}
        -:  885:
        -:  886:bool
    #####:  887:pred_readable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  888:{
        -:  889:  (void) pathname;
        -:  890:  (void) stat_buf;
        -:  891:  (void) pred_ptr;
        -:  892:
        -:  893:  /* As for access, the check is performed with the real user id. */
    #####:  894:  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, R_OK, 0);
        -:  895:}
        -:  896:
        -:  897:bool
    #####:  898:pred_writable (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  899:{
        -:  900:  (void) pathname;
        -:  901:  (void) stat_buf;
        -:  902:  (void) pred_ptr;
        -:  903:
        -:  904:  /* As for access, the check is performed with the real user id. */
    #####:  905:  return 0 == faccessat (state.cwd_dir_fd, state.rel_pathname, W_OK, 0);
        -:  906:}
        -:  907:
        -:  908:bool
    #####:  909:pred_print (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  910:{
        -:  911:  (void) stat_buf;
        -:  912:  (void) pred_ptr;
        -:  913:
    #####:  914:  print_quoted (pred_ptr->args.printf_vec.stream,
    #####:  915:		pred_ptr->args.printf_vec.quote_opts,
    #####:  916:		pred_ptr->args.printf_vec.dest_is_tty,
        -:  917:		"%s\n", pathname);
    #####:  918:  return true;
        -:  919:}
        -:  920:
        -:  921:bool
    #####:  922:pred_print0 (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  923:{
    #####:  924:  return pred_fprint0(pathname, stat_buf, pred_ptr);
        -:  925:}
        -:  926:
        -:  927:bool
    #####:  928:pred_prune (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  929:{
        -:  930:  (void) pathname;
        -:  931:  (void) pred_ptr;
        -:  932:
    #####:  933:  if (options.do_dir_first == true) { /* no effect with -depth */
    #####:  934:    assert (state.have_stat);
    #####:  935:    if (stat_buf != NULL &&
    #####:  936:	S_ISDIR(stat_buf->st_mode))
    #####:  937:      state.stop_at_current_level = true;
        -:  938:  }
        -:  939:
        -:  940:  /* findutils used to return options.do_dir_first here, so that -prune
        -:  941:   * returns true only if -depth is not in effect.   But POSIX requires
        -:  942:   * that -prune always evaluate as true.
        -:  943:   */
    #####:  944:  return true;
        -:  945:}
        -:  946:
        -:  947:bool
    #####:  948:pred_quit (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  949:{
        -:  950:  (void) pathname;
        -:  951:  (void) stat_buf;
        -:  952:  (void) pred_ptr;
        -:  953:
        -:  954:  /* Run any cleanups.  This includes executing any command lines
        -:  955:   * we have partly built but not executed.
        -:  956:   */
    #####:  957:  cleanup ();
        -:  958:
        -:  959:  /* Since -exec and friends don't leave child processes running in the
        -:  960:   * background, there is no need to wait for them here.
        -:  961:   */
    #####:  962:  exit (state.exit_status);	/* 0 for success, etc. */
        -:  963:}
        -:  964:
        -:  965:bool
    #####:  966:pred_regex (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  967:{
    #####:  968:  int len = strlen (pathname);
        -:  969:(void) stat_buf;
    #####:  970:  if (re_match (pred_ptr->args.regex, pathname, len, 0,
        -:  971:		(struct re_registers *) NULL) == len)
    #####:  972:    return (true);
    #####:  973:  return (false);
        -:  974:}
        -:  975:
        -:  976:bool
    #####:  977:pred_size (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -:  978:{
        -:  979:  uintmax_t f_val;
        -:  980:
        -:  981:  (void) pathname;
    #####:  982:  f_val = ((stat_buf->st_size / pred_ptr->args.size.blocksize)
    #####:  983:	   + (stat_buf->st_size % pred_ptr->args.size.blocksize != 0));
    #####:  984:  switch (pred_ptr->args.size.kind)
        -:  985:    {
        -:  986:    case COMP_GT:
    #####:  987:      if (f_val > pred_ptr->args.size.size)
    #####:  988:	return (true);
    #####:  989:      break;
        -:  990:    case COMP_LT:
    #####:  991:      if (f_val < pred_ptr->args.size.size)
    #####:  992:	return (true);
    #####:  993:      break;
        -:  994:    case COMP_EQ:
    #####:  995:      if (f_val == pred_ptr->args.size.size)
    #####:  996:	return (true);
    #####:  997:      break;
        -:  998:    }
    #####:  999:  return (false);
        -: 1000:}
        -: 1001:
        -: 1002:bool
    #####: 1003:pred_samefile (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1004:{
        -: 1005:  /* Potential optimisation: because of the loop protection, we always
        -: 1006:   * know the device of the current directory, hence the device number
        -: 1007:   * of the file we're currently considering.  If -L is not in effect,
        -: 1008:   * and the device number of the file we're looking for is not the
        -: 1009:   * same as the device number of the current directory, this
        -: 1010:   * predicate cannot return true.  Hence there would be no need to
        -: 1011:   * stat the file we're looking at.
        -: 1012:   *
        -: 1013:   * For the moment, we simply compare inode numbers, which should cut
        -: 1014:   * down greatly on the number of calls to stat.  Some of the
        -: 1015:   * remainder will be unnecessary, but the additional complexity
        -: 1016:   * probably isn't worthwhile.
        -: 1017:   */
        -: 1018:  (void) pathname;
        -: 1019:
        -: 1020:  /* We will often still have an fd open on the file under consideration,
        -: 1021:   * but that's just to ensure inode number stability by maintaining
        -: 1022:   * a reference to it; we don't need the file for anything else.
        -: 1023:   */
    #####: 1024:  if (stat_buf->st_ino)
        -: 1025:    {
    #####: 1026:      if (stat_buf->st_ino != pred_ptr->args.samefileid.ino)
    #####: 1027:	return false;
        -: 1028:    }
        -: 1029:  /* Now stat the file to check the device number. */
    #####: 1030:  if (0 == get_statinfo (pathname, state.rel_pathname, stat_buf))
        -: 1031:    {
        -: 1032:      /* the repeated test here is necessary in case stat_buf.st_ino had been zero. */
    #####: 1033:      return stat_buf->st_ino == pred_ptr->args.samefileid.ino
    #####: 1034:	&& stat_buf->st_dev == pred_ptr->args.samefileid.dev;
        -: 1035:    }
        -: 1036:  else
        -: 1037:    {
        -: 1038:      /* get_statinfo will already have emitted an error message. */
    #####: 1039:      return false;
        -: 1040:    }
        -: 1041:}
        -: 1042:
        -: 1043:bool
    #####: 1044:pred_true (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1045:{
        -: 1046:  (void) pathname;
        -: 1047:  (void) stat_buf;
        -: 1048:  (void) pred_ptr;
    #####: 1049:  return true;
        -: 1050:}
        -: 1051:
        -: 1052:bool
    #####: 1053:pred_type (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1054:{
        -: 1055:  mode_t mode;
    #####: 1056:  mode_t type = pred_ptr->args.type;
        -: 1057:
    #####: 1058:  assert (state.have_type);
        -: 1059:
    #####: 1060:  if (0 == state.type)
        -: 1061:    {
        -: 1062:      /* This can sometimes happen with broken NFS servers.
        -: 1063:       * See Savannah bug #16378.
        -: 1064:       */
    #####: 1065:      return false;
        -: 1066:    }
        -: 1067:
        -: 1068:  (void) pathname;
        -: 1069:
    #####: 1070:  if (state.have_stat)
    #####: 1071:     mode = stat_buf->st_mode;
        -: 1072:  else
    #####: 1073:     mode = state.type;
        -: 1074:
        -: 1075:#ifndef S_IFMT
        -: 1076:  /* POSIX system; check `mode' the slow way. */
        -: 1077:  if ((S_ISBLK (mode) && type == S_IFBLK)
        -: 1078:      || (S_ISCHR (mode) && type == S_IFCHR)
        -: 1079:      || (S_ISDIR (mode) && type == S_IFDIR)
        -: 1080:      || (S_ISREG (mode) && type == S_IFREG)
        -: 1081:#ifdef S_IFLNK
        -: 1082:      || (S_ISLNK (mode) && type == S_IFLNK)
        -: 1083:#endif
        -: 1084:#ifdef S_IFIFO
        -: 1085:      || (S_ISFIFO (mode) && type == S_IFIFO)
        -: 1086:#endif
        -: 1087:#ifdef S_IFSOCK
        -: 1088:      || (S_ISSOCK (mode) && type == S_IFSOCK)
        -: 1089:#endif
        -: 1090:#ifdef S_IFDOOR
        -: 1091:      || (S_ISDOOR (mode) && type == S_IFDOOR)
        -: 1092:#endif
        -: 1093:      )
        -: 1094:#else /* S_IFMT */
        -: 1095:  /* Unix system; check `mode' the fast way. */
    #####: 1096:  if ((mode & S_IFMT) == type)
        -: 1097:#endif /* S_IFMT */
    #####: 1098:    return (true);
        -: 1099:  else
    #####: 1100:    return (false);
        -: 1101:}
        -: 1102:
        -: 1103:bool
    #####: 1104:pred_uid (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1105:{
        -: 1106:  (void) pathname;
    #####: 1107:  switch (pred_ptr->args.numinfo.kind)
        -: 1108:    {
        -: 1109:    case COMP_GT:
    #####: 1110:      if (stat_buf->st_uid > pred_ptr->args.numinfo.l_val)
    #####: 1111:	return (true);
    #####: 1112:      break;
        -: 1113:    case COMP_LT:
    #####: 1114:      if (stat_buf->st_uid < pred_ptr->args.numinfo.l_val)
    #####: 1115:	return (true);
    #####: 1116:      break;
        -: 1117:    case COMP_EQ:
    #####: 1118:      if (stat_buf->st_uid == pred_ptr->args.numinfo.l_val)
    #####: 1119:	return (true);
    #####: 1120:      break;
        -: 1121:    }
    #####: 1122:  return (false);
        -: 1123:}
        -: 1124:
        -: 1125:bool
    #####: 1126:pred_used (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1127:{
        -: 1128:  struct timespec delta, at, ct;
        -: 1129:
        -: 1130:  (void) pathname;
        -: 1131:
        -: 1132:  /* TODO: this needs to be retested carefully (manually, if necessary) */
    #####: 1133:  at = get_stat_atime (stat_buf);
    #####: 1134:  ct = get_stat_ctime (stat_buf);
    #####: 1135:  delta.tv_sec  = at.tv_sec  - ct.tv_sec;
    #####: 1136:  delta.tv_nsec = at.tv_nsec - ct.tv_nsec;
    #####: 1137:  if (delta.tv_nsec < 0)
        -: 1138:    {
    #####: 1139:      delta.tv_nsec += 1000000000;
    #####: 1140:      delta.tv_sec  -=          1;
        -: 1141:    }
    #####: 1142:  return pred_timewindow (delta, pred_ptr, DAYSECS);
        -: 1143:}
        -: 1144:
        -: 1145:bool
    #####: 1146:pred_user (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1147:{
        -: 1148:  (void) pathname;
    #####: 1149:  if (pred_ptr->args.uid == stat_buf->st_uid)
    #####: 1150:    return (true);
        -: 1151:  else
    #####: 1152:    return (false);
        -: 1153:}
        -: 1154:
        -: 1155:bool
    #####: 1156:pred_xtype (const char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
        -: 1157:{
        -: 1158:  struct stat sbuf;		/* local copy, not stat_buf because we're using a different stat method */
        -: 1159:  int (*ystat) (const char*, struct stat *p);
        -: 1160:
        -: 1161:  /* If we would normally stat the link itself, stat the target instead.
        -: 1162:   * If we would normally follow the link, stat the link itself instead.
        -: 1163:   */
    #####: 1164:  if (following_links ())
    #####: 1165:    ystat = optionp_stat;
        -: 1166:  else
    #####: 1167:    ystat = optionl_stat;
        -: 1168:
    #####: 1169:  set_stat_placeholders (&sbuf);
    #####: 1170:  if ((*ystat) (state.rel_pathname, &sbuf) != 0)
        -: 1171:    {
    #####: 1172:      if (following_links () && errno == ENOENT)
        -: 1173:	{
        -: 1174:	  /* If we failed to follow the symlink,
        -: 1175:	   * fall back on looking at the symlink itself.
        -: 1176:	   */
        -: 1177:	  /* Mimic behavior of ls -lL. */
    #####: 1178:	  return (pred_type (pathname, stat_buf, pred_ptr));
        -: 1179:	}
        -: 1180:      else
        -: 1181:	{
    #####: 1182:	  error (0, errno, "%s", safely_quote_err_filename (0, pathname));
    #####: 1183:	  state.exit_status = 1;
        -: 1184:	}
    #####: 1185:      return false;
        -: 1186:    }
        -: 1187:  /* Now that we have our stat() information, query it in the same
        -: 1188:   * way that -type does.
        -: 1189:   */
    #####: 1190:  return (pred_type (pathname, &sbuf, pred_ptr));
        -: 1191:}
        -: 1192:
        -: 1193:
        -: 1194:bool
    #####: 1195:pred_context (const char *pathname, struct stat *stat_buf,
        -: 1196:	      struct predicate *pred_ptr)
        -: 1197:{
        -: 1198:  security_context_t scontext;
    #####: 1199:  int rv = (*options.x_getfilecon) (state.cwd_dir_fd, state.rel_pathname,
        -: 1200:				    &scontext);
        -: 1201:  (void) stat_buf;
        -: 1202:
    #####: 1203:  if (rv < 0)
        -: 1204:    {
    #####: 1205:      error (0, errno, _("getfilecon failed: %s"),
        -: 1206:	     safely_quote_err_filename (0, pathname));
    #####: 1207:      return false;
        -: 1208:    }
        -: 1209:
    #####: 1210:  rv = (fnmatch (pred_ptr->args.scontext, scontext, 0) == 0);
    #####: 1211:  freecon (scontext);
    #####: 1212:  return rv;
        -: 1213:}
        -: 1214:
        -: 1215:/* Copy STR into BUF and trim blanks from the end of BUF.
        -: 1216:   Return BUF. */
        -: 1217:
        -: 1218:static char *
    #####: 1219:blank_rtrim (const char *str, char *buf)
        -: 1220:{
        -: 1221:  int i;
        -: 1222:
    #####: 1223:  if (str == NULL)
    #####: 1224:    return (NULL);
    #####: 1225:  strcpy (buf, str);
    #####: 1226:  i = strlen (buf) - 1;
    #####: 1227:  while ((i >= 0) && ((buf[i] == ' ') || buf[i] == '\t'))
    #####: 1228:    i--;
    #####: 1229:  buf[++i] = '\0';
    #####: 1230:  return buf;
        -: 1231:}
        -: 1232:
        -: 1233:/* Print out the predicate list starting at NODE. */
        -: 1234:void
    #####: 1235:print_list (FILE *fp, struct predicate *node)
        -: 1236:{
        -: 1237:  struct predicate *cur;
        -: 1238:  char name[256];
        -: 1239:
    #####: 1240:  cur = node;
    #####: 1241:  while (cur != NULL)
        -: 1242:    {
    #####: 1243:      fprintf (fp, "[%s] ", blank_rtrim (cur->p_name, name));
    #####: 1244:      cur = cur->pred_next;
        -: 1245:    }
    #####: 1246:  fprintf (fp, "\n");
    #####: 1247:}
        -: 1248:
        -: 1249:/* Print out the predicate list starting at NODE. */
        -: 1250:static void
    #####: 1251:print_parenthesised (FILE *fp, struct predicate *node)
        -: 1252:{
    #####: 1253:  int parens = 0;
        -: 1254:
    #####: 1255:  if (node)
        -: 1256:    {
    #####: 1257:      if ((pred_is (node, pred_or) || pred_is (node, pred_and))
    #####: 1258:	  && node->pred_left == NULL)
        -: 1259:	{
        -: 1260:	  /* We print "<nothing> or  X" as just "X"
        -: 1261:	   * We print "<nothing> and X" as just "X"
        -: 1262:	   */
    #####: 1263:	  print_parenthesised(fp, node->pred_right);
        -: 1264:	}
        -: 1265:      else
        -: 1266:	{
    #####: 1267:	  if (node->pred_left || node->pred_right)
    #####: 1268:	    parens = 1;
        -: 1269:
    #####: 1270:	  if (parens)
    #####: 1271:	    fprintf (fp, "%s", " ( ");
    #####: 1272:	  print_optlist (fp, node);
    #####: 1273:	  if (parens)
    #####: 1274:	    fprintf (fp, "%s", " ) ");
        -: 1275:	}
        -: 1276:    }
    #####: 1277:}
        -: 1278:
        -: 1279:void
    #####: 1280:print_optlist (FILE *fp, const struct predicate *p)
        -: 1281:{
    #####: 1282:  if (p)
        -: 1283:    {
    #####: 1284:      print_parenthesised (fp, p->pred_left);
    #####: 1285:      fprintf (fp,
        -: 1286:	       "%s%s%s",
    #####: 1287:	       p->need_stat ? "[call stat] " : "",
    #####: 1288:	       p->need_type ? "[need type] " : "",
    #####: 1289:	       p->need_inum ? "[need inum] " : "");
    #####: 1290:      print_predicate (fp, p);
    #####: 1291:      fprintf (fp, " [%g] ", p->est_success_rate);
    #####: 1292:      if (options.debug_options & DebugSuccessRates)
        -: 1293:	{
    #####: 1294:	  fprintf (fp, "[%ld/%ld", p->perf.successes, p->perf.visits);
    #####: 1295:	  if (p->perf.visits)
        -: 1296:	    {
    #####: 1297:	      double real_rate = (double)p->perf.successes / (double)p->perf.visits;
    #####: 1298:	      fprintf (fp, "=%g] ", real_rate);
        -: 1299:	    }
        -: 1300:	  else
        -: 1301:	    {
    #####: 1302:	      fprintf (fp, "=_] ");
        -: 1303:	    }
        -: 1304:	}
    #####: 1305:      print_parenthesised (fp, p->pred_right);
        -: 1306:    }
    #####: 1307:}
        -: 1308:
        8: 1309:void show_success_rates (const struct predicate *p)
        -: 1310:{
        8: 1311:  if (options.debug_options & DebugSuccessRates)
        -: 1312:    {
    #####: 1313:      fprintf (stderr, "Predicate success rates after completion:\n");
    #####: 1314:      print_optlist (stderr, p);
    #####: 1315:      fprintf (stderr, "\n");
        -: 1316:    }
        8: 1317:}
        -: 1318:
        -: 1319:
        -: 1320:
        -: 1321:
        -: 1322:#ifdef _NDEBUG
        -: 1323:/* If _NDEBUG is defined, the assertions will do nothing.   Hence
        -: 1324: * there is no point in having a function body for pred_sanity_check()
        -: 1325: * if that preprocessor macro is defined.
        -: 1326: */
        -: 1327:void
        -: 1328:pred_sanity_check (const struct predicate *predicates)
        -: 1329:{
        -: 1330:  /* Do nothing, since assert is a no-op with _NDEBUG set */
        -: 1331:  return;
        -: 1332:}
        -: 1333:#else
        -: 1334:void
       41: 1335:pred_sanity_check (const struct predicate *predicates)
        -: 1336:{
        -: 1337:  const struct predicate *p;
        -: 1338:
       90: 1339:  for (p=predicates; p != NULL; p=p->pred_next)
        -: 1340:    {
        -: 1341:      /* All predicates must do something. */
       49: 1342:      assert (p->pred_func != NULL);
        -: 1343:
        -: 1344:      /* All predicates must have a parser table entry. */
       49: 1345:      assert (p->parser_entry != NULL);
        -: 1346:
        -: 1347:      /* If the parser table tells us that just one predicate function is
        -: 1348:       * possible, verify that that is still the one that is in effect.
        -: 1349:       * If the parser has NULL for the predicate function, that means that
        -: 1350:       * the parse_xxx function fills it in, so we can't check it.
        -: 1351:       */
       49: 1352:      if (p->parser_entry->pred_func)
        -: 1353:	{
       49: 1354:	  assert (p->parser_entry->pred_func == p->pred_func);
        -: 1355:	}
        -: 1356:
       49: 1357:      switch (p->parser_entry->type)
        -: 1358:	{
        -: 1359:	  /* Options all take effect during parsing, so there should
        -: 1360:	   * be no predicate entries corresponding to them.  Hence we
        -: 1361:	   * should not see any ARG_OPTION or ARG_POSITIONAL_OPTION
        -: 1362:	   * items.
        -: 1363:	   *
        -: 1364:	   * This is a silly way of coding this test, but it prevents
        -: 1365:	   * a compiler warning (i.e. otherwise it would think that
        -: 1366:	   * there would be case statements missing).
        -: 1367:	   */
        -: 1368:	case ARG_OPTION:
        -: 1369:	case ARG_POSITIONAL_OPTION:
    #####: 1370:	  assert (p->parser_entry->type != ARG_OPTION);
    #####: 1371:	  assert (p->parser_entry->type != ARG_POSITIONAL_OPTION);
    #####: 1372:	  break;
        -: 1373:
        -: 1374:	case ARG_ACTION:
       32: 1375:	  assert (p->side_effects); /* actions have side effects. */
       32: 1376:	  if (!pred_is (p, pred_prune) && !pred_is(p, pred_quit))
        -: 1377:	    {
        -: 1378:	      /* actions other than -prune and -quit should
        -: 1379:	       * inhibit the default -print
        -: 1380:	       */
       32: 1381:	      assert (p->no_default_print);
        -: 1382:	    }
       32: 1383:	  break;
        -: 1384:
        -: 1385:	/* We happen to know that the only user of ARG_SPECIAL_PARSE
        -: 1386:	 * is a test, so handle it like ARG_TEST.
        -: 1387:	 */
        -: 1388:	case ARG_SPECIAL_PARSE:
        -: 1389:	case ARG_TEST:
        -: 1390:	case ARG_PUNCTUATION:
        -: 1391:	case ARG_NOOP:
        -: 1392:	  /* Punctuation and tests should have no side
        -: 1393:	   * effects and not inhibit default print.
        -: 1394:	   */
       17: 1395:	  assert (!p->no_default_print);
       17: 1396:	  assert (!p->side_effects);
       17: 1397:	  break;
        -: 1398:	}
        -: 1399:    }
       41: 1400:}
        -: 1401:#endif
