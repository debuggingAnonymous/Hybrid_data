        -:    0:Source:parser.c
        -:    0:Graph:parser.gcno
        -:    0:Data:parser.gcda
        -:    0:Runs:9
        -:    0:Programs:2
        -:    1:/* parser.c -- convert the command line args into an expression tree.
        -:    2:   Copyright (C) 1990, 1991, 1992, 1993, 1994, 2000, 2001, 2003,
        -:    3:     2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
        -:    4:
        -:    5:   This program is free software: you can redistribute it and/or modify
        -:    6:   it under the terms of the GNU General Public License as published by
        -:    7:   the Free Software Foundation, either version 3 of the License, or
        -:    8:   (at your option) any later version.
        -:    9:
        -:   10:   This program is distributed in the hope that it will be useful,
        -:   11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:   GNU General Public License for more details.
        -:   14:
        -:   15:   You should have received a copy of the GNU General Public License
        -:   16:   along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   17:*/
        -:   18:
        -:   19:#include <config.h>
        -:   20:
        -:   21:#include "defs.h"
        -:   22:#include <ctype.h>
        -:   23:#include <math.h>
        -:   24:#include <assert.h>
        -:   25:#include <pwd.h>
        -:   26:#include <errno.h>
        -:   27:#include <grp.h>
        -:   28:#include <fnmatch.h>
        -:   29:#include "modechange.h"
        -:   30:#include "modetype.h"
        -:   31:#include "xstrtol.h"
        -:   32:#include "xalloc.h"
        -:   33:#include "quote.h"
        -:   34:#include "quotearg.h"
        -:   35:#include "buildcmd.h"
        -:   36:#include "nextelem.h"
        -:   37:#include "stdio-safer.h"
        -:   38:#include "regextype.h"
        -:   39:#include "stat-time.h"
        -:   40:#include "xstrtod.h"
        -:   41:#include "fts_.h"
        -:   42:#include "getdate.h"
        -:   43:#include "error.h"
        -:   44:#include "findutils-version.h"
        -:   45:
        -:   46:#include <fcntl.h>
        -:   47:
        -:   48:
        -:   49:/* The presence of unistd.h is assumed by gnulib these days, so we
        -:   50: * might as well assume it too.
        -:   51: */
        -:   52:/* We need <unistd.h> for isatty(). */
        -:   53:#include <unistd.h>
        -:   54:#include <sys/stat.h>
        -:   55:
        -:   56:#if ENABLE_NLS
        -:   57:# include <libintl.h>
        -:   58:# define _(Text) gettext (Text)
        -:   59:#else
        -:   60:# define _(Text) Text
        -:   61:#endif
        -:   62:#ifdef gettext_noop
        -:   63:# define N_(String) gettext_noop (String)
        -:   64:#else
        -:   65:/* See locate.c for explanation as to why not use (String) */
        -:   66:# define N_(String) String
        -:   67:#endif
        -:   68:
        -:   69:#if !defined (isascii) || defined (STDC_HEADERS)
        -:   70:#ifdef isascii
        -:   71:#undef isascii
        -:   72:#endif
        -:   73:#define isascii(c) 1
        -:   74:#endif
        -:   75:
        -:   76:#define ISDIGIT(c) (isascii ((unsigned char)c) && isdigit ((unsigned char)c))
        -:   77:
        -:   78:#ifndef HAVE_ENDGRENT
        -:   79:#define endgrent()
        -:   80:#endif
        -:   81:#ifndef HAVE_ENDPWENT
        -:   82:#define endpwent()
        -:   83:#endif
        -:   84:
        -:   85:static boolean parse_accesscheck   PARAMS((const struct parser_table* entry, char **argv, int *arg_ptr));
        -:   86:static boolean parse_amin          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   87:static boolean parse_and           PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   88:static boolean parse_anewer        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   89:static boolean parse_cmin          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   90:static boolean parse_cnewer        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   91:static boolean parse_comma         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   92:static boolean parse_daystart      PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   93:static boolean parse_delete        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   94:static boolean parse_d             PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   95:static boolean parse_depth         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   96:static boolean parse_empty         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   97:static boolean parse_exec          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   98:static boolean parse_execdir       PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:   99:static boolean parse_false         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  100:static boolean parse_fls           PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  101:static boolean parse_fprintf       PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  102:static boolean parse_follow        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  103:static boolean parse_fprint        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  104:static boolean parse_fprint0       PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  105:static boolean parse_fstype        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  106:static boolean parse_gid           PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  107:static boolean parse_group         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  108:static boolean parse_help          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  109:static boolean parse_ilname        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  110:static boolean parse_iname         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  111:static boolean parse_inum          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  112:static boolean parse_ipath         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  113:static boolean parse_iregex        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  114:static boolean parse_iwholename    PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  115:static boolean parse_links         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  116:static boolean parse_lname         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  117:static boolean parse_ls            PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  118:static boolean parse_maxdepth      PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  119:static boolean parse_mindepth      PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  120:static boolean parse_mmin          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  121:static boolean parse_name          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  122:static boolean parse_negate        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  123:static boolean parse_newer         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  124:static boolean parse_newerXY       PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  125:static boolean parse_noleaf        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  126:static boolean parse_nogroup       PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  127:static boolean parse_nouser        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  128:static boolean parse_nowarn        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  129:static boolean parse_ok            PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  130:static boolean parse_okdir         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  131:static boolean parse_or            PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  132:static boolean parse_path          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  133:static boolean parse_perm          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  134:static boolean parse_print0        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  135:static boolean parse_printf        PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  136:static boolean parse_prune         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  137:static boolean parse_regex         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  138:static boolean parse_regextype     PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  139:static boolean parse_samefile      PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  140:#if 0
        -:  141:static boolean parse_show_control_chars PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  142:#endif
        -:  143:static boolean parse_size          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  144:static boolean parse_time          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  145:static boolean parse_true          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  146:static boolean parse_type          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  147:static boolean parse_uid           PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  148:static boolean parse_used          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  149:static boolean parse_user          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  150:static boolean parse_version       PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  151:static boolean parse_wholename     PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  152:static boolean parse_xdev          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  153:static boolean parse_ignore_race   PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  154:static boolean parse_noignore_race PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  155:static boolean parse_warn          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  156:static boolean parse_xtype         PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  157:static boolean parse_quit          PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  158:
        -:  159:boolean parse_print             PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
        -:  160:
        -:  161:
        -:  162:static boolean insert_type PARAMS((char **argv, int *arg_ptr,
        -:  163:				   const struct parser_table *entry,
        -:  164:				   PRED_FUNC which_pred));
        -:  165:static boolean insert_regex PARAMS((char *argv[], int *arg_ptr,
        -:  166:				    const struct parser_table *entry,
        -:  167:				    int regex_options));
        -:  168:static boolean insert_fprintf (struct format_val *vec,
        -:  169:			       const struct parser_table *entry,
        -:  170:			       PRED_FUNC func,
        -:  171:			       const char *format);
        -:  172:
        -:  173:static struct segment **make_segment PARAMS((struct segment **segment,
        -:  174:					     char *format, int len,
        -:  175:					     int kind, char format_char,
        -:  176:					     char aux_format_char,
        -:  177:					     struct predicate *pred));
        -:  178:static boolean insert_exec_ok PARAMS((const char *action,
        -:  179:				      const struct parser_table *entry,
        -:  180:				      int dir_fd,
        -:  181:				      char *argv[],
        -:  182:				      int *arg_ptr));
        -:  183:static boolean get_comp_type PARAMS((const char **str,
        -:  184:				     enum comparison_type *comp_type));
        -:  185:static boolean get_relative_timestamp PARAMS((const char *str,
        -:  186:					      struct time_val *tval,
        -:  187:					      struct timespec origin,
        -:  188:					      double sec_per_unit,
        -:  189:					      const char *overflowmessage));
        -:  190:static boolean get_num PARAMS((const char *str,
        -:  191:			       uintmax_t *num,
        -:  192:			       enum comparison_type *comp_type));
        -:  193:static struct predicate* insert_num PARAMS((char *argv[], int *arg_ptr,
        -:  194:					    const struct parser_table *entry));
        -:  195:static void open_output_file (const char *path, struct format_val *p);
        -:  196:static void open_stdout (struct format_val *p);
        -:  197:static boolean stream_is_tty(FILE *fp);
        -:  198:static boolean parse_noop PARAMS((const struct parser_table* entry,
        -:  199:				  char **argv, int *arg_ptr));
        -:  200:
        -:  201:#define PASTE(x,y) x##y
        -:  202:#define STRINGIFY(s) #s
        -:  203:
        -:  204:#define PARSE_OPTION(what,suffix) \
        -:  205:  { (ARG_OPTION), (what), PASTE(parse_,suffix), NULL }
        -:  206:
        -:  207:#define PARSE_POSOPT(what,suffix) \
        -:  208:  { (ARG_POSITIONAL_OPTION), (what), PASTE(parse_,suffix), NULL }
        -:  209:
        -:  210:#define PARSE_TEST(what,suffix) \
        -:  211:  { (ARG_TEST), (what), PASTE(parse_,suffix), PASTE(pred_,suffix) }
        -:  212:
        -:  213:#define PARSE_TEST_NP(what,suffix) \
        -:  214:  { (ARG_TEST), (what), PASTE(parse_,suffix), NULL }
        -:  215:
        -:  216:#define PARSE_ACTION(what,suffix) \
        -:  217:  { (ARG_ACTION), (what), PASTE(parse_,suffix), PASTE(pred_,suffix) }
        -:  218:
        -:  219:#define PARSE_ACTION_NP(what,suffix) \
        -:  220:  { (ARG_ACTION), (what), PASTE(parse_,suffix), NULL }
        -:  221:
        -:  222:#define PARSE_PUNCTUATION(what,suffix) \
        -:  223:  { (ARG_PUNCTUATION), (what), PASTE(parse_,suffix), PASTE(pred_,suffix) }
        -:  224:
        -:  225:
        -:  226:/* Predicates we cannot handle in the usual way.  If you add an entry
        -:  227: * to this table, double-check the switch statement in
        -:  228: * pred_sanity_check() to make sure that the new case is being
        -:  229: * correctly handled.
        -:  230: */
        -:  231:static struct parser_table const parse_entry_newerXY =
        -:  232:  {
        -:  233:    ARG_SPECIAL_PARSE, "newerXY",            parse_newerXY, pred_newerXY /* BSD  */
        -:  234:  };
        -:  235:
        -:  236:/* GNU find predicates that are not mentioned in POSIX.2 are marked `GNU'.
        -:  237:   If they are in some Unix versions of find, they are marked `Unix'. */
        -:  238:
        -:  239:static struct parser_table const parse_table[] =
        -:  240:{
        -:  241:  PARSE_PUNCTUATION("!",                     negate), /* POSIX */
        -:  242:  PARSE_PUNCTUATION("not",                   negate),	     /* GNU */
        -:  243:  PARSE_PUNCTUATION("(",                     openparen), /* POSIX */
        -:  244:  PARSE_PUNCTUATION(")",                     closeparen), /* POSIX */
        -:  245:  PARSE_PUNCTUATION(",",                     comma),	     /* GNU */
        -:  246:  PARSE_PUNCTUATION("a",                     and), /* POSIX */
        -:  247:  PARSE_TEST       ("amin",                  amin),	     /* GNU */
        -:  248:  PARSE_PUNCTUATION("and",                   and),		/* GNU */
        -:  249:  PARSE_TEST       ("anewer",                anewer),	     /* GNU */
        -:  250:  {ARG_TEST,       "atime",                  parse_time, pred_atime}, /* POSIX */
        -:  251:  PARSE_TEST       ("cmin",                  cmin),	     /* GNU */
        -:  252:  PARSE_TEST       ("cnewer",                cnewer),	     /* GNU */
        -:  253:  {ARG_TEST,       "ctime",                  parse_time, pred_ctime}, /* POSIX */
        -:  254:  PARSE_POSOPT     ("daystart",              daystart),	     /* GNU */
        -:  255:  PARSE_ACTION     ("delete",                delete), /* GNU, Mac OS, FreeBSD */
        -:  256:  PARSE_OPTION     ("d",                     d), /* Mac OS X, FreeBSD, NetBSD, OpenBSD, but deprecated  in favour of -depth */
        -:  257:  PARSE_OPTION     ("depth",                 depth), /* POSIX */
        -:  258:  PARSE_TEST       ("empty",                 empty),	     /* GNU */
        -:  259:  {ARG_ACTION,      "exec",    parse_exec, pred_exec}, /* POSIX */
        -:  260:  {ARG_TEST,        "executable",            parse_accesscheck, pred_executable}, /* GNU, 4.3.0+ */
        -:  261:  PARSE_ACTION     ("execdir",               execdir), /* *BSD, GNU */
        -:  262:  PARSE_ACTION     ("fls",                   fls),	     /* GNU */
        -:  263:  PARSE_POSOPT     ("follow",                follow),  /* GNU, Unix */
        -:  264:  PARSE_ACTION     ("fprint",                fprint),	     /* GNU */
        -:  265:  PARSE_ACTION     ("fprint0",               fprint0),	     /* GNU */
        -:  266:  {ARG_ACTION,      "fprintf", parse_fprintf, pred_fprintf}, /* GNU */
        -:  267:  PARSE_TEST       ("fstype",                fstype),  /* GNU, Unix */
        -:  268:  PARSE_TEST       ("gid",                   gid),	     /* GNU */
        -:  269:  PARSE_TEST       ("group",                 group), /* POSIX */
        -:  270:  PARSE_OPTION     ("ignore_readdir_race",   ignore_race),   /* GNU */
        -:  271:  PARSE_TEST       ("ilname",                ilname),	     /* GNU */
        -:  272:  PARSE_TEST       ("iname",                 iname),	     /* GNU */
        -:  273:  PARSE_TEST       ("inum",                  inum),    /* GNU, Unix */
        -:  274:  PARSE_TEST       ("ipath",                 ipath), /* GNU, deprecated in favour of iwholename */
        -:  275:  PARSE_TEST_NP    ("iregex",                iregex),	     /* GNU */
        -:  276:  PARSE_TEST_NP    ("iwholename",            iwholename),    /* GNU */
        -:  277:  PARSE_TEST       ("links",                 links), /* POSIX */
        -:  278:  PARSE_TEST       ("lname",                 lname),	     /* GNU */
        -:  279:  PARSE_ACTION     ("ls",                    ls),      /* GNU, Unix */
        -:  280:  PARSE_OPTION     ("maxdepth",              maxdepth),	     /* GNU */
        -:  281:  PARSE_OPTION     ("mindepth",              mindepth),	     /* GNU */
        -:  282:  PARSE_TEST       ("mmin",                  mmin),	     /* GNU */
        -:  283:  PARSE_OPTION     ("mount",                 xdev),	    /* Unix */
        -:  284:  {ARG_TEST,       "mtime",                  parse_time, pred_mtime}, /* POSIX */
        -:  285:  PARSE_TEST       ("name",                  name),
        -:  286:#ifdef UNIMPLEMENTED_UNIX
        -:  287:  PARSE(ARG_UNIMPLEMENTED, "ncpio",          ncpio),	    /* Unix */
        -:  288:#endif
        -:  289:  PARSE_TEST       ("newer",                 newer), /* POSIX */
        -:  290:  {ARG_TEST,       "atime",                  parse_time, pred_atime}, /* POSIX */
        -:  291:  PARSE_OPTION     ("noleaf",                noleaf),	     /* GNU */
        -:  292:  PARSE_TEST       ("nogroup",               nogroup), /* POSIX */
        -:  293:  PARSE_TEST       ("nouser",                nouser), /* POSIX */
        -:  294:  PARSE_OPTION     ("noignore_readdir_race", noignore_race), /* GNU */
        -:  295:  PARSE_POSOPT     ("nowarn",                nowarn),	     /* GNU */
        -:  296:  PARSE_PUNCTUATION("o",                     or), /* POSIX */
        -:  297:  PARSE_PUNCTUATION("or",                    or),	     /* GNU */
        -:  298:  PARSE_ACTION     ("ok",                    ok), /* POSIX */
        -:  299:  PARSE_ACTION     ("okdir",                 okdir), /* GNU (-execdir is BSD) */
        -:  300:  PARSE_TEST       ("path",                  path), /* GNU, HP-UX, RMS prefers wholename, but anyway soon POSIX */
        -:  301:  PARSE_TEST       ("perm",                  perm), /* POSIX */
        -:  302:  PARSE_ACTION     ("print",                 print), /* POSIX */
        -:  303:  PARSE_ACTION     ("print0",                print0),	     /* GNU */
        -:  304:  {ARG_ACTION,      "printf",   parse_printf, NULL},	     /* GNU */
        -:  305:  PARSE_ACTION     ("prune",                 prune), /* POSIX */
        -:  306:  PARSE_ACTION     ("quit",                  quit),	     /* GNU */
        -:  307:  {ARG_TEST,       "readable",            parse_accesscheck, pred_readable}, /* GNU, 4.3.0+ */
        -:  308:  PARSE_TEST       ("regex",                 regex),	     /* GNU */
        -:  309:  PARSE_POSOPT     ("regextype",             regextype),     /* GNU */
        -:  310:  PARSE_TEST       ("samefile",              samefile),	     /* GNU */
        -:  311:#if 0
        -:  312:  PARSE_OPTION     ("show-control-chars",    show_control_chars), /* GNU, 4.3.0+ */
        -:  313:#endif
        -:  314:  PARSE_TEST       ("size",                  size), /* POSIX */
        -:  315:  PARSE_TEST       ("type",                  type), /* POSIX */
        -:  316:  PARSE_TEST       ("uid",                   uid),	     /* GNU */
        -:  317:  PARSE_TEST       ("used",                  used),	     /* GNU */
        -:  318:  PARSE_TEST       ("user",                  user), /* POSIX */
        -:  319:  PARSE_OPTION     ("warn",                  warn),	     /* GNU */
        -:  320:  PARSE_TEST_NP    ("wholename",             wholename), /* GNU, replaced -path, but anyway -path will soon be in POSIX */
        -:  321:  {ARG_TEST,       "writable",               parse_accesscheck, pred_writable}, /* GNU, 4.3.0+ */
        -:  322:  PARSE_OPTION     ("xdev",                  xdev), /* POSIX */
        -:  323:  PARSE_TEST       ("xtype",                 xtype),	     /* GNU */
        -:  324:#ifdef UNIMPLEMENTED_UNIX
        -:  325:  /* It's pretty ugly for find to know about archive formats.
        -:  326:     Plus what it could do with cpio archives is very limited.
        -:  327:     Better to leave it out.  */
        -:  328:  PARSE(ARG_UNIMPLEMENTED,      "cpio",                  cpio),	/* Unix */
        -:  329:#endif
        -:  330:  /* gnulib's stdbool.h might have made true and false into macros,
        -:  331:   * so we can't leave named 'true' and 'false' tokens, so we have
        -:  332:   * to expeant the relevant entries longhand.
        -:  333:   */
        -:  334:  {ARG_TEST, "false",                 parse_false,   pred_false}, /* GNU */
        -:  335:  {ARG_TEST, "true",                  parse_true,    pred_true }, /* GNU */
        -:  336:  {ARG_NOOP, "noop",                  NULL,          pred_true }, /* GNU, internal use only */
        -:  337:
        -:  338:  /* Various other cases that don't fit neatly into our macro scheme. */
        -:  339:  {ARG_TEST, "help",                  parse_help,    NULL},       /* GNU */
        -:  340:  {ARG_TEST, "-help",                 parse_help,    NULL},       /* GNU */
        -:  341:  {ARG_TEST, "version",               parse_version, NULL},	  /* GNU */
        -:  342:  {ARG_TEST, "-version",              parse_version, NULL},	  /* GNU */
        -:  343:  {0, 0, 0, 0}
        -:  344:};
        -:  345:
        -:  346:
        -:  347:static const char *first_nonoption_arg = NULL;
        -:  348:static const struct parser_table *noop = NULL;
        -:  349:
        -:  350:
        -:  351:void
        8:  352:check_option_combinations(const struct predicate *p)
        -:  353:{
        -:  354:  enum { seen_delete=1u, seen_prune=2u };
        8:  355:  unsigned int predicates = 0u;
        -:  356:
       72:  357:  while (p)
        -:  358:    {
       56:  359:      if (p->pred_func == pred_delete)
    #####:  360:	predicates |= seen_delete;
       56:  361:      else if (p->pred_func == pred_prune)
    #####:  362:	predicates |= seen_prune;
       56:  363:      p = p->pred_next;
        -:  364:    }
        -:  365:
        8:  366:  if ((predicates & seen_prune) && (predicates & seen_delete))
        -:  367:    {
        -:  368:      /* The user specified both -delete and -prune.  One might test
        -:  369:       * this by first doing
        -:  370:       *    find dirs   .... -prune ..... -print
        -:  371:       * to fnd out what's going to get deleted, and then switch to
        -:  372:       *    find dirs   .... -prune ..... -delete
        -:  373:       * once we are happy.  Unfortunately, the -delete action also
        -:  374:       * implicitly turns on -depth, which will affect the behaviour
        -:  375:       * of -prune (in fact, it makes it a no-op).  In this case we
        -:  376:       * would like to prevent unfortunate accidents, so we require
        -:  377:       * the user to have explicitly used -depth.
        -:  378:       *
        -:  379:       * We only get away with this because the -delete predicate is not
        -:  380:       * in POSIX.   If it was, we couldn't issue a fatal error here.
        -:  381:       */
    #####:  382:      if (!options.explicit_depth)
        -:  383:	{
        -:  384:	  /* This fixes Savannah bug #20865. */
    #####:  385:	  error (1, 0, _("The -delete action atomatically turns on -depth, "
        -:  386:			 "but -prune does nothing when -depth is in effect.  "
        -:  387:			 "If you want to carry on anyway, just explicitly use "
        -:  388:			 "the -depth option."));
        -:  389:	}
        -:  390:    }
        8:  391:}
        -:  392:
        -:  393:
        -:  394:static const struct parser_table*
        8:  395:get_noop(void)
        -:  396:{
        -:  397:  int i;
        8:  398:  if (NULL == noop)
        -:  399:    {
      640:  400:      for (i = 0; parse_table[i].parser_name != 0; i++)
        -:  401:	{
      640:  402:	  if (ARG_NOOP ==parse_table[i].type)
        -:  403:	    {
        8:  404:	      noop = &(parse_table[i]);
        8:  405:	      break;
        -:  406:	    }
        -:  407:	}
        -:  408:    }
        8:  409:  return noop;
        -:  410:}
        -:  411:
        -:  412:static int
    #####:  413:get_stat_Ytime(const struct stat *p,
        -:  414:	       char what,
        -:  415:	       struct timespec *ret)
        -:  416:{
    #####:  417:  switch (what)
        -:  418:    {
        -:  419:    case 'a':
    #####:  420:      *ret = get_stat_atime(p);
    #####:  421:      return 1;
        -:  422:    case 'B':
    #####:  423:      *ret = get_stat_birthtime(p);
    #####:  424:      return (ret->tv_nsec >= 0);
        -:  425:    case 'c':
    #####:  426:      *ret = get_stat_ctime(p);
    #####:  427:      return 1;
        -:  428:    case 'm':
    #####:  429:      *ret = get_stat_mtime(p);
    #####:  430:      return 1;
        -:  431:    default:
    #####:  432:      assert (0);
        -:  433:      abort();
        -:  434:    }
        -:  435:}
        -:  436:
        -:  437:void
        9:  438:set_follow_state(enum SymlinkOption opt)
        -:  439:{
        9:  440:  if (options.debug_options & DebugStat)
        -:  441:    {
        -:  442:      /* For DebugStat, the choice is made at runtime within debug_stat()
        -:  443:       * by checking the contents of the symlink_handling variable.
        -:  444:       */
    #####:  445:      options.xstat = debug_stat;
        -:  446:    }
        -:  447:  else
        -:  448:    {
        9:  449:      switch (opt)
        -:  450:	{
        -:  451:	case SYMLINK_ALWAYS_DEREF:  /* -L */
    #####:  452:	  options.xstat = optionl_stat;
    #####:  453:	  options.no_leaf_check = true;
    #####:  454:	  break;
        -:  455:
        -:  456:	case SYMLINK_NEVER_DEREF:	/* -P (default) */
        9:  457:	  options.xstat = optionp_stat;
        -:  458:	  /* Can't turn no_leaf_check off because the user might have specified
        -:  459:	   * -noleaf anyway
        -:  460:	   */
        9:  461:	  break;
        -:  462:
        -:  463:	case SYMLINK_DEREF_ARGSONLY: /* -H */
    #####:  464:	  options.xstat = optionh_stat;
    #####:  465:	  options.no_leaf_check = true;
        -:  466:	}
        -:  467:    }
        9:  468:  options.symlink_handling = opt;
        9:  469:}
        -:  470:
        -:  471:
        -:  472:void
        9:  473:parse_begin_user_args (char **args, int argno,
        -:  474:		       const struct predicate *last,
        -:  475:		       const struct predicate *predicates)
        -:  476:{
        -:  477:  (void) args;
        -:  478:  (void) argno;
        -:  479:  (void) last;
        -:  480:  (void) predicates;
        9:  481:  first_nonoption_arg = NULL;
        9:  482:}
        -:  483:
        -:  484:void
        8:  485:parse_end_user_args (char **args, int argno,
        -:  486:		     const struct predicate *last,
        -:  487:		     const struct predicate *predicates)
        -:  488:{
        -:  489:  /* does nothing */
        -:  490:  (void) args;
        -:  491:  (void) argno;
        -:  492:  (void) last;
        -:  493:  (void) predicates;
        8:  494:}
        -:  495:
        -:  496:
        -:  497:/* Check that it is legal to fid the given primary in its
        -:  498: * position and return it.
        -:  499: */
        -:  500:const struct parser_table*
       69:  501:found_parser(const char *original_arg, const struct parser_table *entry)
        -:  502:{
        -:  503:  /* If this is an option, but we have already had a
        -:  504:   * non-option argument, the user may be under the
        -:  505:   * impression that the behaviour of the option
        -:  506:   * argument is conditional on some preceding
        -:  507:   * tests.  This might typically be the case with,
        -:  508:   * for example, -maxdepth.
        -:  509:   *
        -:  510:   * The options -daystart and -follow are exempt
        -:  511:   * from this treatment, since their positioning
        -:  512:   * in the command line does have an effect on
        -:  513:   * subsequent tests but not previous ones.  That
        -:  514:   * might be intentional on the part of the user.
        -:  515:   */
       69:  516:  if (entry->type != ARG_POSITIONAL_OPTION)
        -:  517:    {
        -:  518:      /* Something other than -follow/-daystart.
        -:  519:       * If this is an option, check if it followed
        -:  520:       * a non-option and if so, issue a warning.
        -:  521:       */
       69:  522:      if (entry->type == ARG_OPTION)
        -:  523:	{
        8:  524:	  if ((first_nonoption_arg != NULL)
    #####:  525:	      && options.warnings )
        -:  526:	    {
        -:  527:	      /* option which follows a non-option */
    #####:  528:	      error (0, 0,
        -:  529:		     _("warning: you have specified the %s "
        -:  530:		       "option after a non-option argument %s, "
        -:  531:		       "but options are not positional (%s affects "
        -:  532:		       "tests specified before it as well as those "
        -:  533:		       "specified after it).  Please specify options "
        -:  534:		       "before other arguments.\n"),
        -:  535:		     original_arg,
        -:  536:		     first_nonoption_arg,
        -:  537:		     original_arg);
        -:  538:	    }
        -:  539:	}
        -:  540:      else
        -:  541:	{
        -:  542:	  /* Not an option or a positional option,
        -:  543:	   * so remember we've seen it in order to
        -:  544:	   * use it in a possible future warning message.
        -:  545:	   */
       61:  546:	  if (first_nonoption_arg == NULL)
        -:  547:	    {
       18:  548:	      first_nonoption_arg = original_arg;
        -:  549:	    }
        -:  550:	}
        -:  551:    }
        -:  552:
       69:  553:  return entry;
        -:  554:}
        -:  555:
        -:  556:
        -:  557:/* Return a pointer to the parser function to invoke for predicate
        -:  558:   SEARCH_NAME.
        -:  559:   Return NULL if SEARCH_NAME is not a valid predicate name. */
        -:  560:
        -:  561:const struct parser_table*
       69:  562:find_parser (char *search_name)
        -:  563:{
        -:  564:  int i;
       69:  565:  const char *original_arg = search_name;
        -:  566:
        -:  567:  /* Ugh.  Special case -newerXY. */
       69:  568:  if (0 == strncmp("-newer", search_name, 6)
    #####:  569:      && (8 == strlen(search_name)))
        -:  570:    {
    #####:  571:      return found_parser(original_arg, &parse_entry_newerXY);
        -:  572:    }
        -:  573:
       69:  574:  if (*search_name == '-')
       33:  575:    search_name++;
        -:  576:
     2462:  577:  for (i = 0; parse_table[i].parser_name != 0; i++)
        -:  578:    {
     2462:  579:      if (strcmp (parse_table[i].parser_name, search_name) == 0)
        -:  580:	{
       69:  581:	  return found_parser(original_arg, &parse_table[i]);
        -:  582:	}
        -:  583:    }
    #####:  584:  return NULL;
        -:  585:}
        -:  586:
        -:  587:static float
    #####:  588:estimate_file_age_success_rate(float num_days)
        -:  589:{
    #####:  590:  if (num_days < 0.1)
        -:  591:    {
        -:  592:      /* Assume 1% of files have timestamps in the future */
    #####:  593:      return 0.01f;
        -:  594:    }
    #####:  595:  else if (num_days < 1)
        -:  596:    {
        -:  597:      /* Assume 30% of files have timestamps today */
    #####:  598:      return 0.3f;
        -:  599:    }
    #####:  600:  else if (num_days > 100)
        -:  601:    {
        -:  602:      /* Assume 30% of files are very old */
    #####:  603:      return 0.3f;
        -:  604:    }
        -:  605:  else
        -:  606:    {
        -:  607:      /* Assume 39% of files are between 1 and 100 days old. */
    #####:  608:      return 0.39f;
        -:  609:    }
        -:  610:}
        -:  611:
        -:  612:static float
    #####:  613:estimate_timestamp_success_rate(time_t when)
        -:  614:{
        -:  615:  /* This calculation ignores the nanoseconds field of the
        -:  616:   * origin, but I don't think that makes much difference
        -:  617:   * to our estimate.
        -:  618:   */
    #####:  619:  int num_days = (options.cur_day_start.tv_sec - when) / 86400;
    #####:  620:  return estimate_file_age_success_rate(num_days);
        -:  621:}
        -:  622:
        -:  623:/* Collect an argument from the argument list, or
        -:  624: * return false.
        -:  625: */
        -:  626:static boolean
    #####:  627:collect_arg(char **argv, int *arg_ptr, const char **collected_arg)
        -:  628:{
    #####:  629:  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
        -:  630:    {
    #####:  631:      *collected_arg = NULL;
    #####:  632:      return false;
        -:  633:    }
        -:  634:  else
        -:  635:    {
    #####:  636:      *collected_arg = argv[*arg_ptr];
    #####:  637:      (*arg_ptr)++;
    #####:  638:      return true;
        -:  639:    }
        -:  640:}
        -:  641:
        -:  642:static boolean
    #####:  643:collect_arg_stat_info(char **argv, int *arg_ptr, struct stat *p,
        -:  644:		      const char **argument)
        -:  645:{
        -:  646:  const char *filename;
    #####:  647:  if (collect_arg(argv, arg_ptr, &filename))
        -:  648:    {
    #####:  649:      *argument = filename;
    #####:  650:      if (0 == (options.xstat)(filename, p))
        -:  651:	{
    #####:  652:	  return true;
        -:  653:	}
        -:  654:      else
        -:  655:	{
    #####:  656:	  fatal_file_error(filename);
        -:  657:	}
        -:  658:    }
        -:  659:  else
        -:  660:    {
    #####:  661:      *argument = NULL;
    #####:  662:      return false;
        -:  663:    }
        -:  664:}
        -:  665:
        -:  666:/* The parsers are responsible to continue scanning ARGV for
        -:  667:   their arguments.  Each parser knows what is and isn't
        -:  668:   allowed for itself.
        -:  669:
        -:  670:   ARGV is the argument array.
        -:  671:   *ARG_PTR is the index to start at in ARGV,
        -:  672:   updated to point beyond the last element consumed.
        -:  673:
        -:  674:   The predicate structure is updated with the new information. */
        -:  675:
        -:  676:
        -:  677:static boolean
    #####:  678:parse_and (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  679:{
        -:  680:  struct predicate *our_pred;
        -:  681:
        -:  682:  (void) argv;
        -:  683:  (void) arg_ptr;
        -:  684:
    #####:  685:  our_pred = get_new_pred_noarg (entry);
    #####:  686:  our_pred->pred_func = pred_and;
    #####:  687:  our_pred->p_type = BI_OP;
    #####:  688:  our_pred->p_prec = AND_PREC;
    #####:  689:  our_pred->need_stat = our_pred->need_type = false;
    #####:  690:  return true;
        -:  691:}
        -:  692:
        -:  693:static boolean
    #####:  694:parse_anewer (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  695:{
        -:  696:  struct stat stat_newer;
        -:  697:  const char *arg;
        -:  698:
    #####:  699:  set_stat_placeholders(&stat_newer);
    #####:  700:  if (collect_arg_stat_info(argv, arg_ptr, &stat_newer, &arg))
        -:  701:    {
    #####:  702:      struct predicate *our_pred = insert_primary (entry, arg);
    #####:  703:      our_pred->args.reftime.xval = XVAL_ATIME;
    #####:  704:      our_pred->args.reftime.ts = get_stat_mtime(&stat_newer);
    #####:  705:      our_pred->args.reftime.kind = COMP_GT;
    #####:  706:      our_pred->est_success_rate = estimate_timestamp_success_rate(stat_newer.st_mtime);
    #####:  707:      return true;
        -:  708:    }
    #####:  709:  return false;
        -:  710:}
        -:  711:
        -:  712:boolean
    #####:  713:parse_closeparen (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  714:{
        -:  715:  struct predicate *our_pred;
        -:  716:
        -:  717:  (void) argv;
        -:  718:  (void) arg_ptr;
        -:  719:
    #####:  720:  our_pred = get_new_pred_noarg (entry);
    #####:  721:  our_pred->pred_func = pred_closeparen;
    #####:  722:  our_pred->p_type = CLOSE_PAREN;
    #####:  723:  our_pred->p_prec = NO_PREC;
    #####:  724:  our_pred->need_stat = our_pred->need_type = false;
    #####:  725:  return true;
        -:  726:}
        -:  727:
        -:  728:static boolean
    #####:  729:parse_cnewer (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  730:{
        -:  731:  struct stat stat_newer;
        -:  732:  const char *arg;
        -:  733:
    #####:  734:  set_stat_placeholders(&stat_newer);
    #####:  735:  if (collect_arg_stat_info(argv, arg_ptr, &stat_newer, &arg))
        -:  736:    {
    #####:  737:      struct predicate *our_pred = insert_primary (entry, arg);
    #####:  738:      our_pred->args.reftime.xval = XVAL_CTIME; /* like -newercm */
    #####:  739:      our_pred->args.reftime.ts = get_stat_mtime(&stat_newer);
    #####:  740:      our_pred->args.reftime.kind = COMP_GT;
    #####:  741:      our_pred->est_success_rate = estimate_timestamp_success_rate(stat_newer.st_mtime);
    #####:  742:      return true;
        -:  743:    }
    #####:  744:  return false;
        -:  745:}
        -:  746:
        -:  747:static boolean
    #####:  748:parse_comma (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  749:{
        -:  750:  struct predicate *our_pred;
        -:  751:
        -:  752:  (void) argv;
        -:  753:  (void) arg_ptr;
        -:  754:
    #####:  755:  our_pred = get_new_pred_noarg (entry);
    #####:  756:  our_pred->pred_func = pred_comma;
    #####:  757:  our_pred->p_type = BI_OP;
    #####:  758:  our_pred->p_prec = COMMA_PREC;
    #####:  759:  our_pred->need_stat = our_pred->need_type = false;
    #####:  760:  our_pred->est_success_rate = 1.0f;
    #####:  761:  return true;
        -:  762:}
        -:  763:
        -:  764:static boolean
    #####:  765:parse_daystart (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  766:{
        -:  767:  struct tm *local;
        -:  768:
        -:  769:  (void) entry;
        -:  770:  (void) argv;
        -:  771:  (void) arg_ptr;
        -:  772:
    #####:  773:  if (options.full_days == false)
        -:  774:    {
    #####:  775:      options.cur_day_start.tv_sec += DAYSECS;
    #####:  776:      options.cur_day_start.tv_nsec = 0;
    #####:  777:      local = localtime (&options.cur_day_start.tv_sec);
    #####:  778:      options.cur_day_start.tv_sec -= (local
    #####:  779:				       ? (local->tm_sec + local->tm_min * 60
    #####:  780:					  + local->tm_hour * 3600)
    #####:  781:				       : options.cur_day_start.tv_sec % DAYSECS);
    #####:  782:      options.full_days = true;
        -:  783:    }
    #####:  784:  return true;
        -:  785:}
        -:  786:
        -:  787:static boolean
    #####:  788:parse_delete (const struct parser_table* entry, char *argv[], int *arg_ptr)
        -:  789:{
        -:  790:  struct predicate *our_pred;
        -:  791:  (void) argv;
        -:  792:  (void) arg_ptr;
        -:  793:
    #####:  794:  our_pred = insert_primary_noarg (entry);
    #####:  795:  our_pred->side_effects = our_pred->no_default_print = true;
        -:  796:  /* -delete implies -depth */
    #####:  797:  options.do_dir_first = false;
        -:  798:
        -:  799:  /* We do not need stat information because we check for the case
        -:  800:   * (errno==EISDIR) in pred_delete.
        -:  801:   */
    #####:  802:  our_pred->need_stat = our_pred->need_type = false;
        -:  803:
    #####:  804:  our_pred->est_success_rate = 1.0f;
    #####:  805:  return true;
        -:  806:}
        -:  807:
        -:  808:static boolean
        8:  809:parse_depth (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  810:{
        -:  811:  (void) entry;
        -:  812:  (void) argv;
        -:  813:
        8:  814:  options.do_dir_first = false;
        8:  815:  options.explicit_depth = true;
        8:  816:  return parse_noop(entry, argv, arg_ptr);
        -:  817:}
        -:  818:
        -:  819:static boolean
    #####:  820:parse_d (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  821:{
    #####:  822:  if (options.warnings)
        -:  823:    {
    #####:  824:      error (0, 0,
        -:  825:	     _("warning: the -d option is deprecated; please use "
        -:  826:	       "-depth instead, because the latter is a "
        -:  827:	       "POSIX-compliant feature."));
        -:  828:    }
    #####:  829:  return parse_depth(entry, argv, arg_ptr);
        -:  830:}
        -:  831:
        -:  832:static boolean
    #####:  833:parse_empty (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  834:{
        -:  835:  struct predicate *our_pred;
        -:  836:  (void) argv;
        -:  837:  (void) arg_ptr;
        -:  838:
    #####:  839:  our_pred = insert_primary_noarg (entry);
    #####:  840:  our_pred->est_success_rate = 0.01f; /* assume 1% of files are empty. */
    #####:  841:  return true;
        -:  842:}
        -:  843:
        -:  844:static boolean
    #####:  845:parse_exec (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  846:{
    #####:  847:  return insert_exec_ok ("-exec", entry, get_start_dirfd(), argv, arg_ptr);
        -:  848:}
        -:  849:
        -:  850:static boolean
    #####:  851:parse_execdir (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  852:{
    #####:  853:  return insert_exec_ok ("-execdir", entry, -1, argv, arg_ptr);
        -:  854:}
        -:  855:
        -:  856:static boolean
    #####:  857:parse_false (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  858:{
        -:  859:  struct predicate *our_pred;
        -:  860:
        -:  861:  (void) argv;
        -:  862:  (void) arg_ptr;
        -:  863:
    #####:  864:  our_pred = insert_primary_noarg (entry);
    #####:  865:  our_pred->need_stat = our_pred->need_type = false;
    #####:  866:  our_pred->side_effects = our_pred->no_default_print = false;
    #####:  867:  our_pred->est_success_rate = 0.0f;
    #####:  868:  return true;
        -:  869:}
        -:  870:
        -:  871:static boolean
    #####:  872:insert_fls (const struct parser_table* entry, const char *filename)
        -:  873:{
    #####:  874:  struct predicate *our_pred = insert_primary_noarg (entry);
    #####:  875:  if (filename)
    #####:  876:    open_output_file (filename, &our_pred->args.printf_vec);
        -:  877:  else
    #####:  878:    open_stdout (&our_pred->args.printf_vec);
    #####:  879:  our_pred->side_effects = our_pred->no_default_print = true;
    #####:  880:  our_pred->est_success_rate = 1.0f;
    #####:  881:  return true;
        -:  882:}
        -:  883:
        -:  884:
        -:  885:static boolean
    #####:  886:parse_fls (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  887:{
        -:  888:  const char *filename;
    #####:  889:  return collect_arg(argv, arg_ptr, &filename)
    #####:  890:    &&  insert_fls(entry, filename);
        -:  891:}
        -:  892:
        -:  893:static boolean
    #####:  894:parse_follow (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  895:{
    #####:  896:  set_follow_state(SYMLINK_ALWAYS_DEREF);
    #####:  897:  return parse_noop(entry, argv, arg_ptr);
        -:  898:}
        -:  899:
        -:  900:static boolean
    #####:  901:parse_fprint (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  902:{
        -:  903:  struct predicate *our_pred;
        -:  904:  const char *filename;
    #####:  905:  if (collect_arg(argv, arg_ptr, &filename))
        -:  906:    {
    #####:  907:      our_pred = insert_primary (entry, filename);
    #####:  908:      open_output_file (filename, &our_pred->args.printf_vec);
    #####:  909:      our_pred->side_effects = our_pred->no_default_print = true;
    #####:  910:      our_pred->need_stat = our_pred->need_type = false;
    #####:  911:      our_pred->est_success_rate = 1.0f;
    #####:  912:      return true;
        -:  913:    }
        -:  914:  else
        -:  915:    {
    #####:  916:      return false;
        -:  917:    }
        -:  918:}
        -:  919:
        -:  920:static boolean
    #####:  921:insert_fprint(const struct parser_table* entry, const char *filename)
        -:  922:{
    #####:  923:  struct predicate *our_pred = insert_primary (entry, filename);
    #####:  924:  if (filename)
    #####:  925:    open_output_file (filename, &our_pred->args.printf_vec);
        -:  926:  else
    #####:  927:    open_stdout (&our_pred->args.printf_vec);
    #####:  928:  our_pred->side_effects = our_pred->no_default_print = true;
    #####:  929:  our_pred->need_stat = our_pred->need_type = false;
    #####:  930:  our_pred->est_success_rate = 1.0f;
    #####:  931:  return true;
        -:  932:}
        -:  933:
        -:  934:
        -:  935:static boolean
    #####:  936:parse_fprint0 (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  937:{
        -:  938:  const char *filename;
    #####:  939:  if (collect_arg(argv, arg_ptr, &filename))
    #####:  940:    return insert_fprint(entry, filename);
        -:  941:  else
    #####:  942:    return false;
        -:  943:}
        -:  944:
    #####:  945:static float estimate_fstype_success_rate(const char *fsname)
        -:  946:{
        -:  947:  struct stat dir_stat;
    #####:  948:  const char *dir = "/";
    #####:  949:  if (0 == stat(dir, &dir_stat))
        -:  950:    {
    #####:  951:      const char *fstype = filesystem_type(&dir_stat, dir);
        -:  952:      /* Assume most files are on the same file system type as the root fs. */
    #####:  953:      if (0 == strcmp(fsname, fstype))
    #####:  954:	  return 0.7f;
        -:  955:      else
    #####:  956:	return 0.3f;
        -:  957:    }
    #####:  958:  return 1.0f;
        -:  959:}
        -:  960:
        -:  961:
        -:  962:static boolean
    #####:  963:parse_fstype (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  964:{
        -:  965:  const char *typename;
    #####:  966:  if (collect_arg(argv, arg_ptr, &typename))
        -:  967:    {
    #####:  968:      struct predicate *our_pred = insert_primary (entry, typename);
    #####:  969:      our_pred->args.str = typename;
        -:  970:
        -:  971:      /* This is an expensive operation, so although there are
        -:  972:       * circumstances where it is selective, we ignore this fact
        -:  973:       * because we probably don't want to promote this test to the
        -:  974:       * front anyway.
        -:  975:       */
    #####:  976:      our_pred->est_success_rate = estimate_fstype_success_rate(typename);
    #####:  977:      return true;
        -:  978:    }
        -:  979:  else
        -:  980:    {
    #####:  981:      return false;
        -:  982:    }
        -:  983:}
        -:  984:
        -:  985:static boolean
    #####:  986:parse_gid (const struct parser_table* entry, char **argv, int *arg_ptr)
        -:  987:{
    #####:  988:  struct predicate *p = insert_num (argv, arg_ptr, entry);
    #####:  989:  if (p)
        -:  990:    {
    #####:  991:      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
    #####:  992:      return true;
        -:  993:    }
        -:  994:  else
        -:  995:    {
    #####:  996:      return false;
        -:  997:    }
        -:  998:}
        -:  999:
        -: 1000:
        -: 1001:static int
    #####: 1002:safe_atoi (const char *s)
        -: 1003:{
        -: 1004:  long lval;
        -: 1005:  char *end;
        -: 1006:
    #####: 1007:  errno = 0;
    #####: 1008:  lval = strtol(s, &end, 10);
    #####: 1009:  if ( (LONG_MAX == lval) || (LONG_MIN == lval) )
        -: 1010:    {
        -: 1011:      /* max/min possible value, or an error. */
    #####: 1012:      if (errno == ERANGE)
        -: 1013:	{
        -: 1014:	  /* too big, or too small. */
    #####: 1015:	  error(1, errno, "%s", s);
        -: 1016:	}
        -: 1017:      else
        -: 1018:	{
        -: 1019:	  /* not a valid number */
    #####: 1020:	  error(1, errno, "%s", s);
        -: 1021:	}
        -: 1022:      /* Otherwise, we do a range chack against INT_MAX and INT_MIN
        -: 1023:       * below.
        -: 1024:       */
        -: 1025:    }
        -: 1026:
    #####: 1027:  if (lval > INT_MAX || lval < INT_MIN)
        -: 1028:    {
        -: 1029:      /* The number was in range for long, but not int. */
    #####: 1030:      errno = ERANGE;
    #####: 1031:      error(1, errno, "%s", s);
        -: 1032:    }
    #####: 1033:  else if (*end)
        -: 1034:    {
    #####: 1035:      error(1, errno, _("Unexpected suffix %s on %s"),
        -: 1036:	    quotearg_n_style(0, options.err_quoting_style, end),
        -: 1037:	    quotearg_n_style(1, options.err_quoting_style, s));
        -: 1038:    }
    #####: 1039:  else if (end == s)
        -: 1040:    {
    #####: 1041:      error(1, errno, "Expected an integer: %s",
        -: 1042:	    quotearg_n_style(0, options.err_quoting_style, s));
        -: 1043:    }
    #####: 1044:  return (int)lval;
        -: 1045:}
        -: 1046:
        -: 1047:
        -: 1048:static boolean
    #####: 1049:parse_group (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1050:{
        -: 1051:  const char *groupname;
        -: 1052:
    #####: 1053:  if (collect_arg(argv, arg_ptr, &groupname))
        -: 1054:    {
        -: 1055:      gid_t gid;
        -: 1056:      struct predicate *our_pred;
    #####: 1057:      struct group *cur_gr = getgrnam(groupname);
    #####: 1058:      endgrent();
    #####: 1059:      if (cur_gr)
        -: 1060:	{
    #####: 1061:	  gid = cur_gr->gr_gid;
        -: 1062:	}
        -: 1063:      else
        -: 1064:	{
    #####: 1065:	  const int gid_len = strspn (groupname, "0123456789");
    #####: 1066:	  if (gid_len)
        -: 1067:	    {
    #####: 1068:	      if (groupname[gid_len] == 0)
        -: 1069:		{
    #####: 1070:		  gid = safe_atoi (groupname);
        -: 1071:		}
        -: 1072:	      else
        -: 1073:		{
        -: 1074:		  /* XXX: no test in test suite for this */
    #####: 1075:		  error(1, 0, _("%s is not the name of an existing group and"
        -: 1076:				" it does not look like a numeric group ID "
        -: 1077:				"because it has the unexpected suffix %s"),
        -: 1078:			quotearg_n_style(0, options.err_quoting_style, groupname),
        -: 1079:			quotearg_n_style(1, options.err_quoting_style, groupname+gid_len));
    #####: 1080:		  return false;
        -: 1081:		}
        -: 1082:	    }
        -: 1083:	  else
        -: 1084:	    {
    #####: 1085:	      if (*groupname)
        -: 1086:		{
        -: 1087:		  /* XXX: no test in test suite for this */
    #####: 1088:		  error(1, 0, _("%s is not the name of an existing group"),
        -: 1089:			quotearg_n_style(0, options.err_quoting_style, groupname));
        -: 1090:		}
        -: 1091:	      else
        -: 1092:		{
    #####: 1093:		  error(1, 0, _("argument to -group is empty, but should be a group name"));
        -: 1094:		}
    #####: 1095:	      return false;
        -: 1096:	    }
        -: 1097:	}
    #####: 1098:      our_pred = insert_primary (entry, groupname);
    #####: 1099:      our_pred->args.gid = gid;
    #####: 1100:      our_pred->est_success_rate = (our_pred->args.numinfo.l_val < 100) ? 0.99 : 0.2;
    #####: 1101:      return true;
        -: 1102:    }
    #####: 1103:  return false;
        -: 1104:}
        -: 1105:
        -: 1106:static boolean
    #####: 1107:parse_help (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1108:{
        -: 1109:  (void) entry;
        -: 1110:  (void) argv;
        -: 1111:  (void) arg_ptr;
        -: 1112:
    #####: 1113:  usage(stdout, 0, NULL);
    #####: 1114:  puts (_("\n\
        -: 1115:default path is the current directory; default expression is -print\n\
        -: 1116:expression may consist of: operators, options, tests, and actions:\n"));
    #####: 1117:  puts (_("\
        -: 1118:operators (decreasing precedence; -and is implicit where no others are given):\n\
        -: 1119:      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\n\
        -: 1120:      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\n"));
    #####: 1121:  puts (_("\
        -: 1122:positional options (always true): -daystart -follow -regextype\n\n\
        -: 1123:normal options (always true, specified before other expressions):\n\
        -: 1124:      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\n\
        -: 1125:      --version -xdev -ignore_readdir_race -noignore_readdir_race\n"));
    #####: 1126:  puts (_("\
        -: 1127:tests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n\
        -: 1128:      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n\
        -: 1129:      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex PATTERN\n\
        -: 1130:      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE"));
    #####: 1131:  puts (_("\
        -: 1132:      -nouser -nogroup -path PATTERN -perm [+-]MODE -regex PATTERN\n\
        -: 1133:      -readable -writable -executable\n\
        -: 1134:      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n\
        -: 1135:      -used N -user NAME -xtype [bcdpfls]\n"));
    #####: 1136:  puts (_("\
        -: 1137:actions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print \n\
        -: 1138:      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\n\
        -: 1139:      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\n\
        -: 1140:      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;\n\
        -: 1141:"));
    #####: 1142:  puts (_("Report (and track progress on fixing) bugs via the findutils bug-reporting\n\
        -: 1143:page at http://savannah.gnu.org/ or, if you have no web access, by sending\n\
        -: 1144:email to <bug-findutils@gnu.org>."));
    #####: 1145:  exit (0);
        -: 1146:}
        -: 1147:
        -: 1148:static float
    #####: 1149:estimate_pattern_match_rate(const char *pattern, int is_regex)
        -: 1150:{
    #####: 1151:  if (strpbrk(pattern, "*?[") || (is_regex && strpbrk(pattern, ".")))
        -: 1152:    {
        -: 1153:      /* A wildcard; assume the pattern matches most files. */
    #####: 1154:      return 0.8f;
        -: 1155:    }
        -: 1156:  else
        -: 1157:    {
    #####: 1158:      return 0.1f;
        -: 1159:    }
        -: 1160:}
        -: 1161:
        -: 1162:static boolean
    #####: 1163:parse_ilname (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1164:{
        -: 1165:  const char *name;
    #####: 1166:  if (collect_arg(argv, arg_ptr, &name))
        -: 1167:    {
    #####: 1168:      struct predicate *our_pred = insert_primary (entry, name);
    #####: 1169:      our_pred->args.str = name;
        -: 1170:      /* Use the generic glob pattern estimator to figure out how many
        -: 1171:       * links will match, but bear in mind that most files won't be links.
        -: 1172:       */
    #####: 1173:      our_pred->est_success_rate = 0.1 * estimate_pattern_match_rate(name, 0);
    #####: 1174:      return true;
        -: 1175:    }
        -: 1176:  else
        -: 1177:    {
    #####: 1178:      return false;
        -: 1179:    }
        -: 1180:}
        -: 1181:
        -: 1182:
        -: 1183:/* sanity check the fnmatch() function to make sure that case folding
        -: 1184: * is supported (as opposed to just having the flag ignored).
        -: 1185: */
        -: 1186:static boolean
    #####: 1187:fnmatch_sanitycheck(void)
        -: 1188:{
        -: 1189:  static boolean checked = false;
    #####: 1190:  if (!checked)
        -: 1191:    {
    #####: 1192:      if (0 != fnmatch("foo", "foo", 0)
    #####: 1193:	  || 0 == fnmatch("Foo", "foo", 0)
    #####: 1194:	  || 0 != fnmatch("Foo", "foo", FNM_CASEFOLD))
        -: 1195:	{
    #####: 1196:	  error (1, 0, _("sanity check of the fnmatch() library function failed."));
    #####: 1197:	  return false;
        -: 1198:	}
    #####: 1199:      checked = true;
        -: 1200:    }
    #####: 1201:  return checked;
        -: 1202:}
        -: 1203:
        -: 1204:
        -: 1205:static boolean
    #####: 1206:check_name_arg(const char *pred, const char *arg)
        -: 1207:{
    #####: 1208:  if (options.warnings && strchr(arg, '/'))
        -: 1209:    {
    #####: 1210:      error(0, 0,_("warning: Unix filenames usually don't contain slashes "
        -: 1211:		   "(though pathnames do).  That means that '%s %s' will "
        -: 1212:		   "probably evaluate to false all the time on this system.  "
        -: 1213:		   "You might find the '-wholename' test more useful, or "
        -: 1214:		   "perhaps '-samefile'.  Alternatively, if you are using "
        -: 1215:		   "GNU grep, you could "
        -: 1216:		   "use 'find ... -print0 | grep -FzZ %s'."),
        -: 1217:	    pred,
        -: 1218:	    safely_quote_err_filename(0, arg),
        -: 1219:	    safely_quote_err_filename(1, arg));
        -: 1220:    }
    #####: 1221:  return true;			/* allow it anyway */
        -: 1222:}
        -: 1223:
        -: 1224:
        -: 1225:
        -: 1226:static boolean
    #####: 1227:parse_iname (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1228:{
        -: 1229:  const char *name;
    #####: 1230:  fnmatch_sanitycheck();
    #####: 1231:  if (collect_arg(argv, arg_ptr, &name))
        -: 1232:    {
    #####: 1233:      if (check_name_arg("-iname", name))
        -: 1234:	{
    #####: 1235:	  struct predicate *our_pred = insert_primary (entry, name);
    #####: 1236:	  our_pred->need_stat = our_pred->need_type = false;
    #####: 1237:	  our_pred->args.str = name;
    #####: 1238:	  our_pred->est_success_rate = estimate_pattern_match_rate(name, 0);
    #####: 1239:	  return true;
        -: 1240:	}
        -: 1241:    }
    #####: 1242:  return false;
        -: 1243:}
        -: 1244:
        -: 1245:static boolean
    #####: 1246:parse_inum (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1247:{
    #####: 1248:  struct predicate *p =  insert_num (argv, arg_ptr, entry);
    #####: 1249:  if (p)
        -: 1250:    {
        -: 1251:      /* inode number is exact match only, so very low proportions of
        -: 1252:       * files match
        -: 1253:       */
    #####: 1254:      p->est_success_rate = 1e-6;
    #####: 1255:      p->need_inum = true;
    #####: 1256:      p->need_stat = false;
    #####: 1257:      p->need_type = false;
    #####: 1258:      return true;
        -: 1259:    }
        -: 1260:  else
        -: 1261:    {
    #####: 1262:      return false;
        -: 1263:    }
        -: 1264:}
        -: 1265:
        -: 1266:static boolean
    #####: 1267:parse_iregex (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1268:{
    #####: 1269:  return insert_regex (argv, arg_ptr, entry, RE_ICASE|options.regex_options);
        -: 1270:}
        -: 1271:
        -: 1272:static boolean
    #####: 1273:parse_links (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1274:{
    #####: 1275:  struct predicate *p = insert_num (argv, arg_ptr, entry);
    #####: 1276:  if (p)
        -: 1277:    {
    #####: 1278:      if (p->args.numinfo.l_val == 1)
    #####: 1279:	p->est_success_rate = 0.99;
    #####: 1280:      else if (p->args.numinfo.l_val == 2)
    #####: 1281:	p->est_success_rate = 0.01;
        -: 1282:      else
    #####: 1283:	p->est_success_rate = 1e-3;
    #####: 1284:      return true;
        -: 1285:    }
        -: 1286:  else
        -: 1287:    {
    #####: 1288:      return false;
        -: 1289:    }
        -: 1290:}
        -: 1291:
        -: 1292:static boolean
    #####: 1293:parse_lname (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1294:{
        -: 1295:  const char *name;
    #####: 1296:  fnmatch_sanitycheck();
    #####: 1297:  if (collect_arg(argv, arg_ptr, &name))
        -: 1298:    {
    #####: 1299:      struct predicate *our_pred = insert_primary (entry, name);
    #####: 1300:      our_pred->args.str = name;
    #####: 1301:      our_pred->est_success_rate = 0.1 * estimate_pattern_match_rate(name, 0);
    #####: 1302:      return true;
        -: 1303:    }
    #####: 1304:  return false;
        -: 1305:}
        -: 1306:
        -: 1307:static boolean
    #####: 1308:parse_ls (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1309:{
        -: 1310:  (void) &argv;
        -: 1311:  (void) &arg_ptr;
    #####: 1312:  return insert_fls(entry, NULL);
        -: 1313:}
        -: 1314:
        -: 1315:static boolean
    #####: 1316:insert_depthspec(const struct parser_table* entry, char **argv, int *arg_ptr,
        -: 1317:		 int *limitptr)
        -: 1318:{
        -: 1319:  const char *depthstr;
        -: 1320:  int depth_len;
    #####: 1321:  const char *predicate = argv[(*arg_ptr)-1];
    #####: 1322:  if (collect_arg(argv, arg_ptr, &depthstr))
        -: 1323:    {
    #####: 1324:      depth_len = strspn (depthstr, "0123456789");
    #####: 1325:      if ((depth_len > 0) && (depthstr[depth_len] == 0))
        -: 1326:	{
    #####: 1327:	  (*limitptr) = safe_atoi (depthstr);
    #####: 1328:	  if (*limitptr >= 0)
        -: 1329:	    {
    #####: 1330:	      return parse_noop(entry, argv, arg_ptr);
        -: 1331:	    }
        -: 1332:	}
    #####: 1333:      error(1, 0, _("Expected a positive decimal integer argument to %s, but got %s"),
        -: 1334:	    predicate,
        -: 1335:	    quotearg_n_style(0, options.err_quoting_style, depthstr));
    #####: 1336:      return false;
        -: 1337:    }
        -: 1338:  /* missing argument */
    #####: 1339:  return false;
        -: 1340:}
        -: 1341:
        -: 1342:
        -: 1343:static boolean
    #####: 1344:parse_maxdepth (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1345:{
    #####: 1346:  return insert_depthspec(entry, argv, arg_ptr, &options.maxdepth);
        -: 1347:}
        -: 1348:
        -: 1349:static boolean
    #####: 1350:parse_mindepth (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1351:{
    #####: 1352:  return insert_depthspec(entry, argv, arg_ptr, &options.mindepth);
        -: 1353:}
        -: 1354:
        -: 1355:
        -: 1356:static boolean
    #####: 1357:do_parse_xmin (const struct parser_table* entry,
        -: 1358:	       char **argv,
        -: 1359:	       int *arg_ptr,
        -: 1360:	       enum xval xv)
        -: 1361:{
        -: 1362:  const char *minutes;
        -: 1363:
    #####: 1364:  if (collect_arg(argv, arg_ptr, &minutes))
        -: 1365:    {
        -: 1366:      struct time_val tval;
    #####: 1367:      struct timespec origin = options.cur_day_start;
    #####: 1368:      tval.xval = xv;
    #####: 1369:      origin.tv_sec += DAYSECS;
    #####: 1370:      if (get_relative_timestamp(minutes, &tval, origin, 60,
        -: 1371:				 "arithmetic overflow while converting %s "
        -: 1372:				 "minutes to a number of seconds"))
        -: 1373:	{
    #####: 1374:	  struct predicate *our_pred = insert_primary (entry, minutes);
    #####: 1375:	  our_pred->args.reftime = tval;
    #####: 1376:	  our_pred->est_success_rate = estimate_timestamp_success_rate(tval.ts.tv_sec);
    #####: 1377:	  return true;
        -: 1378:	}
        -: 1379:    }
    #####: 1380:  return false;
        -: 1381:}
        -: 1382:static boolean
    #####: 1383:parse_amin (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1384:{
    #####: 1385:  return do_parse_xmin(entry, argv, arg_ptr, XVAL_ATIME);
        -: 1386:}
        -: 1387:
        -: 1388:static boolean
    #####: 1389:parse_cmin (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1390:{
    #####: 1391:  return do_parse_xmin(entry, argv, arg_ptr, XVAL_CTIME);
        -: 1392:}
        -: 1393:
        -: 1394:
        -: 1395:static boolean
    #####: 1396:parse_mmin (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1397:{
    #####: 1398:  return do_parse_xmin(entry, argv, arg_ptr, XVAL_MTIME);
        -: 1399:}
        -: 1400:
        -: 1401:static boolean
    #####: 1402:parse_name (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1403:{
        -: 1404:  const char *name;
    #####: 1405:  if (collect_arg(argv, arg_ptr, &name))
        -: 1406:    {
    #####: 1407:      fnmatch_sanitycheck();
    #####: 1408:      if (check_name_arg("-name", name))
        -: 1409:	{
    #####: 1410:	  struct predicate *our_pred = insert_primary (entry, name);
    #####: 1411:	  our_pred->need_stat = our_pred->need_type = false;
    #####: 1412:	  our_pred->args.str = name;
    #####: 1413:	  our_pred->est_success_rate = estimate_pattern_match_rate(name, 0);
    #####: 1414:	  return true;
        -: 1415:	}
        -: 1416:    }
    #####: 1417:  return false;
        -: 1418:}
        -: 1419:
        -: 1420:static boolean
    #####: 1421:parse_negate (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1422:{
        -: 1423:  struct predicate *our_pred;
        -: 1424:
        -: 1425:  (void) &argv;
        -: 1426:  (void) &arg_ptr;
        -: 1427:
    #####: 1428:  our_pred = get_new_pred_chk_op (entry, NULL);
    #####: 1429:  our_pred->pred_func = pred_negate;
    #####: 1430:  our_pred->p_type = UNI_OP;
    #####: 1431:  our_pred->p_prec = NEGATE_PREC;
    #####: 1432:  our_pred->need_stat = our_pred->need_type = false;
    #####: 1433:  return true;
        -: 1434:}
        -: 1435:
        -: 1436:static boolean
    #####: 1437:parse_newer (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1438:{
        -: 1439:  struct predicate *our_pred;
        -: 1440:  struct stat stat_newer;
        -: 1441:  const char *arg;
        -: 1442:
    #####: 1443:  set_stat_placeholders(&stat_newer);
    #####: 1444:  if (collect_arg_stat_info(argv, arg_ptr, &stat_newer, &arg))
        -: 1445:    {
    #####: 1446:      our_pred = insert_primary (entry, arg);
    #####: 1447:      our_pred->args.reftime.ts = get_stat_mtime(&stat_newer);
    #####: 1448:      our_pred->args.reftime.xval = XVAL_MTIME;
    #####: 1449:      our_pred->args.reftime.kind = COMP_GT;
    #####: 1450:      our_pred->est_success_rate = estimate_timestamp_success_rate(stat_newer.st_mtime);
    #####: 1451:      return true;
        -: 1452:    }
    #####: 1453:  return false;
        -: 1454:}
        -: 1455:
        -: 1456:
        -: 1457:static boolean
    #####: 1458:parse_newerXY (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1459:{
        -: 1460:  (void) argv;
        -: 1461:  (void) arg_ptr;
        -: 1462:
    #####: 1463:  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
        -: 1464:    {
    #####: 1465:      return false;
        -: 1466:    }
    #####: 1467:  else if (8u != strlen(argv[*arg_ptr]))
        -: 1468:    {
    #####: 1469:      return false;
        -: 1470:    }
        -: 1471:  else
        -: 1472:    {
        -: 1473:      char x, y;
    #####: 1474:      const char validchars[] = "aBcmt";
        -: 1475:
    #####: 1476:      assert (0 == strncmp("-newer", argv[*arg_ptr], 6));
    #####: 1477:      x = argv[*arg_ptr][6];
    #####: 1478:      y = argv[*arg_ptr][7];
        -: 1479:
        -: 1480:
        -: 1481:#if !defined(HAVE_STRUCT_STAT_ST_BIRTHTIME) && !defined(HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC) && !defined(HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC) && !defined HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC
    #####: 1482:      if ('B' == x || 'B' == y)
        -: 1483:	{
    #####: 1484:	  error(0, 0,
        -: 1485:		_("This system does not provide a way to find the birth time of a file."));
    #####: 1486:	  return false;
        -: 1487:	}
        -: 1488:#endif
        -: 1489:
        -: 1490:      /* -newertY (for any Y) is invalid. */
    #####: 1491:      if (x == 't'
    #####: 1492:	  || 0 == strchr(validchars, x)
    #####: 1493:	  || 0 == strchr( validchars, y))
        -: 1494:	{
    #####: 1495:	  return false;
        -: 1496:	}
        -: 1497:      else
        -: 1498:	{
        -: 1499:	  struct predicate *our_pred;
        -: 1500:
        -: 1501:	  /* Because this item is ARG_SPECIAL_PARSE, we have to advance arg_ptr
        -: 1502:	   * past the test name (for most other tests, this is already done)
        -: 1503:	   */
    #####: 1504:	  if (argv[1+*arg_ptr] == NULL)
        -: 1505:	    {
    #####: 1506:	      error(1, 0, _("The %s test needs an argument"),
    #####: 1507:		    quotearg_n_style(0, options.err_quoting_style, argv[*arg_ptr]));
        -: 1508:	    }
        -: 1509:	  else
        -: 1510:	    {
    #####: 1511:	      (*arg_ptr)++;
        -: 1512:	    }
        -: 1513:
    #####: 1514:	  our_pred = insert_primary (entry, argv[*arg_ptr]);
        -: 1515:
        -: 1516:
    #####: 1517:	  switch (x)
        -: 1518:	    {
        -: 1519:	    case 'a':
    #####: 1520:	      our_pred->args.reftime.xval = XVAL_ATIME;
    #####: 1521:	      break;
        -: 1522:	    case 'B':
    #####: 1523:	      our_pred->args.reftime.xval = XVAL_BIRTHTIME;
    #####: 1524:	      break;
        -: 1525:	    case 'c':
    #####: 1526:	      our_pred->args.reftime.xval = XVAL_CTIME;
    #####: 1527:	      break;
        -: 1528:	    case 'm':
    #####: 1529:	      our_pred->args.reftime.xval = XVAL_MTIME;
    #####: 1530:	      break;
        -: 1531:	    default:
    #####: 1532:	      assert (strchr(validchars, x));
    #####: 1533:	      assert (0);
        -: 1534:	    }
        -: 1535:
    #####: 1536:	  if ('t' == y)
        -: 1537:	    {
    #####: 1538:	      if (!get_date(&our_pred->args.reftime.ts,
        -: 1539:			    argv[*arg_ptr],
        -: 1540:			    &options.start_time))
        -: 1541:		{
    #####: 1542:		  error(1, 0,
        -: 1543:			_("I cannot figure out how to interpret %s as a date or time"),
    #####: 1544:			quotearg_n_style(0, options.err_quoting_style, argv[*arg_ptr]));
        -: 1545:		}
        -: 1546:	    }
        -: 1547:	  else
        -: 1548:	    {
        -: 1549:	      struct stat stat_newer;
        -: 1550:
        -: 1551:	      /* Stat the named file. */
    #####: 1552:	      set_stat_placeholders(&stat_newer);
    #####: 1553:	      if ((*options.xstat) (argv[*arg_ptr], &stat_newer))
    #####: 1554:		fatal_file_error(argv[*arg_ptr]);
        -: 1555:
    #####: 1556:	      if (!get_stat_Ytime(&stat_newer, y, &our_pred->args.reftime.ts))
        -: 1557:		{
        -: 1558:		  /* We cannot extract a timestamp from the struct stat. */
    #####: 1559:		  error(1, 0, _("Cannot obtain birth time of file %s"),
    #####: 1560:			safely_quote_err_filename(0, argv[*arg_ptr]));
        -: 1561:		}
        -: 1562:	    }
    #####: 1563:	  our_pred->args.reftime.kind = COMP_GT;
    #####: 1564:	  our_pred->est_success_rate = estimate_timestamp_success_rate(our_pred->args.reftime.ts.tv_sec);
    #####: 1565:	  (*arg_ptr)++;
        -: 1566:
    #####: 1567:	  assert (our_pred->pred_func != NULL);
    #####: 1568:	  assert (our_pred->pred_func == pred_newerXY);
    #####: 1569:	  assert (our_pred->need_stat);
    #####: 1570:	  return true;
        -: 1571:	}
        -: 1572:    }
        -: 1573:}
        -: 1574:
        -: 1575:
        -: 1576:static boolean
    #####: 1577:parse_noleaf (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1578:{
    #####: 1579:  options.no_leaf_check = true;
    #####: 1580:  return parse_noop(entry, argv, arg_ptr);
        -: 1581:}
        -: 1582:
        -: 1583:#ifdef CACHE_IDS
        -: 1584:/* Arbitrary amount by which to increase size
        -: 1585:   of `uid_unused' and `gid_unused'. */
        -: 1586:#define ALLOC_STEP 2048
        -: 1587:
        -: 1588:/* Boolean: if uid_unused[n] is nonzero, then UID n has no passwd entry. */
        -: 1589:char *uid_unused = NULL;
        -: 1590:
        -: 1591:/* Number of elements in `uid_unused'. */
        -: 1592:unsigned uid_allocated;
        -: 1593:
        -: 1594:/* Similar for GIDs and group entries. */
        -: 1595:char *gid_unused = NULL;
        -: 1596:unsigned gid_allocated;
        -: 1597:#endif
        -: 1598:
        -: 1599:static boolean
    #####: 1600:parse_nogroup (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1601:{
        -: 1602:  struct predicate *our_pred;
        -: 1603:
        -: 1604:  (void) &argv;
        -: 1605:  (void) &arg_ptr;
        -: 1606:
    #####: 1607:  our_pred = insert_primary (entry, NULL);
    #####: 1608:  our_pred->est_success_rate = 1e-4;
        -: 1609:#ifdef CACHE_IDS
        -: 1610:  if (gid_unused == NULL)
        -: 1611:    {
        -: 1612:      struct group *gr;
        -: 1613:
        -: 1614:      gid_allocated = ALLOC_STEP;
        -: 1615:      gid_unused = xmalloc (gid_allocated);
        -: 1616:      memset (gid_unused, 1, gid_allocated);
        -: 1617:      setgrent ();
        -: 1618:      while ((gr = getgrent ()) != NULL)
        -: 1619:	{
        -: 1620:	  if ((unsigned) gr->gr_gid >= gid_allocated)
        -: 1621:	    {
        -: 1622:	      unsigned new_allocated = (unsigned) gr->gr_gid + ALLOC_STEP;
        -: 1623:	      gid_unused = xrealloc (gid_unused, new_allocated);
        -: 1624:	      memset (gid_unused + gid_allocated, 1,
        -: 1625:		      new_allocated - gid_allocated);
        -: 1626:	      gid_allocated = new_allocated;
        -: 1627:	    }
        -: 1628:	  gid_unused[(unsigned) gr->gr_gid] = 0;
        -: 1629:	}
        -: 1630:      endgrent ();
        -: 1631:    }
        -: 1632:#endif
    #####: 1633:  return true;
        -: 1634:}
        -: 1635:
        -: 1636:static boolean
    #####: 1637:parse_nouser (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1638:{
        -: 1639:  struct predicate *our_pred;
        -: 1640:  (void) argv;
        -: 1641:  (void) arg_ptr;
        -: 1642:
        -: 1643:
    #####: 1644:  our_pred = insert_primary_noarg (entry);
    #####: 1645:  our_pred->est_success_rate = 1e-3;
        -: 1646:#ifdef CACHE_IDS
        -: 1647:  if (uid_unused == NULL)
        -: 1648:    {
        -: 1649:      struct passwd *pw;
        -: 1650:
        -: 1651:      uid_allocated = ALLOC_STEP;
        -: 1652:      uid_unused = xmalloc (uid_allocated);
        -: 1653:      memset (uid_unused, 1, uid_allocated);
        -: 1654:      setpwent ();
        -: 1655:      while ((pw = getpwent ()) != NULL)
        -: 1656:	{
        -: 1657:	  if ((unsigned) pw->pw_uid >= uid_allocated)
        -: 1658:	    {
        -: 1659:	      unsigned new_allocated = (unsigned) pw->pw_uid + ALLOC_STEP;
        -: 1660:	      uid_unused = xrealloc (uid_unused, new_allocated);
        -: 1661:	      memset (uid_unused + uid_allocated, 1,
        -: 1662:		      new_allocated - uid_allocated);
        -: 1663:	      uid_allocated = new_allocated;
        -: 1664:	    }
        -: 1665:	  uid_unused[(unsigned) pw->pw_uid] = 0;
        -: 1666:	}
        -: 1667:      endpwent ();
        -: 1668:    }
        -: 1669:#endif
    #####: 1670:  return true;
        -: 1671:}
        -: 1672:
        -: 1673:static boolean
    #####: 1674:parse_nowarn (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1675:{
    #####: 1676:  options.warnings = false;
    #####: 1677:  return parse_noop(entry, argv, arg_ptr);
        -: 1678:}
        -: 1679:
        -: 1680:static boolean
    #####: 1681:parse_ok (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1682:{
    #####: 1683:  return insert_exec_ok ("-ok", entry, get_start_dirfd(), argv, arg_ptr);
        -: 1684:}
        -: 1685:
        -: 1686:static boolean
    #####: 1687:parse_okdir (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1688:{
    #####: 1689:  return insert_exec_ok ("-okdir", entry, -1, argv, arg_ptr);
        -: 1690:}
        -: 1691:
        -: 1692:boolean
        9: 1693:parse_openparen (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1694:{
        -: 1695:  struct predicate *our_pred;
        -: 1696:
        -: 1697:  (void) argv;
        -: 1698:  (void) arg_ptr;
        -: 1699:
        9: 1700:  our_pred = get_new_pred_chk_op (entry, NULL);
        9: 1701:  our_pred->pred_func = pred_openparen;
        9: 1702:  our_pred->p_type = OPEN_PAREN;
        9: 1703:  our_pred->p_prec = NO_PREC;
        9: 1704:  our_pred->need_stat = our_pred->need_type = false;
        9: 1705:  return true;
        -: 1706:}
        -: 1707:
        -: 1708:static boolean
    #####: 1709:parse_or (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1710:{
        -: 1711:  struct predicate *our_pred;
        -: 1712:
        -: 1713:  (void) argv;
        -: 1714:  (void) arg_ptr;
        -: 1715:
    #####: 1716:  our_pred = get_new_pred_noarg (entry);
    #####: 1717:  our_pred->pred_func = pred_or;
    #####: 1718:  our_pred->p_type = BI_OP;
    #####: 1719:  our_pred->p_prec = OR_PREC;
    #####: 1720:  our_pred->need_stat = our_pred->need_type = false;
    #####: 1721:  return true;
        -: 1722:}
        -: 1723:
        -: 1724:static boolean
    #####: 1725:is_feasible_path_argument(const char *arg, boolean foldcase)
        -: 1726:{
    #####: 1727:  const char *last = strrchr (arg, '/');
    #####: 1728:  if (last && !last[1])
        -: 1729:    {
        -: 1730:      /* The name ends with "/". */
    #####: 1731:      if (matches_start_point (arg, foldcase))
        -: 1732:	{
        -: 1733:	  /* "-path foo/" can succeed if one of the start points is "foo/". */
    #####: 1734:	  return true;
        -: 1735:	}
        -: 1736:      else
        -: 1737:	{
    #####: 1738:	  return false;
        -: 1739:	}
        -: 1740:    }
    #####: 1741:  return true;
        -: 1742:}
        -: 1743:
        -: 1744:
        -: 1745:static boolean
    #####: 1746:insert_path_check (const struct parser_table* entry, char **argv, int *arg_ptr,
        -: 1747:		   const char *pred_name, PREDICATEFUNCTION pred)
        -: 1748:{
        -: 1749:  const char *name;
    #####: 1750:  boolean foldcase = false;
        -: 1751:
    #####: 1752:  if (pred == pred_ipath)
    #####: 1753:    foldcase = true;
        -: 1754:
    #####: 1755:  fnmatch_sanitycheck ();
        -: 1756:
    #####: 1757:  if (collect_arg (argv, arg_ptr, &name))
        -: 1758:    {
    #####: 1759:      struct predicate *our_pred = insert_primary_withpred (entry, pred, name);
    #####: 1760:      our_pred->need_stat = our_pred->need_type = false;
    #####: 1761:      our_pred->args.str = name;
    #####: 1762:      our_pred->est_success_rate = estimate_pattern_match_rate (name, 0);
        -: 1763:
    #####: 1764:      if (!options.posixly_correct
    #####: 1765:	  && !is_feasible_path_argument(name, foldcase))
        -: 1766:	{
    #####: 1767:	  error (0, 0, _("warning: -%s %s will not match anything "
        -: 1768:			 "because it ends with /."),
        -: 1769:		 pred_name, name);
    #####: 1770:	  our_pred->est_success_rate = 1.0e-8;
        -: 1771:	}
    #####: 1772:      return true;
        -: 1773:    }
    #####: 1774:  return false;
        -: 1775:}
        -: 1776:
        -: 1777:/* For some time, -path was deprecated (at RMS's request) in favour of
        -: 1778: * -iwholename.  See the node "GNU Manuals" in standards.texi for the
        -: 1779: * rationale for this (basically, GNU prefers the use of the phrase
        -: 1780: * "file name" to "path name".
        -: 1781: *
        -: 1782: * We do not issue a warning that this usage is deprecated
        -: 1783: * since
        -: 1784: * (a) HPUX find supports this predicate also and
        -: 1785: * (b) it will soon be in POSIX anyway.
        -: 1786: */
        -: 1787:static boolean
    #####: 1788:parse_path (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1789:{
    #####: 1790:  return insert_path_check (entry, argv, arg_ptr, "path", pred_path);
        -: 1791:}
        -: 1792:
        -: 1793:static boolean
    #####: 1794:parse_wholename (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1795:{
    #####: 1796:  return insert_path_check (entry, argv, arg_ptr, "wholename", pred_path);
        -: 1797:}
        -: 1798:
        -: 1799:/* -ipath was deprecated (at RMS's request) in favour of
        -: 1800: * -iwholename.   See the node "GNU Manuals" in standards.texi
        -: 1801: * for the rationale for this (basically, GNU prefers the use
        -: 1802: * of the phrase "file name" to "path name".
        -: 1803: * However, -path is now standardised so I un-deprecated -ipath.
        -: 1804: */
        -: 1805:static boolean
    #####: 1806:parse_ipath (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1807:{
    #####: 1808:  return insert_path_check (entry, argv, arg_ptr, "ipath", pred_ipath);
        -: 1809:}
        -: 1810:
        -: 1811:static boolean
    #####: 1812:parse_iwholename (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1813:{
    #####: 1814:  return insert_path_check (entry, argv, arg_ptr, "iwholename", pred_ipath);
        -: 1815:}
        -: 1816:
        -: 1817:static void
    #####: 1818:non_posix_mode(const char *mode)
        -: 1819:{
    #####: 1820:  if (options.posixly_correct)
        -: 1821:    {
    #####: 1822:      error (1, 0, _("Mode %s is not valid when POSIXLY_CORRECT is on."),
        -: 1823:	     quotearg_n_style(0, options.err_quoting_style, mode));
        -: 1824:    }
    #####: 1825:}
        -: 1826:
        -: 1827:
        -: 1828:static boolean
    #####: 1829:parse_perm (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1830:{
        -: 1831:  mode_t perm_val[2];
        -: 1832:  float rate;
    #####: 1833:  int mode_start = 0;
    #####: 1834:  boolean havekind = false;
    #####: 1835:  enum permissions_type kind = PERM_EXACT;
    #####: 1836:  struct mode_change *change = NULL;
        -: 1837:  struct predicate *our_pred;
        -: 1838:  const char *perm_expr;
        -: 1839:
    #####: 1840:  if (!collect_arg(argv, arg_ptr, &perm_expr))
    #####: 1841:    return false;
        -: 1842:
    #####: 1843:  switch (perm_expr[0])
        -: 1844:    {
        -: 1845:    case '-':
    #####: 1846:      mode_start = 1;
    #####: 1847:      kind = PERM_AT_LEAST;
    #####: 1848:      havekind = true;
    #####: 1849:      rate = 0.2;
    #####: 1850:      break;
        -: 1851:
        -: 1852:     case '+':
    #####: 1853:       change = mode_compile (perm_expr);
    #####: 1854:       if (NULL == change)
        -: 1855:	 {
        -: 1856:	   /* Most likely the caller is an old script that is still
        -: 1857:	    * using the obsolete GNU syntax '-perm +MODE'.  This old
        -: 1858:	    * syntax was withdrawn in favor of '-perm /MODE' because
        -: 1859:	    * it is incompatible with POSIX in some cases, but we
        -: 1860:	    * still support uses of it that are not incompatible with
        -: 1861:	    * POSIX.
        -: 1862:	    *
        -: 1863:	    * Example: POSIXLY_CORRECT=y find -perm +a+x
        -: 1864:	    */
    #####: 1865:	   non_posix_mode(perm_expr);
        -: 1866:
        -: 1867:	   /* support the previous behaviour. */
    #####: 1868:	   mode_start = 1;
    #####: 1869:	   kind = PERM_ANY;
    #####: 1870:	   rate = 0.3;
        -: 1871:	 }
        -: 1872:       else
        -: 1873:	 {
        -: 1874:	   /* This is a POSIX-compatible usage */
    #####: 1875:	   mode_start = 0;
    #####: 1876:	   kind = PERM_EXACT;
    #####: 1877:	   rate = 0.1;
        -: 1878:	 }
    #####: 1879:       havekind = true;
    #####: 1880:       break;
        -: 1881:
        -: 1882:    case '/':			/* GNU extension */
    #####: 1883:      non_posix_mode(perm_expr);
    #####: 1884:      mode_start = 1;
    #####: 1885:      kind = PERM_ANY;
    #####: 1886:      havekind = true;
    #####: 1887:      rate = 0.3;
    #####: 1888:      break;
        -: 1889:
        -: 1890:    default:
        -: 1891:      /* For example, '-perm 0644', which is valid and matches
        -: 1892:       * only files whose mode is exactly 0644.
        -: 1893:       */
    #####: 1894:      mode_start = 0;
    #####: 1895:      kind = PERM_EXACT;
    #####: 1896:      havekind = true;
    #####: 1897:      rate = 0.01;
    #####: 1898:      break;
        -: 1899:    }
        -: 1900:
    #####: 1901:  if (NULL == change)
        -: 1902:    {
    #####: 1903:      change = mode_compile (perm_expr + mode_start);
    #####: 1904:      if (NULL == change)
    #####: 1905:	error (1, 0, _("invalid mode %s"),
        -: 1906:	       quotearg_n_style(0, options.err_quoting_style, perm_expr));
        -: 1907:    }
    #####: 1908:  perm_val[0] = mode_adjust (0, false, 0, change, NULL);
    #####: 1909:  perm_val[1] = mode_adjust (0, true, 0, change, NULL);
    #####: 1910:  free (change);
        -: 1911:
    #####: 1912:  if (('/' == perm_expr[0]) && (0 == perm_val[0]) && (0 == perm_val[1]))
        -: 1913:    {
        -: 1914:      /* The meaning of -perm /000 will change in the future.  It
        -: 1915:       * currently matches no files, but like -perm -000 it should
        -: 1916:       * match all files.
        -: 1917:       *
        -: 1918:       * Starting in 2005, we used to issue a warning message
        -: 1919:       * informing the user that the behaviour would change in the
        -: 1920:       * future.  We have now changed the behaviour and issue a
        -: 1921:       * warning message that the behaviour recently changed.
        -: 1922:       */
    #####: 1923:      error (0, 0,
        -: 1924:	     _("warning: you have specified a mode pattern %s (which is "
        -: 1925:	       "equivalent to /000). The meaning of -perm /000 has now been "
        -: 1926:	       "changed to be consistent with -perm -000; that is, while it "
        -: 1927:	       "used to match no files, it now matches all files."),
        -: 1928:	     perm_expr);
        -: 1929:
    #####: 1930:      kind = PERM_AT_LEAST;
    #####: 1931:      havekind = true;
        -: 1932:
        -: 1933:      /* The "magic" number below is just the fraction of files on my
        -: 1934:       * own system that "-type l -xtype l" fails for (i.e. unbroken symlinks).
        -: 1935:       * Actual totals are 1472 and 1073833.
        -: 1936:       */
    #####: 1937:      rate = 0.9986; /* probably matches anything but a broken symlink */
        -: 1938:    }
        -: 1939:
    #####: 1940:  our_pred = insert_primary (entry, perm_expr);
    #####: 1941:  our_pred->est_success_rate = rate;
    #####: 1942:  if (havekind)
        -: 1943:    {
    #####: 1944:      our_pred->args.perm.kind = kind;
        -: 1945:    }
        -: 1946:  else
        -: 1947:    {
        -: 1948:
    #####: 1949:      switch (perm_expr[0])
        -: 1950:	{
        -: 1951:	case '-':
    #####: 1952:	  our_pred->args.perm.kind = PERM_AT_LEAST;
    #####: 1953:	  break;
        -: 1954:	case '+':
    #####: 1955:	  our_pred->args.perm.kind = PERM_ANY;
    #####: 1956:	  break;
        -: 1957:	default:
    #####: 1958:	  our_pred->args.perm.kind = PERM_EXACT;
    #####: 1959:	  break;
        -: 1960:	}
        -: 1961:    }
    #####: 1962:  memcpy (our_pred->args.perm.val, perm_val, sizeof perm_val);
    #####: 1963:  return true;
        -: 1964:}
        -: 1965:
        -: 1966:boolean
       16: 1967:parse_print (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1968:{
        -: 1969:  struct predicate *our_pred;
        -: 1970:
        -: 1971:  (void) argv;
        -: 1972:  (void) arg_ptr;
        -: 1973:
       16: 1974:  our_pred = insert_primary_noarg (entry);
        -: 1975:  /* -print has the side effect of printing.  This prevents us
        -: 1976:     from doing undesired multiple printing when the user has
        -: 1977:     already specified -print. */
       16: 1978:  our_pred->side_effects = our_pred->no_default_print = true;
       16: 1979:  our_pred->need_stat = our_pred->need_type = false;
       16: 1980:  open_stdout(&our_pred->args.printf_vec);
       16: 1981:  return true;
        -: 1982:}
        -: 1983:
        -: 1984:static boolean
    #####: 1985:parse_print0 (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1986:{
    #####: 1987:  return insert_fprint(entry, NULL);
        -: 1988:}
        -: 1989:
        -: 1990:static boolean
    #####: 1991:parse_printf (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 1992:{
        -: 1993:  const char *format;
    #####: 1994:  if (collect_arg(argv, arg_ptr, &format))
        -: 1995:    {
        -: 1996:      struct format_val fmt;
    #####: 1997:      open_stdout(&fmt);
    #####: 1998:      return insert_fprintf (&fmt, entry, pred_fprintf, format);
        -: 1999:    }
    #####: 2000:  return false;
        -: 2001:}
        -: 2002:
        -: 2003:static boolean
    #####: 2004:parse_fprintf (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2005:{
        -: 2006:  const char *format, *filename;
    #####: 2007:  if (collect_arg(argv, arg_ptr, &filename))
        -: 2008:    {
    #####: 2009:      if (collect_arg(argv, arg_ptr, &format))
        -: 2010:	{
        -: 2011:	  struct format_val fmt;
    #####: 2012:	  open_output_file (filename, &fmt);
    #####: 2013:	  return insert_fprintf (&fmt, entry, pred_fprintf, format);
        -: 2014:	}
        -: 2015:    }
    #####: 2016:  return false;
        -: 2017:}
        -: 2018:
        -: 2019:static boolean
    #####: 2020:parse_prune (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2021:{
        -: 2022:  struct predicate *our_pred;
        -: 2023:
        -: 2024:  (void) argv;
        -: 2025:  (void) arg_ptr;
        -: 2026:
    #####: 2027:  our_pred = insert_primary_noarg (entry);
    #####: 2028:  if (options.do_dir_first == false)
    #####: 2029:    our_pred->need_stat = our_pred->need_type = false;
        -: 2030:  /* -prune has a side effect that it does not descend into
        -: 2031:     the current directory. */
    #####: 2032:  our_pred->side_effects = true;
    #####: 2033:  our_pred->no_default_print = false;
    #####: 2034:  return true;
        -: 2035:}
        -: 2036:
        -: 2037:static boolean
    #####: 2038:parse_quit  (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2039:{
    #####: 2040:  struct predicate *our_pred = insert_primary_noarg (entry);
        -: 2041:  (void) argv;
        -: 2042:  (void) arg_ptr;
    #####: 2043:  our_pred->need_stat = our_pred->need_type = false;
    #####: 2044:  our_pred->side_effects = true; /* Exiting is a side effect... */
    #####: 2045:  our_pred->no_default_print = false; /* Don't inhibit the default print, though. */
    #####: 2046:  our_pred->est_success_rate = 1.0f;
    #####: 2047:  return true;
        -: 2048:}
        -: 2049:
        -: 2050:
        -: 2051:static boolean
    #####: 2052:parse_regextype (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2053:{
        -: 2054:  const char *type_name;
    #####: 2055:  if (collect_arg(argv, arg_ptr, &type_name))
        -: 2056:    {
        -: 2057:      /* collect the regex type name */
    #####: 2058:      options.regex_options = get_regex_type(type_name);
    #####: 2059:      return parse_noop(entry, argv, arg_ptr);
        -: 2060:    }
    #####: 2061:  return false;
        -: 2062:}
        -: 2063:
        -: 2064:
        -: 2065:static boolean
    #####: 2066:parse_regex (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2067:{
    #####: 2068:  return insert_regex (argv, arg_ptr, entry, options.regex_options);
        -: 2069:}
        -: 2070:
        -: 2071:static boolean
    #####: 2072:insert_regex (char **argv,
        -: 2073:	      int *arg_ptr,
        -: 2074:	      const struct parser_table *entry,
        -: 2075:	      int regex_options)
        -: 2076:{
        -: 2077:  const char *rx;
    #####: 2078:  if (collect_arg(argv, arg_ptr, &rx))
        -: 2079:    {
        -: 2080:      struct re_pattern_buffer *re;
        -: 2081:      const char *error_message;
    #####: 2082:      struct predicate *our_pred = insert_primary_withpred (entry, pred_regex, rx);
    #####: 2083:      our_pred->need_stat = our_pred->need_type = false;
    #####: 2084:      re = xmalloc (sizeof (struct re_pattern_buffer));
    #####: 2085:      our_pred->args.regex = re;
    #####: 2086:      re->allocated = 100;
    #####: 2087:      re->buffer = xmalloc (re->allocated);
    #####: 2088:      re->fastmap = NULL;
        -: 2089:
    #####: 2090:      re_set_syntax(regex_options);
    #####: 2091:      re->syntax = regex_options;
    #####: 2092:      re->translate = NULL;
        -: 2093:
    #####: 2094:      error_message = re_compile_pattern (rx, strlen(rx), re);
    #####: 2095:      if (error_message)
    #####: 2096:	error (1, 0, "%s", error_message);
    #####: 2097:      our_pred->est_success_rate = estimate_pattern_match_rate(rx, 1);
    #####: 2098:      return true;
        -: 2099:    }
    #####: 2100:  return false;
        -: 2101:}
        -: 2102:
        -: 2103:static boolean
    #####: 2104:parse_size (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2105:{
        -: 2106:  struct predicate *our_pred;
        -: 2107:  char *arg;
        -: 2108:  uintmax_t num;
        -: 2109:  char suffix;
        -: 2110:  enum comparison_type c_type;
        -: 2111:
    #####: 2112:  int blksize = 512;
        -: 2113:  int len;
        -: 2114:
        -: 2115:  /* XXX: cannot (yet) convert to ue collect_arg() as this
        -: 2116:   * function modifies the args in-place.
        -: 2117:   */
    #####: 2118:  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    #####: 2119:    return false;
    #####: 2120:  arg = argv[*arg_ptr];
        -: 2121:
    #####: 2122:  len = strlen (arg);
    #####: 2123:  if (len == 0)
    #####: 2124:    error (1, 0, _("invalid null argument to -size"));
        -: 2125:
    #####: 2126:  suffix = arg[len - 1];
    #####: 2127:  switch (suffix)
        -: 2128:    {
        -: 2129:    case 'b':
    #####: 2130:      blksize = 512;
    #####: 2131:      arg[len - 1] = '\0';
    #####: 2132:      break;
        -: 2133:
        -: 2134:    case 'c':
    #####: 2135:      blksize = 1;
    #####: 2136:      arg[len - 1] = '\0';
    #####: 2137:      break;
        -: 2138:
        -: 2139:    case 'k':
    #####: 2140:      blksize = 1024;
    #####: 2141:      arg[len - 1] = '\0';
    #####: 2142:      break;
        -: 2143:
        -: 2144:    case 'M':			/* Megabytes */
    #####: 2145:      blksize = 1024*1024;
    #####: 2146:      arg[len - 1] = '\0';
    #####: 2147:      break;
        -: 2148:
        -: 2149:    case 'G':			/* Gigabytes */
    #####: 2150:      blksize = 1024*1024*1024;
    #####: 2151:      arg[len - 1] = '\0';
    #####: 2152:      break;
        -: 2153:
        -: 2154:    case 'w':
    #####: 2155:      blksize = 2;
    #####: 2156:      arg[len - 1] = '\0';
    #####: 2157:      break;
        -: 2158:
        -: 2159:    case '0':
        -: 2160:    case '1':
        -: 2161:    case '2':
        -: 2162:    case '3':
        -: 2163:    case '4':
        -: 2164:    case '5':
        -: 2165:    case '6':
        -: 2166:    case '7':
        -: 2167:    case '8':
        -: 2168:    case '9':
    #####: 2169:      break;
        -: 2170:
        -: 2171:    default:
    #####: 2172:      error (1, 0, _("invalid -size type `%c'"), argv[*arg_ptr][len - 1]);
        -: 2173:    }
        -: 2174:  /* TODO: accept fractional megabytes etc. ? */
    #####: 2175:  if (!get_num (arg, &num, &c_type))
        -: 2176:    {
    #####: 2177:      error(1, 0,
        -: 2178:	    _("Invalid argument `%s%c' to -size"),
        -: 2179:	    arg, (int)suffix);
    #####: 2180:      return false;
        -: 2181:    }
    #####: 2182:our_pred = insert_primary (entry, arg);
    #####: 2183:  our_pred->args.size.kind = c_type;
    #####: 2184:  our_pred->args.size.blocksize = blksize;
    #####: 2185:  our_pred->args.size.size = num;
    #####: 2186:  our_pred->need_stat = true;
    #####: 2187:  our_pred->need_type = false;
        -: 2188:
    #####: 2189:  if (COMP_GT == c_type)
    #####: 2190:    our_pred->est_success_rate = (num*blksize > 20480) ? 0.1 : 0.9;
    #####: 2191:  else if (COMP_LT == c_type)
    #####: 2192:    our_pred->est_success_rate = (num*blksize > 20480) ? 0.9 : 0.1;
        -: 2193:  else
    #####: 2194:    our_pred->est_success_rate = 0.01;
        -: 2195:
    #####: 2196:  (*arg_ptr)++;
    #####: 2197:  return true;
        -: 2198:}
        -: 2199:
        -: 2200:
        -: 2201:static boolean
    #####: 2202:parse_samefile (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2203:{
        -: 2204:  /* General idea: stat the file, remember device and inode numbers.
        -: 2205:   * If a candidate file matches those, it's the same file.
        -: 2206:   */
        -: 2207:  struct predicate *our_pred;
        -: 2208:  struct stat st, fst;
        -: 2209:  int fd, openflags;
        -: 2210:  const char *filename;
        -: 2211:
    #####: 2212:  set_stat_placeholders(&st);
    #####: 2213:  if (!collect_arg_stat_info(argv, arg_ptr, &st, &filename))
    #####: 2214:    return false;
        -: 2215:
    #####: 2216:  set_stat_placeholders(&fst);
        -: 2217:  /* POSIX systems are free to re-use the inode number of a deleted
        -: 2218:   * file.  To ensure that we are not fooled by inode reuse, we hold
        -: 2219:   * the file open if we can.  This would prevent the system reusing
        -: 2220:   * the file.
        -: 2221:   */
    #####: 2222:  fd = -3;			/* means, uninitialised */
    #####: 2223:  openflags = O_RDONLY;
        -: 2224:
    #####: 2225:  if (options.symlink_handling == SYMLINK_NEVER_DEREF)
        -: 2226:    {
    #####: 2227:      if (options.open_nofollow_available)
        -: 2228:	{
        -: 2229:	  assert (O_NOFOLLOW != 0);
    #####: 2230:	  openflags |= O_NOFOLLOW;
    #####: 2231:	  fd = -1;		/* safe to open it. */
        -: 2232:	}
        -: 2233:      else
        -: 2234:	{
    #####: 2235:	  if (S_ISLNK(st.st_mode))
        -: 2236:	    {
        -: 2237:	      /* no way to ensure that a symlink will not be followed
        -: 2238:	       * by open(2), so fall back on using lstat().  Accept
        -: 2239:	       * the risk that the named file will be deleted and
        -: 2240:	       * replaced with another having the same inode.
        -: 2241:	       *
        -: 2242:	       * Avoid opening the file.
        -: 2243:	       */
    #####: 2244:	      fd = -2;		/* Do not open it */
        -: 2245:	    }
        -: 2246:	  else
        -: 2247:	    {
    #####: 2248:	      fd = -1;
        -: 2249:	      /* Race condition here: the file might become a symlink here. */
        -: 2250:	    }
        -: 2251:	}
        -: 2252:    }
        -: 2253:  else
        -: 2254:    {
        -: 2255:      /* We want to dereference the symlink anyway */
    #####: 2256:      fd = -1;			/* safe to open it without O_NOFOLLOW */
        -: 2257:    }
        -: 2258:
    #####: 2259:  assert (fd != -3);		/* check we made a decision */
    #####: 2260:  if (fd == -1)
        -: 2261:    {
        -: 2262:      /* Race condition here.  The file might become a
        -: 2263:       * symbolic link in between out call to stat and
        -: 2264:       * the call to open.
        -: 2265:       */
    #####: 2266:      fd = open(argv[*arg_ptr], openflags);
        -: 2267:
    #####: 2268:      if (fd >= 0)
        -: 2269:	{
        -: 2270:	  /* We stat the file again here to prevent a race condition
        -: 2271:	   * between the first stat and the call to open(2).
        -: 2272:	   */
    #####: 2273:	  if (0 != fstat(fd, &fst))
        -: 2274:	    {
    #####: 2275:	      fatal_file_error(argv[*arg_ptr]);
        -: 2276:	    }
        -: 2277:	  else
        -: 2278:	    {
        -: 2279:	      /* Worry about the race condition.  If the file became a
        -: 2280:	       * symlink after our first stat and before our call to
        -: 2281:	       * open, fst may contain the stat information for the
        -: 2282:	       * destination of the link, not the link itself.
        -: 2283:	       */
    #####: 2284:	      if ((*options.xstat) (argv[*arg_ptr], &st))
    #####: 2285:		fatal_file_error(argv[*arg_ptr]);
        -: 2286:
    #####: 2287:	      if ((options.symlink_handling == SYMLINK_NEVER_DEREF)
    #####: 2288:		  && (!options.open_nofollow_available))
        -: 2289:		{
    #####: 2290:		  if (S_ISLNK(st.st_mode))
        -: 2291:		    {
        -: 2292:		      /* We lost the race.  Leave the data in st.  The
        -: 2293:		       * file descriptor points to the wrong thing.
        -: 2294:		       */
    #####: 2295:		      close(fd);
    #####: 2296:		      fd = -1;
        -: 2297:		    }
        -: 2298:		  else
        -: 2299:		    {
        -: 2300:		      /* Several possibilities here:
        -: 2301:		       * 1. There was no race
        -: 2302:		       * 2. The file changed into a symlink after the stat and
        -: 2303:		       *    before the open, and then back into a non-symlink
        -: 2304:		       *    before the second stat.
        -: 2305:		       *
        -: 2306:		       * In case (1) there is no problem.  In case (2),
        -: 2307:		       * the stat() and fstat() calls will have returned
        -: 2308:		       * different data.  O_NOFOLLOW was not available,
        -: 2309:		       * so the open() call may have followed a symlink
        -: 2310:		       * even if the -P option is in effect.
        -: 2311:		       */
    #####: 2312:		      if ((st.st_dev == fst.st_dev)
    #####: 2313:			  && (st.st_ino == fst.st_ino))
        -: 2314:			{
        -: 2315:			  /* No race.  No need to copy fst to st,
        -: 2316:			   * since they should be identical (modulo
        -: 2317:			   * differences in padding bytes).
        -: 2318:			   */
        -: 2319:			}
        -: 2320:		      else
        -: 2321:			{
        -: 2322:			  /* We lost the race.  Leave the data in st.  The
        -: 2323:			   * file descriptor points to the wrong thing.
        -: 2324:			   */
    #####: 2325:			  close(fd);
    #####: 2326:			  fd = -1;
        -: 2327:			}
        -: 2328:		    }
        -: 2329:		}
        -: 2330:	      else
        -: 2331:		{
    #####: 2332:		  st = fst;
        -: 2333:		}
        -: 2334:	    }
        -: 2335:	}
        -: 2336:    }
        -: 2337:
    #####: 2338:  our_pred = insert_primary (entry, filename);
    #####: 2339:  our_pred->args.samefileid.ino = st.st_ino;
    #####: 2340:  our_pred->args.samefileid.dev = st.st_dev;
    #####: 2341:  our_pred->args.samefileid.fd  = fd;
    #####: 2342:  our_pred->need_type = false;
        -: 2343:  /* smarter way: compare type and inode number first. */
        -: 2344:  /* TODO: maybe optimise this away by being optimistic */
    #####: 2345:  our_pred->need_stat = true;
    #####: 2346:  our_pred->est_success_rate = 0.01f;
    #####: 2347:  return true;
        -: 2348:}
        -: 2349:
        -: 2350:#if 0
        -: 2351:/* This function is commented out partly because support for it is
        -: 2352: * uneven.
        -: 2353: */
        -: 2354:static boolean
        -: 2355:parse_show_control_chars (const struct parser_table* entry,
        -: 2356:			  char **argv,
        -: 2357:			  int *arg_ptr)
        -: 2358:{
        -: 2359:  const char *arg;
        -: 2360:  const char *errmsg = _("The -show-control-chars option takes "
        -: 2361:			 "a single argument which "
        -: 2362:			 "must be 'literal' or 'safe'");
        -: 2363:
        -: 2364:  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
        -: 2365:    {
        -: 2366:      error (1, errno, "%s", errmsg);
        -: 2367:      return false;
        -: 2368:    }
        -: 2369:  else
        -: 2370:    {
        -: 2371:      arg = argv[*arg_ptr];
        -: 2372:
        -: 2373:      if (0 == strcmp("literal", arg))
        -: 2374:	{
        -: 2375:	  options.literal_control_chars = true;
        -: 2376:	}
        -: 2377:      else if (0 == strcmp("safe", arg))
        -: 2378:	{
        -: 2379:	  options.literal_control_chars = false;
        -: 2380:	}
        -: 2381:      else
        -: 2382:	{
        -: 2383:	  error (1, errno, "%s", errmsg);
        -: 2384:	  return false;
        -: 2385:	}
        -: 2386:      (*arg_ptr)++;		/* consume the argument. */
        -: 2387:      return true;
        -: 2388:    }
        -: 2389:}
        -: 2390:#endif
        -: 2391:
        -: 2392:
        -: 2393:static boolean
       16: 2394:parse_true (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2395:{
        -: 2396:  struct predicate *our_pred;
        -: 2397:
        -: 2398:  (void) argv;
        -: 2399:  (void) arg_ptr;
        -: 2400:
       16: 2401:  our_pred = insert_primary_noarg (entry);
       16: 2402:  our_pred->need_stat = our_pred->need_type = false;
       16: 2403:  our_pred->est_success_rate = 1.0f;
       16: 2404:  return true;
        -: 2405:}
        -: 2406:
        -: 2407:static boolean
        8: 2408:parse_noop (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2409:{
        -: 2410:  (void) entry;
        8: 2411:  return parse_true(get_noop(), argv, arg_ptr);
        -: 2412:}
        -: 2413:
        -: 2414:static boolean
    #####: 2415:parse_accesscheck (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2416:{
        -: 2417:  struct predicate *our_pred;
        -: 2418:  (void) argv;
        -: 2419:  (void) arg_ptr;
    #####: 2420:  our_pred = insert_primary_noarg (entry);
    #####: 2421:  our_pred->need_stat = our_pred->need_type = false;
    #####: 2422:  our_pred->side_effects = our_pred->no_default_print = false;
    #####: 2423:  if (pred_is(our_pred, pred_executable))
    #####: 2424:    our_pred->est_success_rate = 0.2;
        -: 2425:  else
    #####: 2426:    our_pred->est_success_rate = 0.9;
    #####: 2427:  return true;
        -: 2428:}
        -: 2429:
        -: 2430:static boolean
    #####: 2431:parse_type (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2432:{
    #####: 2433:  return insert_type (argv, arg_ptr, entry, pred_type);
        -: 2434:}
        -: 2435:
        -: 2436:static boolean
    #####: 2437:parse_uid (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2438:{
    #####: 2439:  struct predicate *p = insert_num (argv, arg_ptr, entry);
    #####: 2440:  if (p)
        -: 2441:    {
    #####: 2442:      p->est_success_rate = (p->args.numinfo.l_val < 100) ? 0.99 : 0.2;
    #####: 2443:      return true;
        -: 2444:    }
        -: 2445:  else
        -: 2446:    {
    #####: 2447:      return false;
        -: 2448:    }
        -: 2449:}
        -: 2450:
        -: 2451:static boolean
    #####: 2452:parse_used (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2453:{
        -: 2454:  struct predicate *our_pred;
        -: 2455:  struct time_val tval;
        -: 2456:  const char *offset_str;
    #####: 2457:  const char *errmsg = "arithmetic overflow while converting %s days to a number of seconds";
        -: 2458:
    #####: 2459:  if (collect_arg(argv, arg_ptr, &offset_str))
        -: 2460:    {
        -: 2461:      /* The timespec is actually a delta value, so we use an origin of 0. */
    #####: 2462:      struct timespec zero = {0,0};
    #####: 2463:      if (get_relative_timestamp(offset_str, &tval, zero, DAYSECS, errmsg))
        -: 2464:	{
    #####: 2465:	  our_pred = insert_primary (entry, offset_str);
    #####: 2466:	  our_pred->args.reftime = tval;
    #####: 2467:	  our_pred->est_success_rate = estimate_file_age_success_rate(tval.ts.tv_sec / DAYSECS);
    #####: 2468:	  return true;
        -: 2469:	}
        -: 2470:      else
        -: 2471:	{
    #####: 2472:	  error(1, 0, _("Invalid argument %s to -used"), offset_str);
    #####: 2473:	  return false;
        -: 2474:	}
        -: 2475:    }
        -: 2476:  else
        -: 2477:    {
    #####: 2478:      return false;		/* missing argument */
        -: 2479:    }
        -: 2480:}
        -: 2481:
        -: 2482:static boolean
    #####: 2483:parse_user (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2484:{
        -: 2485:  const char *username;
        -: 2486:
    #####: 2487:  if (collect_arg(argv, arg_ptr, &username))
        -: 2488:    {
        -: 2489:      struct predicate *our_pred;
        -: 2490:      uid_t uid;
    #####: 2491:      struct passwd *cur_pwd = getpwnam(username);
    #####: 2492:      endpwent();
    #####: 2493:      if (cur_pwd != NULL)
        -: 2494:	{
    #####: 2495:	  uid = cur_pwd->pw_uid;
        -: 2496:	}
        -: 2497:      else
        -: 2498:	{
    #####: 2499:	  const size_t uid_len = strspn (username, "0123456789");
    #####: 2500:	  if (uid_len && (username[uid_len]==0))
        -: 2501:	    {
    #####: 2502:	      uid = safe_atoi (username);
        -: 2503:	    }
        -: 2504:	  else
        -: 2505:	    {
        -: 2506:	      /* This is a fatal error (if we just return false, the caller
        -: 2507:	       * will say "invalid argument `username' to -user", which is
        -: 2508:	       * not as helpful). */
    #####: 2509:	      if (username[0])
        -: 2510:		{
    #####: 2511:		  error (1, 0, _("%s is not the name of a known user"),
        -: 2512:			 quotearg_n_style (0, options.err_quoting_style,
        -: 2513:					   username));
        -: 2514:		}
        -: 2515:	      else
        -: 2516:		{
    #####: 2517:		  error (1, 0, _("The argument to -user should not be empty"));
        -: 2518:		}
        -: 2519:	      /*NOTREACHED*/
    #####: 2520:	      return false;
        -: 2521:	    }
        -: 2522:	}
    #####: 2523:      our_pred = insert_primary (entry, username);
    #####: 2524:      our_pred->args.uid = uid;
    #####: 2525:      our_pred->est_success_rate = (our_pred->args.uid < 100) ? 0.99 : 0.2;
    #####: 2526:      return true;
        -: 2527:    }
    #####: 2528:  return false;
        -: 2529:}
        -: 2530:
        -: 2531:static boolean
        1: 2532:parse_version (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2533:{
        1: 2534:  int features = 0;
        -: 2535:  int flags;
        -: 2536:
        -: 2537:  (void) argv;
        -: 2538:  (void) arg_ptr;
        -: 2539:  (void) entry;
        -: 2540:
        1: 2541:  display_findutils_version("find");
        1: 2542:  printf (_("Features enabled: "));
        -: 2543:
        -: 2544:#if CACHE_IDS
        -: 2545:  printf("CACHE_IDS ");
        -: 2546:  ++features;
        -: 2547:#endif
        -: 2548:#if DEBUG
        -: 2549:  printf("DEBUG ");
        -: 2550:  ++features;
        -: 2551:#endif
        -: 2552:#if DEBUG_STAT
        -: 2553:  printf("DEBUG_STAT ");
        -: 2554:  ++features;
        -: 2555:#endif
        -: 2556:#if defined USE_STRUCT_DIRENT_D_TYPE && defined HAVE_STRUCT_DIRENT_D_TYPE
        1: 2557:  printf("D_TYPE ");
        1: 2558:  ++features;
        -: 2559:#endif
        -: 2560:#if defined O_NOFOLLOW
        1: 2561:  printf("O_NOFOLLOW(%s) ",
        1: 2562:	 (options.open_nofollow_available ? "enabled" : "disabled"));
        1: 2563:  ++features;
        -: 2564:#endif
        -: 2565:#if defined LEAF_OPTIMISATION
        1: 2566:  printf("LEAF_OPTIMISATION ");
        1: 2567:  ++features;
        -: 2568:#endif
        -: 2569:
        1: 2570:  flags = 0;
        1: 2571:  if (is_fts_enabled(&flags))
        -: 2572:    {
        1: 2573:      int nflags = 0;
        1: 2574:      printf("FTS(");
        1: 2575:      ++features;
        -: 2576:
        1: 2577:      if (flags & FTS_CWDFD)
        -: 2578:	{
        1: 2579:	  if (nflags)
        -: 2580:	    {
    #####: 2581:	      printf(",");
        -: 2582:	    }
        1: 2583:	  printf("FTS_CWDFD");
        1: 2584:	  ++nflags;
        -: 2585:	}
        1: 2586:      printf(") ");
        -: 2587:    }
        -: 2588:
        1: 2589:  printf("CBO(level=%d) ", (int)(options.optimisation_level));
        1: 2590:  ++features;
        -: 2591:
        1: 2592:  if (0 == features)
        -: 2593:    {
        -: 2594:      /* For the moment, leave this as English in case someone wants
        -: 2595:	 to parse these strings. */
    #####: 2596:      printf("none");
        -: 2597:    }
        1: 2598:  printf("\n");
        -: 2599:
        1: 2600:  exit (0);
        -: 2601:}
        -: 2602:
        -: 2603:static boolean
    #####: 2604:parse_xdev (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2605:{
    #####: 2606:  options.stay_on_filesystem = true;
    #####: 2607:  return parse_noop(entry, argv, arg_ptr);
        -: 2608:}
        -: 2609:
        -: 2610:static boolean
    #####: 2611:parse_ignore_race (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2612:{
    #####: 2613:  options.ignore_readdir_race = true;
    #####: 2614:  return parse_noop(entry, argv, arg_ptr);
        -: 2615:}
        -: 2616:
        -: 2617:static boolean
    #####: 2618:parse_noignore_race (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2619:{
    #####: 2620:  options.ignore_readdir_race = false;
    #####: 2621:  return parse_noop(entry, argv, arg_ptr);
        -: 2622:}
        -: 2623:
        -: 2624:static boolean
    #####: 2625:parse_warn (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2626:{
    #####: 2627:  options.warnings = true;
    #####: 2628:  return parse_noop(entry, argv, arg_ptr);
        -: 2629:}
        -: 2630:
        -: 2631:static boolean
    #####: 2632:parse_xtype (const struct parser_table* entry, char **argv, int *arg_ptr)
        -: 2633:{
    #####: 2634:  return insert_type (argv, arg_ptr, entry, pred_xtype);
        -: 2635:}
        -: 2636:
        -: 2637:static boolean
    #####: 2638:insert_type (char **argv, int *arg_ptr,
        -: 2639:	     const struct parser_table *entry,
        -: 2640:	     PRED_FUNC which_pred)
        -: 2641:{
        -: 2642:  mode_t type_cell;
        -: 2643:  struct predicate *our_pred;
    #####: 2644:  float rate = 0.5;
        -: 2645:  const char *typeletter;
        -: 2646:
    #####: 2647:  if (collect_arg(argv, arg_ptr, &typeletter))
        -: 2648:    {
    #####: 2649:      if (strlen(typeletter) != 1u)
        -: 2650:	{
    #####: 2651:	  error(1, 0, _("Arguments to -type should contain only one letter"));
    #####: 2652:	  return false;
        -: 2653:	}
        -: 2654:
    #####: 2655:      switch (typeletter[0])
        -: 2656:	{
        -: 2657:	case 'b':			/* block special */
    #####: 2658:	  type_cell = S_IFBLK;
    #####: 2659:	  rate = 0.01f;
    #####: 2660:	  break;
        -: 2661:	case 'c':			/* character special */
    #####: 2662:	  type_cell = S_IFCHR;
    #####: 2663:	  rate = 0.01f;
    #####: 2664:	  break;
        -: 2665:	case 'd':			/* directory */
    #####: 2666:	  type_cell = S_IFDIR;
    #####: 2667:	  rate = 0.4f;
    #####: 2668:	  break;
        -: 2669:	case 'f':			/* regular file */
    #####: 2670:	  type_cell = S_IFREG;
    #####: 2671:	  rate = 0.95f;
    #####: 2672:	  break;
        -: 2673:#ifdef S_IFLNK
        -: 2674:	case 'l':			/* symbolic link */
    #####: 2675:	  type_cell = S_IFLNK;
    #####: 2676:	  rate = 0.1f;
    #####: 2677:	  break;
        -: 2678:#endif
        -: 2679:#ifdef S_IFIFO
        -: 2680:	case 'p':			/* pipe */
    #####: 2681:	  type_cell = S_IFIFO;
    #####: 2682:	  rate = 0.01f;
    #####: 2683:	  break;
        -: 2684:#endif
        -: 2685:#ifdef S_IFSOCK
        -: 2686:	case 's':			/* socket */
    #####: 2687:	  type_cell = S_IFSOCK;
    #####: 2688:	  rate = 0.01f;
    #####: 2689:	  break;
        -: 2690:#endif
        -: 2691:#ifdef S_IFDOOR
        -: 2692:	case 'D':			/* Solaris door */
        -: 2693:	  type_cell = S_IFDOOR;
        -: 2694:	  rate = 0.01f;
        -: 2695:	  break;
        -: 2696:#endif
        -: 2697:	default:			/* None of the above ... nuke 'em. */
    #####: 2698:	  error(1, 0, _("Unknown argument to -type: %c"), (*typeletter));
    #####: 2699:	  return false;
        -: 2700:	}
    #####: 2701:      our_pred = insert_primary_withpred (entry, which_pred, typeletter);
    #####: 2702:      our_pred->est_success_rate = rate;
        -: 2703:
        -: 2704:      /* Figure out if we will need to stat the file, because if we don't
        -: 2705:       * need to follow symlinks, we can avoid a stat call by using
        -: 2706:       * struct dirent.d_type.
        -: 2707:       */
    #####: 2708:      if (which_pred == pred_xtype)
        -: 2709:	{
    #####: 2710:	  our_pred->need_stat = true;
    #####: 2711:	  our_pred->need_type = false;
        -: 2712:	}
        -: 2713:      else
        -: 2714:	{
    #####: 2715:	  our_pred->need_stat = false; /* struct dirent is enough */
    #####: 2716:	  our_pred->need_type = true;
        -: 2717:	}
    #####: 2718:      our_pred->args.type = type_cell;
    #####: 2719:      return true;
        -: 2720:    }
    #####: 2721:  return false;
        -: 2722:}
        -: 2723:
        -: 2724:
        -: 2725:/* Return true if the file accessed via FP is a terminal.
        -: 2726: */
        -: 2727:static boolean
       16: 2728:stream_is_tty(FILE *fp)
        -: 2729:{
       16: 2730:  int fd = fileno(fp);
       16: 2731:  if (-1 == fd)
        -: 2732:    {
    #####: 2733:      return false; /* not a valid stream */
        -: 2734:    }
        -: 2735:  else
        -: 2736:    {
       16: 2737:      return isatty(fd) ? true : false;
        -: 2738:    }
        -: 2739:
        -: 2740:}
        -: 2741:
        -: 2742:
        -: 2743:
        -: 2744:
        -: 2745:/* XXX: do we need to pass FUNC to this function? */
        -: 2746:static boolean
    #####: 2747:insert_fprintf (struct format_val *vec,
        -: 2748:		const struct parser_table *entry, PRED_FUNC func,
        -: 2749:		const char *format_const)
        -: 2750:{
    #####: 2751:  char *format = (char*)format_const; /* XXX: casting away constness */
        -: 2752:  register char *scan;		/* Current address in scanning `format'. */
        -: 2753:  register char *scan2;		/* Address inside of element being scanned. */
        -: 2754:  struct segment **segmentp;	/* Address of current segment. */
        -: 2755:  struct predicate *our_pred;
        -: 2756:
    #####: 2757:  our_pred = insert_primary_withpred (entry, func, format_const);
    #####: 2758:  our_pred->side_effects = our_pred->no_default_print = true;
    #####: 2759:  our_pred->args.printf_vec = *vec;
    #####: 2760:  our_pred->need_type = false;
    #####: 2761:  our_pred->need_stat = false;
    #####: 2762:  our_pred->p_cost    = NeedsNothing;
        -: 2763:
    #####: 2764:  segmentp = &our_pred->args.printf_vec.segment;
    #####: 2765:  *segmentp = NULL;
        -: 2766:
    #####: 2767:  for (scan = format; *scan; scan++)
        -: 2768:    {
    #####: 2769:      if (*scan == '\\')
        -: 2770:	{
    #####: 2771:	  scan2 = scan + 1;
    #####: 2772:	  if (*scan2 >= '0' && *scan2 <= '7')
    #####: 2773:	    {
        -: 2774:	      register int n, i;
        -: 2775:
    #####: 2776:	      for (i = n = 0; i < 3 && (*scan2 >= '0' && *scan2 <= '7');
    #####: 2777:		   i++, scan2++)
    #####: 2778:		n = 8 * n + *scan2 - '0';
    #####: 2779:	      scan2--;
    #####: 2780:	      *scan = n;
        -: 2781:	    }
        -: 2782:	  else
        -: 2783:	    {
    #####: 2784:	      switch (*scan2)
        -: 2785:		{
        -: 2786:		case 'a':
    #####: 2787:		  *scan = 7;
    #####: 2788:		  break;
        -: 2789:		case 'b':
    #####: 2790:		  *scan = '\b';
    #####: 2791:		  break;
        -: 2792:		case 'c':
    #####: 2793:		  make_segment (segmentp, format, scan - format,
        -: 2794:				KIND_STOP, 0, 0,
        -: 2795:				our_pred);
    #####: 2796:		  if (our_pred->need_stat && (our_pred->p_cost < NeedsStatInfo))
    #####: 2797:		    our_pred->p_cost = NeedsStatInfo;
    #####: 2798:		  return true;
        -: 2799:		case 'f':
    #####: 2800:		  *scan = '\f';
    #####: 2801:		  break;
        -: 2802:		case 'n':
    #####: 2803:		  *scan = '\n';
    #####: 2804:		  break;
        -: 2805:		case 'r':
    #####: 2806:		  *scan = '\r';
    #####: 2807:		  break;
        -: 2808:		case 't':
    #####: 2809:		  *scan = '\t';
    #####: 2810:		  break;
        -: 2811:		case 'v':
    #####: 2812:		  *scan = '\v';
    #####: 2813:		  break;
        -: 2814:		case '\\':
        -: 2815:		  /* *scan = '\\'; * it already is */
    #####: 2816:		  break;
        -: 2817:		default:
    #####: 2818:		  error (0, 0,
    #####: 2819:			 _("warning: unrecognized escape `\\%c'"), *scan2);
    #####: 2820:		  scan++;
    #####: 2821:		  continue;
        -: 2822:		}
        -: 2823:	    }
    #####: 2824:	  segmentp = make_segment (segmentp, format, scan - format + 1,
        -: 2825:				   KIND_PLAIN, 0, 0,
        -: 2826:				   our_pred);
    #####: 2827:	  format = scan2 + 1;	/* Move past the escape. */
    #####: 2828:	  scan = scan2;		/* Incremented immediately by `for'. */
        -: 2829:	}
    #####: 2830:      else if (*scan == '%')
        -: 2831:	{
    #####: 2832:	  if (scan[1] == 0)
        -: 2833:	    {
        -: 2834:	      /* Trailing %.  We don't like those. */
    #####: 2835:	      error (1, 0, _("error: %s at end of format string"), scan);
        -: 2836:	    }
    #####: 2837:	  else if (scan[1] == '%')
        -: 2838:	    {
    #####: 2839:	      segmentp = make_segment (segmentp, format, scan - format + 1,
        -: 2840:				       KIND_PLAIN, 0, 0,
        -: 2841:				       our_pred);
    #####: 2842:	      scan++;
    #####: 2843:	      format = scan + 1;
    #####: 2844:	      continue;
        -: 2845:	    }
        -: 2846:	  /* Scan past flags, width and precision, to verify kind. */
    #####: 2847:	  for (scan2 = scan; *++scan2 && strchr ("-+ #", *scan2);)
        -: 2848:	    /* Do nothing. */ ;
    #####: 2849:	  while (ISDIGIT (*scan2))
    #####: 2850:	    scan2++;
    #####: 2851:	  if (*scan2 == '.')
    #####: 2852:	    for (scan2++; ISDIGIT (*scan2); scan2++)
        -: 2853:	      /* Do nothing. */ ;
    #####: 2854:	  if (strchr ("abcdDfFgGhHiklmMnpPsStuUyY", *scan2))
        -: 2855:	    {
    #####: 2856:	      segmentp = make_segment (segmentp, format, scan2 - format,
    #####: 2857:				       KIND_FORMAT, *scan2, 0,
        -: 2858:				       our_pred);
    #####: 2859:	      scan = scan2;
    #####: 2860:	      format = scan + 1;
        -: 2861:	    }
    #####: 2862:	  else if (strchr ("ABCT", *scan2) && scan2[1])
        -: 2863:	    {
    #####: 2864:	      segmentp = make_segment (segmentp, format, scan2 - format,
    #####: 2865:				       KIND_FORMAT, scan2[0], scan2[1],
        -: 2866:				       our_pred);
    #####: 2867:	      scan = scan2 + 1;
    #####: 2868:	      format = scan + 1;
    #####: 2869:	      continue;
        -: 2870:	    }
        -: 2871:	  else
        -: 2872:	    {
        -: 2873:	      /* An unrecognized % escape.  Print the char after the %. */
    #####: 2874:	      error (0, 0, _("warning: unrecognized format directive `%%%c'"),
    #####: 2875:		     *scan2);
    #####: 2876:	      segmentp = make_segment (segmentp, format, scan - format,
        -: 2877:				       KIND_PLAIN, 0, 0,
        -: 2878:				       our_pred);
    #####: 2879:	      format = scan + 1;
    #####: 2880:	      continue;
        -: 2881:	    }
        -: 2882:	}
        -: 2883:    }
        -: 2884:
    #####: 2885:  if (scan > format)
    #####: 2886:    make_segment (segmentp, format, scan - format, KIND_PLAIN, 0, 0,
        -: 2887:		  our_pred);
    #####: 2888:  return true;
        -: 2889:}
        -: 2890:
        -: 2891:/* Create a new fprintf segment in *SEGMENT, with type KIND,
        -: 2892:   from the text in FORMAT, which has length LEN.
        -: 2893:   Return the address of the `next' pointer of the new segment. */
        -: 2894:
        -: 2895:static struct segment **
    #####: 2896:make_segment (struct segment **segment,
        -: 2897:	      char *format,
        -: 2898:	      int len,
        -: 2899:	      int kind,
        -: 2900:	      char format_char,
        -: 2901:	      char aux_format_char,
        -: 2902:	      struct predicate *pred)
        -: 2903:{
    #####: 2904:  enum EvaluationCost mycost = NeedsNothing;
        -: 2905:  char *fmt;
        -: 2906:
    #####: 2907:  *segment = xmalloc (sizeof (struct segment));
        -: 2908:
    #####: 2909:  (*segment)->segkind = kind;
    #####: 2910:  (*segment)->format_char[0] = format_char;
    #####: 2911:  (*segment)->format_char[1] = aux_format_char;
    #####: 2912:  (*segment)->next = NULL;
    #####: 2913:  (*segment)->text_len = len;
        -: 2914:
    #####: 2915:  fmt = (*segment)->text = xmalloc (len + sizeof "d");
    #####: 2916:  strncpy (fmt, format, len);
    #####: 2917:  fmt += len;
        -: 2918:
    #####: 2919:  switch (kind)
        -: 2920:    {
        -: 2921:    case KIND_PLAIN:		/* Plain text string, no % conversion. */
        -: 2922:    case KIND_STOP:		/* Terminate argument, no newline. */
    #####: 2923:      assert (0 == format_char);
    #####: 2924:      assert (0 == aux_format_char);
    #####: 2925:      *fmt = '\0';
    #####: 2926:      if (mycost > pred->p_cost)
    #####: 2927:	pred->p_cost = NeedsNothing;
    #####: 2928:      return &(*segment)->next;
        -: 2929:      break;
        -: 2930:    }
        -: 2931:
    #####: 2932:  assert (kind == KIND_FORMAT);
    #####: 2933:  switch (format_char)
        -: 2934:    {
        -: 2935:    case 'l':			/* object of symlink */
    #####: 2936:      pred->need_stat = true;
    #####: 2937:      mycost = NeedsLinkName;
    #####: 2938:      *fmt++ = 's';
    #####: 2939:      break;
        -: 2940:
        -: 2941:    case 'y':			/* file type */
    #####: 2942:      pred->need_type = true;
    #####: 2943:      mycost = NeedsType;
    #####: 2944:      *fmt++ = 's';
    #####: 2945:      break;
        -: 2946:
        -: 2947:    case 'i':			/* inode number */
    #####: 2948:      pred->need_inum = true;
    #####: 2949:      mycost = NeedsInodeNumber;
    #####: 2950:      *fmt++ = 's';
    #####: 2951:      break;
        -: 2952:
        -: 2953:    case 'a':			/* atime in `ctime' format */
        -: 2954:    case 'A':			/* atime in user-specified strftime format */
        -: 2955:    case 'B':			/* birth time in user-specified strftime format */
        -: 2956:    case 'c':			/* ctime in `ctime' format */
        -: 2957:    case 'C':			/* ctime in user-specified strftime format */
        -: 2958:    case 'F':			/* file system type */
        -: 2959:    case 'g':			/* group name */
        -: 2960:    case 'M':			/* mode in `ls -l' format (eg., "drwxr-xr-x") */
        -: 2961:    case 's':			/* size in bytes */
        -: 2962:    case 't':			/* mtime in `ctime' format */
        -: 2963:    case 'T':			/* mtime in user-specified strftime format */
        -: 2964:    case 'u':			/* user name */
    #####: 2965:      pred->need_stat = true;
    #####: 2966:      mycost = NeedsStatInfo;
    #####: 2967:      *fmt++ = 's';
    #####: 2968:      break;
        -: 2969:
        -: 2970:    case 'S':			/* sparseness */
    #####: 2971:      pred->need_stat = true;
    #####: 2972:      mycost = NeedsStatInfo;
    #####: 2973:      *fmt++ = 'g';
    #####: 2974:      break;
        -: 2975:
        -: 2976:    case 'Y':			/* symlink pointed file type */
    #####: 2977:      pred->need_stat = true;
    #####: 2978:      mycost = NeedsType;	/* true for amortised effect */
    #####: 2979:      *fmt++ = 's';
    #####: 2980:      break;
        -: 2981:
        -: 2982:    case 'f':			/* basename of path */
        -: 2983:    case 'h':			/* leading directories part of path */
        -: 2984:    case 'p':			/* pathname */
        -: 2985:    case 'P':			/* pathname with ARGV element stripped */
    #####: 2986:      *fmt++ = 's';
    #####: 2987:      break;
        -: 2988:
        -: 2989:    case 'H':			/* ARGV element file was found under */
    #####: 2990:      *fmt++ = 's';
    #####: 2991:      break;
        -: 2992:
        -: 2993:      /* Numeric items that one might expect to honour
        -: 2994:       * #, 0, + flags but which do not.
        -: 2995:       */
        -: 2996:    case 'G':			/* GID number */
        -: 2997:    case 'U':			/* UID number */
        -: 2998:    case 'b':			/* size in 512-byte blocks (NOT birthtime in ctime fmt)*/
        -: 2999:    case 'D':                   /* Filesystem device on which the file exits */
        -: 3000:    case 'k':			/* size in 1K blocks */
        -: 3001:    case 'n':			/* number of links */
    #####: 3002:      pred->need_stat = true;
    #####: 3003:      mycost = NeedsStatInfo;
    #####: 3004:      *fmt++ = 's';
    #####: 3005:      break;
        -: 3006:
        -: 3007:      /* Numeric items that DO honour #, 0, + flags.
        -: 3008:       */
        -: 3009:    case 'd':			/* depth in search tree (0 = ARGV element) */
    #####: 3010:      *fmt++ = 'd';
    #####: 3011:      break;
        -: 3012:
        -: 3013:    case 'm':			/* mode as octal number (perms only) */
    #####: 3014:      *fmt++ = 'o';
    #####: 3015:      pred->need_stat = true;
    #####: 3016:      mycost = NeedsStatInfo;
    #####: 3017:      break;
        -: 3018:
        -: 3019:    case '{':
        -: 3020:    case '[':
        -: 3021:    case '(':
    #####: 3022:      error (1, 0,
        -: 3023:	     _("error: the format directive `%%%c' is reserved for future use"),
        -: 3024:	     (int)kind);
        -: 3025:      /*NOTREACHED*/
    #####: 3026:      break;
        -: 3027:    }
    #####: 3028:  *fmt = '\0';
        -: 3029:
    #####: 3030:  if (mycost > pred->p_cost)
    #####: 3031:    pred->p_cost = mycost;
    #####: 3032:  return &(*segment)->next;
        -: 3033:}
        -: 3034:
        -: 3035:static void
    #####: 3036:check_path_safety(const char *action, char **argv)
        -: 3037:{
        -: 3038:  char *s;
    #####: 3039:  const char *path = getenv("PATH");
    #####: 3040:  if (NULL == path)
        -: 3041:    {
        -: 3042:      /* $PATH is not set.  Assume the OS default is safe.
        -: 3043:       * That may not be true on Windows, but I'm not aware
        -: 3044:       * of a way to get Windows to avoid searching the
        -: 3045:       * current directory anyway.
        -: 3046:       */
    #####: 3047:      return;
        -: 3048:    }
        -: 3049:
        -: 3050:  (void)argv;
        -: 3051:
    #####: 3052:  s = next_element(path, 1);
    #####: 3053:  while ((s = next_element ((char *) NULL, 1)) != NULL)
        -: 3054:    {
    #####: 3055:      if (0 == strcmp(s, "."))
        -: 3056:	{
    #####: 3057:	  error(1, 0, _("The current directory is included in the PATH "
        -: 3058:			"environment variable, which is insecure in "
        -: 3059:			"combination with the %s action of find.  "
        -: 3060:			"Please remove the current directory from your "
        -: 3061:			"$PATH (that is, remove \".\" or leading or trailing "
        -: 3062:			"colons)"),
        -: 3063:		action);
        -: 3064:	}
    #####: 3065:      else if ('/' != s[0])
        -: 3066:	{
        -: 3067:	  /* Relative paths are also dangerous in $PATH. */
    #####: 3068:	  error(1, 0, _("The relative path %s is included in the PATH "
        -: 3069:			"environment variable, which is insecure in "
        -: 3070:			"combination with the %s action of find.  "
        -: 3071:			"Please remove that entry from $PATH"),
        -: 3072:		safely_quote_err_filename(0, s),
        -: 3073:		action);
        -: 3074:	}
        -: 3075:    }
        -: 3076:}
        -: 3077:
        -: 3078:
        -: 3079:/* handles both exec and ok predicate */
        -: 3080:static boolean
    #####: 3081:new_insert_exec_ok (const char *action,
        -: 3082:		    const struct parser_table *entry,
        -: 3083:		    int dir_fd,
        -: 3084:		    char **argv,
        -: 3085:		    int *arg_ptr)
        -: 3086:{
        -: 3087:  int start, end;		/* Indexes in ARGV of start & end of cmd. */
        -: 3088:  int i;			/* Index into cmd args */
        -: 3089:  int saw_braces;		/* True if previous arg was '{}'. */
        -: 3090:  boolean allow_plus;		/* True if + is a valid terminator */
        -: 3091:  int brace_count;		/* Number of instances of {}. */
    #####: 3092:  PRED_FUNC func = entry->pred_func;
        -: 3093:  enum BC_INIT_STATUS bcstatus;
        -: 3094:
        -: 3095:  struct predicate *our_pred;
        -: 3096:  struct exec_val *execp;	/* Pointer for efficiency. */
        -: 3097:
    #####: 3098:  if ((argv == NULL) || (argv[*arg_ptr] == NULL))
    #####: 3099:    return false;
        -: 3100:
    #####: 3101:  our_pred = insert_primary_withpred (entry, func, "(some -exec* arguments)");
    #####: 3102:  our_pred->side_effects = our_pred->no_default_print = true;
    #####: 3103:  our_pred->need_type = our_pred->need_stat = false;
        -: 3104:
    #####: 3105:  execp = &our_pred->args.exec_vec;
        -: 3106:
    #####: 3107:  if ((func != pred_okdir) && (func != pred_ok))
        -: 3108:    {
    #####: 3109:      allow_plus = true;
    #####: 3110:      execp->close_stdin = false;
        -: 3111:    }
        -: 3112:  else
        -: 3113:    {
    #####: 3114:      allow_plus = false;
        -: 3115:      /* If find reads stdin (i.e. for -ok and similar), close stdin
        -: 3116:       * in the child to prevent some script from consiming the output
        -: 3117:       * intended for find.
        -: 3118:       */
    #####: 3119:      execp->close_stdin = true;
        -: 3120:    }
        -: 3121:
        -: 3122:
    #####: 3123:  if ((func == pred_execdir) || (func == pred_okdir))
        -: 3124:    {
    #####: 3125:      options.ignore_readdir_race = false;
    #####: 3126:      check_path_safety(action, argv);
    #####: 3127:      execp->use_current_dir = true;
        -: 3128:    }
        -: 3129:  else
        -: 3130:    {
    #####: 3131:      execp->use_current_dir = false;
        -: 3132:    }
        -: 3133:
    #####: 3134:  our_pred->args.exec_vec.multiple = 0;
        -: 3135:
        -: 3136:  /* Count the number of args with path replacements, up until the ';'.
        -: 3137:   * Also figure out if the command is terminated by ";" or by "+".
        -: 3138:   */
    #####: 3139:  start = *arg_ptr;
    #####: 3140:  for (end = start, saw_braces=0, brace_count=0;
    #####: 3141:       (argv[end] != NULL)
    #####: 3142:       && ((argv[end][0] != ';') || (argv[end][1] != '\0'));
    #####: 3143:       end++)
        -: 3144:    {
        -: 3145:      /* For -exec and -execdir, "{} +" can terminate the command. */
    #####: 3146:      if ( allow_plus
    #####: 3147:	   && argv[end][0] == '+' && argv[end][1] == 0
    #####: 3148:	   && saw_braces)
        -: 3149:	{
    #####: 3150:	  our_pred->args.exec_vec.multiple = 1;
    #####: 3151:	  break;
        -: 3152:	}
        -: 3153:
    #####: 3154:      saw_braces = 0;
    #####: 3155:      if (mbsstr (argv[end], "{}"))
        -: 3156:	{
    #####: 3157:	  saw_braces = 1;
    #####: 3158:	  ++brace_count;
        -: 3159:
    #####: 3160:	  if (0 == end && (func == pred_execdir || func == pred_okdir))
        -: 3161:	    {
        -: 3162:	      /* The POSIX standard says that {} replacement should
        -: 3163:	       * occur even in the utility name.  This is insecure
        -: 3164:	       * since it means we will be executing a command whose
        -: 3165:	       * name is chosen according to whatever find finds in
        -: 3166:	       * the file system.  That can be influenced by an
        -: 3167:	       * attacker.  Hence for -execdir and -okdir this is not
        -: 3168:	       * allowed.  We can specify this as those options are
        -: 3169:	       * not defined by POSIX.
        -: 3170:	       */
    #####: 3171:	      error(1, 0, _("You may not use {} within the utility name for "
        -: 3172:			    "-execdir and -okdir, because this is a potential "
        -: 3173:			    "security problem."));
        -: 3174:	    }
        -: 3175:	}
        -: 3176:    }
        -: 3177:
        -: 3178:  /* Fail if no command given or no semicolon found. */
    #####: 3179:  if ((end == start) || (argv[end] == NULL))
        -: 3180:    {
    #####: 3181:      *arg_ptr = end;
    #####: 3182:      free(our_pred);
    #####: 3183:      return false;
        -: 3184:    }
        -: 3185:
    #####: 3186:  if (our_pred->args.exec_vec.multiple && brace_count > 1)
        -: 3187:    {
        -: 3188:
        -: 3189:      const char *suffix;
    #####: 3190:      if (func == pred_execdir)
    #####: 3191:	suffix = "dir";
        -: 3192:      else
    #####: 3193:	suffix = "";
        -: 3194:
    #####: 3195:      error(1, 0,
        -: 3196:	    _("Only one instance of {} is supported with -exec%s ... +"),
        -: 3197:	    suffix);
        -: 3198:    }
        -: 3199:
        -: 3200:  /* We use a switch statement here so that the compiler warns us when
        -: 3201:   * we forget to handle a newly invented enum value.
        -: 3202:   *
        -: 3203:   * Like xargs, we allow 2KiB of headroom for the launched utility to
        -: 3204:   * export its own environment variables before calling something
        -: 3205:   * else.
        -: 3206:   */
    #####: 3207:  bcstatus = bc_init_controlinfo(&execp->ctl, 2048u);
    #####: 3208:  switch (bcstatus)
        -: 3209:    {
        -: 3210:    case BC_INIT_ENV_TOO_BIG:
        -: 3211:    case BC_INIT_CANNOT_ACCOMODATE_HEADROOM:
    #####: 3212:      error(1, 0,
        -: 3213:	    _("The environment is too large for exec()."));
    #####: 3214:      break;
        -: 3215:    case BC_INIT_OK:
        -: 3216:      /* Good news.  Carry on. */
    #####: 3217:      break;
        -: 3218:    }
    #####: 3219:  bc_use_sensible_arg_max(&execp->ctl);
        -: 3220:
        -: 3221:
    #####: 3222:  execp->ctl.exec_callback = launch;
        -: 3223:
    #####: 3224:  if (our_pred->args.exec_vec.multiple)
        -: 3225:    {
        -: 3226:      /* "+" terminator, so we can just append our arguments after the
        -: 3227:       * command and initial arguments.
        -: 3228:       */
    #####: 3229:      execp->replace_vec = NULL;
    #####: 3230:      execp->ctl.replace_pat = NULL;
    #####: 3231:      execp->ctl.rplen = 0;
    #####: 3232:      execp->ctl.lines_per_exec = 0; /* no limit */
    #####: 3233:      execp->ctl.args_per_exec = 0; /* no limit */
        -: 3234:
        -: 3235:      /* remember how many arguments there are */
    #####: 3236:      execp->ctl.initial_argc = (end-start) - 1;
        -: 3237:
        -: 3238:      /* execp->state = xmalloc(sizeof struct buildcmd_state); */
    #####: 3239:      bc_init_state(&execp->ctl, &execp->state, execp);
        -: 3240:
        -: 3241:      /* Gather the initial arguments.  Skip the {}. */
    #####: 3242:      for (i=start; i<end-1; ++i)
        -: 3243:	{
    #####: 3244:	  bc_push_arg(&execp->ctl, &execp->state,
    #####: 3245:		      argv[i], strlen(argv[i])+1,
        -: 3246:		      NULL, 0,
        -: 3247:		      1);
        -: 3248:	}
        -: 3249:    }
        -: 3250:  else
        -: 3251:    {
        -: 3252:      /* Semicolon terminator - more than one {} is supported, so we
        -: 3253:       * have to do brace-replacement.
        -: 3254:       */
    #####: 3255:      execp->num_args = end - start;
        -: 3256:
    #####: 3257:      execp->ctl.replace_pat = "{}";
    #####: 3258:      execp->ctl.rplen = strlen(execp->ctl.replace_pat);
    #####: 3259:      execp->ctl.lines_per_exec = 0; /* no limit */
    #####: 3260:      execp->ctl.args_per_exec = 0; /* no limit */
    #####: 3261:      execp->replace_vec = xmalloc(sizeof(char*)*execp->num_args);
        -: 3262:
        -: 3263:
        -: 3264:      /* execp->state = xmalloc(sizeof(*(execp->state))); */
    #####: 3265:      bc_init_state(&execp->ctl, &execp->state, execp);
        -: 3266:
        -: 3267:      /* Remember the (pre-replacement) arguments for later. */
    #####: 3268:      for (i=0; i<execp->num_args; ++i)
        -: 3269:	{
    #####: 3270:	  execp->replace_vec[i] = argv[i+start];
        -: 3271:	}
        -: 3272:    }
        -: 3273:
    #####: 3274:  if (argv[end] == NULL)
    #####: 3275:    *arg_ptr = end;
        -: 3276:  else
    #####: 3277:    *arg_ptr = end + 1;
        -: 3278:
    #####: 3279:  return true;
        -: 3280:}
        -: 3281:
        -: 3282:
        -: 3283:
        -: 3284:static boolean
    #####: 3285:insert_exec_ok (const char *action,
        -: 3286:		const struct parser_table *entry,
        -: 3287:		int dir_fd,
        -: 3288:		char **argv,
        -: 3289:		int *arg_ptr)
        -: 3290:{
    #####: 3291:  return new_insert_exec_ok(action, entry, dir_fd, argv, arg_ptr);
        -: 3292:}
        -: 3293:
        -: 3294:
        -: 3295:
        -: 3296:/* Get a timestamp and comparison type.
        -: 3297:
        -: 3298:   STR is the ASCII representation.
        -: 3299:   Set *NUM_DAYS to the number of days/minutes/whatever, taken as being
        -: 3300:   relative to ORIGIN (usually the current moment or midnight).
        -: 3301:   Thus the sense of the comparison type appears to be reversed.
        -: 3302:   Set *COMP_TYPE to the kind of comparison that is requested.
        -: 3303:   Issue OVERFLOWMESSAGE if overflow occurs.
        -: 3304:   Return true if all okay, false if input error.
        -: 3305:
        -: 3306:   Used by -atime, -ctime and -mtime (parsers) to
        -: 3307:   get the appropriate information for a time predicate processor. */
        -: 3308:
        -: 3309:static boolean
    #####: 3310:get_relative_timestamp (const char *str,
        -: 3311:			struct time_val *result,
        -: 3312:			struct timespec origin,
        -: 3313:			double sec_per_unit,
        -: 3314:			const char *overflowmessage)
        -: 3315:{
        -: 3316:  double offset, seconds, nanosec;
        -: 3317:  static const long nanosec_per_sec = 1000000000;
        -: 3318:
    #####: 3319:  if (get_comp_type(&str, &result->kind))
        -: 3320:    {
        -: 3321:      /* Invert the sense of the comparison */
    #####: 3322:      switch (result->kind)
        -: 3323:	{
    #####: 3324:	case COMP_LT: result->kind = COMP_GT; break;
    #####: 3325:	case COMP_GT: result->kind = COMP_LT; break;
    #####: 3326:	default: break;
        -: 3327:	}
        -: 3328:
        -: 3329:      /* Convert the ASCII number into floating-point. */
    #####: 3330:      if (xstrtod(str, NULL, &offset, strtod))
        -: 3331:	{
        -: 3332:	  /* Separate the floating point number the user specified
        -: 3333:	   * (which is a number of days, or minutes, etc) into an
        -: 3334:	   * integral number of seconds (SECONDS) and a fraction (NANOSEC).
        -: 3335:	   */
    #####: 3336:	  nanosec = modf(offset * sec_per_unit, &seconds);
    #####: 3337:	  nanosec *= 1.0e9;	/* convert from fractional seconds to ns. */
    #####: 3338:	  assert (nanosec < nanosec_per_sec);
        -: 3339:
        -: 3340:	  /* Perform the subtraction, and then check for overflow.
        -: 3341:	   * On systems where signed aritmetic overflow does not
        -: 3342:	   * wrap, this check may be unreliable.   The C standard
        -: 3343:	   * does not require this approach to work, but I am aware
        -: 3344:	   * of no platforms where it fails.
        -: 3345:	   */
    #####: 3346:	  result->ts.tv_sec  = origin.tv_sec - seconds;
    #####: 3347:	  if ((origin.tv_sec < result->ts.tv_sec) != (seconds < 0))
        -: 3348:	    {
        -: 3349:	      /* an overflow has occurred. */
    #####: 3350:	      error (1, 0, overflowmessage, str);
        -: 3351:	    }
        -: 3352:
    #####: 3353:	  result->ts.tv_nsec = origin.tv_nsec - nanosec;
    #####: 3354:	  if (origin.tv_nsec < nanosec)
        -: 3355:	    {
        -: 3356:	      /* Perform a carry operation */
    #####: 3357:	      result->ts.tv_nsec += nanosec_per_sec;
    #####: 3358:	      result->ts.tv_sec  -= 1;
        -: 3359:	    }
    #####: 3360:	  return true;
        -: 3361:	}
        -: 3362:      else
        -: 3363:	{
        -: 3364:	  /* Conversion from ASCII to double failed. */
    #####: 3365:	  return false;
        -: 3366:	}
        -: 3367:    }
        -: 3368:  else
        -: 3369:    {
    #####: 3370:      return false;
        -: 3371:    }
        -: 3372:}
        -: 3373:
        -: 3374:/* Insert a time predicate based on the information in ENTRY.
        -: 3375:   ARGV is a pointer to the argument array.
        -: 3376:   ARG_PTR is a pointer to an index into the array, incremented if
        -: 3377:   all went well.
        -: 3378:
        -: 3379:   Return true if input is valid, false if not.
        -: 3380:
        -: 3381:   A new predicate node is assigned, along with an argument node
        -: 3382:   obtained with malloc.
        -: 3383:
        -: 3384:   Used by -atime, -ctime, and -mtime parsers. */
        -: 3385:
        -: 3386:static boolean
    #####: 3387:parse_time (const struct parser_table* entry, char *argv[], int *arg_ptr)
        -: 3388:{
        -: 3389:  struct predicate *our_pred;
        -: 3390:  struct time_val tval;
        -: 3391:  enum comparison_type comp;
        -: 3392:  const char *timearg, *orig_timearg;
    #####: 3393:  const char *errmsg = _("arithmetic overflow while converting %s "
        -: 3394:			 "days to a number of seconds");
        -: 3395:  struct timespec origin;
        -: 3396:
    #####: 3397:  if (!collect_arg(argv, arg_ptr, &timearg))
    #####: 3398:    return false;
    #####: 3399:  orig_timearg = timearg;
        -: 3400:
        -: 3401:  /* Decide the origin by previewing the comparison type. */
    #####: 3402:  origin = options.cur_day_start;
        -: 3403:
    #####: 3404:  if (get_comp_type(&timearg, &comp))
        -: 3405:    {
        -: 3406:      /* Remember, we invert the sense of the comparison, so this tests
        -: 3407:       * against COMP_LT instead of COMP_GT...
        -: 3408:       */
    #####: 3409:      if (COMP_LT == comp)
        -: 3410:	{
    #####: 3411:	  uintmax_t expected = origin.tv_sec + (DAYSECS-1);
    #####: 3412:	  origin.tv_sec += (DAYSECS-1);
    #####: 3413:	  if (origin.tv_sec != expected)
        -: 3414:	    {
    #####: 3415:	      error(1, 0,
        -: 3416:		    _("arithmetic overflow when trying to calculate the end of today"));
        -: 3417:	    }
        -: 3418:	}
        -: 3419:    }
        -: 3420:  /* We discard the value of comp here, as get_relative_timestamp
        -: 3421:   * will set tval.kind.  For that to work, we have to restore
        -: 3422:   * timearg so that it points to the +/- prefix, if any.  get_comp_type()
        -: 3423:   * will have advanced timearg, so we restore it.
        -: 3424:   */
    #####: 3425:  timearg = orig_timearg;
        -: 3426:
    #####: 3427:  if (!get_relative_timestamp(timearg, &tval, origin, DAYSECS, errmsg))
    #####: 3428:    return false;
        -: 3429:
    #####: 3430:  our_pred = insert_primary (entry, orig_timearg);
    #####: 3431:  our_pred->args.reftime = tval;
    #####: 3432:  our_pred->est_success_rate = estimate_timestamp_success_rate(tval.ts.tv_sec);
        -: 3433:
    #####: 3434:  if (options.debug_options & DebugExpressionTree)
        -: 3435:    {
        -: 3436:      time_t t;
        -: 3437:
    #####: 3438:      fprintf (stderr, "inserting %s\n", our_pred->p_name);
    #####: 3439:      fprintf (stderr, "    type: %s    %s  ",
    #####: 3440:	       (tval.kind == COMP_GT) ? "gt" :
    #####: 3441:	       ((tval.kind == COMP_LT) ? "lt" : ((tval.kind == COMP_EQ) ? "eq" : "?")),
    #####: 3442:	       (tval.kind == COMP_GT) ? " >" :
    #####: 3443:	       ((tval.kind == COMP_LT) ? " <" : ((tval.kind == COMP_EQ) ? ">=" : " ?")));
    #####: 3444:      t = our_pred->args.reftime.ts.tv_sec;
    #####: 3445:      fprintf (stderr, "%ju %s",
    #####: 3446:	       (uintmax_t) our_pred->args.reftime.ts.tv_sec,
        -: 3447:	       ctime (&t));
    #####: 3448:      if (tval.kind == COMP_EQ)
        -: 3449:	{
    #####: 3450:	  t = our_pred->args.reftime.ts.tv_sec + DAYSECS;
    #####: 3451:	  fprintf (stderr, "                 <  %ju %s",
        -: 3452:		   (uintmax_t) t, ctime (&t));
        -: 3453:	}
        -: 3454:    }
        -: 3455:
    #####: 3456:  return true;
        -: 3457:}
        -: 3458:
        -: 3459:/* Get the comparison type prefix (if any) from a number argument.
        -: 3460:   The prefix is at *STR.
        -: 3461:   Set *COMP_TYPE to the kind of comparison that is requested.
        -: 3462:   Advance *STR beyond any initial comparison prefix.
        -: 3463:
        -: 3464:   Return true if all okay, false if input error.  */
        -: 3465:static boolean
    #####: 3466:get_comp_type(const char **str, enum comparison_type *comp_type)
        -: 3467:{
    #####: 3468:  switch (**str)
        -: 3469:    {
        -: 3470:    case '+':
    #####: 3471:      *comp_type = COMP_GT;
    #####: 3472:      (*str)++;
    #####: 3473:      break;
        -: 3474:    case '-':
    #####: 3475:      *comp_type = COMP_LT;
    #####: 3476:      (*str)++;
    #####: 3477:      break;
        -: 3478:    default:
    #####: 3479:      *comp_type = COMP_EQ;
    #####: 3480:      break;
        -: 3481:    }
    #####: 3482:  return true;
        -: 3483:}
        -: 3484:
        -: 3485:
        -: 3486:
        -: 3487:
        -: 3488:
        -: 3489:/* Get a number with comparison information.
        -: 3490:   The sense of the comparison information is 'normal'; that is,
        -: 3491:   '+' looks for a count > than the number and '-' less than.
        -: 3492:
        -: 3493:   STR is the ASCII representation of the number.
        -: 3494:   Set *NUM to the number.
        -: 3495:   Set *COMP_TYPE to the kind of comparison that is requested.
        -: 3496:
        -: 3497:   Return true if all okay, false if input error.  */
        -: 3498:
        -: 3499:static boolean
    #####: 3500:get_num (const char *str,
        -: 3501:	 uintmax_t *num,
        -: 3502:	 enum comparison_type *comp_type)
        -: 3503:{
        -: 3504:  char *pend;
        -: 3505:
    #####: 3506:  if (str == NULL)
    #####: 3507:    return false;
        -: 3508:
        -: 3509:  /* Figure out the comparison type if the caller accepts one. */
    #####: 3510:  if (comp_type)
        -: 3511:    {
    #####: 3512:      if (!get_comp_type(&str, comp_type))
    #####: 3513:	return false;
        -: 3514:    }
        -: 3515:
    #####: 3516:  return xstrtoumax (str, &pend, 10, num, "") == LONGINT_OK;
        -: 3517:}
        -: 3518:
        -: 3519:/* Insert a number predicate.
        -: 3520:   ARGV is a pointer to the argument array.
        -: 3521:   *ARG_PTR is an index into ARGV, incremented if all went well.
        -: 3522:   *PRED is the predicate processor to insert.
        -: 3523:
        -: 3524:   Return true if input is valid, false if error.
        -: 3525:
        -: 3526:   A new predicate node is assigned, along with an argument node
        -: 3527:   obtained with malloc.
        -: 3528:
        -: 3529:   Used by -inum and -links parsers. */
        -: 3530:
        -: 3531:static struct predicate *
    #####: 3532:insert_num (char **argv, int *arg_ptr, const struct parser_table *entry)
        -: 3533:{
        -: 3534:  const char *numstr;
        -: 3535:
    #####: 3536:  if (collect_arg(argv, arg_ptr, &numstr))
        -: 3537:  {
        -: 3538:    uintmax_t num;
        -: 3539:    enum comparison_type c_type;
        -: 3540:
    #####: 3541:    if (get_num (numstr, &num, &c_type))
        -: 3542:      {
    #####: 3543:	struct predicate *our_pred = insert_primary (entry, numstr);
    #####: 3544:	our_pred->args.numinfo.kind = c_type;
    #####: 3545:	our_pred->args.numinfo.l_val = num;
        -: 3546:
    #####: 3547:	if (options.debug_options & DebugExpressionTree)
        -: 3548:	  {
    #####: 3549:	    fprintf (stderr, "inserting %s\n", our_pred->p_name);
    #####: 3550:	    fprintf (stderr, "    type: %s    %s  ",
    #####: 3551:		     (c_type == COMP_GT) ? "gt" :
    #####: 3552:		     ((c_type == COMP_LT) ? "lt" : ((c_type == COMP_EQ) ? "eq" : "?")),
    #####: 3553:		     (c_type == COMP_GT) ? " >" :
    #####: 3554:		     ((c_type == COMP_LT) ? " <" : ((c_type == COMP_EQ) ? " =" : " ?")));
    #####: 3555:	    fprintf (stderr, "%ju\n", our_pred->args.numinfo.l_val);
        -: 3556:	  }
    #####: 3557:	return our_pred;
        -: 3558:      }
        -: 3559:  }
    #####: 3560:  return NULL;
        -: 3561:}
        -: 3562:
        -: 3563:static void
       16: 3564:open_output_file (const char *path, struct format_val *p)
        -: 3565:{
       16: 3566:  p->segment = NULL;
       16: 3567:  p->quote_opts = clone_quoting_options (NULL);
        -: 3568:
       16: 3569:  if (!strcmp (path, "/dev/stderr"))
        -: 3570:    {
    #####: 3571:      p->stream = stderr;
    #####: 3572:      p->filename = _("standard error");
        -: 3573:    }
       16: 3574:  else if (!strcmp (path, "/dev/stdout"))
        -: 3575:    {
       16: 3576:      p->stream = stdout;
       16: 3577:      p->filename = _("standard output");
        -: 3578:    }
        -: 3579:  else
        -: 3580:    {
    #####: 3581:      p->stream = sharefile_fopen (state.shared_files, path);
    #####: 3582:      p->filename = path;
        -: 3583:
    #####: 3584:      if (p->stream == NULL)
        -: 3585:	{
    #####: 3586:	  fatal_file_error (path);
        -: 3587:	}
        -: 3588:    }
        -: 3589:
       16: 3590:  p->dest_is_tty = stream_is_tty (p->stream);
       16: 3591:}
        -: 3592:
        -: 3593:static void
       16: 3594:open_stdout (struct format_val *p)
        -: 3595:{
       16: 3596:  open_output_file("/dev/stdout", p);
       16: 3597:}
