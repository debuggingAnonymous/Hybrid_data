process_path 

{

  struct stat stat_buf;

  static dev_t root_dev;

  int i;





  stat_buf.st_mode = 0;

  state.rel_pathname = name;

  state.type = 0;

  state.have_stat = 0;

  state.have_type = 0;



  if (!digest_mode(mode, pathname, name, &stat_buf, leaf))

    return 0;



  if (!((((state.type)) & 0170000) == (0040000)))

    {

      if (state.curdepth >= options.mindepth)

 (*(eval_tree)->pred_func)((pathname), (&stat_buf), (eval_tree));

      return 0;

    }















  if (get_statinfo(pathname, name, &stat_buf) != 0)

    return 0;



  state.have_stat = 1;

  mode = state.type = stat_buf.st_mode;

  state.stop_at_current_level =

    options.maxdepth >= 0

    && state.curdepth >= options.maxdepth;







  for (i = 0; i <= dir_curr; i++)

    if (stat_buf.st_ino == dir_ids[i].ino &&

 stat_buf.st_dev == dir_ids[i].dev)

      {

 state.stop_at_current_level = 1;

 issue_loop_warning(name, pathname, i);

      }



  if (dir_alloc <= ++dir_curr)

    {

      dir_alloc += 32;

      dir_ids = (struct dir_id *)

 xrealloc ((char *) dir_ids, dir_alloc * sizeof (struct dir_id));

    }

  dir_ids[dir_curr].ino = stat_buf.st_ino;

  dir_ids[dir_curr].dev = stat_buf.st_dev;



  if (options.stay_on_filesystem)

    {

      if (state.curdepth == 0)

 root_dev = stat_buf.st_dev;

      else if (stat_buf.st_dev != root_dev)

 state.stop_at_current_level = 1;

    }



  if (options.do_dir_first && state.curdepth >= options.mindepth)

    (*(eval_tree)->pred_func)((pathname), (&stat_buf), (eval_tree));













  if (state.stop_at_current_level == 0)



    process_dir (pathname, name, strlen (pathname), &stat_buf, parent);



  if (options.do_dir_first == 0 && state.curdepth >= options.mindepth)

    {





      if (!digest_mode(mode, pathname, name, &stat_buf, leaf))

 return 0;



      state.rel_pathname = name;

      (*(eval_tree)->pred_func)((pathname), (&stat_buf), (eval_tree));

    }



  dir_curr--;



  return 1;

}

