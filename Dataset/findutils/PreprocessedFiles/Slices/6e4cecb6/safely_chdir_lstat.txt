safely_chdir_lstat 

{

  struct stat statbuf_arrived;

  int rv, dotfd=-1;

  int saved_errno;

  boolean rv_set = 0;

  int tries = 0;

  enum WdSanityCheckFatality isfatal = RETRY_IF_SANITY_CHECK_FAILS;



  saved_errno = (*__errno_location ()) = 0;



  dotfd = open(".", 00);









 retry:

  ++tries;



  if (dotfd >= 0)

    {



      if (0 == options.xstat(dest, statbuf_dest))

 {

# 1004 "find.c"

   if (!following_links() && ((((statbuf_dest->st_mode)) & 0170000) == (0120000)))

     {









       if (symlink_handling == SymlinkFollowOk)

  {







    if (0 != stat(dest, statbuf_dest))

      {

        rv = SafeChdirFailNonexistent;

        rv_set = 1;

        saved_errno = (*__errno_location ());

        goto fail;

      }

  }

       else

  {







    rv = SafeChdirFailSymlink;

    rv_set = 1;

    saved_errno = 0;

    goto fail;

  }

     }

# 1042 "find.c"

   if (!((((statbuf_dest->st_mode)) & 0170000) == (0040000)))

     {

       rv = SafeChdirFailNotDir;

       rv_set = 1;

       saved_errno = 0;

       goto fail;

     }









   if (0 == chdir(dest))

     {



       boolean changed = 0;

       if (!wd_sanity_check(".", program_name, ".",

       statbuf_dest->st_dev,

       statbuf_dest->st_ino,

       &statbuf_arrived,

       0, 1061, direction,

       isfatal,

       &changed))

  {



    if ((RETRY_IF_SANITY_CHECK_FAILS == isfatal)

        && (0 == fchdir(dotfd)))

      {

        isfatal = FATAL_IF_SANITY_CHECK_FAILS;

        goto retry;

      }

    else

      {



        rv = SafeChdirFailNonexistent;

        rv_set = 1;

        saved_errno = 0;

        goto fail;

      }

  }



       close(dotfd);

       return SafeChdirOK;

     }

   else

     {

       saved_errno = (*__errno_location ());

       if (2 == saved_errno)

  {

    rv = SafeChdirFailNonexistent;

    rv_set = 1;

    if (options.ignore_readdir_race)

      (*__errno_location ()) = 0;

  }

       else if (20 == saved_errno)

  {









    saved_errno = 0;

    rv = SafeChdirFailNotDir;

    rv_set = 1;

  }

       else

  {

    rv = SafeChdirFailChdirFailed;

    rv_set = 1;

  }

       goto fail;

     }

 }

      else

 {

   saved_errno = (*__errno_location ());

   rv = SafeChdirFailStat;

   rv_set = 1;



   if ( (2 == saved_errno) || (0 == state.curdepth))

     saved_errno = 0;

   goto fail;

 }

    }

  else

    {



      rv = SafeChdirFailWouldBeUnableToReturn;

      rv_set = 1;

      goto fail;

    }









  saved_errno = 0;









 fail:







  if (saved_errno)

    (*__errno_location ()) = saved_errno;



  if (dotfd >= 0)

    {

      close(dotfd);

      dotfd = -1;

    }

  ((rv_set) ? (void) (0) : __assert_fail ("rv_set", "find.c", 1152, __PRETTY_FUNCTION__));

  return rv;

}

