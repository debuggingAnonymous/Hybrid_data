main 

{

  int i;

  PFB parse_function;

  struct predicate *cur_pred;

  char *predicate_name;

  int end_of_leading_options = 0;

  program_name = argv[0];

# 401 "find.c"

  options.open_nofollow_available = check_nofollow();













  setlocale (6, "");



  bindtextdomain ("findutils", "/usr/local/share/locale");

  textdomain ("findutils");

  atexit (close_stdout);





  if (isatty(0))

    {

      options.warnings = 1;

    }

  else

    {

      options.warnings = 0;

    }





  predicates = ((void *)0);

  last_pred = ((void *)0);

  options.do_dir_first = 1;

  options.maxdepth = options.mindepth = -1;

  options.start_time = time (((void *)0));

  options.cur_day_start = options.start_time - 86400;

  options.full_days = 0;

  options.stay_on_filesystem = 0;

  options.ignore_readdir_race = 0;



  state.exit_status = 0;











  if (getenv("POSIXLY_CORRECT"))

    options.output_block_size = 512;

  else

    options.output_block_size = 1024;



  if (getenv("FIND_BLOCK_SIZE"))

    {

      error (1, 0, gettext ("The environment variable FIND_BLOCK_SIZE is not supported, the only thing that affects the block size is the POSIXLY_CORRECT environment variable"));

    }



  options.no_leaf_check = 0;

  set_follow_state(SYMLINK_NEVER_DEREF);













  for (i=1; (end_of_leading_options = i) < argc; ++i)

    {

      if (0 == strcmp("-H", argv[i]))

 {



   set_follow_state(SYMLINK_DEREF_ARGSONLY);

 }

      else if (0 == strcmp("-L", argv[i]))

 {



   set_follow_state(SYMLINK_ALWAYS_DEREF);

 }

      else if (0 == strcmp("-P", argv[i]))

 {



   set_follow_state(SYMLINK_NEVER_DEREF);

 }

      else if (0 == strcmp("--", argv[i]))

 {



   end_of_leading_options = i+1;

   break;

 }

      else

 {









   end_of_leading_options = i;

   break;

 }

    }

# 500 "find.c"

  for (i = end_of_leading_options; i < argc && strchr ("-!(),", argv[i][0]) == ((void *)0); i++)

    {



                        ;

    }







  parse_open (argv, &argc);



  while (i < argc)

    {

      if (strchr ("-!(),", argv[i][0]) == ((void *)0))

 usage (gettext ("paths must precede expression"));

      predicate_name = argv[i];

      parse_function = find_parser (predicate_name);

      if (parse_function == ((void *)0))



 error (1, 0, gettext ("invalid predicate `%s'"), predicate_name);

      i++;

      if (!(*parse_function) (argv, &i))

 {

   if (argv[i] == ((void *)0))



     error (1, 0, gettext ("missing argument to `%s'"), predicate_name);

   else

     error (1, 0, gettext ("invalid argument `%s' to `%s'"),

     argv[i], predicate_name);

 }

    }

  if (predicates->pred_next == ((void *)0))

    {





      cur_pred = predicates;

      predicates = last_pred = predicates->pred_next;

      free ((char *) cur_pred);

      parse_print (argv, &argc);

    }

  else if (!default_prints (predicates->pred_next))

    {





      cur_pred = predicates;

      predicates = predicates->pred_next;

      free ((char *) cur_pred);

    }

  else

    {



      parse_close (argv, &argc);

      parse_print (argv, &argc);

    }















  cur_pred = predicates;

  eval_tree = get_expr (&cur_pred, NO_PREC);









  if (cur_pred != ((void *)0))

    {

      error (1, 0, gettext ("unexpected extra predicate"));

    }















  opt_expr (&eval_tree);





  mark_stat (eval_tree);



  mark_type (eval_tree);

# 602 "find.c"

  if (!options.open_nofollow_available)

    {







    }





  starting_desc = open (".", 00);

  if (0 <= starting_desc && fchdir (starting_desc) != 0)

    {

      close (starting_desc);

      starting_desc = -1;

    }

  if (starting_desc < 0)

    {

      starting_dir = xgetcwd ();

      if (! starting_dir)

 error (1, (*__errno_location ()), gettext ("cannot get current directory"));

    }

  if ((*options.xstat) (".", &starting_stat_buf) != 0)

    error (1, (*__errno_location ()), gettext ("cannot get current directory"));





  for (i = end_of_leading_options; i < argc && strchr ("-!(),", argv[i][0]) == ((void *)0); i++)

    {

      process_top_path (argv[i], 0);

    }





  if (i == end_of_leading_options)

    {













      char defaultpath[2] = ".";

      process_top_path (defaultpath, 0);

    }











  cleanup();

  return state.exit_status;

}

