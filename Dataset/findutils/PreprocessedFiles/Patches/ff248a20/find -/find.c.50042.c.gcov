        -:    0:Source:find.c
        -:    0:Graph:find.gcno
        -:    0:Data:find.gcda
        -:    0:Runs:8
        -:    0:Programs:1
        -:    1:/* find -- search for files in a directory hierarchy
        -:    2:   Copyright (C) 1990, 91, 92, 93, 94, 2000, 2003, 2004 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software; you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation; either version 2, or (at your option)
        -:    7:   any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program; if not, write to the Free Software
        -:   16:   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
        -:   17:   USA.*/
        -:   18:
        -:   19:/* GNU find was written by Eric Decker <cire@cisco.com>,
        -:   20:   with enhancements by David MacKenzie <djm@gnu.org>,
        -:   21:   Jay Plett <jay@silence.princeton.nj.us>,
        -:   22:   and Tim Wood <axolotl!tim@toad.com>.
        -:   23:   The idea for -print0 and xargs -0 came from
        -:   24:   Dan Bernstein <brnstnd@kramden.acf.nyu.edu>.  */
        -:   25:
        -:   26:
        -:   27:#include "defs.h"
        -:   28:
        -:   29:#define USE_SAFE_CHDIR 1
        -:   30:#undef  STAT_MOUNTPOINTS
        -:   31:
        -:   32:
        -:   33:#include <errno.h>
        -:   34:#include <assert.h>
        -:   35:
        -:   36:
        -:   37:#ifdef HAVE_FCNTL_H
        -:   38:#include <fcntl.h>
        -:   39:#else
        -:   40:#include <sys/file.h>
        -:   41:#endif
        -:   42:
        -:   43:#ifdef HAVE_SYS_UTSNAME_H
        -:   44:#include <sys/utsname.h>
        -:   45:#endif
        -:   46:
        -:   47:#include "../gnulib/lib/xalloc.h"
        -:   48:#include "../gnulib/lib/human.h"
        -:   49:#include "../gnulib/lib/canonicalize.h"
        -:   50:#include "closeout.h"
        -:   51:#include <modetype.h>
        -:   52:#include "savedirinfo.h"
        -:   53:#include "buildcmd.h"
        -:   54:#include "dirname.h"
        -:   55:
        -:   56:#ifdef HAVE_LOCALE_H
        -:   57:#include <locale.h>
        -:   58:#endif
        -:   59:
        -:   60:#if ENABLE_NLS
        -:   61:# include <libintl.h>
        -:   62:# define _(Text) gettext (Text)
        -:   63:#else
        -:   64:# define _(Text) Text
        -:   65:#define textdomain(Domain)
        -:   66:#define bindtextdomain(Package, Directory)
        -:   67:#endif
        -:   68:#ifdef gettext_noop
        -:   69:# define N_(String) gettext_noop (String)
        -:   70:#else
        -:   71:/* See locate.c for explanation as to why not use (String) */
        -:   72:# define N_(String) String
        -:   73:#endif
        -:   74:
        -:   75:#define apply_predicate(pathname, stat_buf_ptr, node)	\
        -:   76:  (*(node)->pred_func)((pathname), (stat_buf_ptr), (node))
        -:   77:
        -:   78:#ifdef STAT_MOUNTPOINTS
        -:   79:static void init_mounted_dev_list(void);
        -:   80:#endif
        -:   81:
        -:   82:static void process_top_path PARAMS((char *pathname, mode_t mode));
        -:   83:static int process_path PARAMS((char *pathname, char *name, boolean leaf, char *parent, mode_t type));
        -:   84:static void process_dir PARAMS((char *pathname, char *name, int pathlen, struct stat *statp, char *parent));
        -:   85:
        -:   86:static void complete_pending_execdirs(struct predicate *p);
        -:   87:static void complete_pending_execs   (struct predicate *p);
        -:   88:
        -:   89:
        -:   90:
        -:   91:static boolean default_prints PARAMS((struct predicate *pred));
        -:   92:
        -:   93:/* Name this program was run with. */
        -:   94:char *program_name;
        -:   95:
        -:   96:/* All predicates for each path to process. */
        -:   97:struct predicate *predicates;
        -:   98:
        -:   99:/* The last predicate allocated. */
        -:  100:struct predicate *last_pred;
        -:  101:
        -:  102:/* The root of the evaluation tree. */
        -:  103:static struct predicate *eval_tree = NULL;
        -:  104:
        -:  105:
        -:  106:struct options options;
        -:  107:struct state state;
        -:  108:
        -:  109:/* The full path of the initial working directory, or "." if
        -:  110:   STARTING_DESC is nonnegative.  */
        -:  111:char const *starting_dir = ".";
        -:  112:
        -:  113:/* A file descriptor open to the initial working directory.
        -:  114:   Doing it this way allows us to work when the i.w.d. has
        -:  115:   unreadable parents.  */
        -:  116:int starting_desc;
        -:  117:
        -:  118:/* The stat buffer of the initial working directory. */
        -:  119:struct stat starting_stat_buf;
        -:  120:
        -:  121:enum ChdirSymlinkHandling
        -:  122:  {
        -:  123:    SymlinkHandleDefault,	/* Normally the right choice */
        -:  124:    SymlinkFollowOk		/* see comment in process_top_path() */
        -:  125:  };
        -:  126:
        -:  127:
        -:  128:enum TraversalDirection
        -:  129:  {
        -:  130:    TraversingUp,
        -:  131:    TraversingDown
        -:  132:  };
        -:  133:
        -:  134:enum WdSanityCheckFatality
        -:  135:  {
        -:  136:    FATAL_IF_SANITY_CHECK_FAILS,
        -:  137:    RETRY_IF_SANITY_CHECK_FAILS,
        -:  138:    NON_FATAL_IF_SANITY_CHECK_FAILS
        -:  139:  };
        -:  140:
        -:  141:
        -:  142:int
       43:  143:following_links(void)
        -:  144:{
       43:  145:  switch (options.symlink_handling)
        -:  146:    {
        -:  147:    case SYMLINK_ALWAYS_DEREF:
        7:  148:      return 1;
        -:  149:    case SYMLINK_DEREF_ARGSONLY:
        3:  150:      return (state.curdepth == 0);
        -:  151:    case SYMLINK_NEVER_DEREF:
        -:  152:    default:
       33:  153:      return 0;
        -:  154:    }
        -:  155:}
        -:  156:
        -:  157:
        -:  158:static int
        4:  159:fallback_stat(const char *name, struct stat *p, int prev_rv)
        -:  160:{
        -:  161:  /* Our original stat() call failed.  Perhaps we can't follow a
        -:  162:   * symbolic link.  If that might be the problem, lstat() the link. 
        -:  163:   * Otherwise, admit defeat. 
        -:  164:   */
        4:  165:  switch (errno)
        -:  166:    {
        -:  167:    case ENOENT:
        -:  168:    case ENOTDIR:
        -:  169:#ifdef DEBUG_STAT
        -:  170:      fprintf(stderr, "fallback_stat(): stat(%s) failed; falling back on lstat()\n", name);
        -:  171:#endif
    #####:  172:      return lstat(name, p);
        -:  173:
        -:  174:    case EACCES:
        -:  175:    case EIO:
        -:  176:    case ELOOP:
        -:  177:    case ENAMETOOLONG:
        -:  178:#ifdef EOVERFLOW
        -:  179:    case EOVERFLOW:	    /* EOVERFLOW is not #defined on UNICOS. */
        -:  180:#endif
        -:  181:    default:
        4:  182:      return prev_rv;	       
        -:  183:    }
        -:  184:}
        -:  185:
        -:  186:
        -:  187:/* optionh_stat() implements the stat operation when the -H option is
        -:  188: * in effect.
        -:  189: * 
        -:  190: * If the item to be examined is a command-line argument, we follow
        -:  191: * symbolic links.  If the stat() call fails on the command-line item,
        -:  192: * we fall back on the properties of the symbolic link.
        -:  193: *
        -:  194: * If the item to be examined is not a command-line argument, we
        -:  195: * examine the link itself.
        -:  196: */
        -:  197:int 
        2:  198:optionh_stat(const char *name, struct stat *p)
        -:  199:{
        2:  200:  if (0 == state.curdepth) 
        -:  201:    {
        -:  202:      /* This file is from the command line; deference the link (if it
        -:  203:       * is a link).  
        -:  204:       */
        2:  205:      int rv = stat(name, p);
        2:  206:      if (0 == rv)
        2:  207:	return 0;		/* success */
        -:  208:      else
    #####:  209:	return fallback_stat(name, p, rv);
        -:  210:    }
        -:  211:  else
        -:  212:    {
        -:  213:      /* Not a file on the command line; do not derefernce the link.
        -:  214:       */
    #####:  215:      return lstat(name, p);
        -:  216:    }
        -:  217:}
        -:  218:
        -:  219:/* optionl_stat() implements the stat operation when the -L option is
        -:  220: * in effect.  That option makes us examine the thing the symbolic
        -:  221: * link points to, not the symbolic link itself.
        -:  222: */
        -:  223:int 
        8:  224:optionl_stat(const char *name, struct stat *p)
        -:  225:{
        8:  226:  int rv = stat(name, p);
        8:  227:  if (0 == rv)
        4:  228:    return 0;			/* normal case. */
        -:  229:  else
        4:  230:    return fallback_stat(name, p, rv);
        -:  231:}
        -:  232:
        -:  233:/* optionp_stat() implements the stat operation when the -P option is
        -:  234: * in effect (this is also the default).  That option makes us examine
        -:  235: * the symbolic link itself, not the thing it points to.
        -:  236: */
        -:  237:int 
      315:  238:optionp_stat(const char *name, struct stat *p)
        -:  239:{
      315:  240:  return lstat(name, p);
        -:  241:}
        -:  242:
        -:  243:#ifdef DEBUG_STAT
        -:  244:static uintmax_t stat_count = 0u;
        -:  245:
        -:  246:static int
        -:  247:debug_stat (const char *file, struct stat *bufp)
        -:  248:{
        -:  249:  ++stat_count;
        -:  250:  fprintf (stderr, "debug_stat (%s)\n", file);
        -:  251:  switch (options.symlink_handling)
        -:  252:    {
        -:  253:    case SYMLINK_ALWAYS_DEREF:
        -:  254:      return optionl_stat(file, bufp);
        -:  255:    case SYMLINK_DEREF_ARGSONLY:
        -:  256:      return optionh_stat(file, bufp);
        -:  257:    case SYMLINK_NEVER_DEREF:
        -:  258:      return optionp_stat(file, bufp);
        -:  259:    }
        -:  260:}
        -:  261:#endif /* DEBUG_STAT */
        -:  262:
        -:  263:void 
       11:  264:set_follow_state(enum SymlinkOption opt)
        -:  265:{
       11:  266:  switch (opt)
        -:  267:    {
        -:  268:    case SYMLINK_ALWAYS_DEREF:  /* -L */
        2:  269:      options.xstat = optionl_stat;
        2:  270:      options.no_leaf_check = true;
        2:  271:      break;
        -:  272:      
        -:  273:    case SYMLINK_NEVER_DEREF:	/* -P (default) */
        8:  274:      options.xstat = optionp_stat;
        -:  275:      /* Can't turn no_leaf_check off because the user might have specified 
        -:  276:       * -noleaf anyway
        -:  277:       */
        8:  278:      break;
        -:  279:      
        -:  280:    case SYMLINK_DEREF_ARGSONLY: /* -H */
        1:  281:      options.xstat = optionh_stat;
        1:  282:      options.no_leaf_check = true;
        -:  283:    }
        -:  284:
       11:  285:  options.symlink_handling = opt;
        -:  286:  
        -:  287:  /* For DBEUG_STAT, the choice is made at runtime within debug_stat()
        -:  288:   * by checking the contents of the symlink_handling variable.
        -:  289:   */
        -:  290:#if defined(DEBUG_STAT)
        -:  291:  options.xstat = debug_stat;
        -:  292:#endif /* !DEBUG_STAT */
       11:  293:}
        -:  294:
        -:  295:
        -:  296:/* Complete any outstanding commands.
        -:  297: */
        -:  298:void 
        7:  299:cleanup(void)
        -:  300:{
        7:  301:  if (eval_tree)
        -:  302:    {
        7:  303:      complete_pending_execs(eval_tree);
        7:  304:      complete_pending_execdirs(eval_tree);
        -:  305:    }
        7:  306:}
        -:  307:
        -:  308:/* Get the stat information for a file, if it is 
        -:  309: * not already known. 
        -:  310: */
        -:  311:int
      329:  312:get_statinfo (const char *pathname, const char *name, struct stat *p)
        -:  313:{
      329:  314:  if (!state.have_stat && (*options.xstat) (name, p) != 0)
        -:  315:    {
        4:  316:      if (!options.ignore_readdir_race || (errno != ENOENT) )
        -:  317:	{
        4:  318:	  error (0, errno, "%s", pathname);
        4:  319:	  state.exit_status = 1;
        -:  320:	}
        4:  321:      return -1;
        -:  322:    }
      325:  323:  state.have_stat = true;
      325:  324:  state.have_type = true;
      325:  325:  state.type = p->st_mode;
      325:  326:  return 0;
        -:  327:}
        -:  328:
        -:  329:/* Get the stat/type information for a file, if it is 
        -:  330: * not already known. 
        -:  331: */
        -:  332:int
      620:  333:get_info (const char *pathname,
        -:  334:	  const char *name,
        -:  335:	  struct stat *p,
        -:  336:	  struct predicate *pred_ptr)
        -:  337:{
        -:  338:  /* If we need the full stat info, or we need the type info but don't 
        -:  339:   * already have it, stat the file now.
        -:  340:   */
        -:  341:  (void) name;
      620:  342:  if (pred_ptr->need_stat)
        -:  343:    {
      303:  344:      return get_statinfo(pathname, state.rel_pathname, p);
        -:  345:    }
      317:  346:  if ((pred_ptr->need_type && (0 == state.have_type)))
        -:  347:    {
    #####:  348:      return get_statinfo(pathname, state.rel_pathname, p);
        -:  349:    }
      317:  350:  return 0;
        -:  351:}
        -:  352:
        -:  353:/* Determine if we can use O_NOFOLLOW.
        -:  354: */
        -:  355:#if defined(O_NOFOLLOW)
        -:  356:static boolean 
        8:  357:check_nofollow(void)
        -:  358:{
        -:  359:  struct utsname uts;
        -:  360:  float  release;
        -:  361:
        8:  362:  if (0 == uname(&uts))
        -:  363:    {
        -:  364:      /* POSIX requires that atof() ignore "unrecognised suffixes". */
        8:  365:      release = atof(uts.release);
        -:  366:      
        8:  367:      if (0 == strcmp("Linux", uts.sysname))
        -:  368:	{
        -:  369:	  /* Linux kernels 2.1.126 and earlier ignore the O_NOFOLLOW flag. */
        8:  370:	  return release >= 2.2; /* close enough */
        -:  371:	}
    #####:  372:      else if (0 == strcmp("FreeBSD", uts.sysname)) 
        -:  373:	{
        -:  374:	  /* FreeBSD 3.0-CURRENT and later support it */
    #####:  375:	  return release >= 3.1;
        -:  376:	}
        -:  377:    }
        -:  378:
        -:  379:  /* Well, O_NOFOLLOW was defined, so we'll try to use it. */
    #####:  380:  return true;
        -:  381:}
        -:  382:#endif
        -:  383:
        -:  384:int
        8:  385:main (int argc, char **argv)
        -:  386:{
        -:  387:  int i;
        -:  388:  PARSE_FUNC parse_function; /* Pointer to the function which parses. */
        -:  389:  struct predicate *cur_pred;
        -:  390:  char *predicate_name;		/* Name of predicate being parsed. */
        8:  391:  int end_of_leading_options = 0; /* First arg after any -H/-L etc. */
        8:  392:  program_name = argv[0];
        -:  393:
        -:  394:  /* We call check_nofollow() before setlocale() because the numbers 
        -:  395:   * for which we check (in the results of uname) definitiely have "."
        -:  396:   * as the decimal point indicator even under locales for which that 
        -:  397:   * is not normally true.   Hence atof() would do the wrong thing 
        -:  398:   * if we call it after setlocale().
        -:  399:   */
        -:  400:#ifdef O_NOFOLLOW
        8:  401:  options.open_nofollow_available = check_nofollow();
        -:  402:#else
        -:  403:  options.open_nofollow_available = false;
        -:  404:#endif
        -:  405:
        -:  406:  
        -:  407:#ifdef HAVE_SETLOCALE
        8:  408:  setlocale (LC_ALL, "");
        -:  409:#endif
        8:  410:  bindtextdomain (PACKAGE, LOCALEDIR);
        8:  411:  textdomain (PACKAGE);
        8:  412:  atexit (close_stdout);
        -:  413:
        -:  414:  
        8:  415:  if (isatty(0))
        -:  416:    {
        8:  417:      options.warnings = true;
        -:  418:    }
        -:  419:  else
        -:  420:    {
    #####:  421:      options.warnings = false;
        -:  422:    }
        -:  423:  
        -:  424:  
        8:  425:  predicates = NULL;
        8:  426:  last_pred = NULL;
        8:  427:  options.do_dir_first = true;
        8:  428:  options.maxdepth = options.mindepth = -1;
        8:  429:  options.start_time = time (NULL);
        8:  430:  options.cur_day_start = options.start_time - DAYSECS;
        8:  431:  options.full_days = false;
        8:  432:  options.stay_on_filesystem = false;
        8:  433:  options.ignore_readdir_race = false;
        -:  434:
        8:  435:  state.exit_status = 0;
        -:  436:
        -:  437:#if defined(DEBUG_STAT)
        -:  438:  options.xstat = debug_stat;
        -:  439:#endif /* !DEBUG_STAT */
        -:  440:
        8:  441:  if (getenv("POSIXLY_CORRECT"))
    #####:  442:    options.output_block_size = 512;
        -:  443:  else
        8:  444:    options.output_block_size = 1024;
        -:  445:
        8:  446:  if (getenv("FIND_BLOCK_SIZE"))
        -:  447:    {
    #####:  448:      error (1, 0, _("The environment variable FIND_BLOCK_SIZE is not supported, the only thing that affects the block size is the POSIXLY_CORRECT environment variable"));
        -:  449:    }
        -:  450:
        8:  451:  options.no_leaf_check = false;
        8:  452:  set_follow_state(SYMLINK_NEVER_DEREF); /* The default is equivalent to -P. */
        -:  453:
        -:  454:#ifdef DEBUG
        -:  455:  fprintf (stderr, "cur_day_start = %s", ctime (&options.cur_day_start));
        -:  456:#endif /* DEBUG */
        -:  457:
        -:  458:  /* Check for -P, -H or -L options. */
       11:  459:  for (i=1; (end_of_leading_options = i) < argc; ++i)
        -:  460:    {
       11:  461:      if (0 == strcmp("-H", argv[i]))
        -:  462:	{
        -:  463:	  /* Meaning: dereference symbolic links on command line, but nowhere else. */
        1:  464:	  set_follow_state(SYMLINK_DEREF_ARGSONLY);
        -:  465:	}
       10:  466:      else if (0 == strcmp("-L", argv[i]))
        -:  467:	{
        -:  468:	  /* Meaning: dereference all symbolic links. */
        2:  469:	  set_follow_state(SYMLINK_ALWAYS_DEREF);
        -:  470:	}
        8:  471:      else if (0 == strcmp("-P", argv[i]))
        -:  472:	{
        -:  473:	  /* Meaning: never dereference symbolic links (default). */
    #####:  474:	  set_follow_state(SYMLINK_NEVER_DEREF);
        -:  475:	}
        8:  476:      else if (0 == strcmp("--", argv[i]))
        -:  477:	{
        -:  478:	  /* -- signifies the end of options. */
    #####:  479:	  end_of_leading_options = i+1;	/* Next time start with the next option */
    #####:  480:	  break;
        -:  481:	}
        -:  482:      else
        -:  483:	{
        -:  484:	  /* Hmm, must be one of 
        -:  485:	   * (a) A path name
        -:  486:	   * (b) A predicate
        -:  487:	   */
        8:  488:	  end_of_leading_options = i; /* Next time start with this option */
        8:  489:	  break;
        -:  490:	}
        -:  491:    }
        -:  492:
        -:  493:  /* We are now processing the part of the "find" command line 
        -:  494:   * after the -H/-L options (if any).
        -:  495:   */
        -:  496:
        -:  497:  /* fprintf(stderr, "rest: optind=%ld\n", (long)optind); */
        -:  498:  
        -:  499:  /* Find where in ARGV the predicates begin. */
        8:  500:  for (i = end_of_leading_options; i < argc && strchr ("-!(),", argv[i][0]) == NULL; i++)
        -:  501:    {
        -:  502:      /* fprintf(stderr, "Looks like %s is not a predicate\n", argv[i]); */
        -:  503:      /* Do nothing. */ ;
        -:  504:    }
        -:  505:  
        -:  506:  /* Enclose the expression in `( ... )' so a default -print will
        -:  507:     apply to the whole expression. */
        8:  508:  parse_open (argv, &argc);
        -:  509:  /* Build the input order list. */
       28:  510:  while (i < argc)
        -:  511:    {
       13:  512:      if (strchr ("-!(),", argv[i][0]) == NULL)
    #####:  513:	usage (_("paths must precede expression"));
       13:  514:      predicate_name = argv[i];
       13:  515:      parse_function = find_parser (predicate_name);
       13:  516:      if (parse_function == NULL)
        -:  517:	/* Command line option not recognized */
        1:  518:	error (1, 0, _("invalid predicate `%s'"), predicate_name);
       12:  519:      i++;
       12:  520:      if (!(*parse_function) (argv, &i))
        -:  521:	{
    #####:  522:	  if (argv[i] == NULL)
        -:  523:	    /* Command line option requires an argument */
    #####:  524:	    error (1, 0, _("missing argument to `%s'"), predicate_name);
        -:  525:	  else
    #####:  526:	    error (1, 0, _("invalid argument `%s' to `%s'"),
    #####:  527:		   argv[i], predicate_name);
        -:  528:	}
        -:  529:    }
        7:  530:  if (predicates->pred_next == NULL)
        -:  531:    {
        -:  532:      /* No predicates that do something other than set a global variable
        -:  533:	 were given; remove the unneeded initial `(' and add `-print'. */
        1:  534:      cur_pred = predicates;
        1:  535:      predicates = last_pred = predicates->pred_next;
        1:  536:      free ((char *) cur_pred);
        1:  537:      parse_print (argv, &argc);
        -:  538:    }
        6:  539:  else if (!default_prints (predicates->pred_next))
        -:  540:    {
        -:  541:      /* One or more predicates that produce output were given;
        -:  542:	 remove the unneeded initial `('. */
        3:  543:      cur_pred = predicates;
        3:  544:      predicates = predicates->pred_next;
        3:  545:      free ((char *) cur_pred);
        -:  546:    }
        -:  547:  else
        -:  548:    {
        -:  549:      /* `( user-supplied-expression ) -print'. */
        3:  550:      parse_close (argv, &argc);
        3:  551:      parse_print (argv, &argc);
        -:  552:    }
        -:  553:
        -:  554:#ifdef	DEBUG
        -:  555:  fprintf (stderr, "Predicate List:\n");
        -:  556:  print_list (stderr, predicates);
        -:  557:#endif /* DEBUG */
        -:  558:
        -:  559:  /* Done parsing the predicates.  Build the evaluation tree. */
        7:  560:  cur_pred = predicates;
        7:  561:  eval_tree = get_expr (&cur_pred, NO_PREC);
        -:  562:
        -:  563:  /* Check if we have any left-over predicates (this fixes
        -:  564:   * Debian bug #185202).
        -:  565:   */
        7:  566:  if (cur_pred != NULL)
        -:  567:    {
    #####:  568:      error (1, 0, _("unexpected extra predicate"));
        -:  569:    }
        -:  570:  
        -:  571:#ifdef	DEBUG
        -:  572:  fprintf (stderr, "Eval Tree:\n");
        -:  573:  print_tree (stderr, eval_tree, 0);
        -:  574:#endif /* DEBUG */
        -:  575:
        -:  576:  /* Rearrange the eval tree in optimal-predicate order. */
        7:  577:  opt_expr (&eval_tree);
        -:  578:
        -:  579:  /* Determine the point, if any, at which to stat the file. */
        7:  580:  mark_stat (eval_tree);
        -:  581:  /* Determine the point, if any, at which to determine file type. */
        7:  582:  mark_type (eval_tree);
        -:  583:
        -:  584:#ifdef DEBUG
        -:  585:  fprintf (stderr, "Optimized Eval Tree:\n");
        -:  586:  print_tree (stderr, eval_tree, 0);
        -:  587:  fprintf (stderr, "Optimized command line:\n");
        -:  588:  print_optlist(stderr, eval_tree);
        -:  589:  fprintf(stderr, "\n");
        -:  590:#endif /* DEBUG */
        -:  591:
        -:  592:  /* safely_chdir() needs to check that it has ended up in the right place. 
        -:  593:   * To avoid bailing out when something gets automounted, it checks if 
        -:  594:   * the target directory appears to have had a directory mounted on it as
        -:  595:   * we chdir()ed.  The problem with this is that in order to notice that 
        -:  596:   * a filesystem was mounted, we would need to lstat() all the mount points.
        -:  597:   * That strategy loses if our machine is a client of a dead NFS server.
        -:  598:   *
        -:  599:   * Hence if safely_chdir() and wd_sanity_check() can manage without needing 
        -:  600:   * to know the mounted device list, we do that.  
        -:  601:   */
        7:  602:  if (!options.open_nofollow_available)
        -:  603:    {
        -:  604:#ifdef STAT_MOUNTPOINTS
        -:  605:      init_mounted_dev_list();
        -:  606:#endif
        -:  607:    }
        -:  608:  
        -:  609:
        7:  610:  starting_desc = open (".", O_RDONLY);
        7:  611:  if (0 <= starting_desc && fchdir (starting_desc) != 0)
        -:  612:    {
    #####:  613:      close (starting_desc);
    #####:  614:      starting_desc = -1;
        -:  615:    }
        7:  616:  if (starting_desc < 0)
        -:  617:    {
    #####:  618:      starting_dir = xgetcwd ();
    #####:  619:      if (! starting_dir)
    #####:  620:	error (1, errno, _("cannot get current directory"));
        -:  621:    }
        7:  622:  if ((*options.xstat) (".", &starting_stat_buf) != 0)
    #####:  623:    error (1, errno, _("cannot get current directory"));
        -:  624:
        -:  625:  /* If no paths are given, default to ".".  */
       13:  626:  for (i = end_of_leading_options; i < argc && strchr ("-!(),", argv[i][0]) == NULL; i++)
        -:  627:    {
        6:  628:      process_top_path (argv[i], 0);
        -:  629:    }
        -:  630:
        -:  631:  /* If there were no path arguments, default to ".". */
        7:  632:  if (i == end_of_leading_options)
        -:  633:    {
        -:  634:      /* 
        -:  635:       * We use a temporary variable here because some actions modify 
        -:  636:       * the path temporarily.  Hence if we use a string constant, 
        -:  637:       * we get a coredump.  The best example of this is if we say 
        -:  638:       * "find -printf %H" (note, not "find . -printf %H").
        -:  639:       */
        1:  640:      char defaultpath[2] = ".";
        1:  641:      process_top_path (defaultpath, 0);
        -:  642:    }
        -:  643:
        -:  644:  /* If "-exec ... {} +" has been used, there may be some 
        -:  645:   * partially-full command lines which have been built, 
        -:  646:   * but which are not yet complete.   Execute those now.
        -:  647:   */
        7:  648:  cleanup();
        7:  649:  return state.exit_status;
        -:  650:}
        -:  651:
        -:  652:
        -:  653:static char *
    #####:  654:specific_dirname(const char *dir)
        -:  655:{
        -:  656:  char dirbuf[1024];
        -:  657:
    #####:  658:  if (0 == strcmp(".", dir))
        -:  659:    {
        -:  660:      /* OK, what's '.'? */
    #####:  661:      if (NULL != getcwd(dirbuf, sizeof(dirbuf)))
        -:  662:	{
    #####:  663:	  return strdup(dirbuf);
        -:  664:	}
        -:  665:      else
        -:  666:	{
    #####:  667:	  return strdup(dir);
        -:  668:	}
        -:  669:    }
        -:  670:  else
        -:  671:    {
    #####:  672:      char *result = canonicalize_filename_mode(dir, CAN_EXISTING);
    #####:  673:      if (NULL == result)
    #####:  674:	return strdup(dir);
        -:  675:      else
    #####:  676:	return result;
        -:  677:    }
        -:  678:}
        -:  679:
        -:  680:
        -:  681:
        -:  682:/* Return non-zero if FS is the name of a filesystem that is likely to
        -:  683: * be automounted
        -:  684: */
        -:  685:static int
    #####:  686:fs_likely_to_be_automounted(const char *fs)
        -:  687:{
    #####:  688:  return ( (0==strcmp(fs, "nfs")) || (0==strcmp(fs, "autofs")) || (0==strcmp(fs, "subfs")));
        -:  689:}
        -:  690:
        -:  691:
        -:  692:
        -:  693:#ifdef STAT_MOUNTPOINTS
        -:  694:static dev_t *mounted_devices = NULL;
        -:  695:static size_t num_mounted_devices = 0u;
        -:  696:
        -:  697:
        -:  698:static void
        -:  699:init_mounted_dev_list()
        -:  700:{
        -:  701:  assert(NULL == mounted_devices);
        -:  702:  assert(0 == num_mounted_devices);
        -:  703:  mounted_devices = get_mounted_devices(&num_mounted_devices);
        -:  704:}
        -:  705:
        -:  706:static void
        -:  707:refresh_mounted_dev_list(void)
        -:  708:{
        -:  709:  if (mounted_devices)
        -:  710:    {
        -:  711:      free(mounted_devices);
        -:  712:      mounted_devices = 0;
        -:  713:    }
        -:  714:  num_mounted_devices = 0u;
        -:  715:  init_mounted_dev_list();
        -:  716:}
        -:  717:
        -:  718:
        -:  719:/* Search for device DEV in the array LIST, which is of size N. */
        -:  720:static int
        -:  721:dev_present(dev_t dev, const dev_t *list, size_t n)
        -:  722:{
        -:  723:  if (list)
        -:  724:    {
        -:  725:      while (n-- > 0u)
        -:  726:	{
        -:  727:	  if ( (*list++) == dev )
        -:  728:	    return 1;
        -:  729:	}
        -:  730:    }
        -:  731:  return 0;
        -:  732:}
        -:  733:
        -:  734:enum MountPointStateChange
        -:  735:  {
        -:  736:    MountPointRecentlyMounted,
        -:  737:    MountPointRecentlyUnmounted,
        -:  738:    MountPointStateUnchanged
        -:  739:  };
        -:  740:
        -:  741:
        -:  742:
        -:  743:static enum MountPointStateChange
        -:  744:get_mount_state(dev_t newdev)
        -:  745:{
        -:  746:  int new_is_present, new_was_present;
        -:  747:  
        -:  748:  new_was_present = dev_present(newdev, mounted_devices, num_mounted_devices);
        -:  749:  refresh_mounted_dev_list();
        -:  750:  new_is_present  = dev_present(newdev, mounted_devices, num_mounted_devices);
        -:  751:  
        -:  752:  if (new_was_present == new_is_present)
        -:  753:    return MountPointStateUnchanged;
        -:  754:  else if (new_is_present)
        -:  755:    return MountPointRecentlyMounted;
        -:  756:  else
        -:  757:    return MountPointRecentlyUnmounted;
        -:  758:}
        -:  759:
        -:  760:
        -:  761:
        -:  762:/* We stat()ed a directory, chdir()ed into it (we know this 
        -:  763: * since direction is TraversingDown), stat()ed it again,
        -:  764: * and noticed that the device numbers are different.  Check
        -:  765: * if the filesystem was recently mounted. 
        -:  766: * 
        -:  767: * If it was, it looks like chdir()ing into the directory
        -:  768: * caused a filesystem to be mounted.  Maybe automount is
        -:  769: * running.  Anyway, that's probably OK - but it happens
        -:  770: * only when we are moving downward.
        -:  771: *
        -:  772: * We also allow for the possibility that a similar thing
        -:  773: * has happened with the unmounting of a filesystem.  This
        -:  774: * is much rarer, as it relies on an automounter timeout
        -:  775: * occurring at exactly the wrong moment.
        -:  776: */
        -:  777:static enum WdSanityCheckFatality
        -:  778:dirchange_is_fatal(const char *specific_what,
        -:  779:		   enum WdSanityCheckFatality isfatal,
        -:  780:		   int silent,
        -:  781:		   struct stat *newinfo)
        -:  782:{
        -:  783:  enum MountPointStateChange transition = get_mount_state(newinfo->st_dev);
        -:  784:  switch (transition)
        -:  785:    {
        -:  786:    case MountPointRecentlyUnmounted:
        -:  787:      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
        -:  788:      if (!silent)
        -:  789:	{
        -:  790:	  error (0, 0,
        -:  791:		 _("Warning: filesystem %s has recently been unmounted."),
        -:  792:		 specific_what);
        -:  793:	}
        -:  794:      break;
        -:  795:	      
        -:  796:    case MountPointRecentlyMounted:
        -:  797:      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
        -:  798:      if (!silent)
        -:  799:	{
        -:  800:	  error (0, 0,
        -:  801:		 _("Warning: filesystem %s has recently been mounted."),
        -:  802:		 specific_what);
        -:  803:	}
        -:  804:      break;
        -:  805:
        -:  806:    case MountPointStateUnchanged:
        -:  807:      /* leave isfatal as it is */
        -:  808:      break;
        -:  809:    }
        -:  810:  
        -:  811:  return isfatal;
        -:  812:}
        -:  813:
        -:  814:
        -:  815:#endif
        -:  816:
        -:  817:
        -:  818:
        -:  819:/* Examine the results of the stat() of a directory from before we
        -:  820: * entered or left it, with the results of stat()ing it afterward.  If
        -:  821: * these are different, the filesystem tree has been modified while we
        -:  822: * were traversing it.  That might be an attempt to use a race
        -:  823: * condition to persuade find to do something it didn't intend
        -:  824: * (e.g. an attempt by an ordinary user to exploit the fact that root
        -:  825: * sometimes runs find on the whole filesystem).  However, this can
        -:  826: * also happen if automount is running (certainly on Solaris).  With 
        -:  827: * automount, moving into a directory can cause a filesystem to be 
        -:  828: * mounted there.
        -:  829: *
        -:  830: * To cope sensibly with this, we will raise an error if we see the
        -:  831: * device number change unless we are chdir()ing into a subdirectory,
        -:  832: * and the directory we moved into has been mounted or unmounted "recently".  
        -:  833: * Here "recently" means since we started "find" or we last re-read 
        -:  834: * the /etc/mnttab file. 
        -:  835: *
        -:  836: * If the device number does not change but the inode does, that is a
        -:  837: * problem.
        -:  838: *
        -:  839: * If the device number and inode are both the same, we are happy.
        -:  840: *
        -:  841: * If a filesystem is (un)mounted as we chdir() into the directory, that 
        -:  842: * may mean that we're now examining a section of the filesystem that might 
        -:  843: * have been excluded from consideration (via -prune or -quit for example).
        -:  844: * Hence we print a warning message to indicate that the output of find 
        -:  845: * might be inconsistent due to the change in the filesystem.
        -:  846: */
        -:  847:static boolean
    #####:  848:wd_sanity_check(const char *thing_to_stat,
        -:  849:		const char *progname,
        -:  850:		const char *what,
        -:  851:		dev_t old_dev,
        -:  852:		ino_t old_ino,
        -:  853:		struct stat *newinfo,
        -:  854:		int parent,
        -:  855:		int line_no,
        -:  856:		enum TraversalDirection direction,
        -:  857:		enum WdSanityCheckFatality isfatal,
        -:  858:		boolean *changed) /* output parameter */
        -:  859:{
        -:  860:  const char *fstype;
    #####:  861:  char *specific_what = NULL;
    #####:  862:  int silent = 0;
        -:  863:  
    #####:  864:  *changed = false;
        -:  865:  
    #####:  866:  if ((*options.xstat) (".", newinfo) != 0)
    #####:  867:    error (1, errno, "%s", thing_to_stat);
        -:  868:  
    #####:  869:  if (old_dev != newinfo->st_dev)
        -:  870:    {
    #####:  871:      *changed = true;
    #####:  872:      specific_what = specific_dirname(what);
    #####:  873:      fstype = filesystem_type(newinfo);
    #####:  874:      silent = fs_likely_to_be_automounted(fstype);
        -:  875:
        -:  876:      /* This condition is rare, so once we are here it is 
        -:  877:       * reasonable to perform an expensive computation to 
        -:  878:       * determine if we should continue or fail. 
        -:  879:       */
    #####:  880:      if (TraversingDown == direction)
        -:  881:	{
        -:  882:#ifdef STAT_MOUNTPOINTS
        -:  883:	  isfatal = dirchange_is_fatal(specific_what,isfatal,silent,newinfo);
        -:  884:#else
    #####:  885:	  isfatal = RETRY_IF_SANITY_CHECK_FAILS;
        -:  886:#endif
        -:  887:	}
        -:  888:
    #####:  889:      switch (isfatal)
        -:  890:	{
        -:  891:	case FATAL_IF_SANITY_CHECK_FAILS:
        -:  892:	  {
    #####:  893:	    fstype = filesystem_type(newinfo);
    #####:  894:	    error (1, 0,
        -:  895:		   _("%s%s changed during execution of %s (old device number %ld, new device number %ld, filesystem type is %s) [ref %ld]"),
        -:  896:		   specific_what,
        -:  897:		   parent ? "/.." : "",
        -:  898:		   progname,
        -:  899:		   (long) old_dev,
    #####:  900:		   (long) newinfo->st_dev,
        -:  901:		   fstype,
        -:  902:		   line_no);
        -:  903:	    /*NOTREACHED*/
    #####:  904:	    return false;
        -:  905:	  }
        -:  906:	  
        -:  907:	case NON_FATAL_IF_SANITY_CHECK_FAILS:
        -:  908:	  {
        -:  909:	    /* Since the device has changed under us, the inode number 
        -:  910:	     * will almost certainly also be different. However, we have 
        -:  911:	     * already decided that this is not a problem.  Hence we return
        -:  912:	     * without checking the inode number.
        -:  913:	     */
    #####:  914:	    free(specific_what);
    #####:  915:	    return true;
        -:  916:	  }
        -:  917:
        -:  918:	case RETRY_IF_SANITY_CHECK_FAILS:
    #####:  919:	  return false;
        -:  920:	}
        -:  921:    }
        -:  922:
        -:  923:  /* Device number was the same, check if the inode has changed. */
    #####:  924:  if (old_ino != newinfo->st_ino)
        -:  925:    {
    #####:  926:      *changed = true;
    #####:  927:      specific_what = specific_dirname(what);
    #####:  928:      fstype = filesystem_type(newinfo);
        -:  929:      
    #####:  930:      error ((isfatal == FATAL_IF_SANITY_CHECK_FAILS) ? 1 : 0,
        -:  931:	     0,			/* no relevant errno value */
        -:  932:	     _("%s%s changed during execution of %s (old inode number %ld, new inode number %ld, filesystem type is %s) [ref %ld]"),
        -:  933:	     specific_what, 
        -:  934:	     parent ? "/.." : "",
        -:  935:	     progname,
        -:  936:	     (long) old_ino,
    #####:  937:	     (long) newinfo->st_ino,
        -:  938:	     fstype,
        -:  939:	     line_no);
    #####:  940:      free(specific_what);
    #####:  941:      return false;
        -:  942:    }
        -:  943:  
    #####:  944:  return true;
        -:  945:}
        -:  946:
        -:  947:enum SafeChdirStatus
        -:  948:  {
        -:  949:    SafeChdirOK,
        -:  950:    SafeChdirFailSymlink,
        -:  951:    SafeChdirFailNotDir,
        -:  952:    SafeChdirFailStat,
        -:  953:    SafeChdirFailWouldBeUnableToReturn,
        -:  954:    SafeChdirFailChdirFailed,
        -:  955:    SafeChdirFailNonexistent
        -:  956:  };
        -:  957:
        -:  958:/* Safely perform a change in directory.  We do this by calling
        -:  959: * lstat() on the subdirectory, using chdir() tro move into it, and
        -:  960: * then lstat()ing ".".  We compare the results of the two stat calls
        -:  961: * to see if they are consistent.  If not, we sound the alarm.
        -:  962: *
        -:  963: * If following_links() is true, we do follow symbolic links.
        -:  964: */
        -:  965:static enum SafeChdirStatus
    #####:  966:safely_chdir_lstat(const char *dest,
        -:  967:		   enum TraversalDirection direction,
        -:  968:		   struct stat *statbuf_dest,
        -:  969:		   enum ChdirSymlinkHandling symlink_follow_option)
        -:  970:{
        -:  971:  struct stat statbuf_arrived;
    #####:  972:  int rv, dotfd=-1;
        -:  973:  int saved_errno;		/* specific_dirname() changes errno. */
    #####:  974:  boolean rv_set = false;
    #####:  975:  int tries = 0;
    #####:  976:  enum WdSanityCheckFatality isfatal = RETRY_IF_SANITY_CHECK_FAILS;
        -:  977:  
    #####:  978:  saved_errno = errno = 0;
        -:  979:
    #####:  980:  dotfd = open(".", O_RDONLY);
        -:  981:
        -:  982:  /* We jump back to here if wd_sanity_check()
        -:  983:   * recoverably triggers an alert.
        -:  984:   */
        -:  985: retry:
    #####:  986:  ++tries;
        -:  987:  
    #####:  988:  if (dotfd >= 0)
        -:  989:    {
        -:  990:      /* Stat the directory we're going to. */
    #####:  991:      if (0 == options.xstat(dest, statbuf_dest))
        -:  992:	{
        -:  993:#ifdef S_ISLNK
        -:  994:	  /* symlink_follow_option might be set to SymlinkFollowOk, which
        -:  995:	   * would allow us to chdir() into a symbolic link.  This is
        -:  996:	   * only useful for the case where the directory we're
        -:  997:	   * chdir()ing into is the basename of a command line
        -:  998:	   * argument, for example where "foo/bar/baz" is specified on
        -:  999:	   * the command line.  When -P is in effect (the default),
        -: 1000:	   * baz will not be followed if it is a symlink, but if bar
        -: 1001:	   * is a symlink, it _should_ be followed.  Hence we need the
        -: 1002:	   * ability to override the policy set by following_links().
        -: 1003:	   */
    #####: 1004:	  if (!following_links() && S_ISLNK(statbuf_dest->st_mode))
        -: 1005:	    {
        -: 1006:	      /* We're not supposed to be following links, but this is 
        -: 1007:	       * a link.  Check symlink_follow_option to see if we should 
        -: 1008:	       * make a special exception.
        -: 1009:	       */
    #####: 1010:	      if (symlink_follow_option == SymlinkFollowOk)
        -: 1011:		{
        -: 1012:		  /* We need to re-stat() the file so that the 
        -: 1013:		   * sanity check can pass. 
        -: 1014:		   */
    #####: 1015:		  if (0 != stat(dest, statbuf_dest))
        -: 1016:		    {
    #####: 1017:		      rv = SafeChdirFailNonexistent;
    #####: 1018:		      rv_set = true;
    #####: 1019:		      saved_errno = errno;
    #####: 1020:		      goto fail;
        -: 1021:		    }
        -: 1022:		}
        -: 1023:	      else
        -: 1024:		{
        -: 1025:		  /* Not following symlinks, so the attempt to
        -: 1026:		   * chdir() into a symlink should be prevented.
        -: 1027:		   */
    #####: 1028:		  rv = SafeChdirFailSymlink;
    #####: 1029:		  rv_set = true;
    #####: 1030:		  saved_errno = 0;	/* silence the error message */
    #####: 1031:		  goto fail;
        -: 1032:		}
        -: 1033:	    }
        -: 1034:#endif	  
        -: 1035:#ifdef S_ISDIR
        -: 1036:	  /* Although the immediately following chdir() would detect
        -: 1037:	   * the fact that this is not a directory for us, this would
        -: 1038:	   * result in an extra system call that fails.  Anybody
        -: 1039:	   * examining the system-call trace should ideally not be
        -: 1040:	   * concerned that something is actually failing.
        -: 1041:	   */
    #####: 1042:	  if (!S_ISDIR(statbuf_dest->st_mode))
        -: 1043:	    {
    #####: 1044:	      rv = SafeChdirFailNotDir;
    #####: 1045:	      rv_set = true;
    #####: 1046:	      saved_errno = 0;	/* silence the error message */
    #####: 1047:	      goto fail;
        -: 1048:	    }
        -: 1049:#endif	  
        -: 1050:#ifdef DEBUG_STAT
        -: 1051:	  fprintf(stderr, "safely_chdir(): chdir(\"%s\")\n", dest);
        -: 1052:#endif
    #####: 1053:	  if (0 == chdir(dest))
        -: 1054:	    {
        -: 1055:	      /* check we ended up where we wanted to go */
    #####: 1056:	      boolean changed = false;
    #####: 1057:	      if (!wd_sanity_check(".", program_name, ".",
        -: 1058:				   statbuf_dest->st_dev,
        -: 1059:				   statbuf_dest->st_ino,
        -: 1060:				   &statbuf_arrived, 
        -: 1061:				   0, __LINE__, direction,
        -: 1062:				   isfatal,
        -: 1063:				   &changed))
        -: 1064:		{
        -: 1065:		  /* Only allow one failure. */
    #####: 1066:		  if (RETRY_IF_SANITY_CHECK_FAILS == isfatal)
        -: 1067:		    {
    #####: 1068:		      if (0 == fchdir(dotfd))
        -: 1069:			{
    #####: 1070:			  isfatal = FATAL_IF_SANITY_CHECK_FAILS;
        -: 1071:			  goto retry;
        -: 1072:			}
        -: 1073:		      else
        -: 1074:			{
        -: 1075:			  /* Failed to return to original directory,
        -: 1076:			   * but we know that the current working
        -: 1077:			   * directory is not the one that we intend
        -: 1078:			   * to be in.  Since fchdir() failed, we
        -: 1079:			   * can't recover from this and so this error
        -: 1080:			   * is fatal.
        -: 1081:			   */
    #####: 1082:			  error(1, errno,
        -: 1083:				"failed to return to parent directory");
        -: 1084:			}
        -: 1085:		    }
        -: 1086:		  else
        -: 1087:		    {
        -: 1088:		      /* XXX: not sure what to use as an excuse here. */
    #####: 1089:		      rv = SafeChdirFailNonexistent;
    #####: 1090:		      rv_set = true;
    #####: 1091:		      saved_errno = 0;
        -: 1092:		      goto fail;
        -: 1093:		    }
        -: 1094:		}
        -: 1095:	      
    #####: 1096:	      close(dotfd);
    #####: 1097:	      return SafeChdirOK;
        -: 1098:	    }
        -: 1099:	  else
        -: 1100:	    {
    #####: 1101:	      saved_errno = errno;
    #####: 1102:	      if (ENOENT == saved_errno)
        -: 1103:		{
    #####: 1104:		  rv = SafeChdirFailNonexistent;
    #####: 1105:		  rv_set = true;
    #####: 1106:		  if (options.ignore_readdir_race)
    #####: 1107:		    errno = 0;	/* don't issue err msg */
        -: 1108:		}
    #####: 1109:	      else if (ENOTDIR == saved_errno)
        -: 1110:		{
        -: 1111:		  /* This can happen if the we stat a directory,
        -: 1112:		   * and then filesystem activity changes it into 
        -: 1113:		   * a non-directory.
        -: 1114:		   */
    #####: 1115:		  saved_errno = 0;	/* don't issue err msg */
    #####: 1116:		  rv = SafeChdirFailNotDir;
    #####: 1117:		  rv_set = true;
        -: 1118:		}
        -: 1119:	      else
        -: 1120:		{
    #####: 1121:		  rv = SafeChdirFailChdirFailed;
    #####: 1122:		  rv_set = true;
        -: 1123:		}
    #####: 1124:	      goto fail;
        -: 1125:	    }
        -: 1126:	}
        -: 1127:      else
        -: 1128:	{
    #####: 1129:	  saved_errno = errno;
    #####: 1130:	  rv = SafeChdirFailStat;
    #####: 1131:	  rv_set = true;
        -: 1132:
    #####: 1133:	  if ( (ENOENT == saved_errno) || (0 == state.curdepth))
    #####: 1134:	    saved_errno = 0;	/* don't issue err msg */
    #####: 1135:	  goto fail;
        -: 1136:	}
        -: 1137:    }
        -: 1138:  else
        -: 1139:    {
        -: 1140:      /* We do not have read permissions on "." */
    #####: 1141:      rv = SafeChdirFailWouldBeUnableToReturn;
    #####: 1142:      rv_set = true;
    #####: 1143:      goto fail;
        -: 1144:    }
        -: 1145:
        -: 1146:  /* This is the success path, so we clear errno.  The caller probably
        -: 1147:   * won't be calling error() anyway.
        -: 1148:   */
        -: 1149:  saved_errno = 0;
        -: 1150:  
        -: 1151:  /* We use the same exit path for successs or failure. 
        -: 1152:   * which has occurred is recorded in RV. 
        -: 1153:   */
        -: 1154: fail:
        -: 1155:  /* We do not call error() as this would result in a duplicate error
        -: 1156:   * message when the caller does the same thing.
        -: 1157:   */
    #####: 1158:  if (saved_errno)
    #####: 1159:    errno = saved_errno;
        -: 1160:  
    #####: 1161:  if (dotfd >= 0)
        -: 1162:    {
    #####: 1163:      close(dotfd);
    #####: 1164:      dotfd = -1;
        -: 1165:    }
    #####: 1166:  assert(rv_set);
    #####: 1167:  return rv;
        -: 1168:}
        -: 1169:
        -: 1170:#if defined(O_NOFOLLOW)
        -: 1171:/* Safely change working directory to the specified subdirectory.  If
        -: 1172: * we are not allowed to follow symbolic links, we use open() with
        -: 1173: * O_NOFOLLOW, followed by fchdir().  This ensures that we don't
        -: 1174: * follow symbolic links (of course, we do follow them if the -L
        -: 1175: * option is in effect).
        -: 1176: */
        -: 1177:static enum SafeChdirStatus
       30: 1178:safely_chdir_nofollow(const char *dest,
        -: 1179:		      enum TraversalDirection direction,
        -: 1180:		      struct stat *statbuf_dest,
        -: 1181:		      enum ChdirSymlinkHandling symlink_follow_option)
        -: 1182:{
        -: 1183:  int extraflags, fd;
       30: 1184:  extraflags = 0;
        -: 1185:  
       30: 1186:  switch (symlink_follow_option)
        -: 1187:    {
        -: 1188:    case SymlinkFollowOk:
        4: 1189:      extraflags = 0;
        4: 1190:      break;
        -: 1191:      
        -: 1192:    case SymlinkHandleDefault:
       26: 1193:      if (following_links())
        4: 1194:	extraflags = 0;
        -: 1195:      else
       22: 1196:	extraflags = O_NOFOLLOW;
       26: 1197:      break;
        -: 1198:    }
        -: 1199:  
       30: 1200:  errno = 0;
       30: 1201:  fd = open(dest, O_RDONLY|extraflags);
       30: 1202:  if (fd < 0)
        -: 1203:    {
    #####: 1204:      switch (errno)
        -: 1205:	{
        -: 1206:	case ELOOP:
    #####: 1207:	  return SafeChdirFailSymlink; /* This is why we use O_NOFOLLOW */
        -: 1208:	case ENOENT:
    #####: 1209:	  return SafeChdirFailNonexistent;
        -: 1210:	default:
    #####: 1211:	  return SafeChdirFailChdirFailed;
        -: 1212:	}
        -: 1213:    }
        -: 1214:  
       30: 1215:  errno = 0;
       30: 1216:  if (0 == fchdir(fd))
        -: 1217:    {
       30: 1218:      close(fd);
       30: 1219:      return SafeChdirOK;
        -: 1220:    }
        -: 1221:  else
        -: 1222:    {
    #####: 1223:      int saved_errno = errno;
    #####: 1224:      close(fd);
    #####: 1225:      errno = saved_errno;
        -: 1226:      
    #####: 1227:      switch (errno)
        -: 1228:	{
        -: 1229:	case ENOTDIR:
    #####: 1230:	  return SafeChdirFailNotDir;
        -: 1231:	  
        -: 1232:	case EACCES:
        -: 1233:	case EBADF:		/* Shouldn't happen */
        -: 1234:	case EINTR:
        -: 1235:	case EIO:
        -: 1236:	default:
    #####: 1237:	  return SafeChdirFailChdirFailed;
        -: 1238:	}
        -: 1239:    }
        -: 1240:}
        -: 1241:#endif
        -: 1242:
        -: 1243:static enum SafeChdirStatus
       30: 1244:safely_chdir(const char *dest,
        -: 1245:	     enum TraversalDirection direction,
        -: 1246:	     struct stat *statbuf_dest,
        -: 1247:	     enum ChdirSymlinkHandling symlink_follow_option)
        -: 1248:{
        -: 1249:  /* We're about to leave a directory.  If there are any -execdir
        -: 1250:   * argument lists which have been built but have not yet been
        -: 1251:   * processed, do them now because they must be done in the same
        -: 1252:   * directory.
        -: 1253:   */
       30: 1254:  complete_pending_execdirs(eval_tree);
        -: 1255:
        -: 1256:#if defined(O_NOFOLLOW)
       30: 1257:  if (options.open_nofollow_available)
       30: 1258:    return safely_chdir_nofollow(dest, direction, statbuf_dest, symlink_follow_option);
        -: 1259:#endif
    #####: 1260:  return safely_chdir_lstat(dest, direction, statbuf_dest, symlink_follow_option);
        -: 1261:}
        -: 1262:
        -: 1263:
        -: 1264:
        -: 1265:/* Safely go back to the starting directory. */
        -: 1266:static void
        9: 1267:chdir_back (void)
        -: 1268:{
        -: 1269:  struct stat stat_buf;
        -: 1270:  boolean dummy;
        -: 1271:  
        9: 1272:  if (starting_desc < 0)
        -: 1273:    {
        -: 1274:#ifdef DEBUG_STAT
        -: 1275:      fprintf(stderr, "chdir_back(): chdir(\"%s\")\n", starting_dir);
        -: 1276:#endif
        -: 1277:      
        -: 1278:#ifdef STAT_MOUNTPOINTS
        -: 1279:      /* We will need the mounted device list.  Get it now if we don't
        -: 1280:       * already have it.
        -: 1281:       */
        -: 1282:      if (NULL == mounted_devices)
        -: 1283:	init_mounted_dev_list();
        -: 1284:#endif
        -: 1285:      
    #####: 1286:      if (chdir (starting_dir) != 0)
    #####: 1287:	error (1, errno, "%s", starting_dir);
        -: 1288:
    #####: 1289:      wd_sanity_check(starting_dir,
        -: 1290:		      program_name,
        -: 1291:		      starting_dir,
        -: 1292:		      starting_stat_buf.st_dev,
        -: 1293:		      starting_stat_buf.st_ino,
        -: 1294:		      &stat_buf, 0, __LINE__,
        -: 1295:		      TraversingUp,
        -: 1296:		      FATAL_IF_SANITY_CHECK_FAILS,
        -: 1297:		      &dummy);
        -: 1298:    }
        -: 1299:  else
        -: 1300:    {
        -: 1301:#ifdef DEBUG_STAT
        -: 1302:      fprintf(stderr, "chdir_back(): chdir(<starting-point>)\n");
        -: 1303:#endif
        9: 1304:      if (fchdir (starting_desc) != 0)
    #####: 1305:	error (1, errno, "%s", starting_dir);
        -: 1306:    }
        9: 1307:}
        -: 1308:
        -: 1309:/* Move to the parent of a given directory and then call a function,
        -: 1310: * restoring the cwd.  Don't bother changing directory if the
        -: 1311: * specified directory is a child of "." or is the root directory.
        -: 1312: */
        -: 1313:static void
        7: 1314:at_top (char *pathname,
        -: 1315:	mode_t mode,
        -: 1316:	struct stat *pstat,
        -: 1317:	void (*action)(char *pathname,
        -: 1318:		       char *basename,
        -: 1319:		       int mode,
        -: 1320:		       struct stat *pstat))
        -: 1321:{
        -: 1322:  int dirchange;
        7: 1323:  char *parent_dir = dir_name(pathname);
        7: 1324:  char *base = base_name(pathname);
        -: 1325:  
        7: 1326:  state.curdepth = 0;
        7: 1327:  state.path_length = strlen (pathname);
        -: 1328:
        7: 1329:  if (0 == strcmp(pathname, parent_dir)
        5: 1330:      || 0 == strcmp(parent_dir, "."))
        -: 1331:    {
        3: 1332:      dirchange = 0;
        3: 1333:      base = pathname;
        -: 1334:    }
        -: 1335:  else
        -: 1336:    {
        -: 1337:      enum TraversalDirection direction;
        -: 1338:      enum SafeChdirStatus chdir_status;
        -: 1339:      struct stat st;
        -: 1340:
        4: 1341:      dirchange = 1;
        4: 1342:      if (0 == strcmp(base, ".."))
    #####: 1343:	direction = TraversingUp;
        -: 1344:      else
        4: 1345:	direction = TraversingDown;
        -: 1346:
        -: 1347:      /* We pass SymlinkFollowOk to safely_chdir(), which allows it to
        -: 1348:       * chdir() into a symbolic link.  This is only useful for the
        -: 1349:       * case where the directory we're chdir()ing into is the
        -: 1350:       * basename of a command line argument, for example where
        -: 1351:       * "foo/bar/baz" is specified on the command line.  When -P is
        -: 1352:       * in effect (the default), baz will not be followed if it is a
        -: 1353:       * symlink, but if bar is a symlink, it _should_ be followed.
        -: 1354:       * Hence we need the ability to override the policy set by
        -: 1355:       * following_links().
        -: 1356:       */
        4: 1357:      chdir_status = safely_chdir(parent_dir, direction, &st, SymlinkFollowOk);
        4: 1358:      if (SafeChdirOK != chdir_status)
        -: 1359:	{
    #####: 1360:	  const char *what = (SafeChdirFailWouldBeUnableToReturn == chdir_status) ? "." : parent_dir;
    #####: 1361:	  if (errno)
    #####: 1362:	    error (0, errno, "%s", what);
        -: 1363:	  else
    #####: 1364:	    error (0, 0, "Failed to safely change directory into `%s'",
        -: 1365:		   parent_dir);
        -: 1366:	    
        -: 1367:	  /* We can't process this command-line argument. */
    #####: 1368:	  state.exit_status = 1;
        7: 1369:	  return;
        -: 1370:	}
        -: 1371:    }
        -: 1372:
        7: 1373:  free (parent_dir);
        7: 1374:  parent_dir = NULL;
        -: 1375:  
        7: 1376:  action(pathname, base, mode, pstat);
        -: 1377:  
        7: 1378:  if (dirchange)
        -: 1379:    {
        4: 1380:      chdir_back();
        -: 1381:    }
        -: 1382:}
        -: 1383:
        -: 1384:
        7: 1385:static void do_process_top_dir(char *pathname,
        -: 1386:			       char *base,
        -: 1387:			       int mode,
        -: 1388:			       struct stat *pstat)
        -: 1389:{
        7: 1390:  process_path (pathname, base, false, ".", mode);
        7: 1391:  complete_pending_execdirs(eval_tree);
        7: 1392:}
        -: 1393:
    #####: 1394:static void do_process_predicate(char *pathname,
        -: 1395:				 char *base,
        -: 1396:				 int mode,
        -: 1397:				 struct stat *pstat)
        -: 1398:{
    #####: 1399:  state.rel_pathname = base;
    #####: 1400:  apply_predicate (pathname, pstat, eval_tree);
    #####: 1401:}
        -: 1402:
        -: 1403:
        -: 1404:
        -: 1405:
        -: 1406:/* Descend PATHNAME, which is a command-line argument.  
        -: 1407:
        -: 1408:   Actions like -execdir assume that we are in the 
        -: 1409:   parent directory of the file we're examining, 
        -: 1410:   and on entry to this function our working directory
        -: 1411:   is whetever it was when find was invoked.  Therefore
        -: 1412:   If PATHNAME is "." we just leave things as they are. 
        -: 1413:   Otherwise, we figure out what the parent directory is, 
        -: 1414:   and move to that.
        -: 1415:*/
        -: 1416:static void
        7: 1417:process_top_path (char *pathname, mode_t mode)
        -: 1418:{
        7: 1419:  at_top(pathname, mode, NULL, do_process_top_dir);
        7: 1420:}
        -: 1421:
        -: 1422:
        -: 1423:/* Info on each directory in the current tree branch, to avoid
        -: 1424:   getting stuck in symbolic link loops.  */
        -: 1425:static struct dir_id *dir_ids = NULL;
        -: 1426:/* Entries allocated in `dir_ids'.  */
        -: 1427:static int dir_alloc = 0;
        -: 1428:/* Index in `dir_ids' of directory currently being searched.
        -: 1429:   This is always the last valid entry.  */
        -: 1430:static int dir_curr = -1;
        -: 1431:/* (Arbitrary) number of entries to grow `dir_ids' by.  */
        -: 1432:#define DIR_ALLOC_STEP 32
        -: 1433:
        -: 1434:
        -: 1435:
        -: 1436:/* We've detected a filesystem loop.   This is caused by one of 
        -: 1437: * two things:
        -: 1438: *
        -: 1439: * 1. Option -L is in effect and we've hit a symbolic link that 
        -: 1440: *    points to an ancestor.  This is harmless.  We won't traverse the 
        -: 1441: *    symbolic link.
        -: 1442: *
        -: 1443: * 2. We have hit a real cycle in the directory hierarchy.  In this 
        -: 1444: *    case, we issue a diagnostic message (POSIX requires this) and we
        -: 1445: *    skip that directory entry.
        -: 1446: */
        -: 1447:static void
    #####: 1448:issue_loop_warning(const char *name, const char *pathname, int level)
        -: 1449:{
        -: 1450:  struct stat stbuf_link;
    #####: 1451:  if (lstat(name, &stbuf_link) != 0)
    #####: 1452:    stbuf_link.st_mode = S_IFREG;
        -: 1453:  
    #####: 1454:  if (S_ISLNK(stbuf_link.st_mode))
        -: 1455:    {
    #####: 1456:      error(0, 0,
        -: 1457:	    _("Symbolic link `%s' is part of a loop in the directory hierarchy; we have already visited the directory to which it points."),
        -: 1458:	    pathname);
        -: 1459:    }
        -: 1460:  else
        -: 1461:    {
    #####: 1462:      int distance = 1 + (dir_curr-level);
        -: 1463:      /* We have found an infinite loop.  POSIX requires us to
        -: 1464:       * issue a diagnostic.  Usually we won't get to here
        -: 1465:       * because when the leaf optimisation is on, it will cause
        -: 1466:       * the subdirectory to be skipped.  If /a/b/c/d is a hard
        -: 1467:       * link to /a/b, then the link count of /a/b/c is 2,
        -: 1468:       * because the ".." entry of /b/b/c/d points to /a, not
        -: 1469:       * to /a/b/c.
        -: 1470:       */
    #####: 1471:      error(0, 0,
        -: 1472:	    _("Filesystem loop detected; `%s' has the same device number and inode as a directory which is %d %s."),
        -: 1473:	    pathname,
        -: 1474:	    distance,
        -: 1475:	    (distance == 1 ?
        -: 1476:	     _("level higher in the filesystem hierarchy") :
        -: 1477:	     _("levels higher in the filesystem hierarchy")));
        -: 1478:    }
    #####: 1479:}
        -: 1480:
        -: 1481:/* Take a "mode" indicator and fill in the files of 'state'.
        -: 1482: */
        -: 1483:static int
      318: 1484:digest_mode(mode_t mode,
        -: 1485:	    const char *pathname,
        -: 1486:	    const char *name,
        -: 1487:	    struct stat *pstat,
        -: 1488:	    boolean leaf)
        -: 1489:{
        -: 1490:  /* If we know the type of the directory entry, and it is not a
        -: 1491:   * symbolic link, we may be able to avoid a stat() or lstat() call.
        -: 1492:   */
      318: 1493:  if (mode)
        -: 1494:    {
      311: 1495:      if (S_ISLNK(mode) && following_links())
        -: 1496:	{
        -: 1497:	  /* mode is wrong because we should have followed the symlink. */
        4: 1498:	  if (get_statinfo(pathname, name, pstat) != 0)
        4: 1499:	    return 0;
    #####: 1500:	  mode = state.type = pstat->st_mode;
    #####: 1501:	  state.have_type = true;
        -: 1502:	}
        -: 1503:      else
        -: 1504:	{
      307: 1505:	  state.have_type = true;
      307: 1506:	  pstat->st_mode = state.type = mode;
        -: 1507:	}
        -: 1508:    }
        -: 1509:  else
        -: 1510:    {
        -: 1511:      /* Mode is not yet known; may have to stat the file unless we 
        -: 1512:       * can deduce that it is not a directory (which is all we need to 
        -: 1513:       * know at this stage)
        -: 1514:       */
        7: 1515:      if (leaf)
        -: 1516:	{
    #####: 1517:	  state.have_stat = false;
    #####: 1518:	  state.have_type = false;;
    #####: 1519:	  state.type = 0;
        -: 1520:	}
        -: 1521:      else
        -: 1522:	{
        7: 1523:	  if (get_statinfo(pathname, name, pstat) != 0)
    #####: 1524:	    return 0;
        -: 1525:	  
        -: 1526:	  /* If -L is in effect and we are dealing with a symlink,
        -: 1527:	   * st_mode is the mode of the pointed-to file, while mode is
        -: 1528:	   * the mode of the directory entry (S_IFLNK).  Hence now
        -: 1529:	   * that we have the stat information, override "mode".
        -: 1530:	   */
        7: 1531:	  state.type = pstat->st_mode;
        7: 1532:	  state.have_type = true;
        -: 1533:	}
        -: 1534:    }
        -: 1535:
        -: 1536:  /* success. */
      314: 1537:  return 1;
        -: 1538:}
        -: 1539:
        -: 1540:
        -: 1541:
        -: 1542:/* Recursively descend path PATHNAME, applying the predicates.
        -: 1543:   LEAF is true if PATHNAME is known to be in a directory that has no
        -: 1544:   more unexamined subdirectories, and therefore it is not a directory.
        -: 1545:   Knowing this allows us to avoid calling stat as long as possible for
        -: 1546:   leaf files.
        -: 1547:
        -: 1548:   NAME is PATHNAME relative to the current directory.  We access NAME
        -: 1549:   but print PATHNAME.
        -: 1550:
        -: 1551:   PARENT is the path of the parent of NAME, relative to find's
        -: 1552:   starting directory.
        -: 1553:
        -: 1554:   Return nonzero iff PATHNAME is a directory. */
        -: 1555:
        -: 1556:static int
      318: 1557:process_path (char *pathname, char *name, boolean leaf, char *parent,
        -: 1558:	      mode_t mode)
        -: 1559:{
        -: 1560:  struct stat stat_buf;
        -: 1561:  static dev_t root_dev;	/* Device ID of current argument pathname. */
        -: 1562:  int i;
        -: 1563:
        -: 1564:  /* Assume it is a non-directory initially. */
      318: 1565:  stat_buf.st_mode = 0;
      318: 1566:  state.rel_pathname = name;
      318: 1567:  state.type = 0;
      318: 1568:  state.have_stat = false;
      318: 1569:  state.have_type = false;
        -: 1570:
      318: 1571:  if (!digest_mode(mode, pathname, name, &stat_buf, leaf))
        4: 1572:    return 0;
        -: 1573:  
      314: 1574:  if (!S_ISDIR (state.type))
        -: 1575:    {
      299: 1576:      if (state.curdepth >= options.mindepth)
      299: 1577:	apply_predicate (pathname, &stat_buf, eval_tree);
      299: 1578:      return 0;
        -: 1579:    }
        -: 1580:
        -: 1581:  /* From here on, we're working on a directory.  */
        -: 1582:
        -: 1583:  
        -: 1584:  /* Now we really need to stat the directory, even if we know the
        -: 1585:   * type, because we need information like struct stat.st_rdev.
        -: 1586:   */
       15: 1587:  if (get_statinfo(pathname, name, &stat_buf) != 0)
    #####: 1588:    return 0;
        -: 1589:
       15: 1590:  state.have_stat = true;
       15: 1591:  mode = state.type = stat_buf.st_mode;	/* use full info now that we have it. */
       15: 1592:  state.stop_at_current_level =
       15: 1593:    options.maxdepth >= 0
       15: 1594:    && state.curdepth >= options.maxdepth;
        -: 1595:
        -: 1596:  /* If we've already seen this directory on this branch,
        -: 1597:     don't descend it again.  */
       26: 1598:  for (i = 0; i <= dir_curr; i++)
       11: 1599:    if (stat_buf.st_ino == dir_ids[i].ino &&
    #####: 1600:	stat_buf.st_dev == dir_ids[i].dev)
        -: 1601:      {
    #####: 1602:	state.stop_at_current_level = true;
    #####: 1603:	issue_loop_warning(name, pathname, i);
        -: 1604:      }
        -: 1605:  
       15: 1606:  if (dir_alloc <= ++dir_curr)
        -: 1607:    {
        7: 1608:      dir_alloc += DIR_ALLOC_STEP;
        7: 1609:      dir_ids = (struct dir_id *)
        7: 1610:	xrealloc ((char *) dir_ids, dir_alloc * sizeof (struct dir_id));
        -: 1611:    }
       15: 1612:  dir_ids[dir_curr].ino = stat_buf.st_ino;
       15: 1613:  dir_ids[dir_curr].dev = stat_buf.st_dev;
        -: 1614:
       15: 1615:  if (options.stay_on_filesystem)
        -: 1616:    {
    #####: 1617:      if (state.curdepth == 0)
    #####: 1618:	root_dev = stat_buf.st_dev;
    #####: 1619:      else if (stat_buf.st_dev != root_dev)
    #####: 1620:	state.stop_at_current_level = true;
        -: 1621:    }
        -: 1622:
       15: 1623:  if (options.do_dir_first && state.curdepth >= options.mindepth)
       15: 1624:    apply_predicate (pathname, &stat_buf, eval_tree);
        -: 1625:
        -: 1626:#ifdef DEBUG
        -: 1627:  fprintf(stderr, "pathname = %s, stop_at_current_level = %d\n",
        -: 1628:	  pathname, state.stop_at_current_level);
        -: 1629:#endif /* DEBUG */
        -: 1630:  
       15: 1631:  if (state.stop_at_current_level == false)
        -: 1632:    /* Scan directory on disk. */
       14: 1633:    process_dir (pathname, name, strlen (pathname), &stat_buf, parent);
        -: 1634:
       15: 1635:  if (options.do_dir_first == false && state.curdepth >= options.mindepth)
        -: 1636:    {
        -: 1637:      /* The fields in 'state' are now out of date.  Correct them.
        -: 1638:       */
    #####: 1639:      if (!digest_mode(mode, pathname, name, &stat_buf, leaf))
    #####: 1640:	return 0;
        -: 1641:
    #####: 1642:      if (0 == dir_curr)
        -: 1643:	{
    #####: 1644:	  at_top(pathname, mode, &stat_buf, do_process_predicate);
        -: 1645:	}
        -: 1646:      else
        -: 1647:	{
    #####: 1648:	  do_process_predicate(pathname, name, mode, &stat_buf);
        -: 1649:	}
        -: 1650:    }
        -: 1651:
       15: 1652:  dir_curr--;
        -: 1653:
       15: 1654:  return 1;
        -: 1655:}
        -: 1656:
        -: 1657:/* Examine the predicate list for instances of -execdir or -okdir
        -: 1658: * which have been terminated with '+' (build argument list) rather
        -: 1659: * than ';' (singles only).  If there are any, run them (this will
        -: 1660: * have no effect if there are no arguments waiting).
        -: 1661: */
        -: 1662:static void
      872: 1663:complete_pending_execdirs(struct predicate *p)
        -: 1664:{
        -: 1665:#if defined(NEW_EXEC)
      872: 1666:  if (NULL == p)
     1344: 1667:    return;
        -: 1668:  
      400: 1669:  complete_pending_execdirs(p->pred_left);
        -: 1670:  
      400: 1671:  if (p->pred_func == pred_execdir || p->pred_func == pred_okdir)
        -: 1672:    {
        -: 1673:      /* It's an exec-family predicate.  p->args.exec_val is valid. */
       46: 1674:      if (p->args.exec_vec.multiple)
        -: 1675:	{
    #####: 1676:	  struct exec_val *execp = &p->args.exec_vec;
        -: 1677:	  
        -: 1678:	  /* This one was terminated by '+' and so might have some
        -: 1679:	   * left... Run it if neccessary.  
        -: 1680:	   */
    #####: 1681:	  if (execp->state.todo)
        -: 1682:	    {
        -: 1683:	      /* There are not-yet-executed arguments. */
    #####: 1684:	      launch (&execp->ctl, &execp->state);
        -: 1685:	    }
        -: 1686:	}
        -: 1687:    }
        -: 1688:
      400: 1689:  complete_pending_execdirs(p->pred_right);
        -: 1690:#else
        -: 1691:  /* nothing to do. */
        -: 1692:  return;
        -: 1693:#endif
        -: 1694:}
        -: 1695:
        -: 1696:/* Examine the predicate list for instances of -exec which have been
        -: 1697: * terminated with '+' (build argument list) rather than ';' (singles
        -: 1698: * only).  If there are any, run them (this will have no effect if
        -: 1699: * there are no arguments waiting).
        -: 1700: */
        -: 1701:static void
       67: 1702:complete_pending_execs(struct predicate *p)
        -: 1703:{
        -: 1704:#if defined(NEW_EXEC)
       67: 1705:  if (NULL == p)
      104: 1706:    return;
        -: 1707:  
       30: 1708:  complete_pending_execs(p->pred_left);
        -: 1709:  
        -: 1710:  /* It's an exec-family predicate then p->args.exec_val is valid
        -: 1711:   * and we can check it. 
        -: 1712:   */
       30: 1713:  if (p->pred_func == pred_exec && p->args.exec_vec.multiple)
        -: 1714:    {
    #####: 1715:      struct exec_val *execp = &p->args.exec_vec;
        -: 1716:      
        -: 1717:      /* This one was terminated by '+' and so might have some
        -: 1718:       * left... Run it if neccessary.  Set state.exit_status if
        -: 1719:       * there are any problems.
        -: 1720:       */
    #####: 1721:      if (execp->state.todo)
        -: 1722:	{
        -: 1723:	  /* There are not-yet-executed arguments. */
    #####: 1724:	  launch (&execp->ctl, &execp->state);
        -: 1725:	}
        -: 1726:    }
        -: 1727:
       30: 1728:  complete_pending_execs(p->pred_right);
        -: 1729:#else
        -: 1730:  /* nothing to do. */
        -: 1731:  return;
        -: 1732:#endif
        -: 1733:}
        -: 1734:
        -: 1735:
        -: 1736:/* Scan directory PATHNAME and recurse through process_path for each entry.
        -: 1737:
        -: 1738:   PATHLEN is the length of PATHNAME.
        -: 1739:
        -: 1740:   NAME is PATHNAME relative to the current directory.
        -: 1741:
        -: 1742:   STATP is the results of *options.xstat on it.
        -: 1743:
        -: 1744:   PARENT is the path of the parent of NAME, relative to find's
        -: 1745:   starting directory.  */
        -: 1746:
        -: 1747:static void
       14: 1748:process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *parent)
        -: 1749:{
        -: 1750:  int subdirs_left;		/* Number of unexamined subdirs in PATHNAME. */
        -: 1751:  int idx;			/* Which entry are we on? */
        -: 1752:  struct stat stat_buf;
        -: 1753:
        -: 1754:#undef USE_OLD_SAVEDIR 
        -: 1755:  
        -: 1756:#if USE_OLD_SAVEDIR
        -: 1757:  char *name_space;		/* Names of files in PATHNAME. */
        -: 1758:  struct savedir_extrainfo *extra;
        -: 1759:#else
        -: 1760:  struct savedir_dirinfo *dirinfo;
        -: 1761:#endif  
       14: 1762:  subdirs_left = statp->st_nlink - 2; /* Account for name and ".". */
        -: 1763:
       14: 1764:  errno = 0;
        -: 1765:#if USE_OLD_SAVEDIR
        -: 1766:  name_space = savedirinfo (name, &extra);
        -: 1767:#else
       14: 1768:  dirinfo = xsavedir(name, 0);
        -: 1769:#endif  
        -: 1770:  
       14: 1771:  if (
        -: 1772:#if USE_OLD_SAVEDIR
        -: 1773:      name_space
        -: 1774:#else
        -: 1775:      dirinfo
        -: 1776:#endif
        -: 1777:      == NULL)
        -: 1778:    {
    #####: 1779:      assert(errno != 0);
    #####: 1780:      error (0, errno, "%s", pathname);
    #####: 1781:      state.exit_status = 1;
        -: 1782:    }
        -: 1783:  else
        -: 1784:    {
        -: 1785:      register char *namep;	/* Current point in `name_space'. */
        -: 1786:      char *cur_path;		/* Full path of each file to process. */
        -: 1787:      char *cur_name;		/* Base name of each file to process. */
        -: 1788:      unsigned cur_path_size;	/* Bytes allocated for `cur_path'. */
        -: 1789:      register unsigned file_len; /* Length of each path to process. */
        -: 1790:      register unsigned pathname_len; /* PATHLEN plus trailing '/'. */
        -: 1791:
       14: 1792:      if (pathname[pathlen - 1] == '/')
    #####: 1793:	pathname_len = pathlen + 1; /* For '\0'; already have '/'. */
        -: 1794:      else
       14: 1795:	pathname_len = pathlen + 2; /* For '/' and '\0'. */
       14: 1796:      cur_path_size = 0;
       14: 1797:      cur_path = NULL;
        -: 1798:
        -: 1799:      /* We're about to leave the directory.  If there are any
        -: 1800:       * -execdir argument lists which have been built but have not
        -: 1801:       * yet been processed, do them now because they must be done in
        -: 1802:       * the same directory.
        -: 1803:       */
       14: 1804:      complete_pending_execdirs(eval_tree);
        -: 1805:      
       14: 1806:      if (strcmp (name, "."))
        -: 1807:	{
       13: 1808:	  enum SafeChdirStatus status = safely_chdir (name, TraversingDown, &stat_buf, SymlinkHandleDefault);
       13: 1809:	  switch (status)
        -: 1810:	    {
        -: 1811:	    case SafeChdirOK:
        -: 1812:	      /* If there had been a change but wd_sanity_check()
        -: 1813:	       * accepted it, we need to accept that on the 
        -: 1814:	       * way back up as well, so modify our record 
        -: 1815:	       * of what we think we should see later.
        -: 1816:	       * If there was no change, the assignments are a no-op.
        -: 1817:	       */
       13: 1818:	      dir_ids[dir_curr].dev = stat_buf.st_dev;
       13: 1819:	      dir_ids[dir_curr].ino = stat_buf.st_ino;
       13: 1820:	      break;
        -: 1821:      
        -: 1822:	    case SafeChdirFailWouldBeUnableToReturn:
    #####: 1823:	      error (0, errno, ".");
    #####: 1824:	      state.exit_status = 1;
    #####: 1825:	      break;
        -: 1826:	      
        -: 1827:	    case SafeChdirFailNonexistent:
        -: 1828:	    case SafeChdirFailStat:
        -: 1829:	    case SafeChdirFailSymlink:
        -: 1830:	    case SafeChdirFailNotDir:
        -: 1831:	    case SafeChdirFailChdirFailed:
    #####: 1832:	      error (0, errno, "%s", pathname);
    #####: 1833:	      state.exit_status = 1;
        -: 1834:	      return;
        -: 1835:	    }
        -: 1836:	}
        -: 1837:
        -: 1838:#if USE_OLD_SAVEDIR
        -: 1839:      for (idx=0, namep = name_space; *namep; namep += file_len - pathname_len + 1, ++idx)
        -: 1840:#else
      325: 1841:      for (idx=0; idx < dirinfo->size; ++idx)
        -: 1842:#endif
        -: 1843:	{
        -: 1844:	  /* savedirinfo() may return dirinfo=NULL if extended information 
        -: 1845:	   * is not available. 
        -: 1846:	   */
        -: 1847:#if USE_OLD_SAVEDIR
        -: 1848:	  mode_t mode = extra ? extra[idx].type_info : 0;
        -: 1849:#else
      622: 1850:	  mode_t mode = (dirinfo->entries[idx].flags & SavedirHaveFileType) ? 
      311: 1851:	    dirinfo->entries[idx].type_info : 0;
      311: 1852:	  namep = dirinfo->entries[idx].name;
        -: 1853:#endif
        -: 1854:	  /* Append this directory entry's name to the path being searched. */
      311: 1855:	  file_len = pathname_len + strlen (namep);
      311: 1856:	  if (file_len > cur_path_size)
        -: 1857:	    {
       30: 1858:	      while (file_len > cur_path_size)
       10: 1859:		cur_path_size += 1024;
       10: 1860:	      if (cur_path)
    #####: 1861:		free (cur_path);
       10: 1862:	      cur_path = xmalloc (cur_path_size);
       10: 1863:	      strcpy (cur_path, pathname);
       10: 1864:	      cur_path[pathname_len - 2] = '/';
        -: 1865:	    }
      311: 1866:	  cur_name = cur_path + pathname_len - 1;
      311: 1867:	  strcpy (cur_name, namep);
        -: 1868:
      311: 1869:	  state.curdepth++;
      311: 1870:	  if (!options.no_leaf_check)
        -: 1871:	    {
      307: 1872:	      if (mode && S_ISDIR(mode) && (subdirs_left == 0))
        -: 1873:		{
        -: 1874:		  /* This is a subdirectory, but the number of directories we 
        -: 1875:		   * have found now exceeds the number we would expect given 
        -: 1876:		   * the hard link count on the parent.   This is likely to be 
        -: 1877:		   * a bug in the filesystem driver (e.g. Linux's 
        -: 1878:		   * /proc filesystem) or may just be a fact that the OS 
        -: 1879:		   * doesn't really handle hard links with Unix semantics.
        -: 1880:		   * In the latter case, -noleaf should be used routinely.
        -: 1881:		   */
    #####: 1882:		  error(0, 0, _("WARNING: Hard link count is wrong for %s: this may be a bug in your filesystem driver.  Automatically turning on find's -noleaf option.  Earlier results may have failed to include directories that should have been searched."),
        -: 1883:			parent);
    #####: 1884:		  state.exit_status = 1; /* We know the result is wrong, now */
    #####: 1885:		  options.no_leaf_check = true;	/* Don't make same
        -: 1886:						   mistake again */
    #####: 1887:		  subdirs_left = 1; /* band-aid for this iteration. */
        -: 1888:		}
        -: 1889:	      
        -: 1890:	      /* Normal case optimization.  On normal Unix
        -: 1891:		 filesystems, a directory that has no subdirectories
        -: 1892:		 has two links: its name, and ".".  Any additional
        -: 1893:		 links are to the ".." entries of its subdirectories.
        -: 1894:		 Once we have processed as many subdirectories as
        -: 1895:		 there are additional links, we know that the rest of
        -: 1896:		 the entries are non-directories -- in other words,
        -: 1897:		 leaf files. */
      307: 1898:	      subdirs_left -= process_path (cur_path, cur_name,
        -: 1899:					    subdirs_left == 0, pathname,
        -: 1900:					    mode);
        -: 1901:	    }
        -: 1902:	  else
        -: 1903:	    {
        -: 1904:	      /* There might be weird (e.g., CD-ROM or MS-DOS) filesystems
        -: 1905:		 mounted, which don't have Unix-like directory link counts. */
        4: 1906:	      process_path (cur_path, cur_name, false, pathname, mode);
        -: 1907:	    }
        -: 1908:	  
      311: 1909:	  state.curdepth--;
        -: 1910:	}
        -: 1911:
        -: 1912:
        -: 1913:      /* We're about to leave the directory.  If there are any
        -: 1914:       * -execdir argument lists which have been built but have not
        -: 1915:       * yet been processed, do them now because they must be done in
        -: 1916:       * the same directory.
        -: 1917:       */
       14: 1918:      complete_pending_execdirs(eval_tree); 
        -: 1919:
        -: 1920:
       14: 1921:      if (strcmp (name, "."))
        -: 1922:	{
        -: 1923:	  enum SafeChdirStatus status;
        -: 1924:	  struct dir_id did;
        -: 1925:	  
        -: 1926:	  /* We could go back and do the next command-line arg
        -: 1927:	     instead, maybe using longjmp.  */
        -: 1928:	  char const *dir;
       13: 1929:	  boolean deref = following_links() ? true : false;
        -: 1930:	  
       13: 1931:	  if ( (state.curdepth>0) && !deref)
        8: 1932:	    dir = "..";
        -: 1933:	  else
        -: 1934:	    {
        5: 1935:	      chdir_back ();
        5: 1936:	      dir = parent;
        -: 1937:	    }
        -: 1938:	  
       13: 1939:	  status = safely_chdir (dir, TraversingUp, &stat_buf, SymlinkHandleDefault);
       13: 1940:	  switch (status)
        -: 1941:	    {
        -: 1942:	    case SafeChdirOK:
       13: 1943:	      break;
        -: 1944:      
        -: 1945:	    case SafeChdirFailWouldBeUnableToReturn:
    #####: 1946:	      error (1, errno, ".");
        -: 1947:	      return;
        -: 1948:	      
        -: 1949:	    case SafeChdirFailNonexistent:
        -: 1950:	    case SafeChdirFailStat:
        -: 1951:	    case SafeChdirFailSymlink:
        -: 1952:	    case SafeChdirFailNotDir:
        -: 1953:	    case SafeChdirFailChdirFailed:
    #####: 1954:	      error (1, errno, "%s", pathname);
        -: 1955:	      return;
        -: 1956:	    }
        -: 1957:
       13: 1958:	  if (dir_curr > 0)
        -: 1959:	    {
        8: 1960:	      did.dev = dir_ids[dir_curr-1].dev;
        8: 1961:	      did.ino = dir_ids[dir_curr-1].ino;
        -: 1962:	    }
        -: 1963:	  else
        -: 1964:	    {
        5: 1965:	      did.dev = starting_stat_buf.st_dev;
        5: 1966:	      did.ino = starting_stat_buf.st_ino;
        -: 1967:	    }
        -: 1968:	}
        -: 1969:
       14: 1970:      if (cur_path)
       10: 1971:	free (cur_path);
        -: 1972:#ifdef USE_OLD_SAVEDIR
        -: 1973:      free (name_space);
        -: 1974:      free (extra);
        -: 1975:#else
       14: 1976:      free_dirinfo(dirinfo);
        -: 1977:#endif
        -: 1978:    }
        -: 1979:}
        -: 1980:
        -: 1981:/* Return true if there are no predicates with no_default_print in
        -: 1982:   predicate list PRED, false if there are any.
        -: 1983:   Returns true if default print should be performed */
        -: 1984:
        -: 1985:static boolean
        6: 1986:default_prints (struct predicate *pred)
        -: 1987:{
       23: 1988:  while (pred != NULL)
        -: 1989:    {
       14: 1990:      if (pred->no_default_print)
        3: 1991:	return (false);
       11: 1992:      pred = pred->pred_next;
        -: 1993:    }
        3: 1994:  return (true);
        -: 1995:}
